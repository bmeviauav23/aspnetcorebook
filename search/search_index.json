{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftverfejleszt\u00e9s .NET platformra","text":"<p>Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a Szoftverfejleszt\u00e9s .NET platformra c. t\u00e1rgyhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p> <p>A felhaszn\u00e1l\u00e1si felt\u00e9telekr\u0151l b\u0151vebben a repository LICENSE.md f\u00e1jlj\u00e1ban olvashatsz.</p>"},{"location":"homework/","title":"H\u00e1zi feladat tudnival\u00f3k","text":"<p>TBD</p>"},{"location":"information/contributing/","title":"Hozz\u00e1j\u00e1rul\u00e1s az anyaghoz","text":"<p>Az anyag terjedelm\u00e9b\u0151l adand\u00f3an apr\u00f3bb hib\u00e1k esetenk\u00e9nt hi\u00e1nyoss\u00e1gok jelentkezhetnek a laborokban. Ha egy ilyennel tal\u00e1lkozol \u00e9s \u00fagy d\u00f6ntesz szeretn\u00e9l seg\u00edteni hallgat\u00f3t\u00e1rsaidnak, azt a k\u00f6vetkez\u0151kben le\u00edrtak alapj\u00e1n tudod megtenni.</p> <p>Plusz pont jegyzet jav\u00edt\u00e1s\u00e9rt</p> <p>M\u00e1s tant\u00e1rgyak mint\u00e1j\u00e1ra itt is szeretn\u00e9nk plusz pontot adni a jegyzet open-source hozz\u00e1j\u00e1rul\u00e1sai\u00e9rt. Akik a t\u00e1rgyat jelenleg hallgatj\u00e1k, pontokat kaphatnak hozz\u00e1j\u00e1rul\u00e1saik\u00e9rrt.</p> <p>A f\u00e9l\u00e9v sor\u00e1n max 3 db plusz pontot lehet szerezni fejenk\u00e9nt olyan jav\u00edt\u00e1sok\u00e9rt, amik a trivi\u00e1lis 1-2 bet\u0171 elg\u00e9pel\u00e9sen t\u00fal \u00e9rdemben jav\u00edtanak a githubon tal\u00e1lhat\u00f3 labor jegyzetek min\u0151s\u00e9g\u00e9n. Pl.: jelent\u0151s mennyis\u00e9g\u0171 elg\u00e9pel\u00e9s jav\u00edt\u00e1sa, egy\u00e9rtelm\u0171s\u00edt\u00e9sek, illusztr\u00e1ci\u00f3k kieg\u00e9sz\u00edt\u00e9sek k\u00e9sz\u00edt\u00e9se vagy ak\u00e1r egy teljes kieg\u00e9sz\u00edt\u0151 jegyzet \u00edr\u00e1sa  (term\u00e9szetesen nem azonos pont\u00e9rt\u00e9kkel).</p> <p>Persze a pont n\u00e9lk\u00fcl az 1-1 bet\u0171s elg\u00e9pel\u00e9seket is sz\u00edvesen fogadjuk, ami bemeleg\u00edt\u00e9snek is t\u00f6k\u00e9letes.</p>"},{"location":"information/contributing/#hibak-jelzese","title":"Hib\u00e1k jelz\u00e9se","text":"<p>Amennyiben hib\u00e1t tal\u00e1lsz az anyagban, vagy szeretn\u00e9d b\u0151v\u00edteni, de nem \u00e1ll m\u00f3dodban jav\u00edtani, nyithatsz egy issue-t amiben le\u00edrod a hib\u00e1t.</p> <ol> <li>N\u00e9zd meg, hogy valaki nem jelezte-e, amit szeretn\u00e9l.     Gyakran m\u00e1r l\u00e9tez\u0151 probl\u00e9m\u00e1kat tal\u00e1lnak, amire m\u00e1r van pull request,     \u00edgy miel\u0151tt b\u00e1rmit tenn\u00e9l n\u00e9zd meg valaki nem el\u0151z\u00f6tt-e meg</li> <li>Az issues tabon a new issue gombbal hozz l\u00e9tre egy \u00faj issue-t.     </li> <li>L\u00e1sd el a megfelel\u0151 c\u00edmk\u00e9kkel<ol> <li>A labor t\u00edpusa (<code>android</code> az androidos laborokn\u00e1l \u00e9s <code>web</code> a webes laborokn\u00e1l)</li> <li>A hiba t\u00edpusa (<code>clarification</code>, <code>typo</code>, <code>illustration</code> vagy <code>notes</code>)</li> </ol> </li> <li>\u00cdrd le, hogy mit k\u00e9ne tartalmaznia a jav\u00edt\u00e1snak</li> </ol> <p>Tip</p> <p>Az c\u00edme legyen r\u00f6vid \u00e9s l\u00e9nyegret\u00f6r\u0151, pl.: <code>Megfogalmaz\u00e1s pontos\u00edt\u00e1sa a 4. laborban</code> vagy <code>A 6. laborban a le\u00edrt k\u00f3d hib\u00e1san m\u0171k\u00f6dik Android 12-n</code></p> <p>A issue descriptionj\u00e9ben pedig fejtsd ki, hol tal\u00e1lhat\u00f3 a hi\u00e1nyoss\u00e1g, illetve ha van r\u00e1 \u00f6tleted, hogy lehetne orvosolni ezt. Ha ezeken t\u00fal m\u00e9g screenshotot is tudsz mell\u00e9kelni, az nagyban megseg\u00edti a probl\u00e9ma mihamarabbi jav\u00edt\u00e1s\u00e1t.</p> <p>Warning</p> <p>A github issues nem a laborfeladatok megold\u00e1s\u00e1val kapcsolatos probl\u00e9m\u00e1k helye, \u00edgy a \"Nem tudom megoldani hogy az \u00e9rtes\u00edt\u00e9s meg\u00e9rkezzen\" jelleg\u0171 probl\u00e9m\u00e1kat ne itt jelezz\u00e9tek, erre vannak a laboralkalmak.</p>"},{"location":"information/contributing/#valtoztatasok-javaslasa","title":"V\u00e1ltoztat\u00e1sok javasl\u00e1sa","text":"<p>Amennyiben a hozz\u00e1j\u00e1rul\u00e1sod meg tudod val\u00f3s\u00edtani ind\u00edts pull requestet</p> <ol> <li> <p>Forkold a repository-t a Githubon jobb fels\u0151 sarokban tal\u00e1lhat\u00f3 gombbal     </p> </li> <li> <p>V\u00e9gezd el a v\u00e1ltoztat\u00e1sokat.</p> <ol> <li> <p>Hozz l\u00e9tre egy branchet a saj\u00e1t forkodon, amin a v\u00e1ltoztat\u00e1sokat el fogod v\u00e9gezni.</p> </li> <li> <p>Ezen a branchen k\u00e9sz\u00edtsd el a jav\u00edt\u00e1sokat</p> </li> <li> <p>Ellen\u0151rizd, hogy ne ker\u00fclj\u00f6n bele a commitba olyan file, amit az editor gener\u00e1lt (pl.: <code>.idea</code> mappa) illetve olyan file aminek nem k\u00e9ne kiker\u00fclnie, pl.: Github Private Access Token</p> </li> <li> <p>Ha k\u00e9sz vagy ind\u00edts egy pull requestet a jegyzeteket tartalmaz\u00f3 rep\u00f3 f\u0151 \u00e1g\u00e1ra.</p> </li> <li> <p>A le\u00edr\u00e1sban r\u00e9szletezd v\u00e1ltoztat\u00e1sok ok\u00e1t.     Ne felejtsd el bele\u00edrni a NEPTUN k\u00f3dod a le\u00edr\u00e1sba, mert \u00edgy fogjuk tudni megadni a pontokat.</p> </li> </ol> </li> <li> <p>Valaki, akinek hozz\u00e1f\u00e9r\u00e9se van a repositoryhoz, ellen\u0151rzi a v\u00e1ltoztat\u00e1sok sz\u00fcks\u00e9gess\u00e9g\u00e9t, \u00e9s elb\u00edr\u00e1lja, hogy val\u00f3ban beker\u00fclhet az anyagba.</p> </li> <li>A v\u00e1ltoztat\u00e1sokra review-t ind\u00edtunk \u00e9s ha kell m\u00f3dos\u00edt\u00e1sokat fogunk k\u00e9rni.</li> <li>Ha minden k\u00e9rt v\u00e1ltoztat\u00e1s megt\u00f6rt\u00e9nt, a hozz\u00e1j\u00e1rul\u00e1sod beleker\u00fcl az anyagba.</li> </ol>"},{"location":"information/contributing/#code-style","title":"Code style","text":"<ul> <li>Markdown: Mivel az alap spec nem mindig a legtiszt\u00e1bban \u00e9rthet\u0151, a markdownlint szab\u00e1lyai alapj\u00e1n, az n\u00e9h\u00e1ny kiv\u00e9tel\u00e9vel. Ezeket a <code>.markdownlint.yaml</code>-ben tal\u00e1lod, ha VSCode-ot haszn\u00e1lsz automatikusan alkalmazza \u0151ket az editor \u00e9s jelzi ha nem megfelel\u0151 amit \u00edrsz.</li> </ul> <p>Ezek a st\u00edlusok a t\u00e1rgyban aj\u00e1nlott editorokban k\u00f6nnyen be\u00e1ll\u00edthat\u00f3ak.</p>"},{"location":"information/contributing/#vscode","title":"VSCode","text":"<p>Aj\u00e1nlott extension\u00f6k:</p> <ul> <li><code>yzhang.markdown-all-in-one</code>: MD szinkroniz\u00e1lt live preview</li> <li><code>DavidAnson.vscode-markdownlint</code>: MD form\u00e1z\u00e1s, szab\u00e1lyok stb.</li> <li>Prettier: HTML+CSS form\u00e1z\u00f3</li> <li>Error Lens: Kiemeli a hib\u00e1kat hogy gyorsabben megtal\u00e1ljuk \u0151ket</li> <li>Paste Image: egyszer\u0171s\u00edti a k\u00e9pek beilleszt\u00e9s\u00e9t markdownba</li> </ul> <p>Az editor be\u00e1ll\u00edt\u00e1s\u00e1hoz nyisd meg a repo-t a gy\u00f6ker\u00e9ben VSCode-al. A VSCode fel fogja aj\u00e1nlani a k\u00e9t markdown extension-t.</p> <p></p> <p>Ha ez megt\u00f6rt\u00e9nt, nyiss meg egy markdown dokumentumot, \u00e9s haszn\u00e1ld a Ctrl+Shift+P shortcutot, a command palette megnyit\u00e1s\u00e1hoz.</p> <p>Tip</p> <p>A command palette a VSCode parancsaihoz ny\u00fajt hozz\u00e1f\u00e9r\u00e9st, autocompleteeli a parancsokat \u00e9s egy minim\u00e1lis GUI-t is biztos\u00edt.</p> <p>A command palette-be keress\u00fck meg a <code>Format Document With...</code> men\u00fcpontot \u00e9s v\u00e1lasszuk ki. Ekkor egy almen\u00fcbe dob az editor \u00e9s kiv\u00e1laszthatjuk hogy melyik form\u00e1z\u00f3val form\u00e1zzuk a MD dokumentumokat. Legalul lesz egy <code>Configure Default Formatter</code>, v\u00e1lasszuk ezt. Ezut\u00e1n v\u00e1lasszuk a <code>markdownlint</code> extensiont, \u00e9s k\u00e9szen vagyunk.</p> <p>Megfelel\u0151 formatter kiv\u00e1laszt\u00e1sa</p> <p>Ne v\u00e1laszd ki a prettiert formatterk\u00e9nt, mert elt\u00f6ri a sz\u00f6vegbubor\u00e9kokat.</p> <p>Ezen fel\u00fcl \u00e9rdemes lehet bekapcsolni a ment\u00e9s el\u0151tti form\u00e1z\u00e1st.</p> <p>A Ctrl+, shortcuttal megnyitjuk a be\u00e1ll\u00edt\u00e1sokat, \u00e9s r\u00e1keres\u00fcnk arra, hogy format on save. Itt kipip\u00e1ljuk a checkboxot \u00e9s k\u00e9szen vagyunk.</p> <p>Ha ehhez nem lenne t\u00fcrelmed, itt a json amit a <code>settings.json</code>-ba illesztve be\u00e1ll\u00edt\u00f3dik minden.</p> <pre><code>{\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"DavidAnson.vscode-markdownlint\",\n    \"editor.formatOnSave\": true\n  }\n}\n</code></pre>"},{"location":"information/preface/","title":"Tudnival\u00f3k","text":""},{"location":"information/preface/#a-jegyzet-celja-es-celkozonsege","title":"A jegyzet c\u00e9lja \u00e9s c\u00e9lk\u00f6z\u00f6ns\u00e9ge","text":"<p>Ezen jegyzet els\u0151dlegesen a BME Villamosm\u00e9rn\u00f6ki \u00e9s Informatikai Kar\u00e1n oktatott Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgyhoz k\u00e9sz\u00fclt, c\u00e9lja, hogy seg\u00edts\u00e9get ny\u00fajtson egyr\u00e9szt a gyakorlatvezet\u0151nek a gyakorlat megtart\u00e1s\u00e1ban, m\u00e1sr\u00e9szt a kurzus hallgat\u00f3inak a gyakorlat otthoni ut\u00f3lagos megism\u00e9tl\u00e9s\u00e9hez, a tanult ismeretek \u00e1tism\u00e9tl\u00e9s\u00e9hez.</p> <p>Ebb\u0151l kifoly\u00f3lag nem tekinthet\u0151 egy teljesen kezd\u0151 szint\u0171 bevezet\u0151 C# tank\u00f6nyvnek, hiszen er\u0151teljesen \u00e9p\u00edt m\u00e1s kari t\u00e1rgyak (pl. Szoftvertechnik\u00e1k, Adatb\u00e1zisok) \u00e1ltal lefedett ismeretekre, de m\u00e9g ink\u00e1bb a Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgy el\u0151ad\u00e1saira.</p> <p>A felt\u00e9telezett el\u0151ismeretek:</p> <ul> <li>C# \u00e9s objektumorient\u00e1lt nyelvi alapok<ul> <li>oper\u00e1torok, v\u00e1ltoz\u00f3k, t\u00f6mb\u00f6k, strukt\u00far\u00e1k, f\u00fcggv\u00e9nyek fogalma</li> <li>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s \u00e9s f\u00fcggv\u00e9nyv\u00e1ltozatok</li> <li>alapvet\u0151 mem\u00f3riakezel\u00e9s (heap, stack), mutat\u00f3k fogalma, \u00e9rt\u00e9k \u00e9s referencia t\u00edpusok</li> <li>alapvet\u0151 vez\u00e9rl\u00e9si szerkezetek (ciklus, el\u00e1gaz\u00e1s, stb.), \u00e9rt\u00e9k- \u00e9s referencia szerinti param\u00e9ter\u00e1tad\u00e1s, rekurzi\u00f3</li> <li>oszt\u00e1ly, oszt\u00e1lyp\u00e9ld\u00e1ny fogalma, static, <code>new</code> oper\u00e1tor, oszt\u00e1ly szint\u0171 v\u00e1ltoz\u00f3k, generikus t\u00edpusok</li> <li>lesz\u00e1rmaz\u00e1s, virtu\u00e1lis tagf\u00fcggv\u00e9nyek</li> <li>C# esem\u00e9ny, delegate t\u00edpusok \u00e9s delegate p\u00e9ld\u00e1nyok</li> <li>Visual Studio haszn\u00e1lat\u00e1nak alapjai</li> <li>oper\u00e1ci\u00f3s rendszer kapcsolatok, folyamatok, sz\u00e1lak, parancssor, parancssori argumentumok, k\u00f6rnyezeti v\u00e1ltoz\u00f3k</li> </ul> </li> <li>SQL nyelvi alapok (SELECT, UPDATE, INSERT, DELETE utas\u00edt\u00e1sok), valamint alapvet\u0151 rel\u00e1ci\u00f3s adatmodell ismeretek (t\u00e1bl\u00e1k, els\u0151dleges- \u00e9s idegen kulcsok)</li> </ul> <p>A fentiek elsaj\u00e1t\u00edt\u00e1s\u00e1hoz seg\u00edts\u00e9get ny\u00fajthatnak Reiter Istv\u00e1n ingyenesen let\u00f6lthet\u0151 k\u00f6nyvei.</p> <p>A sz\u00f6vegben megtal\u00e1lhat\u00f3k a gyakorlatvezet\u0151knek sz\u00f3l\u00f3 kit\u00e9telek (\u201eR\u00f6viden mondjuk el\u2026\", \u201eMutassuk meg\u2026\", stb.). Ezeket mezei olvas\u00f3k\u00e9nt \u00e9rdemes figyelmen k\u00edv\u00fcl hagyni, illetve sz\u00fcks\u00e9g eset\u00e9n a kapcsol\u00f3d\u00f3 elm\u00e9leti ismereteket az el\u0151ad\u00e1sanyagb\u00f3l \u00e1tism\u00e9telni.</p>"},{"location":"information/preface/#a-jegyzet-naprakeszsege","title":"A jegyzet naprak\u00e9szs\u00e9ge","text":"<p>Az anyag gerinc\u00e9t ad\u00f3 .NET Core / .NET 5,6 platform jelenleg igen gyors \u00fctemben fejl\u0151dik. A .NET Core 1.0-s verzi\u00f3 \u00f3ta a k\u00e9sz\u00edt\u0151k t\u00f6rekednek a visszafel\u00e9 kompatibilit\u00e1sra, azonban az eszk\u00f6zk\u00e9szlet \u00e9s a korszer\u0171nek \u00e9s aj\u00e1nlottnak tekinthet\u0151 m\u00f3dszerek folyamatosan v\u00e1ltoznak, finomodnak.</p> <p>A jegyzet els\u0151dlegesen az al\u00e1bbi technol\u00f3giai verzi\u00f3khoz k\u00e9sz\u00fclt:</p> <ul> <li>C# 12</li> <li>.NET 8</li> <li>ASP.NET Core 8</li> <li>Visual Studio 2022</li> </ul> <p>Ahogyan a fenti verzi\u00f3k v\u00e1ltoznak, \u00fagy avulhatnak el a jegyzetben mutatott elj\u00e1r\u00e1sok.</p>"},{"location":"information/preface/#szoftverkornyezet","title":"Szoftverk\u00f6rnyezet","text":"<p>A gyakorlatok az al\u00e1bbi szoftverekb\u0151l \u00e1ll\u00f3 k\u00f6rnyezethez k\u00e9sz\u00fcltek:</p> <ul> <li>Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>Visual Studio 2022 (az ingyenes Community verzi\u00f3 el\u00e9g) az al\u00e1bbi workloadokkal:<ul> <li>.NET desktop development</li> <li>Data storage and processing</li> <li>ASP.NET and web development</li> <li>Azure Development</li> </ul> </li> <li>Telerik Fiddler Classic</li> <li>Postman</li> </ul> <p>A .NET (kor\u00e1bban .NET Core) sz\u00e9lesk\u00f6r\u0171 platformt\u00e1mogat\u00e1sa miatt bizonyos nem Windows platformokon is elv\u00e9gezhet\u0151k a gyakorlatok Visual Studio helyett Visual Studio Code haszn\u00e1lat\u00e1val - azonban a gyakorlatok sz\u00f6vege a Visual Studio haszn\u00e1lat\u00e1t felt\u00e9telezi.</p>"},{"location":"information/preface/#kodreszletek-valtozaskovetese","title":"K\u00f3dr\u00e9szletek v\u00e1ltoz\u00e1sk\u00f6vet\u00e9se","text":"<p>Az egyes gyakorlatok sor\u00e1n gyakori eset, hogy a C# k\u00f3d egy r\u00e9sz\u00e9t tov\u00e1bbfejlesztj\u00fck, megv\u00e1ltoztatjuk. Ilyen esetben a v\u00e1ltoz\u00f3 sorokat a jegyzetben kiemelt h\u00e1tt\u00e9rrel rendelkeznek. A t\u00f6r\u00f6lt k\u00f3dr\u00e9szleteket (amennyiben van seg\u00edti a meg\u00e9rt\u00e9st) kommentez\u00e9ssel jelezz\u00fck. Jel\u00f6lj\u00fck m\u00e9g a megl\u00e9v\u0151, de a jegyzetben nem megjelen\u00edtett k\u00f3dr\u00e9szleteket komment \u00e9s ... (<code>//...</code>) jellel.</p> <pre><code>using System; //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\nusing static System.Console; //ez \u00faj k\u00f3dsor\n\n//... megl\u00e9v\u0151 k\u00f3dr\u00e9szlet az el\u0151z\u0151 feladatokb\u00f3l\n\nforeach (var dog in dogs)    //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\n  /* Console.*/WriteLine(dog); //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n\n/* Console.*/ReadLine();     //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n</code></pre> <p>JSON kommentek</p> <p>A JSON form\u00e1tum alap\u00e9rtelmez\u00e9sben (RFC szerint) nem t\u00e1mogatja a kommenteket, \u00edgy ha JSON k\u00f3dr\u00e9szletet m\u00e1solunk, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy nem maradt-e a beillesztett k\u00f3dban komment, mert probl\u00e9m\u00e1t okozhat.</p>"},{"location":"seminar/01-csharp1/chapter1/","title":"C# alapok, szintaxis","text":"<p>C\u00e9lunk, hogy a hallgat\u00f3k legal\u00e1bb r\u00e9szben meg\u00e9rts\u00e9k \u00e9s r\u00e1\u00e9rezzenek a C# szintaktik\u00e1j\u00e1ra, megismerkedjenek alapvet\u0151 nyelvi elemekkel \u00e9s konstrukci\u00f3kkal.</p>"},{"location":"seminar/01-csharp1/chapter1/#hello-c","title":"Hello C#!","text":"<p>A Visual Studio ind\u00edt\u00f3ablak\u00e1ban v\u00e1lasszuk a <code>Create a new project</code> opci\u00f3t. Magyar\u00e1zzuk el, hogy van lehet\u0151s\u00e9g\u00fcnk el\u0151re gy\u00e1rtott sablonokb\u00f3l l\u00e9trehozni projekteket, illetve hogy</p> <ul> <li>egy C# projekt egy szerelv\u00e9nny\u00e9 fordul (.dll, .exe).</li> <li>a Solution dolga, hogy logikailag \u00f6sszefogja a Project-eket (t\u00f6bb-t\u00f6bbes kapcsolatban vannak).</li> <li>a projektek k\u00f6z\u00f6tt referenci\u00e1kat adhatunk m\u00e1sik projektekre \u00fagy, hogy a ford\u00edt\u00e1si mechanizmus figyelembe veszi a referenci\u00e1kat \u00e9s sz\u00fcks\u00e9g eset\u00e9n \u00fajraford\u00edtja a szerelv\u00e9nyeket.</li> <li>a projektek hivatkozhatnak k\u00fcls\u0151 forr\u00e1sb\u00f3l sz\u00e1rmaz\u00f3 szerelv\u00e9nyekre is NuGet csomagok form\u00e1j\u00e1ban. A NuGet egy egys\u00e9ges m\u00f3dszer szerelv\u00e9nyeink terjeszt\u00e9s\u00e9re.</li> </ul> <p>Hozzunk l\u00e9tre egy \u00faj C# Console Application-t! Ehhez keress\u00fck ki a sablonok k\u00f6z\u00fcl a Console App nev\u0171t (ne a .NET Framework-\u00f6set). A neve legyen HelloCSharp.</p> <p>New Project dialogusablak keres\u0151</p> <p>A kikeres\u00e9shez haszn\u00e1lhatjuk fel\u00fcl a sz\u00f6vegdobozos sz\u0171r\u0151t, illetve a leg\u00f6rd\u00fcl\u0151 list\u00e1s sz\u0171r\u0151ket is (Nyelv: C#, Platform: Windows, Projektt\u00edpus: Console)</p> <p>A sablon konfigur\u00e1ci\u00f3j\u00e1n\u00e1l adjunk meg egy olyan helyet, ahov\u00e1 van \u00edr\u00e1si jogunk. A Place solution and project in the same directory opci\u00f3t kapcsoljuk be, \u00edgy nem fog l\u00e9trej\u00f6nni egy felesleges mappa a k\u00f6nyvt\u00e1rszerkezetben. A .NET verzi\u00f3t \u00e1ll\u00edtsuk .NET 8-ra.</p> <p>\u00c9szrevehetj\u00fck, hogy az alkalmaz\u00e1s sablonok k\u00f6z\u00f6tt sima \u00e9s (.NET Framework) jel\u00f6l\u00e9s\u0171ek is vannak. A sim\u00e1k alapvet\u0151en a modernebb .NET Core/.NET 5-8 platformot c\u00e9lozz\u00e1k, a .NET Framework ezekhez k\u00e9pest egy r\u00e9gebbi platform.</p> <ul> <li>.NET Core: a .NET Framework modulariz\u00e1lt, moderniz\u00e1lt, cross-platform \u00e9s ny\u00edlt forr\u00e1sk\u00f3d\u00fa megval\u00f3s\u00edt\u00e1sa. Kisebb NuGet csomagokban \u00e9rhet\u0151 el a teljes .NET Framework funkcionalit\u00e1sa (Collections, Reflection, XML feldolgoz\u00e1s, stb.).</li> <li>.NET Framework: a \u201eklasszikus\u201d, teljes\u00e9rt\u00e9k\u0171 .NET keretrendszer, out-of-the-box t\u00e1mogatja a legelterjedtebb alkalmaz\u00e1sfejleszt\u00e9si lehet\u0151s\u00e9geket. A .NET Core megjelen\u00e9s\u00e9t k\u00f6vet\u0151en is t\u00e1mogatott, enterprise k\u00f6rnyezetekben haszn\u00e1latos, ugyanis n\u00e9h\u00e1ny enterprise technol\u00f3gia els\u0151dlegesen csak ebben t\u00e1mogatott (pl. szerver oldali WCF). Csak Windows-ra telep\u00edthet\u0151.</li> <li>.NET 5 \u00e9s f\u00f6l\u00f6tte: A .NET Core 3.1 ut\u00e1ni f\u0151 verzi\u00f3i. M\u00e1r elnevez\u00e9s\u00e9ben is jelzi, hogy ez egyben a kor\u00e1bbi .NET Core \u00e9s .NET Framework verzi\u00f3knak is ut\u00f3dja.</li> </ul> <p>Az al\u00e1bbi elemeket ismertethetj\u00fck, miel\u0151tt a k\u00f3d\u00edr\u00e1sba belekezd\u00fcnk:</p> <ul> <li>R\u00f6vid \u00e1ttekint\u00e9s az IDE-r\u0151l: men\u00fcs\u00e1v, Solution Explorer, Properties, Output, Error List ablakok, ablakoz\u00f3rendszer. Mutassuk meg, hogy drag-n-drop m\u0171veletekkel testreszabhat\u00f3 a fel\u00fclet, pl. helyezz\u00fck a Solution Explorert a k\u00e9perny\u0151 bal oldal\u00e1ra. Ha valaki v\u00e9letlen\u00fcl \u00e1trendezi az alap\u00e9rtelmezett elrendez\u00e9st, a menu:Window[Reset Window Layout] lehet\u0151s\u00e9ggel vissza\u00e1ll\u00edthatja.</li> <li>A projekt tulajdons\u00e1gok (menu:jobb klikk[Properties]) oldal\u00e1n az Application f\u00fcl\u00f6n megn\u00e9zhetj\u00fck, hogy az Output type \u00e9rt\u00e9ke hat\u00e1rozza meg, hogy milyen jelleg\u0171 (konzolos, Windows, oszt\u00e1lyk\u00f6nyvt\u00e1r) alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk.</li> <li>Mutassuk meg, hogy milyen alapvet\u0151 szerelv\u00e9nyekre adunk referenci\u00e1t a projektben!</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> f\u00e1jl tartalm\u00e1t \u00e9s fussuk \u00e1t a l\u00e1that\u00f3 elemeket!</li> <li>Magyar\u00e1zzuk el a <code>using</code> \u00e9s <code>namespace</code> kulcsszavak jelent\u00e9s\u00e9t, egym\u00e1shoz k\u00e9pesti viszonyukat! A n\u00e9vt\u00e9r \u00e9rt\u00e9ke egy \u00fajonnan l\u00e9trehozott f\u00e1jln\u00e1l alap\u00e9rtelmezetten Projektn\u00e9v.Mappaszerkezet alak\u00fa, \u00e9rdemes konvencion\u00e1lisan ezt k\u00f6vetni. Sok hallgat\u00f3n\u00e1l nem tiszta, hogy hogyan viszonyul egym\u00e1shoz a n\u00e9vt\u00e9r \u00e9s a szerelv\u00e9ny fogalma, ez\u00e9rt pr\u00f3b\u00e1ljuk meg ezt tiszt\u00e1zni!</li> <li>Utaljunk arra, hogy alapvet\u0151en kiz\u00e1r\u00f3lag objektumorient\u00e1ltan tudunk k\u00f3dot \u00edrni, \u00edgy a <code>Program</code> egy oszt\u00e1ly, a <code>Main</code> bel\u00e9p\u00e9si pont pedig egy statikus met\u00f3dus.</li> <li>Besz\u00e9lj\u00fcnk r\u00f6viden a C# elnevez\u00e9si konvenci\u00f3kr\u00f3l! A publikus elemeket (pl. Java-val \u00e9s JavaScripttel ellent\u00e9tben) \u00e9s minden met\u00f3dust \u00f6k\u00f6lszab\u00e1lyk\u00e9nt PascalCasing elnevez\u00e9si konvenci\u00f3 k\u00f6vet, a nem publikus elemekn\u00e9l camelCasing (ezek k\u00f6z\u00fcl vannak kiv\u00e9telek \u00e9s m\u00e1s konvenci\u00f3k, de ez egy gyakori megk\u00f6zel\u00edt\u00e9s).</li> </ul> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> met\u00f3dust az al\u00e1bbi k\u00f3dr\u00e9szlettel, k\u00f6zben h\u00edvjuk fel a figyelmet az IntelliSense haszn\u00e1lat\u00e1ra:</p> <pre><code>int a = 5;\nint b = 7;\nConsole.WriteLine(a + b);\nConsole.ReadLine();\n</code></pre> <p>Az IntelliSense-t demonstr\u00e1lhatjuk az al\u00e1bbi m\u00f3don:</p> <ul> <li>A k\u00f3dban b\u00e1rmely logikus helyen haszn\u00e1lhat\u00f3 az IntelliSense a Ctrl+Space billenty\u0171kombin\u00e1ci\u00f3val, ezen k\u00edv\u00fcl alap\u00e9rtelmezetten felugrik k\u00f3d\u00edr\u00e1s k\u00f6zben is.</li> <li>\u00cdrjuk be a <code>Console</code> \u00e9s a <code>.WriteLine()</code> elemeket \u00fagy, hogy g\u00e9pel\u00e9s k\u00f6zben az IntelliSense leg\u00f6rd\u00fcl\u0151b\u0151l v\u00e1lasszuk ki az elemet, majd Tab billenty\u0171vel v\u00e9gleges\u00edts\u00fck a v\u00e1laszt\u00e1st.</li> <li>Haszn\u00e1ljuk a <code>cw</code> code snippetet, amit az IntelliSense is jelez, azaz \u00edrjuk be: <code>cw</code> majd nyomjunk k\u00e9tszer Tab-ot.</li> <li>Ha a <code>Console.ReadLine()</code> helyett <code>Console.Readline()</code>-t \u00edrunk, els\u0151k\u00e9nt az IDE azonnal jav\u00edtja a hib\u00e1t. Ha ezt a jav\u00edt\u00e1st visszavonjuk Ctrl+Z), lehet\u0151s\u00e9g\u00fcnk van a jav\u00edt\u00e1sra a Ctrl+. haszn\u00e1lat\u00e1val: a fejleszt\u0151eszk\u00f6z \u00e9szreveszi, hogy hib\u00e1t v\u00e9tett\u00fcnk, \u00e9s felk\u00edn\u00e1lja a gyakori megold\u00e1sokat.</li> <li>Overload-ok: jel\u00f6lj\u00fck ki a <code>WriteLine</code> h\u00edv\u00e1s nyit\u00f3 z\u00e1r\u00f3jel\u00e9t, \u00e9s \u00edrjuk be ism\u00e9t a nyit\u00f3 z\u00e1r\u00f3jelet. \u00cdgy el\u0151j\u00f6n az overload-ok list\u00e1ja, amik k\u00f6z\u00fcl a megfelel\u0151t a f\u00f6l/le ir\u00e1nybillenty\u0171kkel v\u00e1laszthatjuk ki. Az overload list\u00e1t megnyithatjuk \u00fagy is, hogy a z\u00e1r\u00f3jelben b\u00e1rhova \u00edrunk egy vessz\u0151 karaktert. Az overload azt jelenti, hogy ugyanazzal a f\u00fcggv\u00e9nyn\u00e9vvel t\u00f6bb, k\u00fcl\u00f6nb\u00f6z\u0151 szignat\u00far\u00e1j\u00fa met\u00f3dust is felvehet\u00fcnk, a megfelel\u0151 f\u00fcggv\u00e9ny kiv\u00e1laszt\u00e1sa a megadott param\u00e9terek sz\u00e1ma \u00e9s t\u00edpusa alapj\u00e1n t\u00f6rt\u00e9nik.</li> </ul> <p>Ind\u00edtsuk el az alkalmaz\u00e1st! Ehhez a fent tal\u00e1lhat\u00f3 Start lehet\u0151s\u00e9get haszn\u00e1lhatjuk, de mondjuk el, hogy ez a men\u00fc menu:Debug[Start Debugging] (F5) lehet\u0151s\u00e9ggel ekvivalens.</p> <p>Mutassuk be a <code>for</code> \u00e9s <code>foreach</code> vez\u00e9rl\u00e9si szerkezeteket! A projekt Properties oldal\u00e1n (kbd:[Alt+Enter] a projekt kijel\u00f6l\u00e9se ut\u00e1n) adjunk meg a Debug f\u00fcl\u00f6n a Start Options blokkn\u00e1l legal\u00e1bb \u00f6t tetsz\u0151leges parancssori argumentumot (sz\u00f3k\u00f6zzel elv\u00e1lasztva), pl. kutya alma b\u00e9ka ban\u00e1n l\u00f3.</p> <p> .NET projektbe\u00e1ll\u00edt\u00e1sok</p> <pre><code>for (int i = 0; i &lt; args.Length; i++)\n    Console.WriteLine(args[i]);\n\nforeach (string arg in args)\n    Console.WriteLine(arg);\n\nConsole.ReadLine();\n</code></pre> <p>Ind\u00edtsuk el, \u00e9s gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk.</p>"},{"location":"seminar/01-csharp1/chapter1/#debug","title":"Debug","text":"<p>Rakjunk egy breakpointot (F9), vagy klikkelj\u00fcnk baloldalon a f\u00fcgg\u0151leges s\u00e1von a k\u00f3d sorsz\u00e1ma mellett) a <code>Console.WriteLine(args[i]);</code> sorra, majd ind\u00edtsuk \u00fajra az alkalmaz\u00e1st! Amikor a breakpointon meg\u00e1ll az alkalmaz\u00e1s fut\u00e1sa, a sor s\u00e1rga sz\u00edn\u0171 lesz. Ekkor vigy\u00fck az egeret az <code>i</code>, az <code>args</code> \u00e9s az <code>args.Length</code> elemek fel\u00e9, \u00e9s mutassuk meg, hogy l\u00e1thatjuk az aktu\u00e1lis \u00e9rt\u00e9keiket, komplexebb objektumok eset\u00e9n be tudjuk j\u00e1rni az objektumgr\u00e1fot. A Watch ablakba is \u00edrhatunk kifejez\u00e9seket, \u00e9s megmutathatjuk a Locals ablakot is. F10-zel (vagy a men\u00fcsoron a Step Over elemmel) l\u00e9pj\u00fcnk tov\u00e1bb, n\u00e9zz\u00fck meg, milyen sorrendben \u00e9rt\u00e9kel\u0151dik ki a <code>for</code> ciklus. Az F5-tel tov\u00e1bbengedhetj\u00fck az alkalmaz\u00e1s fut\u00e1s\u00e1t, majd z\u00e1rjuk is be.</p> <p>Mutassuk meg a Conditional Breakpoint haszn\u00e1lat\u00e1t is. Tegy\u00fcnk m\u00e9g egy breakpointot a m\u00e1sik <code>Console.WriteLine</code>-ra is. menu:Jobb eg\u00e9r gomb az els\u0151 breakpointon[Conditions\u2026], majd adjuk meg az al\u00e1bbiakat: Conditional Expression Is true <code>(i == 3)</code>. A m\u00e1sik breakpointon is adjunk meg felt\u00e9telt: Hit Count = 4. Mindk\u00e9t alkalommal a 4. elemen (ban\u00e1n) \u00e1llunk meg. Megjegyezhetj\u00fck, hogy a Conditional Breakpoint haszn\u00e1lat\u00e1val nem \u00e9rdemes mell\u00e9khat\u00e1st okoz\u00f3 m\u0171veleteket megadni, illetve hogy jelent\u0151sen le tudja cs\u00f6kkenteni a debuggol\u00e1s sebess\u00e9g\u00e9t.</p>"},{"location":"seminar/01-csharp1/chapter1/#tulajdonsagok-property-k","title":"Tulajdons\u00e1gok (Property-k)","text":"<p>Hozzuk l\u00e9tre a <code>Person</code> adatoszt\u00e1lyt! Ehhez menu: jobb katt a projekten[Add &gt; Class], a f\u00e1jl neve legyen <code>Person</code> (a kiterjeszt\u00e9st automatikusan hozz\u00e1biggyeszti a Visual Studio, ha nem adjuk meg). .NET-ben nincs megk\u00f6t\u00e9s arra, hogy a k\u00f3dokat tartalmaz\u00f3 f\u00e1jlok \u00e9s az egyes t\u00edpusok sz\u00e1moss\u00e1ga hogyan viszonyul egym\u00e1shoz: lehets\u00e9ges egy k\u00f3df\u00e1jlba is \u00edrnunk a teljes alkalmaz\u00e1s-k\u00f3dot, illetve egy oszt\u00e1lyt is sz\u00e9tdarabolhatunk t\u00f6bb f\u00e1jlra (ehhez a <code>partial</code> kulcssz\u00f3t haszn\u00e1ljuk).</p> <p>A C# tulajdons\u00e1g (property) egy szintaktikai \u00e9des\u00edt\u0151szer, amely egy objektump\u00e9ld\u00e1ny (vagy oszt\u00e1ly) egy explicit (mem\u00f3riabeli) vagy implicit (sz\u00e1rmaztatott vagy indirekt) jellemz\u0151j\u00e9t \u00edrja le. Egy tulajdons\u00e1ggal k\u00e9t m\u0171velet v\u00e9gezhet\u0151: lek\u00e9rdez\u00e9s (get) \u00e9s \u00e9rt\u00e9kad\u00e1s (set); ezeknek megadhat\u00f3 k\u00fcl\u00f6n a l\u00e1that\u00f3s\u00e1ga, \u00e9s a kett\u0151 k\u00f6z\u00fcl elegend\u0151 egy implement\u00e1l\u00e1sa. A legt\u00f6bb C# szintaktikai \u00e9des\u00edt\u0151szer a boilerplate k\u00f3dok \u00edr\u00e1s\u00e1nak elker\u00fcl\u00e9se v\u00e9gett k\u00e9sz\u00fclt, \u00edgy kevesebb k\u00f3dol\u00e1ssal \u00e9rj\u00fck el ugyanazt az eredm\u00e9nyt (sokszor az IL k\u00f3d nem is v\u00e1ltozik, gyakorlatilag hasonl\u00f3 a k\u00f3dgener\u00e1l\u00e1shoz).</p> <p>A <code>Person</code> oszt\u00e1lyban hozzuk l\u00e9tre a <code>string Name</code> property-t, <code>name</code> oszt\u00e1lyv\u00e1ltoz\u00f3val (field). Ehhez haszn\u00e1ljuk a <code>propfull</code> code snippetet (<code>propf</code>, majd Tab+Tab, ezut\u00e1n Tab-bal lehet l\u00e9pkedni a m\u00f3dos\u00edtand\u00f3 elemek k\u00f6z\u00f6tt):</p> <pre><code>public class Person\n{\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        private set { name = value; }\n    }\n\n    public Person(string name)\n    {\n        this.name = name;\n    }\n}\n</code></pre> <p>L\u00e1that\u00f3s\u00e1g</p> <p>Figyelj\u00fcnk az oszt\u00e1ly l\u00e1that\u00f3s\u00e1g\u00e1ra is, alapb\u00f3l nem publikusk\u00e9nt gener\u00e1l\u00f3dik!</p> <p>Igaz\u00e1b\u00f3l csak k\u00e9t tov\u00e1bbi (k\u00f3dban nem l\u00e1that\u00f3) met\u00f3dust hozunk l\u00e9tre, mintha egy-egy <code>GetName</code> \u00e9s <code>SetName</code> met\u00f3dust k\u00e9sz\u00edten\u00e9nk, viszont haszn\u00e1lat szempontj\u00e1b\u00f3l ugyanolyannak t\u0171nik, mintha egy sima mez\u0151 lenne. A settert priv\u00e1t l\u00e1that\u00f3s\u00e1g\u00fara tessz\u00fck, ez\u00e9rt csak egy <code>Person</code> p\u00e9ld\u00e1nyon bel\u00fclr\u0151l tudjuk \u00e1ll\u00edtani a <code>Name</code> property \u00e9rt\u00e9k\u00e9t. Jegyezz\u00fck meg, hogy a getterben \u00e9s setterben teljesen m\u00e1s jelleg\u0171 m\u0171veleteket is v\u00e9gezhet\u00fcnk (pl. els\u00fcthet\u00fcnk egy esem\u00e9nyt, hogy megv\u00e1ltozott a felhaszn\u00e1l\u00f3 neve, napl\u00f3zhatjuk, h\u00e1nyszor k\u00e9rt\u00e9k le a nev\u00e9t, stb.). A property egyik nagy er\u00e9nye, hogy oszt\u00e1lyon k\u00edv\u00fclr\u0151l az oszt\u00e1lyv\u00e1ltoz\u00f3kn\u00e1l megszokott szintaxissal haszn\u00e1lhatjuk.</p> <p>A <code>Main</code> f\u00fcggv\u00e9nybe \u00edrhatjuk p\u00e9ld\u00e1ul:</p> Program.cs<pre><code>Person p = new Person(\"Eric Lippert\");\np.Name = \"Mads Torgersen\";\nConsole.WriteLine(p.Name);\n</code></pre> <p>Debuggerrel figyelj\u00fck meg, hogy az els\u0151 sor a konstruktort, m\u00edg a m\u00e1sodik a property setter\u00e9t, v\u00e9g\u00fcl a harmadik sor ugyanazon property getter\u00e9t h\u00edvja.</p> <p>Mivel a backing field \u00e1ll\u00edt\u00e1s\u00e1n k\u00edv\u00fcl nem csin\u00e1lunk semmit a property k\u00f3dban, ez\u00e9rt haszn\u00e1lhatjuk a <code>propg</code> code snippetet is:</p> Person.cs<pre><code>public string Name { get; private set; }\n</code></pre> <p>Ez az \u00fan. auto-implement\u00e1lt property szintaxis. A property \u00e1ltal lek\u00e9rdezhet\u0151-be\u00e1ll\u00edthat\u00f3 field gener\u00e1l\u00f3dik, arra a k\u00f3dban nem is tudunk hivatkozni - ez az egys\u00e9gbe z\u00e1r\u00e1s miatt el\u0151ny\u00f6s.</p> <p>A l\u00e1that\u00f3s\u00e1g miatt a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben a setter h\u00edv\u00e1s m\u00e1r nem fordul, kommentezz\u00fck ki.</p> Person.cs<pre><code>//p.Name = \"Mads Torgersen\";\n</code></pre> <p>L\u00e9tezik m\u00e9g a <code>prop</code> code snippet is, ami mindk\u00e9t m\u00f3dos\u00edt\u00f3sz\u00f3t publikusan hagyja. L\u00e1that\u00f3s\u00e1gi m\u00f3dos\u00edt\u00f3sz\u00f3t a <code>get</code> \u00e9s <code>set</code> k\u00f6z\u00fcl csak az egyik el\u00e9 tehet\u00fcnk ki, \u00e9s az is csak szigor\u00edthat a k\u00fcls\u0151 l\u00e1that\u00f3s\u00e1gon (ekkor a m\u00e1sik a k\u00fcls\u0151t kapja meg).</p> <p>Ez a megold\u00e1s az el\u0151z\u0151vel teljes m\u00e9rt\u00e9kben ekvivalens (csak nem l\u00e1tjuk a gener\u00e1lt backing fieldet, de val\u00f3j\u00e1ban ott van). Ha van id\u0151nk, akkor vizsg\u00e1ljuk meg decompilerben (pl. Telerik JustDecompile), hogy val\u00f3ban \u00edgy van.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3an vegy\u00fck fel a sz\u00fclet\u00e9si d\u00e1tumot is. A sz\u00fclet\u00e9si d\u00e1tum nem v\u00e1ltozhat, gyakorlatilag <code>readonly</code> mez\u0151r\u0151l van sz\u00f3. Ha egy tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t az objektum is csak a konstruktorban tudja megadni, akkor a setter teljes m\u00e9rt\u00e9kben elhagyhat\u00f3:</p> Person.cs<pre><code>public DateTime DateOfBirth { get; }\n\npublic Person(string name, DateTime dateOfBirth)\n{\n    Name = name;\n    DateOfBirth = dateOfBirth;\n}\n</code></pre> <p>Ez a szintaktika megegyezik azzal, mintha egy <code>readonly</code> mez\u0151t haszn\u00e1ln\u00e1nk, azaz a mez\u0151 \u00e9rt\u00e9ke legk\u00e9s\u0151bb a konstruktorban inicializ\u00e1land\u00f3.</p> <p>Vegy\u00fcnk fel neki egy azonos\u00edt\u00f3t, ami egy <code>Guid</code> strukt\u00fara t\u00edpus\u00fa legyen:</p> Person.cs<pre><code>public Guid Id { get; } = Guid.NewGuid();\n</code></pre> <p>Ez egy csak lek\u00e9rdezhet\u0151 tulajdons\u00e1g, ami konstru\u00e1l\u00e1skor inicializ\u00e1l\u00f3dik egy \u00faj v\u00e9letlenszer\u0171 azonos\u00edt\u00f3 \u00e9rt\u00e9kre.</p> <p>Megadhatjuk a kort, mint implicit/sz\u00e1m\u00edtott tulajdons\u00e1got:</p> Person.cs<pre><code>public int Age { get { return DateTime.Now.Subtract(DateOfBirth).Days / 365; } }\n</code></pre> <p>Mivel a f\u00fcggv\u00e9ny\u00fcnk t\u00f6rzse egyetlen kifejez\u00e9ssel megadhat\u00f3, ez\u00e9rt elhagyva a sallangot (<code>return</code>, kapcsos z\u00e1r\u00f3jelek, stb.) expression bodied property szintaxissal is \u00edrhatjuk:</p> Person.cs<pre><code>public int Age =&gt; DateTime.Now.Subtract(DateOfBirth).Days / 365;\n</code></pre> <p>Tip</p> <p>Alkalmaz\u00e1sok fejleszt\u00e9sekor a legfontosabb els\u0151 l\u00e9p\u00e9sek egyike, hogy az objektummodell\u00fcnk \u00e1tl\u00e1that\u00f3, karbantarthat\u00f3 \u00e9s egy\u00e9rtelm\u0171 legyen. A C# v\u00e1ltozatos szintaxisa nagyon sokat seg\u00edt ezen c\u00e9lok el\u00e9r\u00e9s\u00e9ben.</p>"},{"location":"seminar/01-csharp1/chapter1/#generikus-kollekcio","title":"Generikus kollekci\u00f3","text":"<p>A <code>Main</code> met\u00f3dusban vegy\u00fcnk fel n\u00e9h\u00e1ny <code>Person</code> objektumot, \u00e9s list\u00e1zzuk ki a relev\u00e1ns tulajdons\u00e1gaikat! Ehhez egy <code>Person</code> list\u00e1ban t\u00e1roljuk a szem\u00e9lyeket. A <code>List</code> generikus kollekci\u00f3, azaz t\u00edpusparam\u00e9tert v\u00e1r, t\u00edpusokkal param\u00e9terezhet\u0151. A <code>List</code> t\u00edpusparam\u00e9tere jelzi, hogy milyen t\u00edpus\u00fa objektumokat t\u00e1rol. Met\u00f3dusok, tulajdons\u00e1gok, t\u00edpusok lehetnek generikusak. A genericit\u00e1s fontos a k\u00f3dunk \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1ga \u00e9s karbantarthat\u00f3s\u00e1ga \u00e9rdek\u00e9ben.</p> <pre><code>static void Main(string[] args)\n{\n    List&lt;Person&gt; people = new List&lt;Person&gt;();\n    people.Add(new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)));\n    people.Add(new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)));\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n\n    foreach (Person person in people)\n        Console.WriteLine(person);\n\n    Console.ReadLine();\n}\n</code></pre> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, mi t\u00f6rt\u00e9nik! Annyiszor \u00edr\u00f3dik ki a <code>Person</code> oszt\u00e1lyunk teljes neve (fully qualified type name), ah\u00e1ny elem van a list\u00e1ban.</p>"},{"location":"seminar/01-csharp1/chapter1/#leszarmazas-string-interpolacio","title":"Lesz\u00e1rmaz\u00e1s, string interpol\u00e1ci\u00f3","text":"<p>Ha a <code>WriteLine</code> f\u00f6l\u00e9 vissz\u00fck az egeret, l\u00e1that\u00f3, hogy az overload-ok k\u00f6z\u00fcl az h\u00edv\u00f3dik meg, amelyik objektumot v\u00e1r param\u00e9ter\u00fcl. Ebben az esetben a param\u00e9ter <code>ToString</code> met\u00f3dus\u00e1t h\u00edvja meg a <code>WriteLine</code>, ami alap\u00e9rtelmez\u00e9s szerint az objektum t\u00edpus\u00e1nak teljes nev\u00e9t adj\u00e1k vissza. Tegy\u00fck szebb\u00e9 a ki\u00edr\u00e1st, defini\u00e1ljuk fel\u00fcl az alap\u00e9rtelmezett <code>ToString</code> implement\u00e1ci\u00f3t a <code>Person</code> oszt\u00e1lyban:</p> Person.cs<pre><code>public override string ToString()\n{\n    return string.Format(\"{0} ({1}) [ID: {2}]\", Name, Age, Id);\n}\n</code></pre> <p>A <code>Person</code> oszt\u00e1lynak nincs explicit megadva \u0151soszt\u00e1lya, m\u00e9gis van fel\u00fcldefini\u00e1lhat\u00f3 f\u00fcggv\u00e9nye. Ezeket az <code>Object</code> oszt\u00e1ly defini\u00e1lja. Ha egy referencia t\u00edpusnak nincs megadva \u0151soszt\u00e1lya, akkor az <code>Object</code> lesz az.</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1ra m\u00e1s szintaktikai \u00e9des\u00edt\u0151szereket is haszn\u00e1lhatunk:</p> Person.cs<pre><code>public override string ToString() =&gt; $\"{Name} ({Age}) [ID: {Id}]\";\n</code></pre> <p>A k\u00e9t implement\u00e1ci\u00f3 ekvivalens, a m\u00e1sodik implement\u00e1ci\u00f3 az \u00fan. expression bodied method \u00e9s a string interpol\u00e1ci\u00f3 kombin\u00e1l\u00e1s\u00e1b\u00f3l ad\u00f3dik.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st!</p> <p>Hozzuk l\u00e9tre a <code>Student</code> oszt\u00e1lyt, ami sz\u00e1rmazik a <code>Person</code> oszt\u00e1lyb\u00f3l!</p> <pre><code>public class Student : Person\n{\n    public string Neptun { get; set; }\n\n    public string Major { get; set; }\n\n    public Student(string name, DateTime dateOfBirth)\n        : base(name, dateOfBirth)\n    {\n    }\n\n    public override string ToString() =&gt; $\"{base.ToString()} Neptun: {Neptun} Major: {Major}\";\n}\n</code></pre> <p>Ez az oszt\u00e1ly m\u00e1s megk\u00f6zel\u00edt\u00e9ssel k\u00e9sz\u00fclt, mint a sz\u00fcl\u0151je, az \u00e1llapota nem a konstruktor megh\u00edv\u00e1sakor t\u00f6lt\u0151dik fel, ut\u00f3lag lehet megadni setter h\u00edv\u00e1sokkal. Ez egyr\u00e9szt k\u00e9nyelmes, mert nem kell sokparam\u00e9teres konstruktorokkal k\u00fczdeni, m\u00e1sr\u00e9szt fel kell k\u00e9sz\u00fcln\u00fcnk arra, hogy bizonyos adatokat nem t\u00f6ltenek ki.</p> <p>\u0150s konstruktora</p> <p>Ha az \u0151soszt\u00e1lynak nincs param\u00e9ter n\u00e9lk\u00fcli konstruktora (a <code>Person</code> oszt\u00e1lynak nincs), akkor k\u00f6telesek vagyunk a gyerek konstruktorban az \u0151soszt\u00e1ly valamelyik konstruktor\u00e1t megh\u00edvni a <code>base</code> kulcssz\u00f3val.</p>"},{"location":"seminar/01-csharp1/chapter1/#objektum-inicializalok","title":"Objektum inicializ\u00e1l\u00f3k","text":"<p>Az object initializer seg\u00edts\u00e9g\u00e9vel az objektum l\u00e9trehoz\u00e1s\u00e1t (konstruktor h\u00edv\u00e1s) \u00e9s a property setterek megh\u00edv\u00e1s\u00e1val t\u00f6rt\u00e9n\u0151 inicializ\u00e1l\u00e1s\u00e1t int\u00e9zhetj\u00fck egy f\u00fcst alatt.  Az objektum inicializ\u00e1l\u00f3 csak konstruktorh\u00edv\u00e1s eset\u00e9n haszn\u00e1lhat\u00f3, \u00edgy pl. factory met\u00f3dus \u00e1ltal gy\u00e1rtott objektump\u00e9ld\u00e1ny eset\u00e9n nem.</p> <p>A <code>Main</code> met\u00f3dusban \u00edrhatjuk az al\u00e1bbi p\u00e9ld\u00e1t:</p> <pre><code>static void Main(string[] args)\n{\n    /*...*/\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n    Student elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major = \"Info BSc\"\n    };\n    /*...*/\n}\n</code></pre> <p>Konstruktor szintaktik\u00e1k</p> <p>Objektum inicializ\u00e1l\u00e1s sor\u00e1n, param\u00e9ter n\u00e9lk\u00fcli konstruktor eset\u00e9n a <code>()</code> is elhagyhat\u00f3.</p> <p>T\u00f6bb sorba t\u00f6rdel\u00e9s</p> <p>\u00c1ltal\u00e1ban 1-2 tulajdons\u00e1g eset\u00e9n lehet egy sorba is \u00edrni az inicializ\u00e1ci\u00f3t, t\u00f6bb eset\u00e9n viszont \u00e1ltal\u00e1ban t\u00f6bb sorba \u00e9rdemes t\u00f6rdelni az olvashat\u00f3s\u00e1g \u00e9rdek\u00e9ben.</p> <p>L\u00e1thatjuk, hogy csak az aktu\u00e1lis kontextusban egy\u00e9bk\u00e9nt is l\u00e1that\u00f3 \u00e9s be\u00e1ll\u00edthat\u00f3 tulajdons\u00e1gokat \u00e1ll\u00edthatjuk be, egyik \u00edgy be\u00e1ll\u00edtott tulajdons\u00e1g sem k\u00f6telez\u0151 jelleg\u0171.</p> <p>Az object initializer val\u00f3ban csak az egyes tulajdons\u00e1gokat \u00e1ll\u00edtja be, teh\u00e1t csak szintaktikailag k\u00fcl\u00f6nb\u00f6zik az els\u0151 defin\u00edci\u00f3 az al\u00e1bbit\u00f3l:</p> <p>Note</p> <p>Nem kell be\u00edrni, csak szeml\u00e9ltet\u00e9s.</p> <pre><code>Student _elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10));\n_elek.Neptun = \"ABC123\";\n_elek.Major = \"Info BSc\";\nStudent elek = _elek;\n</code></pre> <p>A h\u00e1tt\u00e9rben t\u00e9nyleg egy (sz\u00e1munkra nem l\u00e1that\u00f3) tempor\u00e1lis v\u00e1ltoz\u00f3ban fog t\u00f6rt\u00e9nni az inicializ\u00e1ci\u00f3, ugyanis, ha az object initializer kiv\u00e9telt dob (az egyik setter \u00e1ltal), az objektumunk nem veszi fel a k\u00edv\u00e1nt \u00e9rt\u00e9ket.</p> <p>Objektum inicializ\u00e1l\u00f3 haszna</p> <p>Ebb\u0151l l\u00e1tszik az objektum inicializ\u00e1l\u00f3 els\u0151dleges haszna, m\u00e9gpedig, hogy nem kell \u00e1lland\u00f3an ki\u00edrogatni, hogy melyik p\u00e9ld\u00e1nyra gondolunk (\u00edgy elrontani sem tudjuk).</p>"},{"location":"seminar/01-csharp1/chapter1/#kollekcio-inicializacio","title":"Kollekci\u00f3 inicializ\u00e1ci\u00f3","text":"<p>Az egyszer\u0171s\u00edtett kollekci\u00f3 inicializ\u00e1ci\u00f3 szintaxissal a lista teljes felt\u00f6lt\u00e9se j\u00f3val kevesebb k\u00f3ddal \u00e9s j\u00f3val olvashat\u00f3bban megadhat\u00f3. R\u00e1ad\u00e1sul a kollekci\u00f3 elemeit l\u00e9trehozhatjuk az objektum inicializ\u00e1ci\u00f3s szintaxissal is. A teljes lista l\u00e9trehoz\u00e1st \u00e9s -felt\u00f6lt\u00e9s r\u00e9szt cser\u00e9lj\u00fck le az al\u00e1bbira.</p> <pre><code>List&lt;Person&gt; people = new List&lt;Person&gt;\n{\n    new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)),\n    new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)),\n    new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)),\n    new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major=\"Info BSc\"\n    },\n    new Student(\"Hi\u00e1ny \u00c1ron\", new DateTime(2000, 02, 13))\n};\n</code></pre> <p>Nem kell az <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1st \u00e9s a lista referenci\u00e1t ki\u00edrni, egy\u00e9rtelm\u0171, hogy melyik list\u00e1hoz adunk hozz\u00e1.</p> <p>Add</p> <p>Ez a forma is ugyanolyan <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokra fordul, mint az eredeti v\u00e1ltozatban.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! L\u00e1thatjuk, hogy a konstruktoron kereszt\u00fcl teljesen inicializ\u00e1lhat\u00f3 <code>Person</code> p\u00e9ld\u00e1nyok eset\u00e9ben a ki\u00edr\u00e1s teljes, viszont vannak olyan <code>Student</code> p\u00e9ld\u00e1nyok, ahol a ki\u00edr\u00e1s \u00fcres \u00e9rt\u00e9keket tal\u00e1l. Ezzel a jelens\u00e9ggel a k\u00f6vetkez\u0151 gyakorlatokon tov\u00e1bb foglalkozunk.</p>"}]}