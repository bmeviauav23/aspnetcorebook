{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftverfejleszt\u00e9s .NET platformra","text":"<p>Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a Szoftverfejleszt\u00e9s .NET platformra c. t\u00e1rgyhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p> <p>A felhaszn\u00e1l\u00e1si felt\u00e9telekr\u0151l b\u0151vebben a repository LICENSE.md f\u00e1jlj\u00e1ban olvashatsz.</p>"},{"location":"homework/","title":"H\u00e1zi feladat tudnival\u00f3k","text":"<p>TBD</p>"},{"location":"information/contributing/","title":"Hozz\u00e1j\u00e1rul\u00e1s az anyaghoz","text":"<p>Az anyag terjedelm\u00e9b\u0151l adand\u00f3an apr\u00f3bb hib\u00e1k esetenk\u00e9nt hi\u00e1nyoss\u00e1gok jelentkezhetnek a laborokban. Ha egy ilyennel tal\u00e1lkozol \u00e9s \u00fagy d\u00f6ntesz szeretn\u00e9l seg\u00edteni hallgat\u00f3t\u00e1rsaidnak, azt a k\u00f6vetkez\u0151kben le\u00edrtak alapj\u00e1n tudod megtenni.</p> <p>Plusz pont jegyzet jav\u00edt\u00e1s\u00e9rt</p> <p>M\u00e1s tant\u00e1rgyak mint\u00e1j\u00e1ra itt is szeretn\u00e9nk plusz pontot adni a jegyzet open-source hozz\u00e1j\u00e1rul\u00e1sai\u00e9rt. Akik a t\u00e1rgyat jelenleg hallgatj\u00e1k, pontokat kaphatnak hozz\u00e1j\u00e1rul\u00e1saik\u00e9rrt.</p> <p>A f\u00e9l\u00e9v sor\u00e1n max 3 db plusz pontot lehet szerezni fejenk\u00e9nt olyan jav\u00edt\u00e1sok\u00e9rt, amik a trivi\u00e1lis 1-2 bet\u0171 elg\u00e9pel\u00e9sen t\u00fal \u00e9rdemben jav\u00edtanak a githubon tal\u00e1lhat\u00f3 labor jegyzetek min\u0151s\u00e9g\u00e9n. Pl.: jelent\u0151s mennyis\u00e9g\u0171 elg\u00e9pel\u00e9s jav\u00edt\u00e1sa, egy\u00e9rtelm\u0171s\u00edt\u00e9sek, illusztr\u00e1ci\u00f3k kieg\u00e9sz\u00edt\u00e9sek k\u00e9sz\u00edt\u00e9se vagy ak\u00e1r egy teljes kieg\u00e9sz\u00edt\u0151 jegyzet \u00edr\u00e1sa  (term\u00e9szetesen nem azonos pont\u00e9rt\u00e9kkel).</p> <p>Persze a pont n\u00e9lk\u00fcl az 1-1 bet\u0171s elg\u00e9pel\u00e9seket is sz\u00edvesen fogadjuk, ami bemeleg\u00edt\u00e9snek is t\u00f6k\u00e9letes.</p>"},{"location":"information/contributing/#hibak-jelzese","title":"Hib\u00e1k jelz\u00e9se","text":"<p>Amennyiben hib\u00e1t tal\u00e1lsz az anyagban, vagy szeretn\u00e9d b\u0151v\u00edteni, de nem \u00e1ll m\u00f3dodban jav\u00edtani, nyithatsz egy issue-t amiben le\u00edrod a hib\u00e1t.</p> <ol> <li>N\u00e9zd meg, hogy valaki nem jelezte-e, amit szeretn\u00e9l.     Gyakran m\u00e1r l\u00e9tez\u0151 probl\u00e9m\u00e1kat tal\u00e1lnak, amire m\u00e1r van pull request,     \u00edgy miel\u0151tt b\u00e1rmit tenn\u00e9l n\u00e9zd meg valaki nem el\u0151z\u00f6tt-e meg</li> <li>Az issues tabon a new issue gombbal hozz l\u00e9tre egy \u00faj issue-t.     </li> <li>L\u00e1sd el a megfelel\u0151 c\u00edmk\u00e9kkel<ol> <li>A labor t\u00edpusa (<code>android</code> az androidos laborokn\u00e1l \u00e9s <code>web</code> a webes laborokn\u00e1l)</li> <li>A hiba t\u00edpusa (<code>clarification</code>, <code>typo</code>, <code>illustration</code> vagy <code>notes</code>)</li> </ol> </li> <li>\u00cdrd le, hogy mit k\u00e9ne tartalmaznia a jav\u00edt\u00e1snak</li> </ol> <p>Tip</p> <p>Az c\u00edme legyen r\u00f6vid \u00e9s l\u00e9nyegret\u00f6r\u0151, pl.: <code>Megfogalmaz\u00e1s pontos\u00edt\u00e1sa a 4. laborban</code> vagy <code>A 6. laborban a le\u00edrt k\u00f3d hib\u00e1san m\u0171k\u00f6dik Android 12-n</code></p> <p>A issue descriptionj\u00e9ben pedig fejtsd ki, hol tal\u00e1lhat\u00f3 a hi\u00e1nyoss\u00e1g, illetve ha van r\u00e1 \u00f6tleted, hogy lehetne orvosolni ezt. Ha ezeken t\u00fal m\u00e9g screenshotot is tudsz mell\u00e9kelni, az nagyban megseg\u00edti a probl\u00e9ma mihamarabbi jav\u00edt\u00e1s\u00e1t.</p> <p>Warning</p> <p>A github issues nem a laborfeladatok megold\u00e1s\u00e1val kapcsolatos probl\u00e9m\u00e1k helye, \u00edgy a \"Nem tudom megoldani hogy az \u00e9rtes\u00edt\u00e9s meg\u00e9rkezzen\" jelleg\u0171 probl\u00e9m\u00e1kat ne itt jelezz\u00e9tek, erre vannak a laboralkalmak.</p>"},{"location":"information/contributing/#valtoztatasok-javaslasa","title":"V\u00e1ltoztat\u00e1sok javasl\u00e1sa","text":"<p>Amennyiben a hozz\u00e1j\u00e1rul\u00e1sod meg tudod val\u00f3s\u00edtani ind\u00edts pull requestet</p> <ol> <li> <p>Forkold a repository-t a Githubon jobb fels\u0151 sarokban tal\u00e1lhat\u00f3 gombbal     </p> </li> <li> <p>V\u00e9gezd el a v\u00e1ltoztat\u00e1sokat.</p> <ol> <li> <p>Hozz l\u00e9tre egy branchet a saj\u00e1t forkodon, amin a v\u00e1ltoztat\u00e1sokat el fogod v\u00e9gezni.</p> </li> <li> <p>Ezen a branchen k\u00e9sz\u00edtsd el a jav\u00edt\u00e1sokat</p> </li> <li> <p>Ellen\u0151rizd, hogy ne ker\u00fclj\u00f6n bele a commitba olyan file, amit az editor gener\u00e1lt (pl.: <code>.idea</code> mappa) illetve olyan file aminek nem k\u00e9ne kiker\u00fclnie, pl.: Github Private Access Token</p> </li> <li> <p>Ha k\u00e9sz vagy ind\u00edts egy pull requestet a jegyzeteket tartalmaz\u00f3 rep\u00f3 f\u0151 \u00e1g\u00e1ra.</p> </li> <li> <p>A le\u00edr\u00e1sban r\u00e9szletezd v\u00e1ltoztat\u00e1sok ok\u00e1t.     Ne felejtsd el bele\u00edrni a NEPTUN k\u00f3dod a le\u00edr\u00e1sba, mert \u00edgy fogjuk tudni megadni a pontokat.</p> </li> </ol> </li> <li> <p>Valaki, akinek hozz\u00e1f\u00e9r\u00e9se van a repositoryhoz, ellen\u0151rzi a v\u00e1ltoztat\u00e1sok sz\u00fcks\u00e9gess\u00e9g\u00e9t, \u00e9s elb\u00edr\u00e1lja, hogy val\u00f3ban beker\u00fclhet az anyagba.</p> </li> <li>A v\u00e1ltoztat\u00e1sokra review-t ind\u00edtunk \u00e9s ha kell m\u00f3dos\u00edt\u00e1sokat fogunk k\u00e9rni.</li> <li>Ha minden k\u00e9rt v\u00e1ltoztat\u00e1s megt\u00f6rt\u00e9nt, a hozz\u00e1j\u00e1rul\u00e1sod beleker\u00fcl az anyagba.</li> </ol>"},{"location":"information/contributing/#code-style","title":"Code style","text":"<ul> <li>Markdown: Mivel az alap spec nem mindig a legtiszt\u00e1bban \u00e9rthet\u0151, a markdownlint szab\u00e1lyai alapj\u00e1n, az n\u00e9h\u00e1ny kiv\u00e9tel\u00e9vel. Ezeket a <code>.markdownlint.yaml</code>-ben tal\u00e1lod, ha VSCode-ot haszn\u00e1lsz automatikusan alkalmazza \u0151ket az editor \u00e9s jelzi ha nem megfelel\u0151 amit \u00edrsz.</li> </ul> <p>Ezek a st\u00edlusok a t\u00e1rgyban aj\u00e1nlott editorokban k\u00f6nnyen be\u00e1ll\u00edthat\u00f3ak.</p>"},{"location":"information/contributing/#vscode","title":"VSCode","text":"<p>Aj\u00e1nlott extension\u00f6k:</p> <ul> <li><code>yzhang.markdown-all-in-one</code>: MD szinkroniz\u00e1lt live preview</li> <li><code>DavidAnson.vscode-markdownlint</code>: MD form\u00e1z\u00e1s, szab\u00e1lyok stb.</li> <li>Prettier: HTML+CSS form\u00e1z\u00f3</li> <li>Error Lens: Kiemeli a hib\u00e1kat hogy gyorsabben megtal\u00e1ljuk \u0151ket</li> <li>Paste Image: egyszer\u0171s\u00edti a k\u00e9pek beilleszt\u00e9s\u00e9t markdownba</li> </ul> <p>Az editor be\u00e1ll\u00edt\u00e1s\u00e1hoz nyisd meg a repo-t a gy\u00f6ker\u00e9ben VSCode-al. A VSCode fel fogja aj\u00e1nlani a k\u00e9t markdown extension-t.</p> <p></p> <p>Ha ez megt\u00f6rt\u00e9nt, nyiss meg egy markdown dokumentumot, \u00e9s haszn\u00e1ld a Ctrl+Shift+P shortcutot, a command palette megnyit\u00e1s\u00e1hoz.</p> <p>Tip</p> <p>A command palette a VSCode parancsaihoz ny\u00fajt hozz\u00e1f\u00e9r\u00e9st, autocompleteeli a parancsokat \u00e9s egy minim\u00e1lis GUI-t is biztos\u00edt.</p> <p>A command palette-be keress\u00fck meg a <code>Format Document With...</code> men\u00fcpontot \u00e9s v\u00e1lasszuk ki. Ekkor egy almen\u00fcbe dob az editor \u00e9s kiv\u00e1laszthatjuk hogy melyik form\u00e1z\u00f3val form\u00e1zzuk a MD dokumentumokat. Legalul lesz egy <code>Configure Default Formatter</code>, v\u00e1lasszuk ezt. Ezut\u00e1n v\u00e1lasszuk a <code>markdownlint</code> extensiont, \u00e9s k\u00e9szen vagyunk.</p> <p>Megfelel\u0151 formatter kiv\u00e1laszt\u00e1sa</p> <p>Ne v\u00e1laszd ki a prettiert formatterk\u00e9nt, mert elt\u00f6ri a sz\u00f6vegbubor\u00e9kokat.</p> <p>Ezen fel\u00fcl \u00e9rdemes lehet bekapcsolni a ment\u00e9s el\u0151tti form\u00e1z\u00e1st.</p> <p>A Ctrl+, shortcuttal megnyitjuk a be\u00e1ll\u00edt\u00e1sokat, \u00e9s r\u00e1keres\u00fcnk arra, hogy format on save. Itt kipip\u00e1ljuk a checkboxot \u00e9s k\u00e9szen vagyunk.</p> <p>Ha ehhez nem lenne t\u00fcrelmed, itt a json amit a <code>settings.json</code>-ba illesztve be\u00e1ll\u00edt\u00f3dik minden.</p> <pre><code>{\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"DavidAnson.vscode-markdownlint\",\n    \"editor.formatOnSave\": true\n  }\n}\n</code></pre>"},{"location":"information/preface/","title":"Tudnival\u00f3k","text":""},{"location":"information/preface/#a-jegyzet-celja-es-celkozonsege","title":"A jegyzet c\u00e9lja \u00e9s c\u00e9lk\u00f6z\u00f6ns\u00e9ge","text":"<p>Ezen jegyzet els\u0151dlegesen a BME Villamosm\u00e9rn\u00f6ki \u00e9s Informatikai Kar\u00e1n oktatott Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgyhoz k\u00e9sz\u00fclt, c\u00e9lja, hogy seg\u00edts\u00e9get ny\u00fajtson egyr\u00e9szt a gyakorlatvezet\u0151nek a gyakorlat megtart\u00e1s\u00e1ban, m\u00e1sr\u00e9szt a kurzus hallgat\u00f3inak a gyakorlat otthoni ut\u00f3lagos megism\u00e9tl\u00e9s\u00e9hez, a tanult ismeretek \u00e1tism\u00e9tl\u00e9s\u00e9hez.</p> <p>Ebb\u0151l kifoly\u00f3lag nem tekinthet\u0151 egy teljesen kezd\u0151 szint\u0171 bevezet\u0151 C# tank\u00f6nyvnek, hiszen er\u0151teljesen \u00e9p\u00edt m\u00e1s kari t\u00e1rgyak (pl. Szoftvertechnik\u00e1k, Adatb\u00e1zisok) \u00e1ltal lefedett ismeretekre, de m\u00e9g ink\u00e1bb a Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgy el\u0151ad\u00e1saira.</p> <p>A felt\u00e9telezett el\u0151ismeretek:</p> <ul> <li>C# \u00e9s objektumorient\u00e1lt nyelvi alapok<ul> <li>oper\u00e1torok, v\u00e1ltoz\u00f3k, t\u00f6mb\u00f6k, strukt\u00far\u00e1k, f\u00fcggv\u00e9nyek fogalma</li> <li>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s \u00e9s f\u00fcggv\u00e9nyv\u00e1ltozatok</li> <li>alapvet\u0151 mem\u00f3riakezel\u00e9s (heap, stack), mutat\u00f3k fogalma, \u00e9rt\u00e9k \u00e9s referencia t\u00edpusok</li> <li>alapvet\u0151 vez\u00e9rl\u00e9si szerkezetek (ciklus, el\u00e1gaz\u00e1s, stb.), \u00e9rt\u00e9k- \u00e9s referencia szerinti param\u00e9ter\u00e1tad\u00e1s, rekurzi\u00f3</li> <li>oszt\u00e1ly, oszt\u00e1lyp\u00e9ld\u00e1ny fogalma, static, <code>new</code> oper\u00e1tor, oszt\u00e1ly szint\u0171 v\u00e1ltoz\u00f3k, generikus t\u00edpusok</li> <li>lesz\u00e1rmaz\u00e1s, virtu\u00e1lis tagf\u00fcggv\u00e9nyek</li> <li>C# esem\u00e9ny, delegate t\u00edpusok \u00e9s delegate p\u00e9ld\u00e1nyok</li> <li>Visual Studio haszn\u00e1lat\u00e1nak alapjai</li> <li>oper\u00e1ci\u00f3s rendszer kapcsolatok, folyamatok, sz\u00e1lak, parancssor, parancssori argumentumok, k\u00f6rnyezeti v\u00e1ltoz\u00f3k</li> </ul> </li> <li>SQL nyelvi alapok (SELECT, UPDATE, INSERT, DELETE utas\u00edt\u00e1sok), valamint alapvet\u0151 rel\u00e1ci\u00f3s adatmodell ismeretek (t\u00e1bl\u00e1k, els\u0151dleges- \u00e9s idegen kulcsok)</li> </ul> <p>A fentiek elsaj\u00e1t\u00edt\u00e1s\u00e1hoz seg\u00edts\u00e9get ny\u00fajthatnak Reiter Istv\u00e1n ingyenesen let\u00f6lthet\u0151 k\u00f6nyvei.</p> <p>A sz\u00f6vegben megtal\u00e1lhat\u00f3k a gyakorlatvezet\u0151knek sz\u00f3l\u00f3 kit\u00e9telek (\u201eR\u00f6viden mondjuk el\u2026\", \u201eMutassuk meg\u2026\", stb.). Ezeket mezei olvas\u00f3k\u00e9nt \u00e9rdemes figyelmen k\u00edv\u00fcl hagyni, illetve sz\u00fcks\u00e9g eset\u00e9n a kapcsol\u00f3d\u00f3 elm\u00e9leti ismereteket az el\u0151ad\u00e1sanyagb\u00f3l \u00e1tism\u00e9telni.</p>"},{"location":"information/preface/#a-jegyzet-naprakeszsege","title":"A jegyzet naprak\u00e9szs\u00e9ge","text":"<p>Az anyag gerinc\u00e9t ad\u00f3 .NET Core / .NET 5,6 platform jelenleg igen gyors \u00fctemben fejl\u0151dik. A .NET Core 1.0-s verzi\u00f3 \u00f3ta a k\u00e9sz\u00edt\u0151k t\u00f6rekednek a visszafel\u00e9 kompatibilit\u00e1sra, azonban az eszk\u00f6zk\u00e9szlet \u00e9s a korszer\u0171nek \u00e9s aj\u00e1nlottnak tekinthet\u0151 m\u00f3dszerek folyamatosan v\u00e1ltoznak, finomodnak.</p> <p>A jegyzet els\u0151dlegesen az al\u00e1bbi technol\u00f3giai verzi\u00f3khoz k\u00e9sz\u00fclt:</p> <ul> <li>C# 12</li> <li>.NET 8</li> <li>ASP.NET Core 8</li> <li>Visual Studio 2022</li> </ul> <p>Ahogyan a fenti verzi\u00f3k v\u00e1ltoznak, \u00fagy avulhatnak el a jegyzetben mutatott elj\u00e1r\u00e1sok.</p>"},{"location":"information/preface/#szoftverkornyezet","title":"Szoftverk\u00f6rnyezet","text":"<p>A gyakorlatok az al\u00e1bbi szoftverekb\u0151l \u00e1ll\u00f3 k\u00f6rnyezethez k\u00e9sz\u00fcltek:</p> <ul> <li>Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>Visual Studio 2022 (az ingyenes Community verzi\u00f3 el\u00e9g) az al\u00e1bbi workloadokkal:<ul> <li>.NET desktop development</li> <li>Data storage and processing</li> <li>ASP.NET and web development</li> <li>Azure Development</li> </ul> </li> <li>Telerik Fiddler Classic</li> <li>Postman</li> </ul> <p>A .NET (kor\u00e1bban .NET Core) sz\u00e9lesk\u00f6r\u0171 platformt\u00e1mogat\u00e1sa miatt bizonyos nem Windows platformokon is elv\u00e9gezhet\u0151k a gyakorlatok Visual Studio helyett Visual Studio Code haszn\u00e1lat\u00e1val - azonban a gyakorlatok sz\u00f6vege a Visual Studio haszn\u00e1lat\u00e1t felt\u00e9telezi.</p>"},{"location":"information/preface/#kodreszletek-valtozaskovetese","title":"K\u00f3dr\u00e9szletek v\u00e1ltoz\u00e1sk\u00f6vet\u00e9se","text":"<p>Az egyes gyakorlatok sor\u00e1n gyakori eset, hogy a C# k\u00f3d egy r\u00e9sz\u00e9t tov\u00e1bbfejlesztj\u00fck, megv\u00e1ltoztatjuk. Ilyen esetben a v\u00e1ltoz\u00f3 sorokat a jegyzetben kiemelt h\u00e1tt\u00e9rrel rendelkeznek. A t\u00f6r\u00f6lt k\u00f3dr\u00e9szleteket (amennyiben van seg\u00edti a meg\u00e9rt\u00e9st) kommentez\u00e9ssel jelezz\u00fck. Jel\u00f6lj\u00fck m\u00e9g a megl\u00e9v\u0151, de a jegyzetben nem megjelen\u00edtett k\u00f3dr\u00e9szleteket komment \u00e9s ... (<code>//...</code>) jellel.</p> <pre><code>using System; //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\nusing static System.Console; //ez \u00faj k\u00f3dsor\n\n//... megl\u00e9v\u0151 k\u00f3dr\u00e9szlet az el\u0151z\u0151 feladatokb\u00f3l\n\nforeach (var dog in dogs)    //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\n  /* Console.*/WriteLine(dog); //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n\n/* Console.*/ReadLine();     //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n</code></pre> <p>JSON kommentek</p> <p>A JSON form\u00e1tum alap\u00e9rtelmez\u00e9sben (RFC szerint) nem t\u00e1mogatja a kommenteket, \u00edgy ha JSON k\u00f3dr\u00e9szletet m\u00e1solunk, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy nem maradt-e a beillesztett k\u00f3dban komment, mert probl\u00e9m\u00e1t okozhat.</p>"},{"location":"seminar/01-csharp1/chapter1/","title":"C# alapok, szintaxis","text":"<p>C\u00e9lunk, hogy a hallgat\u00f3k legal\u00e1bb r\u00e9szben meg\u00e9rts\u00e9k \u00e9s r\u00e1\u00e9rezzenek a C# szintaktik\u00e1j\u00e1ra, megismerkedjenek alapvet\u0151 nyelvi elemekkel \u00e9s konstrukci\u00f3kkal.</p>"},{"location":"seminar/01-csharp1/chapter1/#hello-c","title":"Hello C#!","text":"<p>A Visual Studio ind\u00edt\u00f3ablak\u00e1ban v\u00e1lasszuk a <code>Create a new project</code> opci\u00f3t. Magyar\u00e1zzuk el, hogy van lehet\u0151s\u00e9g\u00fcnk el\u0151re gy\u00e1rtott sablonokb\u00f3l l\u00e9trehozni projekteket, illetve hogy</p> <ul> <li>egy C# projekt egy szerelv\u00e9nny\u00e9 fordul (.dll, .exe).</li> <li>a Solution dolga, hogy logikailag \u00f6sszefogja a Project-eket (t\u00f6bb-t\u00f6bbes kapcsolatban vannak).</li> <li>a projektek k\u00f6z\u00f6tt referenci\u00e1kat adhatunk m\u00e1sik projektekre \u00fagy, hogy a ford\u00edt\u00e1si mechanizmus figyelembe veszi a referenci\u00e1kat \u00e9s sz\u00fcks\u00e9g eset\u00e9n \u00fajraford\u00edtja a szerelv\u00e9nyeket.</li> <li>a projektek hivatkozhatnak k\u00fcls\u0151 forr\u00e1sb\u00f3l sz\u00e1rmaz\u00f3 szerelv\u00e9nyekre is NuGet csomagok form\u00e1j\u00e1ban. A NuGet egy egys\u00e9ges m\u00f3dszer szerelv\u00e9nyeink terjeszt\u00e9s\u00e9re.</li> </ul> <p>Hozzunk l\u00e9tre egy \u00faj C# Console Application-t! Ehhez keress\u00fck ki a sablonok k\u00f6z\u00fcl a Console App nev\u0171t (ne a .NET Framework-\u00f6set). A neve legyen HelloCSharp.</p> <p>New Project dialogusablak keres\u0151</p> <p>A kikeres\u00e9shez haszn\u00e1lhatjuk fel\u00fcl a sz\u00f6vegdobozos sz\u0171r\u0151t, illetve a leg\u00f6rd\u00fcl\u0151 list\u00e1s sz\u0171r\u0151ket is (Nyelv: C#, Platform: Windows, Projektt\u00edpus: Console)</p> <p>A sablon konfigur\u00e1ci\u00f3j\u00e1n\u00e1l adjunk meg egy olyan helyet, ahov\u00e1 van \u00edr\u00e1si jogunk. A Place solution and project in the same directory opci\u00f3t kapcsoljuk be, \u00edgy nem fog l\u00e9trej\u00f6nni egy felesleges mappa a k\u00f6nyvt\u00e1rszerkezetben. A .NET verzi\u00f3t \u00e1ll\u00edtsuk .NET 8-ra.</p> <p>\u00c9szrevehetj\u00fck, hogy az alkalmaz\u00e1s sablonok k\u00f6z\u00f6tt sima \u00e9s (.NET Framework) jel\u00f6l\u00e9s\u0171ek is vannak. A sim\u00e1k alapvet\u0151en a modernebb .NET Core/.NET 5-8 platformot c\u00e9lozz\u00e1k, a .NET Framework ezekhez k\u00e9pest egy r\u00e9gebbi platform.</p> <ul> <li>.NET Core: a .NET Framework modulariz\u00e1lt, moderniz\u00e1lt, cross-platform \u00e9s ny\u00edlt forr\u00e1sk\u00f3d\u00fa megval\u00f3s\u00edt\u00e1sa. Kisebb NuGet csomagokban \u00e9rhet\u0151 el a teljes .NET Framework funkcionalit\u00e1sa (Collections, Reflection, XML feldolgoz\u00e1s, stb.).</li> <li>.NET Framework: a \u201eklasszikus\u201d, teljes\u00e9rt\u00e9k\u0171 .NET keretrendszer, out-of-the-box t\u00e1mogatja a legelterjedtebb alkalmaz\u00e1sfejleszt\u00e9si lehet\u0151s\u00e9geket. A .NET Core megjelen\u00e9s\u00e9t k\u00f6vet\u0151en is t\u00e1mogatott, enterprise k\u00f6rnyezetekben haszn\u00e1latos, ugyanis n\u00e9h\u00e1ny enterprise technol\u00f3gia els\u0151dlegesen csak ebben t\u00e1mogatott (pl. szerver oldali WCF). Csak Windows-ra telep\u00edthet\u0151.</li> <li>.NET 5 \u00e9s f\u00f6l\u00f6tte: A .NET Core 3.1 ut\u00e1ni f\u0151 verzi\u00f3i. M\u00e1r elnevez\u00e9s\u00e9ben is jelzi, hogy ez egyben a kor\u00e1bbi .NET Core \u00e9s .NET Framework verzi\u00f3knak is ut\u00f3dja.</li> </ul> <p>Az al\u00e1bbi elemeket ismertethetj\u00fck, miel\u0151tt a k\u00f3d\u00edr\u00e1sba belekezd\u00fcnk:</p> <ul> <li>R\u00f6vid \u00e1ttekint\u00e9s az IDE-r\u0151l: men\u00fcs\u00e1v, Solution Explorer, Properties, Output, Error List ablakok, ablakoz\u00f3rendszer. Mutassuk meg, hogy drag-n-drop m\u0171veletekkel testreszabhat\u00f3 a fel\u00fclet, pl. helyezz\u00fck a Solution Explorert a k\u00e9perny\u0151 bal oldal\u00e1ra. Ha valaki v\u00e9letlen\u00fcl \u00e1trendezi az alap\u00e9rtelmezett elrendez\u00e9st, a menu:Window[Reset Window Layout] lehet\u0151s\u00e9ggel vissza\u00e1ll\u00edthatja.</li> <li>A projekt tulajdons\u00e1gok (menu:jobb klikk[Properties]) oldal\u00e1n az Application f\u00fcl\u00f6n megn\u00e9zhetj\u00fck, hogy az Output type \u00e9rt\u00e9ke hat\u00e1rozza meg, hogy milyen jelleg\u0171 (konzolos, Windows, oszt\u00e1lyk\u00f6nyvt\u00e1r) alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk.</li> <li>Mutassuk meg, hogy milyen alapvet\u0151 szerelv\u00e9nyekre adunk referenci\u00e1t a projektben!</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> f\u00e1jl tartalm\u00e1t \u00e9s fussuk \u00e1t a l\u00e1that\u00f3 elemeket!</li> <li>Magyar\u00e1zzuk el a <code>using</code> \u00e9s <code>namespace</code> kulcsszavak jelent\u00e9s\u00e9t, egym\u00e1shoz k\u00e9pesti viszonyukat! A n\u00e9vt\u00e9r \u00e9rt\u00e9ke egy \u00fajonnan l\u00e9trehozott f\u00e1jln\u00e1l alap\u00e9rtelmezetten Projektn\u00e9v.Mappaszerkezet alak\u00fa, \u00e9rdemes konvencion\u00e1lisan ezt k\u00f6vetni. Sok hallgat\u00f3n\u00e1l nem tiszta, hogy hogyan viszonyul egym\u00e1shoz a n\u00e9vt\u00e9r \u00e9s a szerelv\u00e9ny fogalma, ez\u00e9rt pr\u00f3b\u00e1ljuk meg ezt tiszt\u00e1zni!</li> <li>Utaljunk arra, hogy alapvet\u0151en kiz\u00e1r\u00f3lag objektumorient\u00e1ltan tudunk k\u00f3dot \u00edrni, \u00edgy a <code>Program</code> egy oszt\u00e1ly, a <code>Main</code> bel\u00e9p\u00e9si pont pedig egy statikus met\u00f3dus.</li> <li>Besz\u00e9lj\u00fcnk r\u00f6viden a C# elnevez\u00e9si konvenci\u00f3kr\u00f3l! A publikus elemeket (pl. Java-val \u00e9s JavaScripttel ellent\u00e9tben) \u00e9s minden met\u00f3dust \u00f6k\u00f6lszab\u00e1lyk\u00e9nt PascalCasing elnevez\u00e9si konvenci\u00f3 k\u00f6vet, a nem publikus elemekn\u00e9l camelCasing (ezek k\u00f6z\u00fcl vannak kiv\u00e9telek \u00e9s m\u00e1s konvenci\u00f3k, de ez egy gyakori megk\u00f6zel\u00edt\u00e9s).</li> </ul> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> met\u00f3dust az al\u00e1bbi k\u00f3dr\u00e9szlettel, k\u00f6zben h\u00edvjuk fel a figyelmet az IntelliSense haszn\u00e1lat\u00e1ra:</p> <pre><code>int a = 5;\nint b = 7;\nConsole.WriteLine(a + b);\nConsole.ReadLine();\n</code></pre> <p>Az IntelliSense-t demonstr\u00e1lhatjuk az al\u00e1bbi m\u00f3don:</p> <ul> <li>A k\u00f3dban b\u00e1rmely logikus helyen haszn\u00e1lhat\u00f3 az IntelliSense a Ctrl+Space billenty\u0171kombin\u00e1ci\u00f3val, ezen k\u00edv\u00fcl alap\u00e9rtelmezetten felugrik k\u00f3d\u00edr\u00e1s k\u00f6zben is.</li> <li>\u00cdrjuk be a <code>Console</code> \u00e9s a <code>.WriteLine()</code> elemeket \u00fagy, hogy g\u00e9pel\u00e9s k\u00f6zben az IntelliSense leg\u00f6rd\u00fcl\u0151b\u0151l v\u00e1lasszuk ki az elemet, majd Tab billenty\u0171vel v\u00e9gleges\u00edts\u00fck a v\u00e1laszt\u00e1st.</li> <li>Haszn\u00e1ljuk a <code>cw</code> code snippetet, amit az IntelliSense is jelez, azaz \u00edrjuk be: <code>cw</code> majd nyomjunk k\u00e9tszer Tab-ot.</li> <li>Ha a <code>Console.ReadLine()</code> helyett <code>Console.Readline()</code>-t \u00edrunk, els\u0151k\u00e9nt az IDE azonnal jav\u00edtja a hib\u00e1t. Ha ezt a jav\u00edt\u00e1st visszavonjuk Ctrl+Z), lehet\u0151s\u00e9g\u00fcnk van a jav\u00edt\u00e1sra a Ctrl+. haszn\u00e1lat\u00e1val: a fejleszt\u0151eszk\u00f6z \u00e9szreveszi, hogy hib\u00e1t v\u00e9tett\u00fcnk, \u00e9s felk\u00edn\u00e1lja a gyakori megold\u00e1sokat.</li> <li>Overload-ok: jel\u00f6lj\u00fck ki a <code>WriteLine</code> h\u00edv\u00e1s nyit\u00f3 z\u00e1r\u00f3jel\u00e9t, \u00e9s \u00edrjuk be ism\u00e9t a nyit\u00f3 z\u00e1r\u00f3jelet. \u00cdgy el\u0151j\u00f6n az overload-ok list\u00e1ja, amik k\u00f6z\u00fcl a megfelel\u0151t a f\u00f6l/le ir\u00e1nybillenty\u0171kkel v\u00e1laszthatjuk ki. Az overload list\u00e1t megnyithatjuk \u00fagy is, hogy a z\u00e1r\u00f3jelben b\u00e1rhova \u00edrunk egy vessz\u0151 karaktert. Az overload azt jelenti, hogy ugyanazzal a f\u00fcggv\u00e9nyn\u00e9vvel t\u00f6bb, k\u00fcl\u00f6nb\u00f6z\u0151 szignat\u00far\u00e1j\u00fa met\u00f3dust is felvehet\u00fcnk, a megfelel\u0151 f\u00fcggv\u00e9ny kiv\u00e1laszt\u00e1sa a megadott param\u00e9terek sz\u00e1ma \u00e9s t\u00edpusa alapj\u00e1n t\u00f6rt\u00e9nik.</li> </ul> <p>Ind\u00edtsuk el az alkalmaz\u00e1st! Ehhez a fent tal\u00e1lhat\u00f3 Start lehet\u0151s\u00e9get haszn\u00e1lhatjuk, de mondjuk el, hogy ez a men\u00fc menu:Debug[Start Debugging] (F5) lehet\u0151s\u00e9ggel ekvivalens.</p> <p>Mutassuk be a <code>for</code> \u00e9s <code>foreach</code> vez\u00e9rl\u00e9si szerkezeteket! A projekt Properties oldal\u00e1n (kbd:[Alt+Enter] a projekt kijel\u00f6l\u00e9se ut\u00e1n) adjunk meg a Debug f\u00fcl\u00f6n a Start Options blokkn\u00e1l legal\u00e1bb \u00f6t tetsz\u0151leges parancssori argumentumot (sz\u00f3k\u00f6zzel elv\u00e1lasztva), pl. kutya alma b\u00e9ka ban\u00e1n l\u00f3.</p> <p> .NET projektbe\u00e1ll\u00edt\u00e1sok</p> <pre><code>for (int i = 0; i &lt; args.Length; i++)\n    Console.WriteLine(args[i]);\n\nforeach (string arg in args)\n    Console.WriteLine(arg);\n\nConsole.ReadLine();\n</code></pre> <p>Ind\u00edtsuk el, \u00e9s gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk.</p>"},{"location":"seminar/01-csharp1/chapter1/#debug","title":"Debug","text":"<p>Rakjunk egy breakpointot (F9), vagy klikkelj\u00fcnk baloldalon a f\u00fcgg\u0151leges s\u00e1von a k\u00f3d sorsz\u00e1ma mellett) a <code>Console.WriteLine(args[i]);</code> sorra, majd ind\u00edtsuk \u00fajra az alkalmaz\u00e1st! Amikor a breakpointon meg\u00e1ll az alkalmaz\u00e1s fut\u00e1sa, a sor s\u00e1rga sz\u00edn\u0171 lesz. Ekkor vigy\u00fck az egeret az <code>i</code>, az <code>args</code> \u00e9s az <code>args.Length</code> elemek fel\u00e9, \u00e9s mutassuk meg, hogy l\u00e1thatjuk az aktu\u00e1lis \u00e9rt\u00e9keiket, komplexebb objektumok eset\u00e9n be tudjuk j\u00e1rni az objektumgr\u00e1fot. A Watch ablakba is \u00edrhatunk kifejez\u00e9seket, \u00e9s megmutathatjuk a Locals ablakot is. F10-zel (vagy a men\u00fcsoron a Step Over elemmel) l\u00e9pj\u00fcnk tov\u00e1bb, n\u00e9zz\u00fck meg, milyen sorrendben \u00e9rt\u00e9kel\u0151dik ki a <code>for</code> ciklus. Az F5-tel tov\u00e1bbengedhetj\u00fck az alkalmaz\u00e1s fut\u00e1s\u00e1t, majd z\u00e1rjuk is be.</p> <p>Mutassuk meg a Conditional Breakpoint haszn\u00e1lat\u00e1t is. Tegy\u00fcnk m\u00e9g egy breakpointot a m\u00e1sik <code>Console.WriteLine</code>-ra is. menu:Jobb eg\u00e9r gomb az els\u0151 breakpointon[Conditions\u2026], majd adjuk meg az al\u00e1bbiakat: Conditional Expression Is true <code>(i == 3)</code>. A m\u00e1sik breakpointon is adjunk meg felt\u00e9telt: Hit Count = 4. Mindk\u00e9t alkalommal a 4. elemen (ban\u00e1n) \u00e1llunk meg. Megjegyezhetj\u00fck, hogy a Conditional Breakpoint haszn\u00e1lat\u00e1val nem \u00e9rdemes mell\u00e9khat\u00e1st okoz\u00f3 m\u0171veleteket megadni, illetve hogy jelent\u0151sen le tudja cs\u00f6kkenteni a debuggol\u00e1s sebess\u00e9g\u00e9t.</p>"},{"location":"seminar/01-csharp1/chapter1/#tulajdonsagok-property-k","title":"Tulajdons\u00e1gok (Property-k)","text":"<p>Hozzuk l\u00e9tre a <code>Person</code> adatoszt\u00e1lyt! Ehhez menu: jobb katt a projekten[Add &gt; Class], a f\u00e1jl neve legyen <code>Person</code> (a kiterjeszt\u00e9st automatikusan hozz\u00e1biggyeszti a Visual Studio, ha nem adjuk meg). .NET-ben nincs megk\u00f6t\u00e9s arra, hogy a k\u00f3dokat tartalmaz\u00f3 f\u00e1jlok \u00e9s az egyes t\u00edpusok sz\u00e1moss\u00e1ga hogyan viszonyul egym\u00e1shoz: lehets\u00e9ges egy k\u00f3df\u00e1jlba is \u00edrnunk a teljes alkalmaz\u00e1s-k\u00f3dot, illetve egy oszt\u00e1lyt is sz\u00e9tdarabolhatunk t\u00f6bb f\u00e1jlra (ehhez a <code>partial</code> kulcssz\u00f3t haszn\u00e1ljuk).</p> <p>A C# tulajdons\u00e1g (property) egy szintaktikai \u00e9des\u00edt\u0151szer, amely egy objektump\u00e9ld\u00e1ny (vagy oszt\u00e1ly) egy explicit (mem\u00f3riabeli) vagy implicit (sz\u00e1rmaztatott vagy indirekt) jellemz\u0151j\u00e9t \u00edrja le. Egy tulajdons\u00e1ggal k\u00e9t m\u0171velet v\u00e9gezhet\u0151: lek\u00e9rdez\u00e9s (get) \u00e9s \u00e9rt\u00e9kad\u00e1s (set); ezeknek megadhat\u00f3 k\u00fcl\u00f6n a l\u00e1that\u00f3s\u00e1ga, \u00e9s a kett\u0151 k\u00f6z\u00fcl elegend\u0151 egy implement\u00e1l\u00e1sa. A legt\u00f6bb C# szintaktikai \u00e9des\u00edt\u0151szer a boilerplate k\u00f3dok \u00edr\u00e1s\u00e1nak elker\u00fcl\u00e9se v\u00e9gett k\u00e9sz\u00fclt, \u00edgy kevesebb k\u00f3dol\u00e1ssal \u00e9rj\u00fck el ugyanazt az eredm\u00e9nyt (sokszor az IL k\u00f3d nem is v\u00e1ltozik, gyakorlatilag hasonl\u00f3 a k\u00f3dgener\u00e1l\u00e1shoz).</p> <p>A <code>Person</code> oszt\u00e1lyban hozzuk l\u00e9tre a <code>string Name</code> property-t, <code>name</code> oszt\u00e1lyv\u00e1ltoz\u00f3val (field). Ehhez haszn\u00e1ljuk a <code>propfull</code> code snippetet (<code>propf</code>, majd Tab+Tab, ezut\u00e1n Tab-bal lehet l\u00e9pkedni a m\u00f3dos\u00edtand\u00f3 elemek k\u00f6z\u00f6tt):</p> <pre><code>public class Person\n{\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        private set { name = value; }\n    }\n\n    public Person(string name)\n    {\n        this.name = name;\n    }\n}\n</code></pre> <p>L\u00e1that\u00f3s\u00e1g</p> <p>Figyelj\u00fcnk az oszt\u00e1ly l\u00e1that\u00f3s\u00e1g\u00e1ra is, alapb\u00f3l nem publikusk\u00e9nt gener\u00e1l\u00f3dik!</p> <p>Igaz\u00e1b\u00f3l csak k\u00e9t tov\u00e1bbi (k\u00f3dban nem l\u00e1that\u00f3) met\u00f3dust hozunk l\u00e9tre, mintha egy-egy <code>GetName</code> \u00e9s <code>SetName</code> met\u00f3dust k\u00e9sz\u00edten\u00e9nk, viszont haszn\u00e1lat szempontj\u00e1b\u00f3l ugyanolyannak t\u0171nik, mintha egy sima mez\u0151 lenne. A settert priv\u00e1t l\u00e1that\u00f3s\u00e1g\u00fara tessz\u00fck, ez\u00e9rt csak egy <code>Person</code> p\u00e9ld\u00e1nyon bel\u00fclr\u0151l tudjuk \u00e1ll\u00edtani a <code>Name</code> property \u00e9rt\u00e9k\u00e9t. Jegyezz\u00fck meg, hogy a getterben \u00e9s setterben teljesen m\u00e1s jelleg\u0171 m\u0171veleteket is v\u00e9gezhet\u00fcnk (pl. els\u00fcthet\u00fcnk egy esem\u00e9nyt, hogy megv\u00e1ltozott a felhaszn\u00e1l\u00f3 neve, napl\u00f3zhatjuk, h\u00e1nyszor k\u00e9rt\u00e9k le a nev\u00e9t, stb.). A property egyik nagy er\u00e9nye, hogy oszt\u00e1lyon k\u00edv\u00fclr\u0151l az oszt\u00e1lyv\u00e1ltoz\u00f3kn\u00e1l megszokott szintaxissal haszn\u00e1lhatjuk.</p> <p>A <code>Main</code> f\u00fcggv\u00e9nybe \u00edrhatjuk p\u00e9ld\u00e1ul:</p> Program.cs<pre><code>Person p = new Person(\"Eric Lippert\");\np.Name = \"Mads Torgersen\";\nConsole.WriteLine(p.Name);\n</code></pre> <p>Debuggerrel figyelj\u00fck meg, hogy az els\u0151 sor a konstruktort, m\u00edg a m\u00e1sodik a property setter\u00e9t, v\u00e9g\u00fcl a harmadik sor ugyanazon property getter\u00e9t h\u00edvja.</p> <p>Mivel a backing field \u00e1ll\u00edt\u00e1s\u00e1n k\u00edv\u00fcl nem csin\u00e1lunk semmit a property k\u00f3dban, ez\u00e9rt haszn\u00e1lhatjuk a <code>propg</code> code snippetet is:</p> Person.cs<pre><code>public string Name { get; private set; }\n</code></pre> <p>Ez az \u00fan. auto-implement\u00e1lt property szintaxis. A property \u00e1ltal lek\u00e9rdezhet\u0151-be\u00e1ll\u00edthat\u00f3 field gener\u00e1l\u00f3dik, arra a k\u00f3dban nem is tudunk hivatkozni - ez az egys\u00e9gbe z\u00e1r\u00e1s miatt el\u0151ny\u00f6s.</p> <p>A l\u00e1that\u00f3s\u00e1g miatt a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben a setter h\u00edv\u00e1s m\u00e1r nem fordul, kommentezz\u00fck ki.</p> Person.cs<pre><code>//p.Name = \"Mads Torgersen\";\n</code></pre> <p>L\u00e9tezik m\u00e9g a <code>prop</code> code snippet is, ami mindk\u00e9t m\u00f3dos\u00edt\u00f3sz\u00f3t publikusan hagyja. L\u00e1that\u00f3s\u00e1gi m\u00f3dos\u00edt\u00f3sz\u00f3t a <code>get</code> \u00e9s <code>set</code> k\u00f6z\u00fcl csak az egyik el\u00e9 tehet\u00fcnk ki, \u00e9s az is csak szigor\u00edthat a k\u00fcls\u0151 l\u00e1that\u00f3s\u00e1gon (ekkor a m\u00e1sik a k\u00fcls\u0151t kapja meg).</p> <p>Ez a megold\u00e1s az el\u0151z\u0151vel teljes m\u00e9rt\u00e9kben ekvivalens (csak nem l\u00e1tjuk a gener\u00e1lt backing fieldet, de val\u00f3j\u00e1ban ott van). Ha van id\u0151nk, akkor vizsg\u00e1ljuk meg decompilerben (pl. Telerik JustDecompile), hogy val\u00f3ban \u00edgy van.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3an vegy\u00fck fel a sz\u00fclet\u00e9si d\u00e1tumot is. A sz\u00fclet\u00e9si d\u00e1tum nem v\u00e1ltozhat, gyakorlatilag <code>readonly</code> mez\u0151r\u0151l van sz\u00f3. Ha egy tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t az objektum is csak a konstruktorban tudja megadni, akkor a setter teljes m\u00e9rt\u00e9kben elhagyhat\u00f3:</p> Person.cs<pre><code>public DateTime DateOfBirth { get; }\n\npublic Person(string name, DateTime dateOfBirth)\n{\n    Name = name;\n    DateOfBirth = dateOfBirth;\n}\n</code></pre> <p>Ez a szintaktika megegyezik azzal, mintha egy <code>readonly</code> mez\u0151t haszn\u00e1ln\u00e1nk, azaz a mez\u0151 \u00e9rt\u00e9ke legk\u00e9s\u0151bb a konstruktorban inicializ\u00e1land\u00f3.</p> <p>Vegy\u00fcnk fel neki egy azonos\u00edt\u00f3t, ami egy <code>Guid</code> strukt\u00fara t\u00edpus\u00fa legyen:</p> Person.cs<pre><code>public Guid Id { get; } = Guid.NewGuid();\n</code></pre> <p>Ez egy csak lek\u00e9rdezhet\u0151 tulajdons\u00e1g, ami konstru\u00e1l\u00e1skor inicializ\u00e1l\u00f3dik egy \u00faj v\u00e9letlenszer\u0171 azonos\u00edt\u00f3 \u00e9rt\u00e9kre.</p> <p>Megadhatjuk a kort, mint implicit/sz\u00e1m\u00edtott tulajdons\u00e1got:</p> Person.cs<pre><code>public int Age { get { return DateTime.Now.Subtract(DateOfBirth).Days / 365; } }\n</code></pre> <p>Mivel a f\u00fcggv\u00e9ny\u00fcnk t\u00f6rzse egyetlen kifejez\u00e9ssel megadhat\u00f3, ez\u00e9rt elhagyva a sallangot (<code>return</code>, kapcsos z\u00e1r\u00f3jelek, stb.) expression bodied property szintaxissal is \u00edrhatjuk:</p> Person.cs<pre><code>public int Age =&gt; DateTime.Now.Subtract(DateOfBirth).Days / 365;\n</code></pre> <p>Tip</p> <p>Alkalmaz\u00e1sok fejleszt\u00e9sekor a legfontosabb els\u0151 l\u00e9p\u00e9sek egyike, hogy az objektummodell\u00fcnk \u00e1tl\u00e1that\u00f3, karbantarthat\u00f3 \u00e9s egy\u00e9rtelm\u0171 legyen. A C# v\u00e1ltozatos szintaxisa nagyon sokat seg\u00edt ezen c\u00e9lok el\u00e9r\u00e9s\u00e9ben.</p>"},{"location":"seminar/01-csharp1/chapter1/#generikus-kollekcio","title":"Generikus kollekci\u00f3","text":"<p>A <code>Main</code> met\u00f3dusban vegy\u00fcnk fel n\u00e9h\u00e1ny <code>Person</code> objektumot, \u00e9s list\u00e1zzuk ki a relev\u00e1ns tulajdons\u00e1gaikat! Ehhez egy <code>Person</code> list\u00e1ban t\u00e1roljuk a szem\u00e9lyeket. A <code>List</code> generikus kollekci\u00f3, azaz t\u00edpusparam\u00e9tert v\u00e1r, t\u00edpusokkal param\u00e9terezhet\u0151. A <code>List</code> t\u00edpusparam\u00e9tere jelzi, hogy milyen t\u00edpus\u00fa objektumokat t\u00e1rol. Met\u00f3dusok, tulajdons\u00e1gok, t\u00edpusok lehetnek generikusak. A genericit\u00e1s fontos a k\u00f3dunk \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1ga \u00e9s karbantarthat\u00f3s\u00e1ga \u00e9rdek\u00e9ben.</p> <pre><code>static void Main(string[] args)\n{\n    List&lt;Person&gt; people = new List&lt;Person&gt;();\n    people.Add(new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)));\n    people.Add(new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)));\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n\n    foreach (Person person in people)\n        Console.WriteLine(person);\n\n    Console.ReadLine();\n}\n</code></pre> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, mi t\u00f6rt\u00e9nik! Annyiszor \u00edr\u00f3dik ki a <code>Person</code> oszt\u00e1lyunk teljes neve (fully qualified type name), ah\u00e1ny elem van a list\u00e1ban.</p>"},{"location":"seminar/01-csharp1/chapter1/#leszarmazas-string-interpolacio","title":"Lesz\u00e1rmaz\u00e1s, string interpol\u00e1ci\u00f3","text":"<p>Ha a <code>WriteLine</code> f\u00f6l\u00e9 vissz\u00fck az egeret, l\u00e1that\u00f3, hogy az overload-ok k\u00f6z\u00fcl az h\u00edv\u00f3dik meg, amelyik objektumot v\u00e1r param\u00e9ter\u00fcl. Ebben az esetben a param\u00e9ter <code>ToString</code> met\u00f3dus\u00e1t h\u00edvja meg a <code>WriteLine</code>, ami alap\u00e9rtelmez\u00e9s szerint az objektum t\u00edpus\u00e1nak teljes nev\u00e9t adj\u00e1k vissza. Tegy\u00fck szebb\u00e9 a ki\u00edr\u00e1st, defini\u00e1ljuk fel\u00fcl az alap\u00e9rtelmezett <code>ToString</code> implement\u00e1ci\u00f3t a <code>Person</code> oszt\u00e1lyban:</p> Person.cs<pre><code>public override string ToString()\n{\n    return string.Format(\"{0} ({1}) [ID: {2}]\", Name, Age, Id);\n}\n</code></pre> <p>A <code>Person</code> oszt\u00e1lynak nincs explicit megadva \u0151soszt\u00e1lya, m\u00e9gis van fel\u00fcldefini\u00e1lhat\u00f3 f\u00fcggv\u00e9nye. Ezeket az <code>Object</code> oszt\u00e1ly defini\u00e1lja. Ha egy referencia t\u00edpusnak nincs megadva \u0151soszt\u00e1lya, akkor az <code>Object</code> lesz az.</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1ra m\u00e1s szintaktikai \u00e9des\u00edt\u0151szereket is haszn\u00e1lhatunk:</p> Person.cs<pre><code>public override string ToString() =&gt; $\"{Name} ({Age}) [ID: {Id}]\";\n</code></pre> <p>A k\u00e9t implement\u00e1ci\u00f3 ekvivalens, a m\u00e1sodik implement\u00e1ci\u00f3 az \u00fan. expression bodied method \u00e9s a string interpol\u00e1ci\u00f3 kombin\u00e1l\u00e1s\u00e1b\u00f3l ad\u00f3dik.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st!</p> <p>Hozzuk l\u00e9tre a <code>Student</code> oszt\u00e1lyt, ami sz\u00e1rmazik a <code>Person</code> oszt\u00e1lyb\u00f3l!</p> <pre><code>public class Student : Person\n{\n    public string Neptun { get; set; }\n\n    public string Major { get; set; }\n\n    public Student(string name, DateTime dateOfBirth)\n        : base(name, dateOfBirth)\n    {\n    }\n\n    public override string ToString() =&gt; $\"{base.ToString()} Neptun: {Neptun} Major: {Major}\";\n}\n</code></pre> <p>Ez az oszt\u00e1ly m\u00e1s megk\u00f6zel\u00edt\u00e9ssel k\u00e9sz\u00fclt, mint a sz\u00fcl\u0151je, az \u00e1llapota nem a konstruktor megh\u00edv\u00e1sakor t\u00f6lt\u0151dik fel, ut\u00f3lag lehet megadni setter h\u00edv\u00e1sokkal. Ez egyr\u00e9szt k\u00e9nyelmes, mert nem kell sokparam\u00e9teres konstruktorokkal k\u00fczdeni, m\u00e1sr\u00e9szt fel kell k\u00e9sz\u00fcln\u00fcnk arra, hogy bizonyos adatokat nem t\u00f6ltenek ki.</p> <p>\u0150s konstruktora</p> <p>Ha az \u0151soszt\u00e1lynak nincs param\u00e9ter n\u00e9lk\u00fcli konstruktora (a <code>Person</code> oszt\u00e1lynak nincs), akkor k\u00f6telesek vagyunk a gyerek konstruktorban az \u0151soszt\u00e1ly valamelyik konstruktor\u00e1t megh\u00edvni a <code>base</code> kulcssz\u00f3val.</p>"},{"location":"seminar/01-csharp1/chapter1/#objektum-inicializalok","title":"Objektum inicializ\u00e1l\u00f3k","text":"<p>Az object initializer seg\u00edts\u00e9g\u00e9vel az objektum l\u00e9trehoz\u00e1s\u00e1t (konstruktor h\u00edv\u00e1s) \u00e9s a property setterek megh\u00edv\u00e1s\u00e1val t\u00f6rt\u00e9n\u0151 inicializ\u00e1l\u00e1s\u00e1t int\u00e9zhetj\u00fck egy f\u00fcst alatt.  Az objektum inicializ\u00e1l\u00f3 csak konstruktorh\u00edv\u00e1s eset\u00e9n haszn\u00e1lhat\u00f3, \u00edgy pl. factory met\u00f3dus \u00e1ltal gy\u00e1rtott objektump\u00e9ld\u00e1ny eset\u00e9n nem.</p> <p>A <code>Main</code> met\u00f3dusban \u00edrhatjuk az al\u00e1bbi p\u00e9ld\u00e1t:</p> <pre><code>static void Main(string[] args)\n{\n    /*...*/\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n    Student elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major = \"Info BSc\"\n    };\n    /*...*/\n}\n</code></pre> <p>Konstruktor szintaktik\u00e1k</p> <p>Objektum inicializ\u00e1l\u00e1s sor\u00e1n, param\u00e9ter n\u00e9lk\u00fcli konstruktor eset\u00e9n a <code>()</code> is elhagyhat\u00f3.</p> <p>T\u00f6bb sorba t\u00f6rdel\u00e9s</p> <p>\u00c1ltal\u00e1ban 1-2 tulajdons\u00e1g eset\u00e9n lehet egy sorba is \u00edrni az inicializ\u00e1ci\u00f3t, t\u00f6bb eset\u00e9n viszont \u00e1ltal\u00e1ban t\u00f6bb sorba \u00e9rdemes t\u00f6rdelni az olvashat\u00f3s\u00e1g \u00e9rdek\u00e9ben.</p> <p>L\u00e1thatjuk, hogy csak az aktu\u00e1lis kontextusban egy\u00e9bk\u00e9nt is l\u00e1that\u00f3 \u00e9s be\u00e1ll\u00edthat\u00f3 tulajdons\u00e1gokat \u00e1ll\u00edthatjuk be, egyik \u00edgy be\u00e1ll\u00edtott tulajdons\u00e1g sem k\u00f6telez\u0151 jelleg\u0171.</p> <p>Az object initializer val\u00f3ban csak az egyes tulajdons\u00e1gokat \u00e1ll\u00edtja be, teh\u00e1t csak szintaktikailag k\u00fcl\u00f6nb\u00f6zik az els\u0151 defin\u00edci\u00f3 az al\u00e1bbit\u00f3l:</p> <p>Note</p> <p>Nem kell be\u00edrni, csak szeml\u00e9ltet\u00e9s.</p> <pre><code>Student _elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10));\n_elek.Neptun = \"ABC123\";\n_elek.Major = \"Info BSc\";\nStudent elek = _elek;\n</code></pre> <p>A h\u00e1tt\u00e9rben t\u00e9nyleg egy (sz\u00e1munkra nem l\u00e1that\u00f3) tempor\u00e1lis v\u00e1ltoz\u00f3ban fog t\u00f6rt\u00e9nni az inicializ\u00e1ci\u00f3, ugyanis, ha az object initializer kiv\u00e9telt dob (az egyik setter \u00e1ltal), az objektumunk nem veszi fel a k\u00edv\u00e1nt \u00e9rt\u00e9ket.</p> <p>Objektum inicializ\u00e1l\u00f3 haszna</p> <p>Ebb\u0151l l\u00e1tszik az objektum inicializ\u00e1l\u00f3 els\u0151dleges haszna, m\u00e9gpedig, hogy nem kell \u00e1lland\u00f3an ki\u00edrogatni, hogy melyik p\u00e9ld\u00e1nyra gondolunk (\u00edgy elrontani sem tudjuk).</p>"},{"location":"seminar/01-csharp1/chapter1/#kollekcio-inicializacio","title":"Kollekci\u00f3 inicializ\u00e1ci\u00f3","text":"<p>Az egyszer\u0171s\u00edtett kollekci\u00f3 inicializ\u00e1ci\u00f3 szintaxissal a lista teljes felt\u00f6lt\u00e9se j\u00f3val kevesebb k\u00f3ddal \u00e9s j\u00f3val olvashat\u00f3bban megadhat\u00f3. R\u00e1ad\u00e1sul a kollekci\u00f3 elemeit l\u00e9trehozhatjuk az objektum inicializ\u00e1ci\u00f3s szintaxissal is. A teljes lista l\u00e9trehoz\u00e1st \u00e9s -felt\u00f6lt\u00e9s r\u00e9szt cser\u00e9lj\u00fck le az al\u00e1bbira.</p> <pre><code>List&lt;Person&gt; people = new List&lt;Person&gt;\n{\n    new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)),\n    new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)),\n    new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)),\n    new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major=\"Info BSc\"\n    },\n    new Student(\"Hi\u00e1ny \u00c1ron\", new DateTime(2000, 02, 13))\n};\n</code></pre> <p>Nem kell az <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1st \u00e9s a lista referenci\u00e1t ki\u00edrni, egy\u00e9rtelm\u0171, hogy melyik list\u00e1hoz adunk hozz\u00e1.</p> <p>Add</p> <p>Ez a forma is ugyanolyan <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokra fordul, mint az eredeti v\u00e1ltozatban.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! L\u00e1thatjuk, hogy a konstruktoron kereszt\u00fcl teljesen inicializ\u00e1lhat\u00f3 <code>Person</code> p\u00e9ld\u00e1nyok eset\u00e9ben a ki\u00edr\u00e1s teljes, viszont vannak olyan <code>Student</code> p\u00e9ld\u00e1nyok, ahol a ki\u00edr\u00e1s \u00fcres \u00e9rt\u00e9keket tal\u00e1l. Ezzel a jelens\u00e9ggel a k\u00f6vetkez\u0151 gyakorlatokon tov\u00e1bb foglalkozunk.</p>"},{"location":"seminar/02-csharp2/chapter2/","title":"C# alapok II.","text":""},{"location":"seminar/02-csharp2/chapter2/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt hozzunk l\u00e9tre egy .NET C# konzolalkalmaz\u00e1st: a projektsablon sz\u0171r\u0151ben v\u00e1lasszuk a C# nyelv - Windows platform - Console projektt\u00edpust. A sz\u0171rt list\u00e1ban v\u00e1lasszuk a Console App sablont (ne a .NET Framework-\u00f6s legyen). A neve legyen HelloCSharp2. A solutiont ne tegy\u00fck k\u00fcl\u00f6n mapp\u00e1ba (Place solution and project in the same directory legyen bekapcsolva). A megc\u00e9lzott framework verzi\u00f3 legyen .NET 8.</p>"},{"location":"seminar/02-csharp2/chapter2/#legfelso-szintu-utasitasok-implicit-globalis-nevter-hivatkozasok","title":"Legfels\u0151 szint\u0171 utas\u00edt\u00e1sok, implicit glob\u00e1lis n\u00e9vt\u00e9r-hivatkoz\u00e1sok","text":"<p>Csod\u00e1lkozzunk r\u00e1, hogy a gener\u00e1lt projekt mind\u00f6ssze egyetlen \u00e9rdemi sort tartalmaz.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\n</code></pre> <p>C# 10 \u00f3ta a program bel\u00e9p\u00e9si pontj\u00e1t ad\u00f3 forr\u00e1sf\u00e1jlt jelent\u0151sen ler\u00f6vid\u00edthetj\u00fck:</p> <ul> <li>a f\u00e1jl tetej\u00e9n l\u00e9v\u0151 using-okat elhagyhatjuk, ha azok implicit hivatkozva vannak. Az implicit hivatkozott using-ok projektt\u00edpust\u00f3l f\u00fcggenek \u00e9s a dokument\u00e1ci\u00f3b\u00f3l olvashatjuk ki</li> <li>a <code>Main</code> f\u00fcggv\u00e9nyt tartalmaz\u00f3 oszt\u00e1ly deklar\u00e1ci\u00f3j\u00e1t (<code>namespace</code> blokk, <code>class</code> blokk) elhagyhatjuk, ezt a ford\u00edt\u00f3 gener\u00e1lja nek\u00fcnk</li> <li>a <code>Main</code> f\u00fcggv\u00e9ny deklar\u00e1ci\u00f3j\u00e1t szint\u00e9n gener\u00e1lja a ford\u00edt\u00f3. A met\u00f3dus neve nem defini\u00e1lt, nem (biztos, hogy) <code>Main</code>. A met\u00f3dus szignat\u00far\u00e1ja att\u00f3l f\u00fcgg, milyen utas\u00edt\u00e1sokat adunk meg a forr\u00e1sf\u00e1jlban. P\u00e9ld\u00e1ul, ha nincs return, akkor <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. A param\u00e9tere viszont mindig <code>string[] args</code>.</li> <li>a f\u00fcggv\u00e9ny blokkba nem foglalt k\u00f3d a gener\u00e1lt bel\u00e9p\u00e9si pont f\u00fcggv\u00e9ny belsej\u00e9be ker\u00fcl. F\u00fcggv\u00e9nyt is \u00edrhatunk, az a bel\u00e9p\u00e9si pontot tartalmaz\u00f3 gener\u00e1lt oszt\u00e1ly tagf\u00fcggv\u00e9nye lesz.</li> <li>t\u00edpusokat, oszt\u00e1lyokat is defini\u00e1lhatunk, de csak a legfels\u0151 szint\u0171 k\u00f3dot k\u00f6vet\u0151en</li> </ul> <p>Warning</p> <p>Fontos \u00e9szrev\u00e9tel a fentiekb\u0151l: ezen k\u00e9pess\u00e9g nem v\u00e1ltoztatja meg a C# semmilyen alapvet\u0151 jellemz\u0151j\u00e9t, p\u00e9ld\u00e1ul ugyan\u00fagy minden f\u00fcggv\u00e9nynek oszt\u00e1lyon bel\u00fcl kell lennie. A ford\u00edt\u00e1s sor\u00e1n a legfels\u0151 szint\u0171 utas\u00edt\u00e1sok k\u00f3dja \u00fagy eg\u00e9sz\u00fcl ki, ami m\u00e1r minden szab\u00e1lynak megfelel.</p> <p>L\u00e1that\u00f3s\u00e1g</p> <p>A legfels\u0151 szint\u0171 k\u00f3d olyan, amit a program m\u00e1s r\u00e9sz\u00e9r\u0151l nem tudunk h\u00edvni, hiszen nem is ismerj\u00fck a burkol\u00f3 oszt\u00e1ly nev\u00e9t. Emiatt nincs \u00e9rtelme legfels\u0151 szint\u0171 k\u00f3dban l\u00e1that\u00f3s\u00e1gi be\u00e1ll\u00edt\u00e1snak (<code>private</code>, <code>protected</code> stb.) vagy propertynek.</p> <p>Akad\u00e1lyozzuk meg a program azonnali lefut\u00e1s\u00e1t egy blokkol\u00f3 h\u00edv\u00e1ssal.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\nConsole.ReadLine();\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a gener\u00e1lt projektet mindenf\u00e9le egy\u00e9b v\u00e1ltoztat\u00e1s n\u00e9lk\u00fcl, ford\u00edt\u00e1s (menu:projekten jobbklikk[Build]) ut\u00e1n. N\u00e9zz\u00fcnk bele a kimeneti k\u00f6nyvt\u00e1rba (menu:projekten jobbklikk[Open Folder in File Explorer], majd menu:bin[Debug &gt; net8.0]): l\u00e1that\u00f3, hogy az alkalmaz\u00e1sunkb\u00f3l a ford\u00edt\u00e1s sor\u00e1n egy cross-platform bin\u00e1ris (\\&lt;projektn\u00e9v&gt;.dll) \u00e9s .NET Core v3 \u00f3ta egy platform specifikus futtathat\u00f3 \u00e1llom\u00e1ny (Windows eset\u00e9n \\&lt;projektn\u00e9v&gt;.exe) is gener\u00e1l\u00f3dik. Kipr\u00f3b\u00e1lhatjuk, hogy az exe a szokott m\u00f3don ind\u00edthat\u00f3 (pl. duplaklikkel), m\u00edg a dll a <code>dotnet</code> paranccsal.</p> <pre><code>dotnet &lt;projektn\u00e9v.dll&gt;\n</code></pre> <p>Parancssor aktu\u00e1lis mapp\u00e1ja</p> <p>A dotnet parancshoz a dll k\u00f6nyvt\u00e1r\u00e1ban kell lenn\u00fcnk. Ehhez a legegyszer\u0171bb, ha a Windows f\u00e1jlkezel\u0151ben a megfelel\u0151 k\u00f6nyvt\u00e1rban \u00e1llva az el\u00e9r\u00e9si \u00fatvonal mez\u0151t \u00e1t\u00edrjuk a <code>cmd</code> sz\u00f6vegre, majd kbd:[ENTER]-t nyomunk.</p> <p>Adjunk a l\u00e9trej\u00f6v\u0151 projekthez egy <code>Dog</code> oszt\u00e1lyt Dog.cs n\u00e9ven, ez lesz az adatmodell\u00fcnk:</p> <pre><code>public class Dog\n{\n    public string Name { get; set; }\n    public Guid Id { get; } = Guid.NewGuid();\n    public DateTime DateOfBirth { get; set; }\n    private int AgeInDays =&gt; DateTime.Now.Subtract(DateOfBirth).Days;\n    public int Age =&gt; AgeInDays / 365;\n    public int AgeInDogYears =&gt; AgeInDays * 7 / 365;\n    public override string ToString() =&gt;\n            $\"{Name} ({Age} | {AgeInDogYears}) [ID: {Id}]\";\n}\n</code></pre> <p>Az adatmodell az el\u0151z\u0151 \u00f3r\u00e1n l\u00e9trehozotthoz nagyon hasonl\u00edt, ennek viszont nincsen explicit konstruktora \u00e9s a <code>Name</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gok publikusan is \u00e1ll\u00edthat\u00f3k.</p> <p>Hozzunk l\u00e9tre egy <code>Dog</code> p\u00e9ld\u00e1nyt objektum inicializ\u00e1ci\u00f3s szintaxissal, majd \u00edrjuk ki ezt a p\u00e9ld\u00e1nyt a kezdeti k\u00f6sz\u00f6nt\u0151 sz\u00f6veg helyett:</p> <pre><code>Dog banan = new Dog\n{\n    Name = \"Ban\u00e1n\",\n    DateOfBirth = new DateTime(2014, 06, 10)\n};\nConsole.WriteLine(banan);\n</code></pre> <p>Ezzel k\u00e9sz a kiindul\u00f3 projekt\u00fcnk.</p>"},{"location":"seminar/02-csharp2/chapter2/#implicit-tipusdeklaracio","title":"Implicit t\u00edpusdeklar\u00e1ci\u00f3","text":"<p>A <code>var</code> kulcssz\u00f3 jelent\u0151s\u00e9ge: ha a ford\u00edt\u00f3 ki tudja tal\u00e1lni a kontextusb\u00f3l az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n \u00e1ll\u00f3 \u00e9rt\u00e9k t\u00edpus\u00e1t, nem sz\u00fcks\u00e9ges a t\u00edpus nev\u00e9t explicit megadnunk, az implicit k\u00f6vetkezik a k\u00f3db\u00f3l. Ebben az esetben a t\u00edpus egy\u00e9rtelm\u0171en <code>Dog</code>. Ha csak deklar\u00e1lni szeretn\u00e9nk egy v\u00e1ltoz\u00f3t (nem adunk \u00e9rt\u00e9k\u00fcl a v\u00e1ltoz\u00f3nak semmit), akkor nem haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t, ugyanis nem k\u00f6vetkezik a k\u00f3db\u00f3l a v\u00e1ltoz\u00f3 t\u00edpusa. Ekkor explicit meg kell adnunk a t\u00edpust.</p> <pre><code>Dog banan = new Dog\n{\n   Name = \"Ban\u00e1n\",\n   DateOfBirth = new DateTime(2014, 06, 10)\n};\nvar watson = new Dog { Name = \"Watson\" };\n\nvar unnamed = new Dog { DateOfBirth = new DateTime(2017, 02, 10) };\nvar unknown = new Dog { };\n//watson = 3; // \n//var error;  // \n\nConsole.WriteLine(banan);\nConsole.ReadLine();\n</code></pre> <ul> <li>Ford\u00edt\u00e1si hiba: a <code>watson</code> deklar\u00e1ci\u00f3jakor eld\u0151lt, hogy \u0151 <code>Dog</code> t\u00edpus, ut\u00f3lag nem lehet megv\u00e1ltoztatni \u00e9s p\u00e9ld\u00e1ul sz\u00e1m\u00e9rt\u00e9ket \u00e9rt\u00e9k\u00fcl adni. Ez nem JavaScript.</li> <li>Ford\u00edt\u00e1si hiba: implicit t\u00edpust csak \u00fagy lehet deklar\u00e1lni, ha egy\u00fattal inicializ\u00e1ljuk is. Az inicializ\u00e1ci\u00f3s kifejez\u00e9s alapj\u00e1n d\u0151l el (implicit) a p\u00e9ld\u00e1ny t\u00edpusa.</li> </ul> <p>Pr\u00f3b\u00e1ljuk ki a nem fordul\u00f3 sorokat, n\u00e9zz\u00fck meg a ford\u00edt\u00f3 hiba\u00fczeneteit!</p> <p>Er\u0151ss t\u00edpusos\u00e1g</p> <p>A <code>var</code> nem a gyenge t\u00edpusoss\u00e1g jele a C#-ban, nem \u00fagy, mint pl. JavaScript-ben. Az inicializ\u00e1ci\u00f3s sor ut\u00e1n a t\u00edpus egy\u00e9rtelm\u0171en eld\u0151l, ut\u00e1na m\u00e1r csak ennek a t\u00edpusnak megfelel\u0151 m\u0171veletek v\u00e9gezhet\u0151k, p\u00e9ld\u00e1ul egy \u00e9rt\u00e9kad\u00e1ssal nem v\u00e1ltoztathatjuk meg a t\u00edpust.</p> <p>A <code>var</code>-t tipikusan akkor alkalmazzuk, ha:</p> <ul> <li>hossz\u00fa t\u00edpusneveket nem akarunk ki\u00edrni</li> <li>feleslegesnek tartjuk az inicializ\u00e1ci\u00f3 mindk\u00e9t oldal\u00e1n ki\u00edrni ugyanazt a t\u00edpust</li> <li>anonim t\u00edpusokat haszn\u00e1lunk (k\u00e9s\u0151bb)</li> </ul>"},{"location":"seminar/02-csharp2/chapter2/#init-only-setter","title":"Init-only setter","text":"<p>Az objektum inicializ\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9hez sz\u00fcks\u00e9ges a megfelel\u0151 l\u00e1that\u00f3s\u00e1g\u00fa setter. Viszont egy ilyen settert nem csak objektum inicializ\u00e1ci\u00f3kor lehet haszn\u00e1lni, hanem b\u00e1rmikor \u00e1t\u00e1ll\u00edthatjuk egy p\u00e9ld\u00e1ny adat\u00e1t (mut\u00e1ci\u00f3).</p> <p>Az al\u00e1bbi p\u00e9lda egy ilyen ut\u00f3lagos m\u00f3dos\u00edt\u00e1sra / mut\u00e1ci\u00f3ra.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nwatson.Name = \"Sherlock\";\n</code></pre> <p>Ez \u00edgy hiba n\u00e9lk\u00fcl lefordul.</p> <p>Kiz\u00e1r\u00f3lag az inicializ\u00e1ci\u00f3ra korl\u00e1tozhatjuk a setter megh\u00edv\u00e1s\u00e1t az init-only setterrel (<code>init</code> kulcssz\u00f3).</p> <pre><code>public class Dog\n{\n    public string Name { get; init; }\n    //...\n}\n</code></pre> <p>Ezut\u00e1n az inicializ\u00e1ci\u00f3s sor tov\u00e1bbra is lefordul, de a n\u00e9v\u00e1t\u00edr\u00e1sos m\u00e1r nem. Ez ut\u00f3bbi sort kommentezz\u00fck ki.</p> <p>Init-only setter konstruktorb\u00f3l</p> <p>Init-only settert az oszt\u00e1ly konstruktor\u00e1b\u00f3l is meg lehet h\u00edvni - hiszen az is inicializ\u00e1ci\u00f3.</p> <p>Haszn\u00e1lata</p> <p>Init-only settert t\u00f6bb okb\u00f3l kifoly\u00f3lag is haszn\u00e1lhatunk, p\u00e9ld\u00e1ul a t\u00edpus p\u00e9ld\u00e1nyainak immut\u00e1bilis kezel\u00e9s\u00e9t akarjuk kik\u00e9nyszer\u00edteni, vagy csak inicializ\u00e1ci\u00f3ra akarjuk korl\u00e1tozni a propertyk be\u00e1ll\u00edt\u00e1s\u00e1t, de nem akarunk ehhez konstruktort \u00edrni.</p> <p>Jelen form\u00e1j\u00e1ban az init-only setter nem tudja helyettes\u00edteni a k\u00f6telez\u0151 konstruktor param\u00e9tert, mert nem k\u00f6telez\u0151 kit\u00f6lteni ezt a propertyt. Erre a megold\u00e1s a C# 11-ben bevezetett <code>required</code> kulcssz\u00f3 a property el\u0151tt.</p> <pre><code>public class Dog\n{\n    public required string Name { get; init;  }\n    //...\n}\n</code></pre> <p>Ezzel k\u00f6telez\u0151v\u00e9 v\u00e1lik a <code>Name</code> kit\u00f6lt\u00e9se, ha a <code>Dog</code> p\u00e9ld\u00e1nyt inicializ\u00e1ljuk.</p>"},{"location":"seminar/02-csharp2/chapter2/#indexer-operator-nameof-operator-index-inicializalo","title":"Indexer oper\u00e1tor, nameof oper\u00e1tor, index inicializ\u00e1l\u00f3","text":"<p>A collection initializer anal\u00f3gi\u00e1j\u00e1ra j\u00f6tt l\u00e9tre az index initializer nyelvi elem, ami a kor\u00e1bbihoz hasonl\u00f3an sorban h\u00edv meg egy oper\u00e1tort, hogy m\u00e1r inicializ\u00e1lt objektumot kapjunk vissza. A k\u00fcl\u00f6nbs\u00e9g egyr\u00e9szt a szintaxis, m\u00e1sr\u00e9szt az ilyenkor megh\u00edvott met\u00f3dus, ami az index oper\u00e1tor.</p> <p>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s</p> <p>Saj\u00e1t t\u00edpusainkban lehet\u0151s\u00e9g\u00fcnk van defini\u00e1lni \u00e9s fel\u00fcldefini\u00e1lni oper\u00e1torokat, mint pl. +, -, indexel\u00e9s, implicit cast, explicit cast, stb.</p> <p>Tegy\u00fck fel, hogy egy kuty\u00e1hoz b\u00e1rmilyen, \u00fczleti logik\u00e1ban nem felhaszn\u00e1lt inform\u00e1ci\u00f3 ker\u00fclhet, amire \u00e1ltal\u00e1nos strukt\u00far\u00e1t szeretn\u00e9nk. Vegy\u00fcnk fel a <code>Dog</code> oszt\u00e1lyba egy <code>string-object</code> sz\u00f3t\u00e1rat, amiben b\u00e1rmilyen tov\u00e1bbi inform\u00e1ci\u00f3t t\u00e1rolhatunk! Ezen fel\u00fcl \u00e1ll\u00edtsuk be a <code>Dog</code> indexer\u00e9t, hogy az a <code>Metadata</code> indexel\u00e9s\u00e9t v\u00e9gezze:</p> <pre><code>public class Dog\n{\n    //...\n    public Dictionary&lt;string, object&gt;  Metadata { get; } = new();\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>Konstruktor t\u00edpus n\u00e9lk\u00fcl</p> <p>A <code>new</code> oper\u00e1tor ut\u00e1ni konstruktorh\u00edv\u00e1s sok esetben elhagyhat\u00f3, ha a bal oldal alapj\u00e1n am\u00fagy is tudhat\u00f3 a t\u00edpus.</p> <p>n\u00e9vt\u00e9r hivatkoz\u00e1sok</p> <p>Az \u00fajabb projektsablonok sokkal kevesebb n\u00e9vt\u00e9rdeklar\u00e1ci\u00f3t (<code>using</code>) gener\u00e1lnak alapb\u00f3l. Ha kell, vegy\u00fck fel a sz\u00fcks\u00e9geseket a fel nem oldott n\u00e9ven \u00e1llva a gyorsm\u0171velet (villanyk\u00f6rte) eszk\u00f6zzel (Ctrl+.)</p> <p>Az objektum inicializ\u00e1l\u00f3 \u00e9s az index inicializ\u00e1l\u00f3 vegy\u00edthet\u0151, \u00edgy az al\u00e1bbi m\u00f3don tudunk felvenni tov\u00e1bbi tulajdons\u00e1gokat a kuty\u00e1khoz a legfels\u0151 szint\u0171 k\u00f3dba:</p> <pre><code>var pimpedli = new Dog\n{\n    Name = \"Pimpedli\",\n    DateOfBirth = new DateTime(2006, 06, 10),\n    [\"Chip azonos\u00edt\u00f3\"] = \"123125AJ\"\n};\n</code></pre> <p>Mivel indexelni \u00e1ltal\u00e1ban kollekci\u00f3kat szok\u00e1s (t\u00f6mb, lista, sz\u00f3t\u00e1r), ez\u00e9rt ezekben az esetekben igen j\u00f3 eszk\u00f6z lehet az index inicializ\u00e1l\u00f3. Vegy\u00fcnk fel egy \u00faj kutyasz\u00f3t\u00e1rt a kuty\u00e1k kiteny\u00e9szt\u00e9se ut\u00e1n:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [\"banan\"] = banan,\n    [\"watson\"] = watson,\n    [\"unnamed\"] = unnamed,\n    [\"unknown\"] = unknown,\n    [\"pimpedli\"] = pimpedli\n};\n\nforeach (var dog in dogs)\n    Console.WriteLine($\"{dog.Key} - {dog.Value}\");\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki - minden n\u00e9v-kutya p\u00e1rt ki kell \u00edrnia a sz\u00f3t\u00e1rb\u00f3l.</p> <p>Els\u0151re j\u00f3 \u00f6tletnek t\u0171nhet kiv\u00e1ltani a sz\u00f6vegliter\u00e1lokat a <code>Name</code> property haszn\u00e1lat\u00e1val.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [banan.Name] = banan,\n    [watson.Name] = watson,\n    [unnamed.Name] = unnamed,\n    [unknown.Name] = unknown,\n    [pimpedli.Name] = pimpedli\n};\n//ArgumentNullException!\n</code></pre> <p>Ez azonban kiv\u00e9telt okoz, amikor a kutya neve nincs kit\u00f6ltve, azaz <code>null</code> \u00e9rt\u00e9k\u0171. Eset\u00fcnkben el\u00e9g lenne az adott v\u00e1ltoz\u00f3 neve sz\u00f6vegk\u00e9nt. Erre j\u00f3 a <code>nameof</code> oper\u00e1tor.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [nameof(banan)] = banan,\n    [nameof(watson)] = watson,\n    [nameof(unnamed)] = unnamed,\n    [nameof(unknown)] = unknown,\n    [nameof(pimpedli)] = pimpedli\n};\n</code></pre> <p>Ez a v\u00e1ltozat m\u00e1r nem fog kiv\u00e9telt okozni.</p> <p>A <code>nameof</code> oper\u00e1tor sokfajta nyelvi elemet t\u00e1mogat, vissza tudja adni egy v\u00e1ltoz\u00f3, egy t\u00edpus, egy property vagy egy f\u00fcggv\u00e9ny nev\u00e9t is.</p> <p>A sz\u00f3t\u00e1r felt\u00f6lt\u00e9s\u00e9t meg\u00edrhatjuk kollekci\u00f3 inicializ\u00e1ci\u00f3val is. Ehhez kihaszn\u00e1ljuk, hogy a sz\u00f3t\u00e1r t\u00edpus rendelkezik egy <code>Add</code> met\u00f3dussal, amelyik egyszer\u0171en egy kulcsot \u00e9s egy hozz\u00e1tartoz\u00f3 \u00e9rt\u00e9ket v\u00e1r:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    { nameof(banan), banan },\n    { nameof(watson), watson },\n    { nameof(unnamed), unnamed },\n    { nameof(unknown), unknown },\n    { nameof(pimpedli), pimpedli }\n};\n</code></pre>"},{"location":"seminar/02-csharp2/chapter2/#using-static","title":"Using static","text":"<p>Ha egy oszt\u00e1ly statikus tagjait vagy egy statikus oszt\u00e1lyt szeretn\u00e9nk haszn\u00e1lni, lehet\u0151s\u00e9g\u00fcnk van a <code>using static</code> kulcsszavakkal az oszt\u00e1lyt bevonni a n\u00e9vfelold\u00e1si logik\u00e1ba. Ha a <code>Console</code> oszt\u00e1lyt refer\u00e1ljuk ilyen m\u00f3don, lehet\u0151s\u00e9g\u00fcnk van a rajta lev\u0151 met\u00f3dusok megh\u00edv\u00e1s\u00e1ra az aktu\u00e1lis kontextusunkban an\u00e9lk\u00fcl, hogy az oszt\u00e1ly nev\u00e9t ki\u00edrn\u00e1nk:</p> <pre><code>using System;\nusing static System.Console;\n//..\nforeach (var dog in dogs)\n    /*Console.*/WriteLine($\"{dog.Key} - {dog.Value}\");\n/*Console.*/WriteLine(banan);\n/*Console.*/ReadLine();\n</code></pre> <p>n\u00e9vfelold\u00e1s</p> <p>Az \u00e1ltal\u00e1nos n\u00e9vfelold\u00e1si szab\u00e1ly tov\u00e1bbra is \u00e9l: ha egy\u00e9rtelm\u0171en feloldhat\u00f3 a hivatkoz\u00e1s, akkor nem sz\u00fcks\u00e9ges kitenni a megk\u00fcl\u00f6nb\u00f6ztet\u0151 el\u0151tagot (itt: oszt\u00e1ly), k\u00fcl\u00f6nben igen.</p>"},{"location":"seminar/02-csharp2/chapter2/#nullozhato-tipusok","title":"Nullozhat\u00f3 t\u00edpusok","text":"<p>Term\u00e9szetesen a referenciat\u00edpusok mind olyan t\u00edpusok, melyek vehetnek fel <code>null</code> \u00e9rt\u00e9ket, viszont esetenk\u00e9nt j\u00f3 volna, ha a <code>null</code> \u00e9rt\u00e9ket egy\u00e9bk\u00e9nt felvenni nem k\u00e9pes t\u00edpusok is lehet\u00e9nek ilyen \u00e9rt\u00e9k\u0171ek, ezzel pl. jelezv\u00e9n, hogy egy \u00e9rt\u00e9k be van-e \u00e1ll\u00edtva vagy sem. Pl. egy sz\u00e1m eset\u00e9n a 0 egy konkr\u00e9t, helyes \u00e9rt\u00e9k lehet a domain modell\u00fcnkben, a <code>null</code> viszont azt jelenthetn\u00e9, hogy nem vett fel \u00e9rt\u00e9ket.</p> <p>Vizsg\u00e1ljuk meg, hogy a konzolra t\u00f6rt\u00e9n\u0151 ki\u00edr\u00e1skor mi\u00e9rt lesz az aktu\u00e1lis \u00e9v Watson kutya \u00e9letkora! Valamelyik <code>Console.WriteLine</code> sorhoz vegy\u00fcnk fel egy t\u00f6r\u00e9spontot (F9), majd debuggol\u00e1s k\u00f6zben a Locals ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Locals]) figyelj\u00fck meg az egyes p\u00e9ld\u00e1nyok adatait. Watsont kinyitva l\u00e1thatjuk, hogy a turpiss\u00e1g abb\u00f3l fakad, hogy a <code>DateOfBirth</code> adat t\u00edpusa, a <code>DateTime</code> nem referenciat\u00edpus, \u00e9s alap\u00e9rtelmez\u00e9s szerinti \u00e9rt\u00e9ket veszi fel, ami 0001. 01. 01. 00:00:00 - hiszen nem \u00e1ll\u00edtottunk be m\u00e1st.</p> <p>Ismeretlen sz\u00fclet\u00e9si d\u00e1tum\u00fa, kor\u00fa egyedek helyes t\u00e1rol\u00e1s\u00e1hoz az <code>Age</code> tulajdons\u00e1g t\u00edpus\u00e1t v\u00e1ltoztassuk <code>int?</code>-re! Az <code>int?</code> szintaktikai \u00e9des\u00edt\u0151szere a <code>Nullable&lt;int&gt;</code>-nek, egy olyan strukt\u00far\u00e1nak, ami egy <code>int</code> \u00e9rt\u00e9ket t\u00e1rol, \u00e9s t\u00e1rolja, hogy az be van-e \u00e1ll\u00edtva vagy sem. A <code>Nullable&lt;int&gt;</code> szignat\u00far\u00e1it megmutathatjuk, hogyha a kurzort a t\u00edpusra helyezve F12-t nyomunk.</p> <p>M\u00f3dos\u00edtsuk a <code>Dog</code> <code>Age</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gait is, hogy tudjuk, be vannak-e \u00e1ll\u00edtva az \u00e9rt\u00e9keik:</p> <pre><code>public class Dog\n{\n    //...\n\n    public DateTime? DateOfBirth { get; set; }\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    //...\n}\n</code></pre> <p>Aritmentikai oper\u00e1torok</p> <p>\u00d6rvendezz\u00fcnk, hogy az alap aritmetikai oper\u00e1torok pont \u00fagy m\u0171k\u00f6dnek, ahogy szeretn\u00e9nk (<code>null</code> bemenetre <code>null</code> eredm\u00e9ny), nem kellett semmilyen tr\u00fckk.</p> <p>Az <code>AgeInDays</code> akkor ad vissza <code>null</code> \u00e9rt\u00e9ket, ha a <code>DateOfBirth</code> maga is <code>null</code> volt. Teh\u00e1t ha nincs megadva sz\u00fclet\u00e9si d\u00e1tumunk, nem tudunk \u00e9letkort sem sz\u00e1m\u00edtani. Ennek kifejez\u00e9s\u00e9re haszn\u00e1lhatjuk a <code>?.</code> (Elvis, magyarban Kozs\u00f3 - <code>null</code> conditional operator) oper\u00e1tort: a ki\u00e9rt\u00e9kelend\u0151 \u00e9rt\u00e9k jobb oldal\u00e1t adja vissza, ha a bal oldal nem <code>null</code>, k\u00fcl\u00f6nben <code>null</code>-t. A kifejez\u00e9st meg kellett v\u00e1ltoztatnunk, hogy a <code>DateOfBirth</code>-b\u0151l vonjuk ki a jelenlegi d\u00e1tumot \u00e9s ezt neg\u00e1ljuk, ugyanis a <code>null</code> vizsg\u00e1land\u00f3 \u00e9rt\u00e9k a bin\u00e1ris oper\u00e1tor bal oldal\u00e1n kell, hogy elhelyezkedjen.</p> Elvis oper\u00e1tor <p>Az Elvis oper\u00e1tor nev\u00e9nek eredet\u00e9re t\u00f6bb magyar\u00e1zatot is lehet tal\u00e1lni, a forr\u00e1sok annyiban nagyr\u00e9szt megegyeznek, hogy a k\u00e9rd\u0151jel tekered\u0151 r\u00e9sze az \u00e9nekes jellegzetes bodorod\u00f3 hajviselet\u00e9re eml\u00e9keztet, a pontok pedig a szemeket jel\u00f6lik, \u00edgy v\u00e9g\u00fclis a ?. egy Elvis emotikonk\u00e9nt foghat\u00f3 fel. Ezen logika ment\u00e9n ad\u00f3dik a magyar megfelel\u0151, a Kozs\u00f3 oper\u00e1tor, hiszen a szem k\u00f6r\u00fcl tekerg\u0151z\u0151 legikonikusabb hajtincs a magyar zenei kult\u00far\u00e1ban Kozs\u00f3 nev\u00e9hez k\u00f6thet\u0151.</p> <p>Ha \u00edgy futtatjuk az alkalmaz\u00e1st, az <code>AgeInDays</code> \u00e9s a sz\u00e1rmaztatott tulajdons\u00e1gok \u00e9rt\u00e9ke <code>null</code> (vagy ki\u00edrva \u00fcres) lesz, ha a sz\u00fclet\u00e9si d\u00e1tum nincs megadva.</p>"},{"location":"seminar/02-csharp2/chapter2/#rekord-tipus","title":"Rekord t\u00edpus","text":"<p>A rekord t\u00edpusok speci\u00e1lis t\u00edpusok, melyek:</p> <ul> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n \u00e9rt\u00e9k t\u00edpusokra jellemz\u0151 logik\u00e1t k\u00f6vetnek, azaz k\u00e9t p\u00e9ld\u00e1ny akkor egyenl\u0151, ha adataik egyenl\u0151ek</li> <li>k\u00f6nnyen immut\u00e1biliss\u00e1 tehet\u0151k, k\u00f6nnyen kezelhet\u0151k immut\u00e1bilis t\u00edpusk\u00e9nt</li> </ul> <p>A <code>Dog</code> t\u00edpus ezzel szemben jelenleg:</p> <ul> <li>nem immut\u00e1bilis, hiszen a sz\u00fclet\u00e9si d\u00e1tum b\u00e1rmikor m\u00f3dos\u00edthat\u00f3 (sima setter)</li> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n a norm\u00e1l referencia szerinti \u00f6sszehasonl\u00edt\u00e1st k\u00f6vet</li> </ul> <p>Az automatikusan gener\u00e1l\u00f3d\u00f3 egyedi azonos\u00edt\u00f3t iktassuk ki a <code>Dog</code> oszt\u00e1lyb\u00f3l, hogy az adat alap\u00fa \u00f6sszehasonl\u00edt\u00e1st k\u00f6nnyebben tesztelhess\u00fck.</p> <pre><code>public Guid Id { get; } = Guid.Empty;\n</code></pre> <p>Vegy\u00fcnk fel egy logikailag megegyez\u0151 p\u00e9ld\u00e1nyt.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nvar watson2 = new Dog { Name = watson.Name };\n</code></pre> <p>Ism\u00e9t \u00e1lljunk meg debug sor\u00e1n valamelyik <code>WriteLine</code> soron. A Locals ablakban n\u00e9zz\u00fck meg, hogy a k\u00e9t p\u00e9ld\u00e1ny minden adata megegyezik. A Watch ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Watch &gt; Watch 1]) \u00e9rt\u00e9kelj\u00fck ki a <code>watson == watson2</code> kifejez\u00e9st. L\u00e1thatjuk, hogy ez az egyenl\u0151s\u00e9gvizsg\u00e1lat hamist ad, ami technikailag helyes, mert k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 mem\u00f3riater\u00fcletr\u0151l van sz\u00f3, a referenci\u00e1k nem ugyanoda mutatnak a mem\u00f3ri\u00e1ban. Sok esetben azonban nem ezt szeretn\u00e9nk, hanem p\u00e9ld\u00e1ul a dupla r\u00f6gz\u00edt\u00e9s elker\u00fcl\u00e9s\u00e9re az adatok alapj\u00e1n t\u00f6rt\u00e9n\u0151 \u00f6sszehasonl\u00edt\u00e1st, ami \u00e9rt\u00e9k t\u00edpusokn\u00e1l van. Referencia t\u00edpusokn\u00e1l klasszikusan ezt a <code>GetHashCode</code>, <code>Equals</code> f\u00fcggv\u00e9nyek fel\u00fcldefini\u00e1l\u00e1s\u00e1val \u00e9rt\u00fck el (vagy az <code>IComparable&lt;T&gt;</code>, <code>IComparer&lt;T&gt;</code> interf\u00e9szre \u00e9p\u00fcl\u0151 logik\u00e1kkal). Egy \u00fajabb lehet\u0151s\u00e9g a rekord t\u00edpus haszn\u00e1lata.</p>"},{"location":"seminar/02-csharp2/chapter2/#pozicio-alapu-megadas","title":"Poz\u00edci\u00f3 alap\u00fa megad\u00e1s","text":"<p>Vegy\u00fcnk fel a <code>Dog</code> t\u00edpus adatainak megfelel\u0151 rekord t\u00edpust, mind\u00f6ssze egy kifejez\u00e9sk\u00e9nt. A <code>Dog</code> t\u00edpus al\u00e1:</p> <pre><code>public record class DogRec(\n    Guid Id,\n    string Name,\n    DateTime? DateOfBirth=null,\n    Dictionary&lt;string, object&gt; Metadata=null\n);\n</code></pre> <p>Note</p> <p>A <code>record class</code> jel\u00f6l\u0151b\u0151l a <code>class</code> elhagyhat\u00f3.</p> <p>Ez az \u00fan. poz\u00edci\u00f3 alap\u00fa megad\u00e1si forma, ami a legink\u00e1bb r\u00f6vid\u00edtett megad\u00e1si form\u00e1ja a rekord t\u00edpusnak. Ebb\u0151l a r\u00f6vid form\u00e1b\u00f3l, mindenfajta extra k\u00f3d \u00edr\u00e1sa n\u00e9lk\u00fcl a ford\u00edt\u00f3 sz\u00e1mos dolgot gener\u00e1l:</p> <ul> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1sb\u00f3l konstruktort \u00e9s dekonstruktort</li> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1s alapj\u00e1n propertyket <code>get</code> \u00e9s <code>init</code> tagf\u00fcggv\u00e9nyekkel</li> <li>alap\u00e9rtelmezett logik\u00e1t az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1shoz</li> <li>kl\u00f3noz\u00f3 \u00e9s m\u00e1sol\u00f3 konstruktor logik\u00e1kat</li> <li>alap\u00e9rtelmezett form\u00e1zott ki\u00edr\u00e1st, sz\u00f6veges reprezent\u00e1ci\u00f3t (<code>ToString</code> implement\u00e1ci\u00f3t)</li> </ul> <p>\u00cdgy egy k\u00f6nnyen kezelhet\u0151, immut\u00e1bilis, az \u00f6sszehasonl\u00edt\u00e1sokban \u00e9rt\u00e9k t\u00edpusk\u00e9nt viselked\u0151 adatoszt\u00e1lyunk lesz.</p> <p>Warning</p> <p>Az <code>Id</code>-nek nem tudjuk be\u00e1ll\u00edtani ebben a form\u00e1ban az alap\u00e9rtelmezett <code>Guid.Empty</code> \u00e9rt\u00e9ket vagy a <code>Metadata</code>-nak az \u00faj p\u00e9ld\u00e1nyt, mert az egyenl\u0151s\u00e9gjeles kifejez\u00e9sekb\u0151l alap\u00e9rtelmezett konstruktorparam\u00e9ter-\u00e9rt\u00e9kek lesznek, amik csak statikus, ford\u00edt\u00e1si id\u0151ben ki\u00e9rt\u00e9kelhet\u0151 kifejez\u00e9sek lehetnek.</p> <p>Vegy\u00fcnk fel a t\u00f6bbi Watson p\u00e9ld\u00e1ny mell\u00e9 k\u00e9t \u00fajabbat, de itt m\u00e1r az \u00faj rekord t\u00edpusunkat haszn\u00e1ljuk.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\");\n</code></pre> <p>A fentebbi Watch ablakos m\u00f3dszerrel ellen\u0151rizz\u00fck a <code>watson3 == watson4</code> kifejez\u00e9s \u00e9rt\u00e9k\u00e9t. Ez m\u00e1r igaz \u00e9rt\u00e9k lesz az adatmez\u0151 alap\u00fa \u00f6sszehasonl\u00edt\u00e1si logika miatt.</p> <p>Pr\u00f3b\u00e1ljuk ki ugyanezt a ki\u00e9rt\u00e9kel\u00e9st az al\u00e1bbi v\u00e1ltozattal:</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\n</code></pre> <p>Ez hamis \u00e9rt\u00e9ket ad, az egyenl\u0151s\u00e9gnek minden mez\u0151re teljes\u00fclnie kell, nem csak a mindkett\u0151ben kit\u00f6lt\u00f6ttekre.</p> <p>A <code>DogRec</code> t\u00edpus alapvet\u0151en immut\u00e1bilis, a p\u00e9ld\u00e1nyainak alapadatai inicializ\u00e1l\u00e1s ut\u00e1n nem m\u00f3dos\u00edthat\u00f3k. Pr\u00f3b\u00e1ljuk fel\u00fcl\u00edrni a nevet.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nwatson4.Name = watson3.Name + \"_2\"; //&lt;= nem fordul\n</code></pre> <p>Nem fog lefordulni, mert minden property init-only t\u00edpus\u00fa. A sor jobboldala egy\u00e9bk\u00e9nt lefordulna, teh\u00e1t a lek\u00e9rdez\u00e9s (getter h\u00edv\u00e1s) m\u0171k\u00f6dne.</p> <p>Ha immut\u00e1bilis t\u00edpusokkal dolgozunk, akkor mut\u00e1ci\u00f3 helyett \u00faj p\u00e9ld\u00e1nyt hozunk l\u00e9tre megv\u00e1ltoztatott adatokkal. Alapvet\u0151en ezt az OO nyelvekben m\u00e1sol\u00f3 konstruktorral oldjuk meg. A rekord t\u00edpusn\u00e1l enn\u00e9l is tov\u00e1bbmenve m\u00e1sol\u00f3 kifejez\u00e9st haszn\u00e1lhatunk.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\n</code></pre> <p>Futtat\u00e1skor a konzolban gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk a rekord t\u00edpusok alap\u00e9rtelmezetten is olvashat\u00f3 sz\u00f6veges ki\u00edr\u00e1s\u00e1ban.</p> <p>A m\u00e1sol\u00f3 kifejez\u00e9sben a <code>with</code> oper\u00e1tor el\u0151tt megadjuk, melyik p\u00e9ld\u00e1nyt kl\u00f3nozn\u00e1nk, majd az inicializ\u00e1ci\u00f3 r\u00e9szek\u00e9nt milyen \u00e9rt\u00e9keket \u00e1ll\u00edtan\u00e1nk \u00e1t, ehhez az objektum inicializ\u00e1ci\u00f3s szintaxist haszn\u00e1lhatjuk. Fontos esz\u00fcnkbe v\u00e9sni, hogy a m\u00e1sol\u00e1s eredm\u00e9nyek\u00e9nt \u00faj p\u00e9ld\u00e1ny j\u00f6n l\u00e9tre, \u00faj mem\u00f3riater\u00fclet foglal\u00f3dik le. Gondoljunk erre akkor, amikor egy ciklusban haszn\u00e1ljuk ezt a m\u00f3dszert sok egym\u00e1st k\u00f6vet\u0151 m\u00f3dos\u00edt\u00e1sra.</p> <p>Mire is j\u00f3 a rekord t\u00edpus</p> <p>Mire j\u00f3 a rekord t\u00edpus, az immutabilit\u00e1s? Az immut\u00e1bilis t\u00edpussokkal val\u00f3 hat\u00e9kony \u00e9s eredm\u00e9nyes munka m\u00e1sfajta, az imperat\u00edv nyelvekhez szokott fejleszt\u0151k sz\u00e1m\u00e1ra szokatlan m\u00f3dszereket k\u00edv\u00e1n. Vannak ter\u00fcletek, ahol ez a befektet\u00e9s megt\u00e9r\u00fcl, ilyen p\u00e9ld\u00e1ul a t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezet. A legt\u00f6bb sz\u00e1lkezel\u00e9ssel kapcsolatos probl\u00e9ma ugyanis a sz\u00e1lak \u00e1ltal k\u00f6z\u00f6sen haszn\u00e1lt adatstrukt\u00far\u00e1k mut\u00e1ci\u00f3j\u00e1ra vezethet\u0151 vissza (\u00fan. race condition, versenyhelyzet). Nincs mut\u00e1ci\u00f3 - nincs probl\u00e9ma. (No mutation - no cry)</p>"},{"location":"seminar/02-csharp2/chapter2/#kitero-a-szotar-visszavag","title":"Kit\u00e9r\u0151: a sz\u00f3t\u00e1r visszav\u00e1g","text":"<p>A rekord t\u00edpus \u00e1ltal biztos\u00edtott kellemes tulajdons\u00e1gok csak akkor \u00e9rv\u00e9nyesek, ha nem keverj\u00fck hagyom\u00e1nyos referencia t\u00edpusokkal.</p> <p>A szok\u00e1sos m\u00f3dszerrel ellen\u0151rizz\u00fck le, hogy a <code>watson5 == watson6</code> kifejez\u00e9s igaz-e. Igen, hiszen minden kit\u00f6lt\u00f6tt adatuk egyezik.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nvar watson6 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Vigy\u00fcnk be egy \u00e1rtatlan inicializ\u00e1ci\u00f3t a <code>Metadata</code> propertyre.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson6 = watson4 with { Name = \"Sherlock\", Metadata= new Dictionary&lt;string, object&gt;() };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Ezzel el\u00e9gg\u00e9 illogikus m\u00f3don hamisra v\u00e1ltozik a <code>watson5 == watson6</code> kifejez\u00e9s. Az oka az, hogy a <code>Metadata</code> sz\u00f3t\u00e1r egy klasszikus referencia t\u00edpus, az \u00f6sszehasonl\u00edt\u00e1sn\u00e1l a klasszikus mem\u00f3riac\u00edm-\u00f6sszehasonl\u00edt\u00e1s t\u00f6rt\u00e9nik, viszont az a k\u00e9t \u00faj sz\u00f3t\u00e1r p\u00e9ld\u00e1ny eset\u00e9ben elt\u00e9r\u0151 lesz. A form\u00e1zott sz\u00f6veges ki\u00edr\u00e1sba is belerond\u00edt a sz\u00f3t\u00e1r, mert ott is a sz\u00f3t\u00e1r t\u00edpus alap\u00e9rtelmezett sz\u00f6veges reprezent\u00e1ci\u00f3ja jut \u00e9rv\u00e9nyre, ami a t\u00edpus neve.</p> <p>Kl\u00f3nozzunk tov\u00e1bb, azt\u00e1n pr\u00f3b\u00e1ljunk mut\u00e1ci\u00f3t v\u00e9grehajtani a <code>Metadata</code> sz\u00f3t\u00e1ron.</p> <pre><code>var watson6 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson7 = watson6 with { Name = \"Watson\" };\nwatson7.Metadata.Add(\"Chip azonos\u00edt\u00f3\", \"12345QQ\");\nWriteLine(watson4);\n</code></pre> <p>Ez lefordul, pedig ez mut\u00e1ci\u00f3. A Locals ablakban figyelj\u00fck meg a <code>watson6</code> \u00e9s <code>watson7</code> sz\u00f3t\u00e1rait: mindkett\u0151be beker\u00fclt a chip azonos\u00edt\u00f3. Ez az \u00fan. shallow copy jelens\u00e9g, amikor nem a sz\u00f3t\u00e1r mem\u00f3riater\u00fclete kl\u00f3noz\u00f3dik, csak a r\u00e1 mutat\u00f3 referencia, ami azt eredm\u00e9nyezi, hogy a k\u00e9t p\u00e9ld\u00e1nynak k\u00f6z\u00f6s sz\u00f3t\u00e1ra lesz.</p> <p>\u00d6sszess\u00e9g\u00e9ben az adatstrukt\u00far\u00e1nkban megjelen\u0151 klasszikus referencia t\u00edpus elrontja:</p> <ul> <li>az immutabilit\u00e1st</li> <li>az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1st</li> <li>a form\u00e1zott sz\u00f6veges megjelen\u00e9st</li> <li>a kl\u00f3noz\u00e1st</li> </ul> <p>Immutabilit\u00e1s</p> <p>Immut\u00e1bilis k\u00f6rnyezetben t\u00f6rekedj\u00fcnk arra, hogy a teljes adatstrukt\u00far\u00e1nk t\u00e1mogassa az immut\u00e1bilis kezel\u00e9st.</p>"},{"location":"seminar/02-csharp2/chapter2/#normal-megadas","title":"Norm\u00e1l megad\u00e1s","text":"<p>Ha nincs sz\u00fcks\u00e9g\u00fcnk a kik\u00e9nyszer\u00edtett immutabilit\u00e1sra, akkor haszn\u00e1lhatjuk a rekord norm\u00e1l megad\u00e1s\u00e1t. Fogjuk a <code>Dog</code> oszt\u00e1lyt, m\u00e1soljuk le a k\u00f3dj\u00e1t, adjunk neki m\u00e1s nevet \u00e9s <code>class</code> helyett <code>record</code> jel\u00f6l\u0151t.</p> <p>A <code>Dog</code> oszt\u00e1ly f\u00f6l\u00e9:</p> <pre><code>public record DogRecExt\n{\n    public string Name { get; init; }\n    public Guid Id { get; } = Guid.Empty;\n    public DateTime? DateOfBirth { get; set; }\n    public Dictionary&lt;string, object&gt; Metadata { get; } = new();\n\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>ToString</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1t elhagytuk az el\u0151z\u0151 szakaszban eml\u00edtettek miatt.</p> <p>A <code>Program.cs</code>-be:</p> <pre><code>var watson8 = new DogRecExt { Name = \"Watson\" };\nwatson8.DateOfBirth = DateTime.Now.AddYears(-15);\nvar watson9 = watson8 with { };\nWriteLine(watson8);\nWriteLine(watson9);\n</code></pre> <p>Ellen\u0151rizz\u00fck le a rekord tulajdons\u00e1gokat:</p> <ul> <li>A konzol kimeneten a form\u00e1z\u00e1st, tov\u00e1bb\u00e1 a mut\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9t, azaz a <code>watson8</code> sz\u00fclet\u00e9si d\u00e1tuma a be\u00e1ll\u00edtott lesz.</li> <li>Ez nem csoda, hiszen a property deklar\u00e1ci\u00f3ban engedt\u00fck a mut\u00e1ci\u00f3t.</li> <li>A konzol kimeneten megfigyelt p\u00e9ld\u00e1nyadatokon a kl\u00f3noz\u00f3 kifejez\u00e9s m\u0171k\u00f6d\u00e9s\u00e9t. Semmi k\u00fcl\u00f6n\u00f6s, ugyan\u00fagy m\u0171k\u00f6dik, mint a t\u00f6m\u00f6r form\u00e1n\u00e1l.</li> <li>A Watch ablakban <code>watson8 == watson9</code> egyenl\u0151s\u00e9get. Ez igaz, mert minden adattagjuk egyezik.</li> </ul> <p>record struct</p> <p>A rekordoknak tov\u00e1bbi v\u00e1lfajai vannak, ugyanis strukt\u00fara is lehet rekord, ilyenkor a <code>record struct</code> kulcssz\u00f3 p\u00e1rt haszn\u00e1ljuk a t\u00edpus deklar\u00e1ci\u00f3j\u00e1n\u00e1l. S\u0151t, a <code>readonly record struct</code> egy immut\u00e1bilis <code>record struct</code>. Ezen v\u00e1lfajok nyilv\u00e1n k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek, mely viselked\u00e9seket itt most nem r\u00e9szletezz\u00fck, de a dokument\u00e1ci\u00f3ban megtal\u00e1lhat\u00f3k.</p>"},{"location":"seminar/03-linq/chapter3/","title":"LINQ","text":""},{"location":"seminar/03-linq/chapter3/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>A gyakorlat kezdet\u00e9n kl\u00f3nozzuk le a kiindul\u00f3 projektet az al\u00e1bbi paranccsal:</p> <pre><code>git clone https://github.com/bmeviauav23/Linq-lab.git\n</code></pre> <p>Nyissuk meg Visual Studio-ban a HelloLinq.sln solution f\u00e1jlt.</p> <p>Megnyit\u00e1s ut\u00e1n tekints\u00fck \u00e1t a kiindul\u00f3 projektben lev\u0151 f\u00e1jlokat:</p> <ul> <li>Program.cs: a legfels\u0151 szint\u0171 k\u00f3dot tartalmaz\u00f3 oszt\u00e1ly. Tal\u00e1lhat\u00f3 benne egy <code>Dogs</code> v\u00e1ltoz\u00f3, ami a <code>Dog</code> oszt\u00e1ly statikus <code>Repository</code> tulajdons\u00e1g\u00e1ba h\u00edv \u00e1t.</li> <li>Dog.cs: a kor\u00e1bbi gyakorlatokon haszn\u00e1lt adatmodell (apr\u00f3bb m\u00f3dos\u00edt\u00e1sokkal).<ul> <li>Beker\u00fclt egy <code>Siblings</code> tulajdons\u00e1g, a <code>ToString</code> pedig ki\u00edrja a kuty\u00e1hoz tartoz\u00f3 testv\u00e9rek sz\u00e1m\u00e1t is (ehhez a <code>TrimPad</code> b\u0151v\u00edt\u0151 met\u00f3dust haszn\u00e1lja).</li> <li>A statikus <code>Repository</code> tulajdons\u00e1g m\u00f6g\u00f6tt egy lust\u00e1n inicializ\u00e1lt <code>Lazy&lt;T&gt; RepositoryHolder</code> tal\u00e1lhat\u00f3, ami egy megfelel\u0151en form\u00e1zott bemeneti CSV f\u00e1jlb\u00f3l elk\u00e9sz\u00edti sz\u00e1munkra az adatmodellt, amivel a k\u00e9s\u0151bbiekben dolgozunk. Ennek implement\u00e1ci\u00f3j\u00e1t el\u00e9g a gyakorlat v\u00e9g\u00e9n megn\u00e9zni. Az <code>Import</code> \u00e9s <code>Export</code> f\u00fcggv\u00e9nyek a kuty\u00e1k soros\u00edt\u00e1s\u00e1t v\u00e9gzik el mindk\u00e9t ir\u00e1nyban.</li> </ul> </li> <li>Extensions/StringExtensions.cs: ez az oszt\u00e1ly tartalmaz egy seg\u00e9dmet\u00f3dust a form\u00e1zott ki\u00edr\u00e1shoz. A <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel. A b\u0151v\u00edt\u0151 met\u00f3dusos r\u00e9szben lesz jelent\u0151s\u00e9ge.</li> <li>dogs.csv: egy pontosvessz\u0151vel tagolt adathalmaz, amelyben 100 darab el\u0151re felvett kutya adata tal\u00e1lhat\u00f3. Innen pusk\u00e1zhatunk, ha ellen\u0151rizni akarjuk, hogy helyesek-e a programunk eredm\u00e9nyei.</li> </ul> <p>A kiindul\u00f3 projektben a glob\u00e1lis implicit n\u00e9vt\u00e9rhivatkoz\u00e1sok ki vannak kapcsolva. A csproj f\u00e1jlban megn\u00e9zhetj\u00fck (menu:jobb klikk a projekten[Edit Project File]):</p> <pre><code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;\n</code></pre>"},{"location":"seminar/03-linq/chapter3/#lambda-kifejezesek-delegatok","title":"Lambda kifejez\u00e9sek, deleg\u00e1tok","text":"<p>Gyakori feladat, hogy objektumok kollekci\u00f3j\u00e1val kell dolgoznunk. K\u00e9pesek vagyunk olyan jelleg\u0171 seg\u00e9df\u00fcggv\u00e9nyeket k\u00e9sz\u00edteni, amik p\u00e9ld\u00e1ul egy kollekci\u00f3ban kikeresik az \u00f6sszes olyan elemet, amely egy megadott felt\u00e9telnek eleget tesz.</p> <p>A <code>Program.cs</code> f\u00e1jlban l\u00e1that\u00f3 ennek a kezdeti naiv v\u00e1ltozata, szemrev\u00e9telezz\u00fck:</p> <pre><code>static List&lt;Dog&gt; ListDogsByNamePrefix(IEnumerable&lt;Dog&gt; dogs, string prefix)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (dog.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>A k\u00f3d m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3.  Ha b\u00e1rmi m\u00e1s alapj\u00e1n szeretn\u00e9nk keresni a kuty\u00e1k k\u00f6z\u00f6tt (pl. a neve tartalmaz-e egy adott sz\u00f6vegr\u00e9szt), mindig egy \u00faj seg\u00e9df\u00fcggv\u00e9nyt kell k\u00e9sz\u00edten\u00fcnk, ami rontja a k\u00f3d \u00fajrahasznos\u00edthat\u00f3s\u00e1g\u00e1t.</p> <p>Oldjuk meg \u00fagy, hogy az \u00e1ltal\u00e1nos probl\u00e9m\u00e1t is megoldjuk! Ehhez az sz\u00fcks\u00e9ges, hogy a kollekci\u00f3nk egyes elemein ki\u00e9rt\u00e9kelhess\u00fcnk egy, a h\u00edv\u00f3 \u00e1ltal megadott predik\u00e1tumot. K\u00e9sz\u00edts\u00fck el az \u00e1ltal\u00e1nosabb v\u00e1ltozatot, ehhez felhaszn\u00e1lhatjuk a <code>ListDogsByNamePrefix</code> k\u00f3dj\u00e1t.</p> <pre><code>static List&lt;Dog&gt; ListDogsByPredicate(\n    IEnumerable&lt;Dog&gt; dogs, Predicate&lt;Dog&gt; predicate)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (predicate(dog))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>A legfels\u0151 szint\u0171 k\u00f3dban \u00edgy h\u00edvhatjuk meg (felhaszn\u00e1lhatjuk az eredeti ciklust):</p> <pre><code>foreach(var dog in ListDogsByPredicate(Dogs, delegate (Dog d) \n    {\n        return d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n    })\n)\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Egy egy bemen\u0151 param\u00e9ter\u0171 \u00e9s egy logikai (<code>bool</code>) \u00e9rt\u00e9ket visszad\u00f3 f\u00fcggv\u00e9nyt defini\u00e1lunk helyben (inline) \u00e9s ezt (illetve a referenci\u00e1j\u00e1t) adjuk \u00e1t. Haszn\u00e1ljunk ink\u00e1bb lambda kifejez\u00e9st, az j\u00f3val r\u00f6videbben le\u00edrhat\u00f3 - egyel\u0151re csak n\u00e9zz\u00fck meg, de ne integr\u00e1ljuk a k\u00f3dba:</p> <pre><code>d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Lambda kifejez\u00e9sek szintaktik\u00e1ja</p> <p>Lambda kifejez\u00e9ssel az egyetlen kifejez\u00e9sb\u0151l \u00e1ll\u00f3 f\u00fcggv\u00e9nyeket adhatjuk meg nagyon kompakt m\u00f3don. A <code>=&gt;</code>-t\u00f3l balra elnevezz\u00fck a bemen\u0151 param\u00e9tereket, jobbra pedig felhaszn\u00e1l(hat)juk. A <code>return</code>, <code>{}</code> \u00e9s egy\u00e9b sallangokat elhagyhatjuk.</p> <p>Vess\u00fck \u00f6ssze, hogy az els\u0151 esetben explicit megadtuk, hogy a bemen\u0151 param\u00e9ter\u00fcnk <code>Dog</code>, most viszont nem. Ezt a ford\u00edt\u00f3 statikus k\u00f3danal\u00edzis alapj\u00e1n el tudja d\u00f6nteni: a <code>d</code> v\u00e1ltoz\u00f3nk nem lehet m\u00e1s, csak <code>Dog</code> (statikus) t\u00edpus\u00fa, ez\u00e9rt csak \u00edgy haszn\u00e1lhatjuk, viszont nem kell ki\u00edrnunk a t\u00edpust.</p> <p>A lambda kifejez\u00e9sek egy lehets\u00e9ges m\u00f3dja a deleg\u00e1tok le\u00edr\u00e1s\u00e1nak. A deleg\u00e1t k\u00f3dot reprezent\u00e1l, viszont a k\u00f3dot kezelhetj\u00fck adatk\u00e9nt is.</p> <p>Pr\u00f3b\u00e1ljuk meg a deleg\u00e1tunkat kivenni egy implicit t\u00edpus\u00fa v\u00e1ltoz\u00f3ba a ciklus el\u0151tt:</p> <pre><code>// ford\u00edt\u00e1si hiba!\nvar predicate = \n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\nforeach (var dog in ListDogsByPredicate(Dogs, predicate))\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Ford\u00edt\u00e1si hib\u00e1t kapunk, lambda kifejez\u00e9s t\u00edpusa nem lehet implicit eld\u00f6nthet\u0151 az inicializ\u00e1ci\u00f3s sorban: sem a bemen\u0151 param\u00e9ter pontos t\u00edpus\u00e1t nem tudjuk (<code>Dog</code>? <code>Puppy</code>?), sem a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket (<code>bool</code>? <code>object</code>? <code>void</code>?). Teh\u00e1t explicit meg kell adnunk a t\u00edpust:</p> <pre><code>Predicate&lt;Dog&gt; predicate =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Ezut\u00e1n fordul \u00e9s fut is az alkalmaz\u00e1sunk.</p> <p>Predicate be\u00e9p\u00edtett deleagate t\u00edpus</p> <p>Ehhez tudnunk kellett, hogy a <code>Predicate&lt;T&gt;</code> megfelel\u0151 szignat\u00far\u00e1j\u00fa. Mutassuk meg ezen t\u00edpus dokument\u00e1ci\u00f3j\u00e1t vagy tegy\u00fck a kurzort a t\u00edpusra \u00e9s nyomjunk F12-t.</p>"},{"location":"seminar/03-linq/chapter3/#func-action","title":"<code>Func&lt;&gt;</code>, <code>Action&lt;&gt;</code>","text":"<p>Ismerkedj\u00fcnk meg a <code>Func</code> \u00e9s <code>Action</code> \u00e1ltal\u00e1nos deleg\u00e1tt\u00edpusokkal. Ezzel a k\u00e9t generikus t\u00edpussal (pontosabban a v\u00e1ltozataikkal) gyakorlatilag az \u00f6sszes gyakorlatban el\u0151fordul\u00f3 f\u00fcggv\u00e9nyszignat\u00far\u00e1t le lehet fedni. P\u00e9ld\u00e1ul a fenti sz\u0171r\u0151logik\u00e1t is \u00e1t\u00edrhatn\u00e1nk erre:</p> <pre><code>Func&lt;Dog, bool&gt; dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A <code>dogFunc</code> \u00e9s a <code>predicate</code> kompatibilisnek t\u0171nhetnek (elv\u00e9gre a jobboldaluk ugyanaz), \u00e1m ha lecser\u00e9ln\u00e9nk pl. a <code>ListDogsByPredicate(Dogs, predicate)</code> h\u00edv\u00e1sban a <code>predicate</code>-et <code>dogFunc</code>-ra, a k\u00f3d nem fordulna, ugyanis a k\u00e9t deleg\u00e1tt\u00edpus nem kompatibilis.</p> <p>Az <code>Action&lt;&gt;</code> hasonl\u00f3 elven m\u0171k\u00f6dik, visszat\u00e9r\u00e9si \u00e9rt\u00e9k n\u00e9lk\u00fcli f\u00fcggv\u00e9nyekre.</p> <p>Egy\u00e9b delegate t\u00edpusok</p> <p>Ha minden esetre j\u00f3k, mi\u00e9rt vannak haszn\u00e1latban <code>Action&lt;&gt;</code> \u00e9s <code>Func&lt;&gt;</code>-on k\u00edv\u00fcl m\u00e1s deleg\u00e1tt\u00edpusok? Egyr\u00e9szt t\u00f6rt\u00e9nelmi okok miatt. K\u00e9s\u0151bb jelentek meg, mint a specifikusak, p\u00e9ld\u00e1ul a <code>Predicate&lt;T&gt;</code>. M\u00e1sr\u00e9szt a specifikusabbak a nev\u00fckkel kifejez\u0151bbek lehetnek.</p> <p>Tiszta f\u00fcggv\u00e9nyek</p> <p>A fenti predik\u00e1tumv\u00e1ltozataink mind nem tiszta f\u00fcggv\u00e9nyek (pure function), ugyanis olyan adatt\u00f3l is f\u00fcgg a visszat\u00e9r\u00e9si \u00e9rt\u00e9ke, ami nem szerepel a param\u00e9terlist\u00e1j\u00e1n - ez eset\u00fcnkben a <code>searchText</code> v\u00e1ltoz\u00f3. A k\u00f3dunk az\u00e9rt m\u0171k\u00f6dik, mert a deleg\u00e1t megad\u00e1sakor a <code>searchText</code> aktu\u00e1lis \u00e9rt\u00e9k\u00e9t elkapjuk (capture), belerakjuk a f\u00fcggv\u00e9nylogik\u00e1ba.</p> <p>Pr\u00f3b\u00e1ljuk a <code>dogFunc</code>-ot <code>var</code>-k\u00e9nt deklar\u00e1lni.</p> <pre><code>//Ford\u00edt\u00e1si hiba!\nvar dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A ford\u00edt\u00f3 nem tudja meghat\u00e1rozni a <code>d</code> param\u00e9ter t\u00edpus\u00e1t, ez\u00e9rt kapjuk a ford\u00edt\u00e1si hib\u00e1t. Adjuk meg explicit a param\u00e9ter t\u00edpus\u00e1t.</p> <pre><code>var dogFunc =\n    (Dog d) =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Debugger-rel ellen\u0151rizhetj\u00fck, hogy a <code>dogFunc</code> val\u00f3di t\u00edpusa <code>Func&lt;Dog, bool&gt;</code> lesz.</p>"},{"location":"seminar/03-linq/chapter3/#ienumerablet-bovito-metodusok","title":"IEnumerable\\&lt;T&gt; b\u0151v\u00edt\u0151 met\u00f3dusok","text":"<p>Vigy\u00fck tov\u00e1bb az \u00e1ltal\u00e1nos\u00edt\u00e1st. \u00cdrjunk olyan logik\u00e1kat, mely nem csak kuty\u00e1k list\u00e1j\u00e1ra, hanem b\u00e1rmilyen felsorolhat\u00f3 (enumer\u00e1lhat\u00f3) kollekci\u00f3ra m\u0171k\u00f6dik. \u00cdrjunk <code>IEnumerable&lt;T&gt;</code> t\u00edpuson m\u0171k\u00f6d\u0151 seg\u00e9df\u00fcggv\u00e9nyeket.</p> <p>Hozzunk l\u00e9tre egy <code>EnumerableExtensions</code> (I bet\u0171 n\u00e9lk\u00fcl, az ugyanis interf\u00e9szre utal) nev\u0171 f\u00e1jlt az <code>Extensions</code> mapp\u00e1ban! Els\u0151k\u00e9nt val\u00f3s\u00edtsuk meg az \u00f6sszegz\u0151 logik\u00e1t.</p> <pre><code>namespace HelloLinq.Extensions.Enumerable;\n\npublic static class EnumerableExtensions\n{\n    public static int Sum&lt;T&gt; (IEnumerable&lt;T&gt;  source, Func&lt;T, int&gt;  sumSelector)\n    {\n        var result = 0;\n        foreach (var elem in source)\n        {\n            result += sumSelector(elem);\n        }\n        return result;\n    }\n}\n</code></pre> <p>H\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3db\u00f3l.</p> <pre><code>using HelloLinq.Extensions.Enumerable;\n\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\nforeach (var dog in Dogs)\n{\n    Console.WriteLine(dog);\n}\n\nConsole.WriteLine(\n    \"\u00c9letkorok \u00f6sszege: \" \n    + $\"{EnumerableExtensions.Sum(Dogs, d =&gt; d.Age ?? 0)}\");\n\nstring searchText;\n</code></pre> <p>A seg\u00e9df\u00fcggv\u00e9nyek h\u00e1tr\u00e1nya, hogy ismern\u00fcnk kell a seg\u00e9doszt\u00e1ly nev\u00e9t. Tov\u00e1bb\u00e1 jobb lenne, ha a kollekci\u00f3n k\u00f6zvetlen\u00fcl h\u00edvhatn\u00e1nk az \u00f6sszegz\u0151 f\u00fcggv\u00e9nyt. Erre megold\u00e1s a b\u0151v\u00edt\u0151 met\u00f3dus.</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok:</p> <ul> <li>statikus oszt\u00e1lyban defini\u00e1lhat\u00f3k</li> <li>statikus f\u00fcggv\u00e9nyek</li> <li>els\u0151 param\u00e9tere el\u0151tt <code>this</code> jel\u00f6li, hogy melyik t\u00edpust b\u0151v\u00edtik</li> </ul> <p>Az els\u0151 param\u00e9ter el\u00e9 tegy\u00fck be a <code>this</code> jel\u00f6l\u0151t.</p> <pre><code>public static int Sum&lt;T&gt; (\n    this IEnumerable&lt;T&gt;  source,\n    Func&lt;T, int&gt;  sumSelector)\n    {\n        // ...\n    }\n</code></pre> <p>Most m\u00e1r haszn\u00e1lhatjuk azt a szintaxist, mintha a kollekci\u00f3nak eleve lenne \u00f6sszegz\u0151 f\u00fcggv\u00e9nye:</p> <pre><code>Console.WriteLine($\"\u00c9letkorok \u00f6sszege: {Dogs.Sum(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>OO egys\u00e9gbez\u00e1r\u00e1si elv</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok semmilyen m\u00f3don nem bontj\u00e1k meg a t\u00edpusok egys\u00e9gbez\u00e1r\u00e1si k\u00e9pess\u00e9geit. A f\u00fcggv\u00e9nyek implement\u00e1ci\u00f3i a b\u0151v\u00edtend\u0151 t\u00edpusok k\u00edv\u00fclr\u0151l is el\u00e9rhet\u0151 f\u00fcggv\u00e9nyeit, propertyjeit haszn\u00e1lhatj\u00e1k, priv\u00e1t adattagokhoz, f\u00fcggv\u00e9nyekhez nem f\u00e9rnek hozz\u00e1.</p> <p>Oszt\u00e1ly nev\u00e9nek felold\u00e1sa</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok alkalmaz\u00e1sakor nagyon fontos, hogy b\u00e1r a b\u0151v\u00edt\u0151 met\u00f3dus oszt\u00e1ly\u00e1nak nev\u00e9t nem \u00edrjuk ki, az oszt\u00e1ly nev\u00e9nek feloldhat\u00f3nak kell lennie, azaz az oszt\u00e1ly n\u00e9vter\u00e9t <code>using</code> direkt\u00edv\u00e1val be kell hivatkoznunk. Egy pr\u00f3ba erej\u00e9ig kommentezz\u00fck ki a <code>using HelloLinq.Extensions.Enumerable;</code> sort \u00e9s ellen\u0151rizz\u00fck, hogy nem fordul a k\u00f3dunk, a b\u0151v\u00edt\u0151 met\u00f3dus nev\u00e9t a ford\u00edt\u00f3 nem tudja feloldani.</p> <p>Gyakorl\u00e1sk\u00e9ppen \u00edrhatunk tov\u00e1bbi gyakori adatfeldolgoz\u00e1si m\u0171veletekre f\u00fcggv\u00e9nyeket, mint amilyen az \u00e1tlagsz\u00e1m\u00edt\u00e1s, min-max keres\u00e9s.</p> Megold\u00e1s <pre><code>public static class EnumerableExtensions\n{\n    //...\n\n    public static double Average&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; sumSelector)\n    {\n        var result = 0.0; // Az oszt\u00e1s m\u0171velet miatt double\n        var elements = 0;\n        foreach (var elem in source)\n        {\n            elements++;\n            result += sumSelector(elem);\n        }\n        return result / elements;\n    }\n\n    public static int Min&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n    {\n        int value = int.MaxValue;\n        foreach (var elem in source)\n        {\n            var currentValue = valueSelector(elem);\n            if (currentValue &lt; value)\n            {\n                value = currentValue;\n            }\n        }\n        return value;\n    }\n\n    public static int Max&lt;T&gt; (this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n        =&gt; -source.Min(e =&gt; -valueSelector(e));\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az \u00faj f\u00fcggv\u00e9nyeket. Mivel a <code>Dogs</code> t\u00edpusa <code>IEnumerable&lt;Dog&gt;</code>, \u00edgy a b\u0151v\u00edt\u0151 met\u00f3dusok b\u0151v\u00edtend\u0151 t\u00edpusa illeszkedik r\u00e1.</p> <pre><code>Console.WriteLine($\"\u00c1tlagos \u00e9letkor: {Dogs.Average(d =&gt; d.Age ?? 0)}\");\nConsole.WriteLine(\n    $\"Minimum-maximum \u00e9letkor: \" +\n    $\"{Dogs.Min(d =&gt; d.Age ?? 0)} | {Dogs.Max(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>StringExtensions.cs</p> <p>A <code>StringExtensions</code> oszt\u00e1lyban egy lambdak\u00e9nt megval\u00f3s\u00edtott b\u0151v\u00edt\u0151 met\u00f3dust l\u00e1thatunk, ami egy sz\u00f6veget adott hosszra (sz\u00e9less\u00e9gre) eg\u00e9sz\u00edt ki sz\u00f3k\u00f6z\u00f6kkel. A f\u00fcggv\u00e9nyt a <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel.</p>"},{"location":"seminar/03-linq/chapter3/#gyakori-lekerdezo-muveletek-yield-return","title":"Gyakori lek\u00e9rdez\u0151 m\u0171veletek, yield return","text":"<p>Gyakran el\u0151fordul, hogy egy list\u00e1t sz\u0171rni vagy projekt\u00e1lni szeretn\u00e9nk. \u00cdrjunk saj\u00e1t gener\u00e1tort ezekhez a m\u0171veletekhez is az <code>EnumerableExtensions</code>-be:</p> <pre><code>public static IEnumerable&lt;T&gt; Where&lt;T&gt;(\n    this IEnumerable&lt;T&gt;  source, Predicate&lt;T&gt;  predicate)\n{\n    foreach (var elem in source)\n    {\n        if (predicate(elem))\n        {\n            yield return elem;\n        }\n    }\n}\n\npublic static IEnumerable&lt;TValue&gt; Select&lt;T, TValue&gt;(\n    this IEnumerable&lt;T&gt;  source, Func&lt;T, TValue&gt; selector)\n{\n    foreach (var elem in source)\n    {\n        yield return selector(elem);\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n, v\u00e1lasszuk ki a 2010 el\u0151tt sz\u00fcletett kuty\u00e1k nev\u00e9t \u00e9s kor\u00e1t egy stringbe:</p> <pre><code>foreach (var text in Dogs\n    .Where(d =&gt; d.DateOfBirth?.Year &lt; 2010)\n    .Select(d =&gt; $\"{d.Name} ({d.Age})\"))\n{\n    Console.WriteLine(text);\n}\n</code></pre> <p>A yield return haszna</p> <p>A <code>yield return</code> egy hasznos eszk\u00f6z, ha IEnumerable-t kell produk\u00e1lnunk visszat\u00e9r\u00e9si \u00e9rt\u00e9kk\u00e9nt. Seg\u00edts\u00e9g\u00e9vel mindig csak akkor \u00e1ll\u00edtjuk el\u0151 a k\u00f6vetkez\u0151 elemet, amikor a h\u00edv\u00f3 k\u00e9ri. A m\u0171k\u00f6d\u00e9s\u00e9t debuggerrel is figyelj\u00fck meg: tegy\u00fcnk breakpointot a k\u00e9t <code>yield return</code> sorra, majd F10-zel k\u00f6vess\u00fck v\u00e9gig, ahogy a <code>foreach</code> elk\u00e9ri a <code>Select</code>-t\u0151l a k\u00f6vetkez\u0151 elemet, ami emiatt elk\u00e9ri a <code>Where</code>-t\u0151l, majd \u00fajraindul a ciklus. A h\u00edv\u00e1sok \u00e1llapotg\u00e9pk\u00e9nt m\u0171k\u00f6dnek, a k\u00f6vetkez\u0151 megh\u00edv\u00e1skor onnan folytat\u00f3dnak, ahonnan az el\u0151z\u0151 <code>yield return</code>-n\u00e9l kil\u00e9pt\u00fcnk.</p> <p>Nem nagy meglepet\u00e9s, hogy az \u00e1ltalunk meg\u00edrt <code>Sum</code>, <code>Average</code> (melyek egyedi visszat\u00e9r\u00e9s\u0171ek), <code>Select</code> \u00e9s <code>Where</code> (amik szekvenci\u00e1lis visszat\u00e9r\u00e9s\u0171ek, gener\u00e1torok) met\u00f3dusok mind a .NET keretrendszer r\u00e9sz\u00e9t k\u00e9pezik (a <code>System.Linq.Enumerable</code> statikus oszt\u00e1lyban defini\u00e1lt b\u0151v\u00edt\u0151 met\u00f3dusok). A LINQ\u2009\u2014\u2009**L**anguage **IN**tegrated **Q**uery\u2009\u2014\u2009ezeket a m\u0171veleteket teszi lehet\u0151v\u00e9 <code>IEnumerable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 objektumokon. A LINQ f\u00fcggv\u00e9nyek b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt lettek hozz\u00e1adva meglev\u0151 funkcionalit\u00e1shoz (kollekci\u00f3khoz, lek\u00e9rdez\u00e9sekhez), s\u0151t, k\u00fcls\u0151 library-k is adnak saj\u00e1t LINQ b\u0151v\u00edt\u0151 met\u00f3dusokat.</p> <p>Cser\u00e9lj\u00fck le a <code>Program.cs</code>-ben a <code>using HelloLinq.Extensions.Enumerable</code> hivatkoz\u00e1st <code>using System.Linq</code>-re: az \u00e1ltalunk meg\u00edrt k\u00f3d tov\u00e1bbra is ugyanazt az eredm\u00e9nyt produk\u00e1lja! N\u00e9zz\u00fck meg, hogy hol vannak defini\u00e1lva ezek a f\u00fcggv\u00e9nyek a keretrendszeren bel\u00fcl: a kurzort tegy\u00fck a k\u00f3dban oda, ahol valamelyik kor\u00e1bban meg\u00edrt f\u00fcggv\u00e9ny\u00fcnket h\u00edvn\u00e1nk, majd nyomjunk F12-t. Pr\u00f3b\u00e1ljuk ki, hogy tov\u00e1bbra is az elv\u00e1rt m\u00f3don m\u0171k\u00f6dik-e a programunk.</p> <p>Implicit usings</p> <p>A n\u00e9vt\u00e9rcsere helyett bekapcsolhatjuk a glob\u00e1lis implicit n\u00e9vt\u00e9r funkci\u00f3t, mert a <code>System.Linq</code> n\u00e9vt\u00e9r is egy implicit hivatkozott n\u00e9vt\u00e9r. Ehhez a projektf\u00e1jlban az <code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;</code> be\u00e1ll\u00edt\u00e1st \u00edrjuk \u00e1t <code>enable</code>-re, majd a <code>using HelloLinq</code> -en k\u00edv\u00fcl minden n\u00e9vt\u00e9rhivatkoz\u00e1st t\u00f6r\u00f6lj\u00fcnk a <code>Program.cs</code>-b\u0151l.</p>"},{"location":"seminar/03-linq/chapter3/#anonim-tipusok","title":"Anonim t\u00edpusok","text":"<p>Lek\u00e9rdez\u00e9sekn\u00e9l gyakran haszn\u00e1latosak az anonim t\u00edpusok, amelyeket jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9nek ideiglenes, t\u00edpusos t\u00e1rol\u00e1s\u00e1ra haszn\u00e1lunk. Az anonim t\u00edpusokkal lehet\u0151s\u00e9g\u00fcnk van inline defini\u00e1lni olyan oszt\u00e1lyokat, amelyek jellemz\u0151en csak dobozol\u00e1sra \u00e9s adattov\u00e1bb\u00edt\u00e1sra haszn\u00e1ltak. Vegy\u00fck az al\u00e1bbi p\u00e9ld\u00e1kat a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n:</p> <pre><code>var dolog1 = new { Name = \"Alma\", Weight = 100, Size = 10 };\nvar dolog2 = new { Name = \"K\u00f6rte\", Weight = 90 };\n</code></pre> <p>Kor\u00e1bban m\u00e1r eml\u00edtett\u00fck a <code>var</code> kulcssz\u00f3t, amellyel implicit t\u00edpus\u00fa, lok\u00e1lis v\u00e1ltoz\u00f3k defini\u00e1lhat\u00f3k. Az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n defini\u00e1lunk egy-egy anonim t\u00edpust, amelynek felvesz\u00fcnk n\u00e9h\u00e1ny tulajdons\u00e1got. A tulajdons\u00e1gok mind t\u00edpusosak maradnak, a t\u00edpusrendszer\u00fcnk tov\u00e1bbra is s\u00e9rtetlen. Az implicit statikus t\u00edpusoss\u00e1g nem csak a <code>var</code> kulcssz\u00f3ban jelenik meg teh\u00e1t, hanem az egyes tulajdons\u00e1gok t\u00edpus\u00e1ban is.</p> <p>Az anonim t\u00edpusok:</p> <ul> <li>csak referencia t\u00edpus\u00faak lehetnek (objektumok, nem pedig strukt\u00far\u00e1k),</li> <li>csak publikusan l\u00e1that\u00f3, csak olvashat\u00f3 tulajdons\u00e1gokat tartalmazhatnak,</li> <li>esem\u00e9nyeket \u00e9s met\u00f3dusokat nem tartalmazhatnak (delegate p\u00e9ld\u00e1nyokat tulajdons\u00e1gban viszont igen),</li> <li>szerelv\u00e9nyen bel\u00fcl l\u00e1that\u00f3k (<code>internal</code>) \u00e9s nem sz\u00e1rmazhat bel\u0151l\u00fck m\u00e1sik t\u00edpus (<code>sealed</code>)</li> <li>t\u00edpusnev\u00e9t nem ismerj\u00fck, \u00edgy hivatkozni sem tudunk r\u00e1, csak a <code>var</code>-t tudjuk haszn\u00e1lni</li> <li>nem haszn\u00e1lhat\u00f3k ott, ahol a <code>var</code> t\u00edpus se haszn\u00e1lhat\u00f3, t\u00f6bbek k\u00f6z\u00f6tt nem adhatjuk \u00e1t f\u00fcggv\u00e9nynek \u00e9s nem lehet visszat\u00e9r\u00e9si \u00e9rt\u00e9k sem</li> </ul> <p>Ha az egeret a <code>var</code> kulcsszavak vagy egyes tulajdons\u00e1gnevek f\u00f6l\u00e9 vissz\u00fck, l\u00e1thatjuk, hogy val\u00f3ban ford\u00edt\u00e1si idej\u0171 t\u00edpusokr\u00f3l van sz\u00f3.</p> <p>IntelliSense</p> <p>Figyelj\u00fck meg, hogy az IntelliSense is m\u0171k\u00f6dik ezekre a t\u00edpusokra, felk\u00edn\u00e1lja a t\u00edpus property-jeit.</p> <p>A ford\u00edt\u00f3 \u00fajra is hasznos\u00edtja az egyes t\u00edpusokat:</p> <pre><code>var dolgok = new { Name = \"Gy\u00fcm\u00f6lcs\u00f6k\", Contents = new[] { dolog1, dolog2 } };\n</code></pre> <p>A <code>Contents</code> tulajdons\u00e1g t\u00edpusa a fenti anonim objektumaink t\u00f6mbje, ez\u00e9rt nem is adhatn\u00e1nk meg m\u00e1sk\u00e9ppen (nem tudjuk a nev\u00e9t, amivel hivatkozhatunk r\u00e1). A ford\u00edt\u00f3 most panaszkodik, ugyanis a k\u00e9t dolog t\u00edpusa nem implicit k\u00f6vetkeztethet\u0151. Ha felvessz\u00fck a <code>Size</code> tulajdons\u00e1got a <code>dolog2</code> defin\u00edci\u00f3j\u00e1ba, m\u00e1ris fordul.</p> <pre><code>var dolog2 = new { Name = \"K\u00f6rte\", Weight = 90, Size = 12 };\n</code></pre> <p>Ha v\u00e9gezt\u00fcnk az anonim t\u00edpusokkal val\u00f3 ismerked\u00e9ssel, az ezekkel kapcsolatos k\u00f3dsorokat kikommentezhetj\u00fck.</p>"},{"location":"seminar/03-linq/chapter3/#linq-szintaxisok","title":"LINQ szintaxisok","text":"<p>Az el\u0151z\u0151 r\u00e9szben ismertetett jelleg\u0171 lek\u00e9rdez\u00e9sek nagyban hasonl\u00edtanak azokhoz, amiket adatb\u00e1zis-lek\u00e9rdez\u00e9sekben alkalmazunk. A k\u00fcl\u00f6nbs\u00e9g itt az, hogy imperat\u00edv szintaxist haszn\u00e1lunk, szemben pl. az SQL-lel, ami deklarat\u00edvat. Ez\u00e9rt is van jelen a C# nyelvben az \u00fan. query syntax, amely j\u00f3val hasonlatosabb az SQL szintaxis\u00e1hoz, \u00edgy az adatb\u00e1zisokban j\u00e1rtas fejleszt\u0151k is k\u00f6nnyebben \u00edrhatnak lek\u00e9rdez\u00e9seket. Ugyanakkor nem minden lek\u00e9rdez\u00e9st tudunk query syntax-szal le\u00edrni.</p> <p>Mi\u00e9rt nem lehet mindent meg\u00edrni query syntaxban?</p> <p>Ennek oka, hogy az oper\u00e1torok bevezet\u00e9se egy nyelvben el\u00e9g dr\u00e1ga - le kell p\u00e9l\u00e1dul foglalni az oper\u00e1tor nev\u00e9t, amit ut\u00e1na korl\u00e1tozottan lehet csak haszn\u00e1lni m\u00e1sra. Ez\u00e9rt sem csin\u00e1lt\u00e1k meg minden LINQ f\u00fcggv\u00e9nynek az oper\u00e1tor p\u00e1rj\u00e1t, csak az SQL-ben gyakrabban haszn\u00e1latosabbaknak.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3 lek\u00e9rdez\u00e9st meg\u00edrhatunk az al\u00e1bbi m\u00f3don query syntax haszn\u00e1lat\u00e1val:</p> <pre><code>using HelloLinq.Extensions;\n\n//...\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\n\nvar query = from d in Dogs\n            where d.DateOfBirth?.Year &lt; 2010\n            select new\n            {\n                Dog = d,\n                AverageSiblingAge = d.Siblings.Average(s =&gt; s.Age ?? 0)\n            };\nforeach (var meta in query)\n{\n    Console.WriteLine(\n        $\"{meta.Dog.Name} - {meta.AverageSiblingAge}\");\n}\n</code></pre> <p>A query szintaxis v\u00e9g\u00fcl a kor\u00e1bban is haszn\u00e1lt, \u00fan. *fluent szintaxis*s\u00e1 fordul. Ennek igazol\u00e1s\u00e1ra n\u00e9zz\u00fck meg F12-vel, hogy hol vannak defini\u00e1lva az \u00fajonnan megismert oper\u00e1torok (<code>select</code>, <code>where</code>). A k\u00e9t szintaxist szok\u00e1s \u00f6tv\u00f6zni is, jellemz\u0151en akkor, ha query szintaxisban \u00edrjuk a lek\u00e9rdez\u00e9st, \u00e9s a hi\u00e1nyz\u00f3 funkcionalit\u00e1st fluent szintaxissal p\u00f3toljuk.</p> <p>Fluent szintaxis</p> <p>A fluent szintaxist olyan kialak\u00edt\u00e1s\u00fa API-kn\u00e1l alkalmazhatjuk, ahol a f\u00fcggv\u00e9nyek a tartalmaz\u00f3 t\u00edpust v\u00e1rj\u00e1k (egyik) bemenetk\u00e9nt \u00e9s azonos (vagy lesz\u00e1rmazott) t\u00edpust adnak vissza. A LINQ-n\u00e9l ez a t\u00edpus az <code>IEnumerable&lt;&gt;</code>.</p> <p>Ezen az \u00f3r\u00e1n mem\u00f3riabeli adatforr\u00e1sokkal dolgoztunk (konkr\u00e9tan a <code>Dogs</code> nev\u0171 <code>Dictionary&lt;,&gt;</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3val), a LINQ oper\u00e1torok k\u00f6z\u00fcl a mem\u00f3riabeli list\u00e1kon dolgoz\u00f3kat haszn\u00e1ltuk, melyeket az <code>IEnumerable&lt;&gt;</code> interf\u00e9szre biggyesztettek r\u00e1 b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt. Ezt a LINQ API-t teljes nev\u00e9n *LINQ-to-Objects*nek h\u00edvj\u00e1k, de gyakran csak LINQ-k\u00e9nt hivatkozz\u00e1k.</p>"},{"location":"seminar/03-linq/chapter3/#kitekinto-expression-linq-providerek","title":"Kitekint\u0151: Expression\\&lt;&gt;, LINQ providerek","text":"<p>Vegy\u00fck az al\u00e1bbi nagyon egyszer\u0171 delegate-et \u00e9s ennek <code>Expression&lt;&gt;</code>-\u00f6s p\u00e1rj\u00e1t.</p> <pre><code>Func&lt;int, int&gt;  f = x =&gt; x + 1;\nExpression&lt;Func&lt;int, int&gt;&gt; e = x =&gt; x + 1;\n</code></pre> <p>N\u00e9zz\u00fck meg debuggol\u00e1s k\u00f6zben a Watch ablakban a fenti k\u00e9t v\u00e1ltoz\u00f3t. Az <code>f</code> egy delegate, leford\u00edtott k\u00f3d*ra mutat\u00f3 referencia, az <code>Expression</code> a jobb oldali kifejez\u00e9sb\u0151l \u00e9p\u00edtett (fa strukt\u00far\u00e1j\u00fa) *adat.</p> <p>A f\u00e1t k\u00f3dd\u00e1 ford\u00edthatjuk a <code>Compile</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel, mely a leford\u00edtott f\u00fcggv\u00e9ny referenci\u00e1j\u00e1t (deleg\u00e1t p\u00e9ld\u00e1ny) adja vissza, amit a f\u00fcggv\u00e9nyh\u00edv\u00e1s szintaxissal h\u00edvhatunk meg. Ebb\u0151l \u00e1ll \u00f6ssze az al\u00e1bbi fura kin\u00e9zet\u0171 kifejez\u00e9s:</p> <pre><code>Console.WriteLine(e.Compile()(5));\n</code></pre> <p>B\u00e1r az <code>Expression&lt;&gt;</code> emiatt okosabb v\u00e1laszt\u00e1snak t\u0171nik, \u00e1m a LINQ-to-Objects alapinterf\u00e9sz\u00e9nek (ami a lek\u00e9rdez\u0151f\u00fcggv\u00e9nyeket biztos\u00edtja) f\u00fcggv\u00e9nyei <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code> deleg\u00e1tokat v\u00e1rnak. Ami nem csoda, hiszen mem\u00f3riabeli list\u00e1kat \u00e1ltal\u00e1ban sima programk\u00f3ddal dolgozunk fel, nincs \u00e9rtelme fel\u00e9p\u00edteni kifejez\u00e9sf\u00e1t csak az\u00e9rt, hogy ut\u00e1na egyb\u0151l k\u00f3dd\u00e1 ford\u00edtsuk. Emellett m\u00e1s, mem\u00f3riabeli adatokon dolgoz\u00f3 LINQ technol\u00f3gia is l\u00e9tezik, pl. LINQ-to-XML saj\u00e1t API-val (nem <code>IEnumerable&lt;&gt;</code> alapt\u00edpussal).</p> <p>A nem mem\u00f3riabeli adatokon, hanem p\u00e9ld\u00e1ul k\u00fcls\u0151 adatb\u00e1zisb\u00f3l dolgoz\u00f3 LINQ provider-ek viszont <code>IQueryable&lt;&gt;</code>-t val\u00f3s\u00edtanak meg. Az <code>IQueryable&lt;&gt;</code> az <code>IEnumerable&lt;&gt;</code>-b\u00f3l sz\u00e1rmazik, \u00edgy neki is vannak <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code>-\u00f6s f\u00fcggv\u00e9nyei, de emellett <code>Expression&lt;&gt;</code>-\u00f6sek is. Ez ut\u00f3bbiak teszik lehet\u0151v\u00e9, hogy ne csak .NET k\u00f3dot gener\u00e1ljanak a lambda kifejez\u00e9sekb\u0151l, hanem helyette pl. SQL kifejez\u00e9st - hiszen egy rel\u00e1ci\u00f3s adatb\u00e1zis adatfeldolgoz\u00f3 nyelve nem .NET, hanem valamilyen SQL dialektus.</p>"},{"location":"seminar/03-linq/chapter3/#a-linq-providerek-altalanos-mukodese","title":"A LINQ providerek \u00e1ltal\u00e1nos m\u0171k\u00f6d\u00e9se","text":"<p>Bemenet\u00fck: query f\u00fcggv\u00e9nyeknek (<code>IQueryable&lt;&gt;</code> vagy <code>IEnumerable&lt;&gt;</code> f\u00fcggv\u00e9nyei vagy pl. <code>XDocument</code>) param\u00e9ter\u00fcl adott lambd\u00e1k (<code>Func&lt;&gt;</code> vagy <code>Expression&lt;&gt;</code>)</p> <p>Kimenet\u00fck: az adatforr\u00e1snak megfelel\u0151 nyelv\u0171, a query-t v\u00e9grehajt\u00f3 k\u00f3d (.NET k\u00f3d vagy SQL).</p> <p>LINQ-to-Objects eset\u00e9n nincs val\u00f3di LINQ provider (a provider az <code>IQueryable.Provider</code>-en kereszt\u00fcl \u00e9rhet\u0151 el, de a <code>List&lt;&gt;</code> nem <code>IQueryable</code>!), hiszen nincs feladata: k\u00f3dot kap bemenet\u00fcl, ugyanazt kellene kimenet\u00fcl adnia. A LINQ-to-XML is hasonl\u00f3 elven m\u0171k\u00f6dik.</p> <p>Val\u00f3di LINQ providert val\u00f3s\u00edt meg p\u00e9ld\u00e1ul az Entity Framework, de ezt a technol\u00f3gi\u00e1t k\u00e9s\u0151bb t\u00e1rgyaljuk.</p>"},{"location":"seminar/04-csharp4/chapter4/","title":"C# alapok IV.","text":"<p>Ezen a gyakorlaton t\u00f6bb k\u00fcl\u00f6nf\u00e9le nyelvi konstrukci\u00f3t tekint\u00fcnk \u00e1t, vegyesfelv\u00e1gott jelleggel. Az egyes f\u0151 t\u00e9mak\u00f6r\u00f6ket k\u00fcl\u00f6n projektk\u00e9nt dolgozzuk ki. A projekteket hozz\u00e1adhatjuk az els\u0151k\u00e9nt l\u00e9trehozott projekt solutionj\u00e9hez (menu:jobbklikk a solution-\u00f6n[Add &gt; New project]). Hozz\u00e1ad\u00e1s ut\u00e1n ne felejts\u00fck el \u00e1t\u00e1ll\u00edtani a futtatand\u00f3 projektet: menu:jobbklikk a projekten[Set as Startup Project].</p>"},{"location":"seminar/04-csharp4/chapter4/#bejarasi-problemak","title":"Bej\u00e1r\u00e1si probl\u00e9m\u00e1k","text":"<p>Enumer\u00e1torok haszn\u00e1lata eset\u00e9n k\u00e9t alapvet\u0151 probl\u00e9m\u00e1ba \u00fctk\u00f6z\u00fcnk: az egyik a m\u00f6g\u00f6ttes kollekci\u00f3 m\u00f3dosul\u00e1sa bej\u00e1r\u00e1s sor\u00e1n, a m\u00e1sik pedig a k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9sb\u0151l ad\u00f3d\u00f3 mell\u00e9khat\u00e1sok kezel\u00e9se.</p>"},{"location":"seminar/04-csharp4/chapter4/#kollekcio-modosulasa-bejarasa-soran","title":"Kollekci\u00f3 m\u00f3dosul\u00e1sa bej\u00e1r\u00e1sa sor\u00e1n","text":"<p>Sz\u0171rj\u00fcnk le egy sz\u00e1mokat tartalmaz\u00f3 kollekci\u00f3t csak azokra az elemekre, amik megfelelnek egy felt\u00e9telnek, \u00e9s ezeket t\u00e1vol\u00edtsuk el a kollekci\u00f3b\u00f3l!</p> <pre><code>var numbers = Enumerable.Range(1, 8).ToList();\nforeach (var p in numbers)\n{\n    if (p % 2 == 0)\n    {\n        numbers.Remove(p);\n    }\n}\nnumbers.ForEach(Console.WriteLine);\n</code></pre> <p>Futtat\u00e1skor kiv\u00e9telt kapunk. Mi a probl\u00e9ma? A kollekci\u00f3t bej\u00e1r\u00e1s k\u00f6zben szerett\u00fck volna m\u00f3dos\u00edtani, viszont ez k\u00f6nnyen nem v\u00e1rt m\u0171k\u00f6d\u00e9st (t\u00falc\u00edmz\u00e9st, nemdeterminisztikus bej\u00e1r\u00e1st) tenne lehet\u0151v\u00e9, ez\u00e9rt kiv\u00e9telt kapunk. Oldjuk meg a probl\u00e9m\u00e1t: nem m\u00f3dos\u00edthatjuk a forr\u00e1s objektumot bej\u00e1r\u00e1s k\u00f6zben, teh\u00e1t ne azt a kollekci\u00f3t j\u00e1rjuk be, m\u00e1soljuk le!</p> <pre><code>foreach (var p in numbers.ToList()) // a ToList beker\u00fclt\n{\n    // ...\n}\n</code></pre> <p>Ez megoldja a probl\u00e9m\u00e1t, siker\u00fcl elt\u00e1vol\u00edtani az elemeket a kollekci\u00f3b\u00f3l. De mi\u00e9rt?  A <code>ToList</code> <code>IEnumerable</code> b\u0151v\u00edt\u0151, teh\u00e1t bej\u00e1rhatja a kollekci\u00f3t, ezut\u00e1n pedig egy m\u00e1sik <code>List&lt;&gt;</code> objektumban t\u00e1rolja az elemeket. \u00cdgy teh\u00e1t k\u00e9t list\u00e1nk lesz (a <code>numbers</code> \u00e9s a <code>numbers.ToList</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9ke), amik kezdetben egym\u00e1s kl\u00f3njai, menet k\u00f6zben az egyikb\u0151l vesz\u00fcnk ki, a m\u00e1sikon pedig iter\u00e1lunk.</p> <p>Kiv\u00e9telek</p> <p>B\u00e1r a fenti az \u00e1ltal\u00e1nos szab\u00e1ly, bizonyos kollekci\u00f3k bizonyos m\u00f3dos\u00edt\u00f3 m\u0171veletei m\u00e9gsem dobnak kiv\u00e9telt, ilyen p\u00e9ld\u00e1ul a <code>Dictionary&lt;,&gt;</code> <code>Remove</code> \u00e9s <code>Clear</code> m\u0171veletei.</p>"},{"location":"seminar/04-csharp4/chapter4/#azonnali-es-kesleltetett-kiertekeles","title":"Azonnali \u00e9s k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s","text":"<p>Amennyiben egy met\u00f3dus gener\u00e1tor (<code>IEnumerable</code> vagy <code>IEnumerable&lt;&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171), az egyes elemeken t\u00f6rt\u00e9n\u0151 iter\u00e1ci\u00f3 a gener\u00e1torok egym\u00e1sba \u00e1gyaz\u00e1s\u00e1t jelenti, azaz az egyes gener\u00e1torokban a <code>yield return</code> \u00e1ltal visszaadott \u00e9rt\u00e9ket fogja az enumer\u00e1tor <code>MoveNext</code> met\u00f3dusa visszaadni. Am\u00edg az <code>IEnumerable</code>-re van referenci\u00e1nk, \u00e9s nem j\u00e1rjuk azt k\u00f6zvetlen\u00fcl be, addig k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9sr\u0151l besz\u00e9l\u00fcnk.</p> <p>Az eddigiek al\u00e1:</p> <pre><code>var i = 0;\nforeach (var n in numbers\n                    .Where(p =&gt; p &gt; 2)\n                    .Select(p =&gt; new { p, x = ++i }))\n{\n    Console.WriteLine($\"{n} - {i}\");\n}\n\nConsole.WriteLine();\n\ni = 0;\nforeach (var n in numbers\n                    .Where(p =&gt; p &gt; 2)\n                    .Select(p =&gt; new { p, x = ++i })\n                    .ToList())\n{\n    Console.WriteLine($\"{n} - {i}\");\n}\n</code></pre> <p>A <code>ToList</code> h\u00edv\u00e1sunk el\u0151sz\u00f6r bej\u00e1rja az iter\u00e1tort \u00e9s visszaad egy list\u00e1t, amelybe \u00f6sszegy\u0171jti az <code>IEnumerable</code> elemeit. Ez\u00e9rt az <code>i</code> v\u00e1ltoz\u00f3nk a m\u00e1sodik esetben nem egy\u00fctt inkrement\u00e1l\u00f3dik a bej\u00e1r\u00e1ssal, mert az k\u00e9tszer t\u00f6rt\u00e9nik meg. Az els\u0151 bej\u00e1r\u00e1skor (a <code>ToList</code> h\u00edv\u00e1sakor) inkrement\u00e1l\u00f3dik az <code>i</code> \u00e9rt\u00e9ke, m\u00e1sodj\u00e1ra pedig m\u00e1r csak bej\u00e1rjuk a kapott list\u00e1t. Eddigre az <code>i</code> \u00e9rt\u00e9ke m\u00e1r meg van n\u00f6velve.</p> <p>Ezzel a megk\u00f6zel\u00edt\u00e9ssel fut\u00e1sid\u0151ben is \u00e1ll\u00edthatunk \u00f6ssze egy id\u0151ben v\u00e1ltoz\u00f3 lek\u00e9rdez\u00e9st, amit majd egyszer, a k\u00e9s\u0151bbiekben fogunk bej\u00e1rni (pl. soros\u00edt\u00e1skor).</p>"},{"location":"seminar/04-csharp4/chapter4/#aszinkron-mukodes","title":"Aszinkron m\u0171k\u00f6d\u00e9s","text":"<p>T\u00f6lts\u00fcnk le egy HTML oldalt, \u00e9s ezen a probl\u00e9m\u00e1n kereszt\u00fcl bemutatjuk az aszinkron programoz\u00e1si modellt. A <code>HttpClient</code> m\u0171k\u00f6d\u00e9s\u00e9nek a r\u00e9szletesebb ismertet\u00e9se most nem t\u00e9ma, csak a legalapvet\u0151bb funkci\u00f3kat fogjuk haszn\u00e1lni.</p> <p>A f\u0151 gond, hogy a hosszan fut\u00f3 m\u0171veletek blokkolhatj\u00e1k a f\u0151/UI/aktu\u00e1lis sz\u00e1l fut\u00e1s\u00e1t, mindez kliens alkalmaz\u00e1sok eset\u00e9ben \u00fagy jelentkezik, hogy nem lesz az alkalmaz\u00e1sunk reszponz\u00edv a felhaszn\u00e1l\u00f3i bemenetekre; szerveralkalmaz\u00e1sok eset\u00e9ben pedig az adott k\u00e9r\u00e9st kiszolg\u00e1l\u00f3 sz\u00e1l feleslegesen blokkol\u00f3dik, amikor esetleg m\u00e1ssal is tudna foglalkozni.</p> <p>\u00d6tlet: a hosszan tart\u00f3 m\u0171veleteket v\u00e9gezz\u00fck aszinkron m\u00f3don, \u00e9s ha az befejez\u0151d\u00f6tt az eredm\u00e9nyr\u0151l valamilyen m\u00f3don \u00e9rtes\u00fclj\u00fcnk. A keretrendszer t\u00f6bbf\u00e9le mint\u00e1t k\u00edn\u00e1l erre:</p> <ul> <li>Asynchronous Programming Model (APM),</li> <li>Event-based Asynchronous Pattern (EAP),</li> <li>Task-based Asynchronous Pattern (TAP).</li> </ul> <p>Mi most a legut\u00f3bbival foglalkozunk csak, a t\u00f6bbi j\u00f3r\u00e9szt elavultnak sz\u00e1m\u00edt ma m\u00e1r.</p>"},{"location":"seminar/04-csharp4/chapter4/#tap-es-asyncawait-alapjai","title":"TAP \u00e9s async/await alapjai","text":"<p>A TAP-ra m\u00e1r C# nyelvi t\u00e1mogat\u00e1st is kapunk az <code>async</code>/<code>await</code> kulcsszavakon kereszt\u00fcl. Vegy\u00fcnk fel egy \u00faj met\u00f3dust \u00e9s h\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3dban. A meg\u00edrt met\u00f3dus \u00edr\u00e1sa sor\u00e1n hivatkozzuk be a <code>System.Net.Http</code> n\u00e9vteret. A k\u00f3d semmi m\u00e1st nem csin\u00e1l, csak elind\u00edt aszinkron m\u00f3don egy HTTP GET k\u00e9r\u00e9st a megadott URL-re, illetve a v\u00e1lasz tartalm\u00e1t is aszinkron m\u00f3don kiolvassa \u00e9s egy r\u00e9sz\u00e9t ki\u00edrja a konzolra.</p> <pre><code>LoadWebPageAsync();\nConsole.WriteLine(\"Ez a v\u00e9ge\");\nConsole.ReadKey();\n\nstatic async void LoadWebPageAsync()\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(new Uri(\"http://www.bing.com\"));\n        Console.WriteLine(response.StatusCode.ToString());\n\n        var content = await response.Content.ReadAsStringAsync();\n        Console.WriteLine(content.Take(1000).ToArray());\n    }\n}\n</code></pre> <p>await: Mindig egy <code>Task</code> <code>await</code>-elhet\u0151 (vagy taszk szer\u0171 dolog: vagyis van neki <code>GetAwaiter</code> met\u00f3dusa, ami meghat\u00e1rozott met\u00f3dusokkal rendelkez\u0151 objektummal t\u00e9r vissza)!  Ak\u00e1r l\u00e9tre is hozhatunk egy <code>Task</code>-ot, amit egy lok\u00e1lis v\u00e1ltoz\u00f3ban t\u00e1rolunk, akkor azt is tudjuk <code>await</code>-elni.</p> <p>async: Ha await-elni akarunk, akkor musz\u00e1j <code>async</code>-nak lennie a tartalmaz\u00f3 met\u00f3dusnak, mert ilyenkor \u00e9p\u00edti fel a ford\u00edt\u00f3 az aszinkron v\u00e9grehajt\u00e1shoz sz\u00fcks\u00e9ges \u00e1llapotg\u00e9pet.</p> <p>Debuggoljuk ki! Minden <code>Console</code>, <code>async</code> sorra tegy\u00fcnk t\u00f6r\u00e9spontot, debuggol\u00e1s sor\u00e1n (F5) k\u00f6vess\u00fck v\u00e9gig, milyen sorrendben \u00e9ri el \u0151ket a v\u00e9grehajt\u00e1s. N\u00e9zz\u00fck meg, melyik r\u00e9sz milyen sz\u00e1lon fut le (debug k\u00f6zben menu:Debug[Windows &gt; Threads]). A <code>LoadWebPageAsync</code> ut\u00e1ni r\u00e9sz el\u0151bb fog lefutni, mint az els\u0151 <code>await</code> ut\u00e1ni r\u00e9sz. Az <code>await</code> ut\u00e1ni r\u00e9sz nem a Main Thread-en fut. Figyelj\u00fck meg azt is, hogy az Ez a v\u00e9ge sz\u00f6veg hamarabb ki\u00edr\u00f3dik, mint a HTML oldal let\u00f6lt\u00e9se.</p> <p>Pr\u00f3b\u00e1ljuk ki a <code>Console.ReadKey</code>-t kikommentezve is, ilyenkor j\u00f3 es\u00e9llyel hamarabb le\u00e1ll a process, minthogy a <code>Task</code> befejez\u0151dne. Az ilyen fire-and-forget t\u00edpus\u00fa h\u00edv\u00e1sokn\u00e1l nem figyel arra senki, hogy itt m\u00e9g valami h\u00e1tt\u00e9rm\u0171velet folyik.</p> <p>async void ker\u00fclend\u0151</p> <p>Az <code>async void</code> \u00e1ltal\u00e1ban helytelen k\u00f3d, mert nem lehet bev\u00e1rni a h\u00e1tt\u00e9rm\u0171velet v\u00e9g\u00e9t. Az <code>async Task</code> m\u00e1ris jobb a bev\u00e1rhat\u00f3s\u00e1g \u00e9s a hibakezel\u00e9s miatt, \u00e9s alig kell m\u00f3dos\u00edtani a k\u00f3dot. Kiv\u00e9tel, amikor valami\u00e9rt k\u00f6telez\u0151 a <code>void</code>, p\u00e9ld\u00e1ul, ha esem\u00e9ny vagy interf\u00e9sz el\u0151\u00edrja.</p>"},{"location":"seminar/04-csharp4/chapter4/#az-oldalletoltes-bevarasa","title":"Az oldallet\u00f6lt\u00e9s bev\u00e1r\u00e1sa","text":"<p>M\u00f3dos\u00edtsuk \u00fagy a k\u00f3dot, hogy a <code>LoadWebPageAsync</code> ut\u00e1ni r\u00e9sz v\u00e1rja meg a let\u00f6lt\u00e9s befejez\u0151d\u00e9s\u00e9t. Ez akkor j\u00f3 p\u00e9ld\u00e1ul, ha a let\u00f6lt\u00e9s ut\u00e1n valamit m\u00e9g szeretn\u00e9k elv\u00e9gezni a h\u00edv\u00f3 f\u00fcggv\u00e9nyben.</p> <p>M\u00f3dos\u00edtsuk a <code>LoadWebPageAsync</code> fejl\u00e9c\u00e9t, hogy taszkot adjon vissza:</p> <pre><code>public static async Task LoadWebPageAsync() //void helyett Task\n</code></pre> <p>V\u00e1rjuk be az aszinkron m\u0171velet v\u00e9g\u00e9t a legfels\u0151 szint\u0171 k\u00f3dban.</p> <pre><code>await LoadWebPageAsync(); //await beker\u00fclt\nConsole.WriteLine(\"Ez a v\u00e9ge\");\n/*Console.ReadKey();*/\n</code></pre> <p>Figyelj\u00fck meg, hogy \u00edgy m\u00e1r az Ez a v\u00e9ge felirat m\u00e1r a let\u00f6lt\u00e9s ut\u00e1n jelenik meg.</p> <p><code>await</code>-et haszn\u00e1ltunk a legfels\u0151 szint\u0171 k\u00f3dban, ilyenkor automatikusan <code>async</code> kulcssz\u00f3val ell\u00e1tott <code>Main</code> gener\u00e1l\u00f3dik - valami hasonl\u00f3, mint az al\u00e1bbi k\u00f3dr\u00e9szlet.</p> <pre><code>await LoadWebPageAsync();\nConsole.WriteLine(\"Ez a v\u00e9ge\");\n//Console.ReadKey();\n</code></pre>"},{"location":"seminar/04-csharp4/chapter4/#hattermuvelet-eredmenyenek-visszaadasa","title":"H\u00e1tt\u00e9rm\u0171velet eredm\u00e9ny\u00e9nek visszaad\u00e1sa","text":"<p>Alak\u00edtsuk \u00e1t, hogy a weboldal tartalm\u00e1nak ki\u00edrat\u00e1sa a legfels\u0151 szint\u0171 k\u00f3dban t\u00f6rt\u00e9njen, \u00e9s a <code>LoadWebPageAsync</code> csak adja vissza a tartalmat <code>string</code>-k\u00e9nt. Ehhez m\u00f3dos\u00edtsuk a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket <code>Task&lt;string&gt;</code>-re, \u00edgy az <code>await</code> m\u00e1r eredm\u00e9nnyel fog tudni visszat\u00e9rni.</p> <pre><code>var content = await LoadWebPageAsync();\nConsole.WriteLine(content);\nConsole.WriteLine(\"Ez a v\u00e9ge\");\nConsole.ReadKey();\nstatic async Task&lt;string&gt; LoadWebPageAsync() //generikus param\u00e9ter\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(new Uri(\"http://www.bing.com\"));\n        Console.WriteLine(response.StatusCode.ToString());\n\n        var content = await response.Content.ReadAsStringAsync();\n        return new string(content.Take(1000).ToArray());\n    }\n}\n</code></pre> <p>A <code>return</code> val\u00f3j\u00e1ban ezen <code>Task</code> eredm\u00e9ny\u00e9t \u00e1ll\u00edtja be <code>async</code> met\u00f3dusok eset\u00e9ben, \u00e9s nem egy nemgenerikus <code>Task</code> objektummal kell visszat\u00e9rj\u00fcnk.</p>"},{"location":"seminar/04-csharp4/chapter4/#nemigazan-nullozhato-referencia-tipusok","title":"Nem(igaz\u00e1n) nullozhat\u00f3 referencia t\u00edpusok","text":"<p>Kor\u00e1bban l\u00e1ttuk, hogy hogyan lehet egy \u00e9rt\u00e9k t\u00edpusnak null \u00e9rt\u00e9ket adni (<code>Nullable&lt;T&gt;</code>). Az \u00e9rem m\u00e1sik oldala a C# 8-ban megjelent nem nullozhat\u00f3 referencia t\u00edpusok. Nem egy \u00faj t\u00edpust vezettek be, hanem az eddig megszokott t\u00edpusneveket \u00e9rtelmezi m\u00e1shogyan a ford\u00edt\u00f3. A projektf\u00e1jlban az al\u00e1bbi be\u00e1ll\u00edt\u00e1s kapcsolja be ezt a funkci\u00f3t.</p> <pre><code>&lt;Nullable&gt;enable&lt;/Nullable&gt;\n</code></pre> <p>Egy\u00e9b konfigur\u00e1ci\u00f3s lehet\u0151s\u00e9gek</p> <p>Ezen k\u00edv\u00fcl m\u00e9g preprocessor direkt\u00edv\u00e1kkal is szab\u00e1lyozhatjuk a m\u0171k\u00f6d\u00e9st.</p> <p>Induljunk ki egy egyszer\u0171 szem\u00e9lyeket nyilv\u00e1ntart\u00f3 adatoszt\u00e1lyb\u00f3l, ahol elhat\u00e1rozzuk, hogy a k\u00f6z\u00e9ps\u0151 n\u00e9v kiv\u00e9tel\u00e9vel a t\u00f6bbi n\u00e9vdarab nem nullozhat\u00f3 sz\u00f6veg lesz.</p> <pre><code>Console.WriteLine(\"Hello World!\");\nclass Person\n{\n    string FirstName;   // Not null\n    string? MiddleName; // May be null\n    string LastName;    // Not null\n}\n</code></pre> <p>Ez m\u00e1ris sz\u00e1mos figyelmeztet\u00e9st gener\u00e1l. A nem nullozhat\u00f3 referencia t\u00edpusok bekapcsol\u00e1s\u00e1val alapesetben nem hib\u00e1k, csak \u00faj figyelmeztet\u00e9sek gener\u00e1l\u00f3dnak. A vezet\u00e9kn\u00e9v \u00e9s keresztn\u00e9v adatoknak nem szabadna <code>null</code> \u00e9rt\u00e9k\u0171nek lennie (a sima <code>string</code> t\u00edpus nem nullozhat\u00f3 t\u00edpust jelent), viszont \u00edgy az alap\u00e9rt\u00e9k nem egy\u00e9rtelm\u0171, explicit inicializ\u00e1lnunk kellene.</p> <p>Fontos meg\u00e9rten\u00fcnk, hogy a string t\u00edpus fizikailag tov\u00e1bbra is lehet null \u00e9rt\u00e9k\u0171, mind\u00f6ssze a ford\u00edt\u00f3 sz\u00e1m\u00e1ra jelezz\u00fck, hogy sz\u00e1nd\u00e9kunk szerint sohasem szabadna <code>null</code> \u00e9rt\u00e9ket felvennie. A ford\u00edt\u00f3 cser\u00e9be figyelmeztet, ha ezt megs\u00e9rt\u0151 k\u00f3dot detekt\u00e1l.</p> <p>Az egyik legk\u00e9zenfekv\u0151bb megold\u00e1s (az inline inicializ\u00e1ci\u00f3 mellett), ha konstruktorban inicializ\u00e1lunk konstruktorparam\u00e9ter alapj\u00e1n. Adjunk konstruktort a t\u00edpusnak:</p> <pre><code>public Person(string fname, string lname, string? mname)\n{\n    FirstName = fname;\n    LastName = lname;\n    MiddleName = mname;\n}\n</code></pre> <p>Ezzel meg is oldottunk minden figyelmeztet\u00e9st.</p> <p>Rebuild</p> <p>Ha biztosan l\u00e1tni akarjuk az \u00f6sszes figyelmeztet\u00e9st, akkor sima Build m\u0171velet helyett haszn\u00e1ljuk a Rebuild-et.</p> <p>Konstruktorok</p> <p>Sajnos a k\u00f6telez\u0151en konstruktoron kereszt\u00fcli inicializ\u00e1ci\u00f3 nem mindig m\u0171k\u00f6dik, p\u00e9ld\u00e1ul a soros\u00edt\u00f3k \u00e1ltal\u00e1ban nem szeretik, ha nincs alap\u00e9rtelmezett konstruktor.</p> <p>Mennyire okos a ford\u00edt\u00f3 a <code>null</code> \u00e9rt\u00e9k detekt\u00e1l\u00e1s\u00e1ban?N\u00e9zz\u00fcnk p\u00e1r p\u00e9ld\u00e1t! Az al\u00e1bbi statikus f\u00fcggv\u00e9nyt tegy\u00fck bele a <code>Person</code> oszt\u00e1lyunkba \u00e9s vegy\u00fck fel a <code>using static System.Console;</code> n\u00e9vt\u00e9rhivatkoz\u00e1st is.</p> <pre><code>static void M(string? ns)\n{\n    WriteLine(ns.Length); // (1)!\n    if (ns != null)\n    {\n        WriteLine(ns.Length); // (2)!\n    }\n    if (ns == null)\n    {\n        return;\n    }\n    WriteLine(ns.Length); // (3)!\n    ns = null;\n    WriteLine(ns.Length); // (4)!\n    string s = default(string); // (5)!\n    string[] a = new string[10]; // (6)!\n}\n</code></pre> <ol> <li>Figyelmeztet\u00e9s lehets\u00e9ges <code>null</code> \u00e9rt\u00e9kre, mert a t\u00edpusa szerint nullozhat\u00f3.</li> <li>Ha egy egyszer\u0171 <code>if</code>-fel levizsg\u00e1ljuk, akkor m\u00e1ris ok. Pedig pl. t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben az <code>if</code> ki\u00e9rt\u00e9kel\u00e9se \u00e9s ezen sor v\u00e9grehajt\u00e1sa k\u00f6z\u00f6tt a v\u00e1ltoz\u00f3 ak\u00e1r <code>null</code> \u00e9rt\u00e9kre is be\u00edr\u00f3dhat.</li> <li>Az el\u0151tte l\u00e9v\u0151 r\u00f6vidz\u00e1r is megnyugtatja a ford\u00edt\u00f3t, \u00edgy itt sincs figyelmeztet\u00e9s.</li> <li>Ezt az el\u0151z\u0151 sor alapj\u00e1n figyelmeztet\u00e9ssel jutalmazza.</li> <li>Ez is figyelmeztet\u00e9s, a <code>default</code> oper\u00e1tor \u00e1ltal adott \u00e9rt\u00e9kkel (<code>null</code>) nem inicializ\u00e1lhatunk.</li> <li>Ez viszont nem figyelmeztet\u00e9s, pedig egy csom\u00f3 <code>null</code> j\u00f6n l\u00e9tre. Ha ez figyelmeztet\u00e9s lenne, az ar\u00e1nytalanul megnehez\u00edten\u00e9 a t\u00f6mb\u00f6k kezel\u00e9s\u00e9t.</li> </ol> <p>L\u00e1that\u00f3, hogy az egyszer\u0171bb eseteket j\u00f3l kezeli a ford\u00edt\u00f3, de kor\u00e1ntsem mindenhat\u00f3, illetve nem mindig sz\u00f3l akkor sem, amikor egy\u00e9bk\u00e9nt sz\u00f3lhatna.</p> <p>A tov\u00e1bbi p\u00e9ld\u00e1khoz vegy\u00fcnk fel p\u00e1r seg\u00e9df\u00fcggv\u00e9nyt a <code>Person</code> oszt\u00e1lyba:</p> <pre><code>private Person GetAnotherPerson()\n{\n    return new Person(LastName, FirstName, MiddleName ?? string.Empty);\n}\n\nprivate void ResetFields()\n{\n    FirstName = default!;\n    LastName = null!;\n    MiddleName = null;\n}\n</code></pre> <p>L\u00e1that\u00f3, hogy vannak megker\u00fcl\u0151 megold\u00e1sok arra, hogy r\u00e1er\u0151szakoljuk a ford\u00edt\u00f3ra az akaratunkat, a felki\u00e1lt\u00f3jel haszn\u00e1lat\u00e1val be\u00edrhatunk <code>null</code> \u00e9rt\u00e9keket nem nullozhat\u00f3 v\u00e1ltoz\u00f3kba (ez az \u00fan. null forgiving operator ). Illetve <code>string</code> eset\u00e9n null helyett haszn\u00e1lhatjuk az \u00fcres <code>string</code> \u00e9rt\u00e9ket - ami nem biztos, hogy sokkal jobb a <code>null</code> \u00e9rt\u00e9kn\u00e9l. Mindenesetre ezek a f\u00fcggv\u00e9nyek nem okoznak \u00fajabb figyelmeztet\u00e9seket.</p> <p>N\u00e9zz\u00fck meg, hogy mennyire tudja lek\u00f6vetni a fenti f\u00fcggv\u00e9nyek m\u0171k\u00f6d\u00e9s\u00e9t a ford\u00edt\u00f3. Vegy\u00fcnk fel ennek tesztel\u00e9s\u00e9re egy \u00fajabb f\u00fcggv\u00e9nyt a <code>Person</code> oszt\u00e1lyba:</p> <pre><code>void M(Person p)\n{\n    if (p.MiddleName != null)\n    {\n        p.ResetFields();\n        WriteLine(p.MiddleName.Length); // (1)!\n\n        p = GetAnotherPerson();\n        WriteLine(p.MiddleName.Length); // (2)!\n    }\n    p.FirstName = null;          // (3)!\n    p.LastName = p.MiddleName;   // (4)!\n}\n</code></pre> <ol> <li>A ford\u00edt\u00f3 nem k\u00f6veti le, hogy a <code>ResetFields</code> vesz\u00e9lyes m\u00f3don v\u00e1ltoztatja az \u00e1llapotot, csak azt n\u00e9zi, hogy az <code>if</code> m\u00e1r kiv\u00e9dte a vesz\u00e9lyt.</li> <li>Ez egy fals pozit\u00edvnak t\u0171n\u0151 eset, az el\u0151z\u0151 sorban l\u00e9v\u0151 f\u00fcggv\u00e9ny alapj\u00e1n a <code>p.MiddleName</code> nem lehetne <code>null</code>, de a ford\u00edt\u00f3 csak azt figyeli, hogy a beburkol\u00f3 <code>if</code> ellen\u0151rz\u00e9se a <code>p</code> megv\u00e1ltoz\u00e1sa miatt m\u00e1r nem \u00e9rv\u00e9nyes.</li> <li>Egy\u00e9rtelm\u0171en jogos figyelmeztet\u00e9s.</li> <li>Jogos a figyelmeztet\u00e9s, mert nem kezelj\u00fck a <code>p.MiddleName == null</code> esetet.</li> </ol> <p>Strukt\u00faratagok eset\u00e9n is a fals negat\u00edv eset j\u00f6n el\u0151. Pr\u00f3b\u00e1ljuk ki, ak\u00e1r a <code>Person</code> oszt\u00e1lyba \u00edrva:</p> <pre><code>struct PersonHandle\n{\n    public Person person;\n}\n</code></pre> <p>Nem kapunk figyelmeztet\u00e9st.</p> <p>A felki\u00e1lt\u00f3jeles r\u00e1er\u0151szakol\u00e1st a <code>ResetFields</code>-ben l\u00e1that\u00f3 \u00e1mokfut\u00e1s helyett ink\u00e1bb a fals pozit\u00edv esetek kezel\u00e9s\u00e9re haszn\u00e1ljuk. Jav\u00edtsuk ki a <code>GetAnotherPerson</code> h\u00edv\u00e1s miatti fals pozit\u00edv esetet az <code>M(Person)</code> f\u00fcggv\u00e9nyben:</p> <pre><code>p = GetAnotherPerson();\nWriteLine(p.MiddleName!.Length); //beker\u00fclt egy '!'\n</code></pre> <p>Figyelj\u00fck meg, ahogy a figyelmeztet\u00e9s elt\u0171nik.</p> <p>Ha igaz\u00e1n elk\u00f6telezettek vagyunk a <code>null</code> kiirt\u00e1sa mellett, akkor bekapcsolhatjuk, hogy minden, a <code>null</code> kezel\u00e9s miatti, ford\u00edt\u00f3 \u00e1ltal detekt\u00e1lt figyelmeztet\u00e9s legyen hiba. A projekt be\u00e1ll\u00edt\u00e1si k\u00f6z\u00f6tt (menu:a projekten jobbklikk[Properties]), a Build lapon adjuk meg a Treat specific warnings as errors opci\u00f3nak a <code>nullable</code> \u00e9rt\u00e9ket. (Ha t\u00f6bb \u00e9rt\u00e9ket akarunk megadni, akkor a <code>;</code> elv\u00e1laszt\u00f3t alkalmazhatjuk.)</p> <p>Ellen\u0151rizz\u00fck, hogy t\u00e9nyleg hibak\u00e9nt jelennek-e meg az eddigi <code>null</code> kezel\u00e9s miatti figyelmeztet\u00e9sek.</p> <p>Mivel ez csak egy p\u00e9ldak\u00f3d, ne jav\u00edtsuk ki a hib\u00e1kat, csak t\u00e1vol\u00edtsuk el a projektet a solutionb\u0151l (menu:a projekten jobbklikk[Remove]).</p>"},{"location":"seminar/04-csharp4/chapter4/#tuple-nyelvi-szinten-lokalis-fuggvenyek-dispose-minta","title":"Tuple nyelvi szinten, lok\u00e1lis f\u00fcggv\u00e9nyek, Dispose minta","text":""},{"location":"seminar/04-csharp4/chapter4/#tuple-nyelvi-szinten-lokalis-fuggvenyek","title":"Tuple nyelvi szinten, lok\u00e1lis f\u00fcggv\u00e9nyek","text":"<p>K\u00e9sz\u00edts\u00fcnk Fibonacci sz\u00e1msor kisz\u00e1mol\u00e1s\u00e1ra alkalmas f\u00fcggv\u00e9nyt, ahol haszn\u00e1ljuk ki az al\u00e1bbi k\u00e9t \u00faj nyelvi elemet. Term\u00e9szetesen nagyon sokf\u00e9lek\u00e9ppen meg lehetne val\u00f3s\u00edtani ezt a met\u00f3dust, de most kifejezetten a tuple-\u00f6k nyelvi t\u00e1mogat\u00e1s\u00e1t \u00e9s lok\u00e1lis f\u00fcggv\u00e9nyeket szeretn\u00e9nk demonstr\u00e1lni.</p> <ul> <li>Lok\u00e1lis f\u00fcggv\u00e9nyek: ezek a f\u00fcggv\u00e9nyek csak adott met\u00f3dusban l\u00e1that\u00f3k.K\u00e9t esetben \u00e9rdemes \u0151ket haszn\u00e1lni: ha nem szeretn\u00e9nk \u201eszennyezni\u201d a k\u00f6rnyez\u0151 oszt\u00e1lyt k\u00fcl\u00f6nf\u00e9le priv\u00e1t seg\u00e9dmet\u00f3dusokkal, vagy ha egy m\u00e9lyebb, komplexebb h\u00edv\u00e1si l\u00e1ncban nem szeretn\u00e9nk a param\u00e9tereket folyamatosan tov\u00e1bbpasszolni, ugyanis ezek a met\u00f3dusok el\u00e9rik a k\u00fcls\u0151 scope-on tal\u00e1lhat\u00f3 v\u00e1ltoz\u00f3kat is (a lenti esetben p\u00e9ld\u00e1ul az <code>x</code>-et).</li> <li>Value tuple t\u00edpus: a tuple (ennes) t\u00f6bb \u00f6sszetartoz\u00f3 \u00e9rt\u00e9k \u00f6sszefog\u00e1sa, ami gyors, nyelvi szinten t\u00e1mogatott adattov\u00e1bb\u00edt\u00e1st tesz lehet\u0151v\u00e9 - gyakorlatilag inline, neves\u00edtetlen strukt\u00farat\u00edpust hozunk \u00edgy l\u00e9tre. Publikus API-kon, f\u00fcggv\u00e9nyeken nem \u00e9rdemes haszn\u00e1lni, viszont priv\u00e1t, bels\u0151 haszn\u00e1latn\u00e1l sebess\u00e9gn\u00f6veked\u00e9st \u00e9s API tisztul\u00e1st \u00e9rhet\u00fcnk vele el. \u00c9rt\u00e9k t\u00edpus.</li> </ul> <p>Referencia t\u00edpus\u00fa Tuple&lt;&gt;</p> <p>L\u00e9teznek generikus <code>Tuple&lt;&gt;</code> t\u00edpusok is. Ezek referencia t\u00edpusok, hasonl\u00f3 szerepet t\u00f6ltenek be, viszont az egyes \u00e9rt\u00e9keiket az el\u00e9g semmitmond\u00f3 <code>Item1</code>, <code>Item2</code>\u2026 neveken lehet el\u00e9rni.</p> <pre><code>static long Fibonacci(long x)\n{\n    (long Current, long Previous) Fib(long i) # (1)!\n    {\n        if (i == 0) return (1, 0);\n        var (curr, prev) = Fib(i - 1); # (2)!\n        Thread.Sleep(100); # (3)!\n        return (curr + prev, curr);\n    }\n\n    return x &lt; 0\n        ? throw new ArgumentException(\"Less negativity please!\", nameof(x))\n        : Fib(x).Current;\n}\n</code></pre> <ol> <li>Neves\u00edtett tuple visszat\u00e9r\u00e9s. Ez egy lok\u00e1lis f\u00fcggv\u00e9ny, szintaxist tekintve f\u00fcggv\u00e9nyen bel\u00fcli f\u00fcggv\u00e9ny.</li> <li>Az eredm\u00e9ny elt\u00e1rol\u00e1sa egy tuple v\u00e1ltoz\u00f3ban. Ezzel dekonstru\u00e1ljuk is, darabokra szedj\u00fck a tuple-t, mert <code>curr</code>, <code>prev</code> v\u00e1ltoz\u00f3n kereszt\u00fcl el\u00e9rj\u00fck a k\u00e9t <code>long</code> alkot\u00f3r\u00e9szt. Ugyanezen sorban t\u00f6rt\u00e9nik a rekurz\u00edv h\u00edv\u00e1s is.</li> <li>Lass\u00fa m\u0171velet szimul\u00e1ci\u00f3ja mesters\u00e9ges k\u00e9sleltet\u00e9ssel.</li> </ol> <p>Dekonstrukci\u00f3</p> <p>A dekonstrukci\u00f3s szintaxis a kor\u00e1bbi gyakorlaton megismert rekord t\u00edpusok eset\u00e9n is m\u0171k\u00f6dik.</p>"},{"location":"seminar/04-csharp4/chapter4/#dispose-minta","title":"Dispose minta","text":"<p>A Dispose minta az er\u0151forr\u00e1s-felszabad\u00edt\u00e1s megfelel\u0151 megval\u00f3s\u00edt\u00e1s\u00e1hoz k\u00e9sz\u00fclt. Hasonl\u00f3 elv ment\u00e9n \u00fczemel, mint a destruktor, viszont a minta nem felt\u00e9tlen\u00fcl k\u00f6t\u00f6tt az objektum \u00e9letciklus\u00e1nak elej\u00e9hez \u00e9s v\u00e9g\u00e9hez. Amennyiben egy objektum megval\u00f3s\u00edtja az <code>IDisposable</code> interf\u00e9szt, van <code>Dispose</code> met\u00f3dusa. A met\u00f3dus megh\u00edv\u00e1s\u00e1val az objektum \u00e1ltal haszn\u00e1lt, nem a keretrendszer \u00e1ltal menedzselt er\u0151forr\u00e1sokat szabad\u00edtjuk fel. Nem csak mem\u00f3riafoglal\u00e1sra kell gondolni, hanem lehetnek nyitott f\u00e1jlrendszeri handle-\u00f6k, adatkapcsolatok, stream-ek, vagy \u00fczleti er\u0151forr\u00e1sok, tranzakci\u00f3k.</p> <p>M\u00e9rj\u00fck meg az els\u0151 p\u00e1r Fibonacci sz\u00e1m kisz\u00e1m\u00edt\u00e1s\u00e1t (a mesters\u00e9ges k\u00e9sleltet\u00e9ssel):</p> <pre><code>var sw = Stopwatch.StartNew();\nforeach (var n in Enumerable.Range(1, 15))\n{\n  Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n}\nsw.Stop();\nConsole.WriteLine($\"Elapsed: {sw.ElapsedMilliseconds}\");\nConsole.ReadKey();\n</code></pre> <p>Ez \u00edgy j\u00f3, m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3 ez az id\u0151m\u00e9r\u00e9si mechanizmus.</p> <p>K\u00e9sz\u00edts\u00fcnk egy saj\u00e1t id\u0151m\u00e9r\u0151 oszt\u00e1lyt <code>StopwatchWrapper</code> n\u00e9ven, ami a <code>Stopwatch</code> haszn\u00e1lat\u00e1t egyszer\u0171s\u00edti a Dispose mint\u00e1n kereszt\u00fcl.</p> <pre><code>public class StopwatchWrapper : IDisposable\n{\n    public Stopwatch Stopwatch { get; }\n\n    public string Title { get; }\n\n    public StopwatchWrapper(string? title = default)\n    {\n        Title = title ?? Guid.NewGuid().ToString();\n        Console.WriteLine($\"Task {title} starting at {DateTime.Now}.\");\n        Stopwatch = Stopwatch.StartNew();\n    }\n}\n</code></pre> <p>Ha k\u00e9rj\u00fck a villanyk\u00f6rte seg\u00edts\u00e9g\u00e9t az <code>IDisposable</code>-\u00f6n, akkor 2x2 lehet\u0151s\u00e9g\u00fcnk van: megval\u00f3s\u00edtjuk az interf\u00e9szt implicit vagy explicit, illetve megval\u00f3s\u00edtjuk-e az interf\u00e9szt a Dispose mint\u00e1t alkalmazva. Val\u00f3s\u00edtsuk meg implicit a Dispose mint\u00e1t!</p> <p> Dispose minta implement\u00e1l\u00e1sa IntelliSense seg\u00edts\u00e9g\u00e9vel</p> <p>Fussuk \u00e1t a gener\u00e1lt k\u00f3dot, ami sz\u00e9pen kommentezett. A pattern l\u00e9nyege, hogy a nem menedzselt er\u0151forr\u00e1sokat (unmanaged objects / resources) sz\u00fcks\u00e9ges felszabad\u00edtanunk, amit a <code>Dispose</code> met\u00f3dusokban, illetve menedzselt k\u00f3d eset\u00e9n a kommentekkel kijel\u00f6lt helyen \u00e9rdemes elv\u00e9gezn\u00fcnk. K\u00e9sz\u00edts\u00fck el az id\u0151m\u00e9r\u0151 mechanizmust!</p> <pre><code>protected virtual void Dispose(bool disposing)\n{\n    if (!disposedValue)\n    {\n        if (disposing)\n        {\n            Stopwatch.Stop();\n            Console.WriteLine(\n                $\"Task {Title} completed in { Stopwatch.ElapsedMilliseconds} ms \"+\n                $\"at { DateTime.Now}\");\n        }\n        disposedValue = true;\n    }\n}\n</code></pre> <p>Csak fel\u00fcgyelt er\u0151forr\u00e1sokkal (managed objects) dolgozunk, \u00edgy csak egy helyen kellett a le\u00e1ll\u00edt\u00f3 logik\u00e1t megadnunk.</p> <p>Az <code>IDisposable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 elemekkel haszn\u00e1lhatjuk a <code>using</code> konstrukci\u00f3t:</p> <pre><code>using (new StopwatchWrapper(\"Fib 1-15\"))\n{\n    foreach (var n in Enumerable.Range(1, 15))\n    {\n        Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n    }\n}\n</code></pre> <p>Teh\u00e1t a <code>using</code> haszn\u00e1lat\u00e1val a blokk elej\u00e9t \u00e9s v\u00e9g\u00e9t tudjuk kezelni. Gyakorlatilag egy <code>try-finally</code>-val ekvivalens a minta, a <code>finally</code>-ben megh\u00edv\u00f3dik a <code>Dispose</code> met\u00f3dus.</p> <p>Jelenleg csak a folyamat v\u00e9g\u00e9n kapunk jelent\u00e9st az eltelt id\u0151r\u0151l. R\u00e9szid\u0151k ki\u00edr\u00e1s\u00e1hoz k\u00e9sz\u00edts\u00fcnk egy seg\u00e9df\u00fcggv\u00e9nyt a <code>StopwatchWrapper</code>-be:</p> <pre><code>public void Snapshot(string text) =&gt;\n    Console.WriteLine(\n        $\"Task {Title} snapshot {text}: {Stopwatch.ElapsedMilliseconds} ms\"\n    );\n</code></pre> <p>H\u00edvjuk meg a <code>foreach</code> ciklusb\u00f3l:</p> <pre><code>using (var sw = new StopwatchWrapper(\"Fib 1-15\"))\n{\n    foreach (var n in Enumerable.Range(1, 15))\n    {\n        sw.Snapshot(n.ToString());\n        Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n    }\n}\n</code></pre>"},{"location":"seminar/05-aspnetcore1/chapter5/","title":"ASP.NET Core alapszolg\u00e1ltat\u00e1sok","text":""},{"location":"seminar/05-aspnetcore1/chapter5/#projekt-letrehozasa","title":"Projekt l\u00e9trehoz\u00e1sa","text":"<p>Ezen a gyakorlaton nem a be\u00e9p\u00edtett API projektsablont fogjuk felhaszn\u00e1lni, hanem egy \u00fcres ASP.NET Core projektb\u0151l pr\u00f3b\u00e1ljuk fel\u00e9p\u00edteni \u00e9s meg\u00e9rteni azt a funkcionalit\u00e1st, amit egy\u00e9bk\u00e9nt az el\u0151re elk\u00e9sz\u00edtett VS projektsablonok adn\u00e1nak k\u00e9szen a kez\u00fcnkbe.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#generalas","title":"Gener\u00e1l\u00e1s","text":"<p>Hozzunk l\u00e9tre a Visual Studioban egy \u00faj, C# nyelv\u0171 projektet az ASP.NET Core Empty sablonnal, a neve legyen HelloAspNetCore. Megc\u00e9lzott keretrendszerk\u00e9nt adjuk meg a .NET 8-ot. Minden extra opci\u00f3 legyen kikapcsolva, a docker \u00e9s a HTTPS is.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#kitero-nuget-es-a-keretrendszert-alkoto-komponensek-helye","title":"Kit\u00e9r\u0151: NuGet \u00e9s a keretrendszert alkot\u00f3 komponensek helye","text":"<p>A .NET 8 \u00e9s az ASP.NET Core gyakorlatilag teljes m\u00e9rt\u00e9kben publikusan el\u00e9rhet\u0151 komponensekb\u0151l \u00e9p\u00fcl fel. A komponensek kezel\u00e9s\u00e9nek infrastrukt\u00far\u00e1j\u00e1t a NuGet csomagkezel\u0151 szolg\u00e1ltatja. A csomagkezel\u0151n kereszt\u00fcl el\u00e9rhet\u0151 csomagokat a nuget.org list\u00e1zza \u00e9s ig\u00e9ny eset\u00e9n a NuGet kliens, illetve a .NET Core eszk\u00f6z\u00f6k (dotnet.exe, Visual Studio) is innen t\u00f6ltik le. A fejleszt\u0151knek teljes\u00edtm\u00e9nyszempontb\u00f3l nem \u00e9rn\u00e9 meg az alap keretrendszert alkot\u00f3 csomagokat \u00e1lland\u00f3an let\u00f6lt\u00f6getni, \u00edgy a klasszikus keretrendszerekhez hasonl\u00f3an a .NET 8 telep\u00edt\u00e9sekor egy k\u00f6nyvt\u00e1rba (Windows-on ide: C:\\Program Files (x86)\\dotnet, illetve C:\\Program Files\\dotnet) beker\u00fclnek az alap keretrendszert alkot\u00f3 komponensek - l\u00e9nyeg\u00e9ben egy csom\u00f3 .dll k\u00fcl\u00f6nb\u00f6z\u0151 alk\u00f6nyvt\u00e1rakban. A futtat\u00e1shoz sz\u00fcks\u00e9ges szerelv\u00e9nyek a shared alk\u00f6nyvt\u00e1rba telep\u00fclnek, ezek az \u00fan. Shared Framework-\u00f6k. A g\u00e9pen fut\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 .NET Core/8 alkalmaz\u00e1sok k\u00f6z\u00f6sen haszn\u00e1lhatj\u00e1k ezeket. A fejleszt\u00e9shez az alapvet\u0151 f\u00fcgg\u0151s\u00e9geket a packs alk\u00f6nyvt\u00e1rb\u00f3l hivatkozhatjuk.</p> <p>Nem fejleszt\u0151i, p\u00e9ld\u00e1ul v\u00e9gfelhaszn\u00e1l\u00f3i vagy szerver k\u00f6rnyezetben- ahol nem is biztos, hogy fel van telep\u00edtve az SDK, nem felt\u00e9tlen\u00fcl \u00edgy biztos\u00edtjuk a f\u00fcgg\u0151s\u00e9geket, de ennek a boncolgat\u00e1sa nem t\u00e9m\u00e1ja ennek a gyakorlatnak.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#eredmeny","title":"Eredm\u00e9ny","text":"<p>N\u00e9zz\u00fck meg, milyen projekt gener\u00e1l\u00f3dott:</p> <ul> <li>.csproj: (menu:Projekten jobb gomb[Edit Project File]) a projekt ford\u00edt\u00e1s\u00e1hoz sz\u00fcks\u00e9ges be\u00e1ll\u00edt\u00e1sokat tartalmazza. El\u0151z\u0151 verzi\u00f3khoz k\u00e9pest itt er\u0151sen \u00e9p\u00edtenek az alap\u00e9rtelmezett \u00e9rt\u00e9kekre, hogy min\u00e9l karcs\u00fabbra tudj\u00e1k fogni ezt az \u00e1llom\u00e1nyt.<ul> <li>Project SDK: projekt t\u00edpusa (Microsoft.NET.Sdk.Web), az eszk\u00f6zk\u00e9szlet funkci\u00f3it szab\u00e1lyozza, meghat\u00e1rozza a futtat\u00e1shoz haszn\u00e1latos shared framework-\u00f6t, illetve meghat\u00e1rozza a megc\u00e9lzott keretrendszert is(l\u00e1sd lentebb).</li> <li>TargetFramework: net8.0. Ezzel jelezz\u00fck, hogy .NET 8-os API-kat haszn\u00e1lunk az alkalmaz\u00e1sban.</li> </ul> </li> <li>Connected Services: k\u00fcls\u0151 szolg\u00e1ltat\u00e1sok, amiket haszn\u00e1l a projekt\u00fcnk, most nincs ilyen\u00fcnk.</li> <li>Dependencies: a keretrendszer alapf\u00fcgg\u0151s\u00e9gei \u00e9s egy\u00e9b NuGet csomagf\u00fcgg\u0151s\u00e9gek szerepelnek itt. Egyel\u0151re csak keretrendszer f\u00fcgg\u0151s\u00e9geink vannak.<ul> <li>Frameworks: k\u00e9t alk\u00f6nyvt\u00e1rat (Microsoft.AspNetCore.App, Microsoft.NETCore.App) hivatkozunk a .NET SDK packs alk\u00f6nyvt\u00e1r\u00e1b\u00f3l. Ezek a f\u00fcgg\u0151s\u00e9gek k\u00fcls\u0151 NuGet csomagk\u00e9nt is el\u00e9rhet\u0151ek, de ahogy fentebb jelezt\u00fck, nem \u00e9rdemes \u00fagy hivatkozni \u0151ket.</li> <li>Analyzers: speci\u00e1lis komponensek, amik k\u00f3danal\u00edzist v\u00e9gzenek, de egy\u00e9bk\u00e9nt ugyan\u00fagy k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9gk\u00e9nt (NuGet csomag) kezelhetj\u00fck \u0151ket. Ha kibontjuk az egyes analiz\u00e1torokat, akkor l\u00e1thatjuk, hogy miket ellen\u0151riznek. Ezek a f\u00fcgg\u0151s\u00e9gek a fut\u00e1shoz nem sz\u00fcks\u00e9gesek.</li> </ul> </li> <li>Properties: duplakattra el\u0151j\u00f6n a klasszikus projektbe\u00e1ll\u00edt\u00f3 fel\u00fclet.<ul> <li>launchSettings.json: a k\u00fcl\u00f6nb\u00f6z\u0151 ind\u00edt\u00e1si konfigur\u00e1ci\u00f3khoz tartoz\u00f3 be\u00e1ll\u00edt\u00e1sok (l\u00e1sd k\u00e9s\u0151bb).</li> </ul> </li> <li>appsettings.json: fut\u00e1sidej\u0171 be\u00e1ll\u00edt\u00e1sok helye. Kibonthat\u00f3, kibontva a k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f6rnyezetekre specifikus konfigur\u00e1ci\u00f3k tal\u00e1lhat\u00f3ak (l\u00e1sd k\u00e9s\u0151bb).</li> </ul>"},{"location":"seminar/05-aspnetcore1/chapter5/#legfelso-szintu-kod-minimal-api","title":"Legfels\u0151 szint\u0171 k\u00f3d, minim\u00e1l API","text":"<p>Az el\u0151z\u0151 ASP.NET verzi\u00f3val ellent\u00e9tben, itt m\u00e1r az ASP.NET Core alkalmaz\u00e1sok a sz\u00fclet\u00e9s\u00fckt\u0151l fogva klasszikus konzolos alkalmaz\u00e1sk\u00e9nt is ind\u00edthat\u00f3k, ekkor az alkalmaz\u00e1s alap\u00e9rtelmezett bel\u00e9p\u00e9si pontja a legfels\u0151 szint\u0171 k\u00f3d (esetleg a <code>Main</code> met\u00f3dus). Az ASP.NET Core 6-os verzi\u00f3ban megjelent \u00fan. minim\u00e1l API seg\u00edts\u00e9g\u00e9vel m\u00e1r nem csak a konfigur\u00e1ci\u00f3t tartalmazhatja ez a k\u00f3d, hanem (egyszer\u0171) kiszolg\u00e1l\u00f3 logik\u00e1t is.</p> <p>Eset\u00fcnkben a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket v\u00e9gzi el a gener\u00e1lt k\u00f3d:</p> <ul> <li>a hosztol\u00e1si k\u00f6rnyezetet \u00e9s az alkalmaz\u00e1s alapszolg\u00e1ltat\u00e1sait konfigur\u00e1l\u00f3 builder objektum \u00f6ssze\u00e1ll\u00edt\u00e1sa (<code>CreateBuilder</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> <li>a builder objektum alapj\u00e1n a hosztol\u00e1si k\u00f6rnyezet \u00e9s az alkalmaz\u00e1s szerkezet\u00e9nek fel\u00e1ll\u00edt\u00e1sa (<code>Build</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> <li>v\u00e9gpontot defini\u00e1l az alkalmaz\u00e1s gy\u00f6k\u00e9rc\u00edm\u00e9re minim\u00e1l API seg\u00edts\u00e9g\u00e9vel. A v\u00e9gpont a megh\u00edv\u00e1s\u00e1ra a Hello World! sz\u00f6veget adja vissza.</li> <li>a fel\u00e1ll\u00edtott szerkezet futtat\u00e1sa (<code>Run</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> </ul> <p>Az igaz\u00e1n munk\u00e1s feladat a builder megalkot\u00e1sa lenne, igen sok mindent lehetne benne konfigur\u00e1lni, ez a k\u00f3dban a <code>CreateBuilder</code>-ben t\u00f6rt\u00e9nik, ami egy szokv\u00e1nyos, az eg\u00e9sz webalkalmaz\u00e1s m\u0171k\u00f6d\u00e9si k\u00f6rnyezet\u00e9t meghat\u00e1roz\u00f3 be\u00e1ll\u00edt\u00e1sokat elv\u00e9gz\u0151 kiindul\u00f3 buildert \u00e1ll\u00edt el\u0151. Ha valamit a kiindul\u00f3 builderben megadott\u00f3l elt\u00e9r\u0151en szeretn\u00e9nk, vagy \u00faj be\u00e1ll\u00edt\u00e1sokat adn\u00e1nk meg, akkor a kiindul\u00f3 builder objektumon t\u00f6rt\u00e9n\u0151 f\u00fcggv\u00e9nyh\u00edv\u00e1sokkal tehetn\u00e9nk meg.</p> <p>Mivel a kiindul\u00f3 builderen nem v\u00e9gz\u00fcnk semmilyen ut\u00f3lagos konfigur\u00e1l\u00e1st, \u00edgy ak\u00e1r egy utas\u00edt\u00e1ssal is megkaphatn\u00e1nk az alkalmaz\u00e1sszerkezetet reprezent\u00e1l\u00f3 <code>WebApplication</code> p\u00e9ld\u00e1nyt.</p> <pre><code>//var builder = WebApplication.CreateBuilder(args);\n//var app = builder.Build();\n\nvar app = WebApplication.Create();\n</code></pre>"},{"location":"seminar/05-aspnetcore1/chapter5/#vegrehajtasi-pipeline-middleware-ek","title":"V\u00e9grehajt\u00e1si pipeline, middleware-ek","text":"<p>Az ASP.NET Core-ban egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa \u00fagy t\u00f6rt\u00e9nik, hogy a k\u00e9r\u00e9s egy cs\u0151vezet\u00e9ken halad (v\u00e9gig). A cs\u0151vezet\u00e9k middleware-ekb\u0151l (MW) \u00e1ll. Az al\u00e1bbi \u00e1bra szeml\u00e9lteti a middleware pipeline m\u0171k\u00f6d\u00e9s\u00e9t.</p> <p> ASP.NET Core pipeline Forr\u00e1s</p> <p>Az ASP.NET Core alkalmaz\u00e1s alapszerkezete, hogy a befut\u00f3 HTTP k\u00e9r\u00e9s (v\u00e9gig)fusson a middleware-ekb\u0151l \u00e1ll\u00f3 cs\u0151vezet\u00e9ken \u00e9s valamelyik (alapesetben az utols\u00f3) middleware el\u0151\u00e1ll\u00edtja a v\u00e1laszt, ami visszair\u00e1nyban halad v\u00e9gig a cs\u0151vezet\u00e9ken. A cs\u0151vezet\u00e9k adja teh\u00e1t az alkalmaz\u00e1s szerkezet\u00e9t. A kiindul\u00f3 cs\u0151vezet\u00e9ket a <code>WebApplication.Create</code> vagy a <code>builder.Build</code> \u00e9p\u00edti fel, ezt ut\u00e1na <code>app.UseX</code> (X= MW neve) h\u00edv\u00e1sokkal testreszabhatjuk, kieg\u00e9sz\u00edthetj\u00fck.</p> <p>Eset\u00fcnkben a kiindul\u00f3 cs\u0151vezet\u00e9kben h\u00e1rom MW van:</p> <ul> <li>kiv\u00e9telkezel\u0151 middleware (<code>UseDeveloperExceptionPage</code>), ami az \u0151t k\u00f6vet\u0151 middleware-ek hib\u00e1it k\u00e9pes elkapni \u00e9s ennek megfelel\u0151en egy a fejleszt\u0151knek sz\u00f3l\u00f3 hibaoldalt jelen\u00edt meg. Ez csak opcion\u00e1lisan ker\u00fcl beregisztr\u00e1l\u00e1sra att\u00f3l f\u00fcgg\u0151en, hogy most \u00e9ppen Development m\u00f3dban futtatjuk-e az alkalmaz\u00e1st vagy sem. (l\u00e1sd k\u00e9s\u0151bb)</li> <li>routing middleware (<code>UseRouting</code>), aminek a feladata, hogy a bej\u00f6v\u0151 k\u00e9r\u00e9s \u00e9s a v\u00e9gpontok (l\u00e1sd lentebb) \u00e1ltal adott inform\u00e1ci\u00f3k alapj\u00e1n kital\u00e1lja, hogy melyik endpoint fel\u00e9 tov\u00e1bb\u00edtsa a bej\u00f6v\u0151 k\u00e9r\u00e9st.</li> <li>v\u00e9gpontok middleware (<code>UseEndpoints</code>), ami a kiv\u00e1lasztott endpoint defin\u00edci\u00f3j\u00e1ban megadott logika t\u00e9nyleges lefuttat\u00e1s\u00e1\u00e9rt felel</li> </ul> <p>P\u00e9lda middleware regisztr\u00e1ci\u00f3ra</p> <p>A kiindul\u00f3 cs\u0151vezet\u00e9k regisztr\u00e1l\u00e1s\u00e1t megfigyelhetj\u00fck a <code>WebApplicationBuilder</code> forr\u00e1sk\u00f3dj\u00e1ban - keress\u00fck az <code>app.UseX</code> sorokat.</p> <p>A kiindul\u00f3 projekt nem v\u00e1ltoztat a kiindul\u00f3 cs\u0151vezet\u00e9ken, csak egy v\u00e9gpont defin\u00edci\u00f3t ad meg (<code>app.MapGet</code> sor).</p> <p>Fontos a sorrend</p> <p>A middleware-ek sorrendje fontos. Ha nem megfelel\u0151 sorrendben regisztr\u00e1ljuk \u0151ket, nem megfelel\u0151 m\u0171k\u00f6d\u00e9s lehet az eredm\u00e9ny. A dokument\u00e1ci\u00f3 \u00e1ltal\u00e1ban tartalmazza, hogy melyik middleware hova illeszthet\u0151 be.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#hosztolasi-lehetosegek-a-fejlesztoi-gepen","title":"Hosztol\u00e1si lehet\u0151s\u00e9gek a fejleszt\u0151i g\u00e9pen","text":"<p>Pr\u00f3b\u00e1ljuk ki IIS Expressen kereszt\u00fcl futtatva, azaz a VS-ben az ind\u00edt\u00f3gomb (z\u00f6ld ny\u00edl) mellett az IIS Express felirat legyen! Ha nem ez a felirat van, \u00e1ll\u00edtsuk \u00e1t az ind\u00edt\u00f3gomb jobb sz\u00e9l\u00e9n l\u00e9v\u0151 men\u00fct lenyitva.</p> <p>K\u00e9t dolog is t\u00f6rt\u00e9nik: az alkalmaz\u00e1sunk IIS Express webkiszolg\u00e1l\u00f3ban hosztolva kezd futni \u00e9s egy b\u00f6ng\u00e9sz\u0151 is elindul, hogy ki tudjuk pr\u00f3b\u00e1lni. Figyelj\u00fck meg az \u00e9rtes\u00edt\u00e9si ter\u00fcleten (az \u00f3ra mellett) megjelen\u0151 IIS Express ikont, \u00e9s azon jobbklikkelve a hosztolt alkalmaz\u00e1s c\u00edm\u00e9t (menu:jobbklikk[Show All Applications]).</p> <p>A b\u00f6ng\u00e9sz\u0151 az alkalmaz\u00e1s gy\u00f6k\u00e9rc\u00edm\u00e9re navig\u00e1l (a c\u00edm csak localhost:port-b\u00f3l \u00e1ll), \u00edgy a Hello World! sz\u00f6veg jelenik meg.</p> <p>B\u00f6ng\u00e9sz\u0151 v\u00e1laszt\u00e1sa</p> <p>A ind\u00edt\u00f3gomb leg\u00f6rd\u00fcl\u0151j\u00e9ben a b\u00f6ng\u00e9sz\u0151 t\u00edpus\u00e1t is \u00e1ll\u00edthatjuk.</p> <p>IIS Express</p> <p>Az IIS Express a Microsoft webszerver\u00e9nek (IIS) fejleszt\u0151i c\u00e9lra optimaliz\u00e1lt v\u00e1ltozata. Alapvet\u0151en csak ugyanarr\u00f3l a g\u00e9pr\u0151l \u00e9rkez\u0151 (localhost) k\u00e9r\u00e9seket szolg\u00e1l ki.</p> <p>A m\u00e1sik lehet\u0151s\u00e9g, ha k\u00f6zvetlen\u00fcl a konzolos alkalmaz\u00e1st szeretn\u00e9nk futtatni, akkor ezt az ind\u00edt\u00f3gombot lenyitva a projekt nev\u00e9t kiv\u00e1lasztva tehetj\u00fck meg. Ebben az esetben egy be\u00e1gyazott webszerverhez (Kestrel) futnak be a k\u00e9r\u00e9sek. Pr\u00f3b\u00e1ljuk ki a Kestrelt k\u00f6zvetlen\u00fcl futtatva!</p> <p>Most is k\u00e9t dolog t\u00f6rt\u00e9nik: az alkalmaz\u00e1sunk konzolos alkalmaz\u00e1sk\u00e9nt kezd futni, illetve az el\u0151z\u0151 esethez hasonl\u00f3an a b\u00f6ng\u00e9sz\u0151 is elindul. Figyelj\u00fck meg a konzolban megjelen\u0151 napl\u00f3\u00fczeneteket.</p> <p>\u00c9les hosting</p> <p>B\u00e1r ezek a hosztol\u00e1si opci\u00f3k fejleszt\u0151i k\u00f6rnyezetben nagyon k\u00e9nyelmesek, \u00e9rdemes \u00e1ttekinteni az \u00e9les hosztol\u00e1si opci\u00f3kat itt. A Kestrel ugyan jelenleg m\u00e1r alkalmas arra, hogy kipublik\u00e1ljuk k\u00f6zvetlen\u00fcl a vil\u00e1gh\u00e1l\u00f3ra, de mivel nem rendelkezik olyan sz\u00e9les konfigur\u00e1ci\u00f3s \u00e9s biztons\u00e1gi be\u00e1ll\u00edt\u00e1sokkal, mint a m\u00e1r bej\u00e1ratott webszerverek, \u00edgy \u00e9rdemes lehet egy ilyen webszervert a Kestrel el\u00e9 rakni proxy gyan\u00e1nt, p\u00e9ld\u00e1ul az IIS-t vagy nginx-et.</p> <p>Rakjunk most a kiszolg\u00e1l\u00f3 logik\u00e1nkba egy kiv\u00e9tel dob\u00e1st a ki\u00edr\u00e1s helyett, hogy kipr\u00f3b\u00e1ljuk a hibakezel\u0151 MW-t.</p> <pre><code>app.MapGet(\"/\", () =&gt;\n{\n    throw new Exception(\"hiba\");\n    //return \"Hello World!\"\n}\n);\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki debugger n\u00e9lk\u00fcl (Ctrl+F5)!</p> <p>L\u00e1thatjuk, hogy a kiv\u00e9telt a hibakezel\u0151 middleware elkapja \u00e9s egy hibaoldalt jelen\u00edt\u00fcnk meg, s\u0151t m\u00e9g a konzolon is megjelenik napl\u00f3bejegyz\u00e9sk\u00e9nt.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#alkalmazasbeallitasok-vs-inditasi-profilok","title":"Alkalmaz\u00e1sbe\u00e1ll\u00edt\u00e1sok vs. ind\u00edt\u00e1si profilok","text":"<p>Figyelj\u00fck meg, hogy most Development konfigur\u00e1ci\u00f3ban fut az alkalmaz\u00e1s (konzolban a Hosting environment kezdet\u0171 sor). Ezt az inform\u00e1ci\u00f3t a keretrendszer k\u00f6rnyezeti v\u00e1ltoz\u00f3 alapj\u00e1n \u00e1llap\u00edtja meg. Ha a lauchSettings.json \u00e1llom\u00e1nyt megn\u00e9zz\u00fck, akkor l\u00e1thatjuk, hogy az <code>ASPNETCORE_ENVIRONMENT</code> k\u00f6rnyezeti v\u00e1ltoz\u00f3 <code>Development</code>-re van \u00e1ll\u00edtva.</p> <p>Pr\u00f3b\u00e1ljuk ki Visual Studio-n k\u00edv\u00fclr\u0151l futtatni. menu:Projekten jobb klikk[Open Folder in File Explorer]. Ezut\u00e1n a c\u00edmsorba mindent kijel\u00f6lve <code>cmd</code> + Enter, a parancssorba <code>dotnet run</code>.</p> <p>Ugyan\u00fagy fog indulni, mint VS-b\u0151l, mert az \u00fajabb .NET verzi\u00f3kban m\u00e1r a dotnet run is figyelembe veszi a launchSettings.json-t. A b\u00f6ng\u00e9sz\u0151t magunknak kell ind\u00edtani (most m\u00e9g) \u00e9s elnavig\u00e1lni a napl\u00f3ban szerepl\u0151 c\u00edmre (Now listening on: http://localhost:port \u00fczenetet keress\u00fcnk).</p> <p>Ha nem akarjuk ezt, akkor a <code>--no-launch-profile</code> kapcsol\u00f3t haszn\u00e1lhatjuk a dotnet run futtat\u00e1s\u00e1n\u00e1l.</p> <p>Most az alkalmaz\u00e1sunk Production m\u00f3dban indul el, \u00e9s ha a localhost:5000-es oldalt megnyitjuk a b\u00f6ng\u00e9sz\u0151ben, akkor nem kapunk hibaoldalt, de a konzolon tov\u00e1bbra is megjelenik a napl\u00f3bejegyz\u00e9s.</p> <p>Le\u00e1ll\u00edt\u00e1s</p> <p>A dotnet run fut\u00e1s\u00e1t Ctrl+C-vel \u00e1ll\u00edthatjuk le.</p> <p>K\u00f6rnyezeti v\u00e1ltoz\u00f3k felv\u00e9tele</p> <p>A konzolban a <code>setx ENV_NAME Value</code> utas\u00edt\u00e1ssal tudunk felvenni k\u00f6rnyezeti v\u00e1ltoz\u00f3t \u00fagy, hogy az permanensen megmaradjon, \u00e9s ne csak a konzolablak bez\u00e1r\u00e1s\u00e1ig maradjon \u00e9rv\u00e9nyben. (Admin/nem admin, illetve powershell konzolok k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek)</p> <p>Az eredeti logik\u00e1nkat kommentezz\u00fck vissza.</p> <pre><code>app.MapGet(\"/\", () =&gt;\n{\n    //throw new Exception(\"hiba\");\n    return \"Hello World!\";\n});\n</code></pre> <p>Az alkalmaz\u00e1s sz\u00e1m\u00e1ra a k\u00fcl\u00f6nb\u00f6z\u0151 be\u00e1ll\u00edt\u00e1sokat JSON \u00e1llom\u00e1nyokban t\u00e1rolhatjuk, amelyek ak\u00e1r k\u00f6rnyezetenk\u00e9nt k\u00fcl\u00f6nb\u00f6z\u0151ek is lehetnek. A gener\u00e1lt projekt\u00fcnkben ez az appsettings.json, n\u00e9zz\u00fcnk bele - f\u0151leg napl\u00f3z\u00e1si be\u00e1ll\u00edt\u00e1sok vannak benne. A f\u00e1jl a Solution Explorer ablakban kinyithat\u00f3, alatta megtal\u00e1ljuk az appsettings.Development.json-t. Ebben a Development nev\u0171 konfigur\u00e1ci\u00f3ra vonatkoz\u00f3 be\u00e1ll\u00edt\u00e1sok vannak. Alap\u00e9rtelmez\u00e9sben az appsettings.\\&lt;ind\u00edt\u00e1si konfigur\u00e1ci\u00f3 neve&gt;.json be\u00e1ll\u00edt\u00e1sai jutnak \u00e9rv\u00e9nyre, fel\u00fcl\u00edrva a sima appsettings.json egyez\u0151 \u00e9rt\u00e9keit (a pontosabb logik\u00e1t l\u00e1sd lentebb).</p> <p>\u00c1ll\u00edtsunk Development m\u00f3dban r\u00e9szletesebb napl\u00f3z\u00e1st. Az appsettings.Development.json-ben minden napl\u00f3z\u00e1si szintet \u00edrjunk <code>Debug</code>-ra.</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Debug\"\n    }\n  }\n}\n</code></pre> <p>Napl\u00f3z\u00e1si szintek</p> <p>A napl\u00f3z\u00e1si szintek sorrendje itt tal\u00e1lhat\u00f3.</p> <p>Pr\u00f3b\u00e1ljuk ki, hogy \u00edgy az alkalmaz\u00e1sunk fut\u00e1sakor minden b\u00f6ng\u00e9sz\u0151beli friss\u00edt\u00e9s\u00fcnk (F5) megjelenik a konzolon.</p> <p>VS-b\u0151l is tudjuk \u00e1ll\u00edtani a k\u00f6rnyezeti v\u00e1ltoz\u00f3kat, nem kell a launchSettings.json-ben k\u00e9zzel var\u00e1zsolni. A projekt tulajdons\u00e1gok Debug lapj\u00e1n az Open debug launch profiles UI sz\u00f6vegre kattintva egy dial\u00f3gusablak ugrik fel, itt tudunk \u00faj ind\u00edt\u00e1si profilt megadni, illetve a megl\u00e9v\u0151eket m\u00f3dos\u00edtani. V\u00e1lasszuk ki az aktu\u00e1lisan haszn\u00e1lt profilunkat (projektneves), majd \u00edrjuk \u00e1t az ASPNETCORE_ENVIRONMENT k\u00f6rnyezeti v\u00e1ltoz\u00f3 \u00e9rt\u00e9k\u00e9t az Environment Variables r\u00e9szen mondjuk Production-re.</p> <p>Ind\u00edtsuk ezzel a profillal \u00e9s figyelj\u00fck meg, hogy m\u00e1r nem jelennek meg az egyes k\u00e9r\u00e9sek a napl\u00f3ban, b\u00e1rhogy is friss\u00edtgetj\u00fck a b\u00f6ng\u00e9sz\u0151t. Oka: nincs appsettings.Production.json, \u00edgy az \u00e1ltal\u00e1nos appsettings.json jut \u00e9rv\u00e9nyre.</p> <p>Konfigur\u00e1ci\u00f3k forr\u00e1sa</p> <p>Sz\u00e1mos forr\u00e1sb\u00f3l lehet konfigur\u00e1ci\u00f3t megadni: parancssor, k\u00f6rnyezeti v\u00e1ltoz\u00f3, f\u00e1jl (ezt l\u00e1ttuk most), felh\u0151 (Azure Key Vault) stb. Ezek k\u00f6z\u00fcl t\u00f6bbet is haszn\u00e1lhatunk egyszerre, a k\u00fcl\u00f6nb\u00f6z\u0151 forr\u00e1sok konfigur\u00e1ci\u00f3ja a k\u00f6z\u00f6s kulcsok ment\u00e9n \u00f6sszef\u00e9s\u00fcl\u0151dik. A forr\u00e1sok (configuration provider-ek) k\u00f6z\u00f6tt sorrendet adhatunk meg, amikor regisztr\u00e1ljuk \u0151ket, a legutols\u00f3k\u00e9nt regisztr\u00e1lt provider konfigur\u00e1ci\u00f3ja a leger\u0151sebb. Az alap\u00e9rtelmezett provider-ek regisztr\u00e1ci\u00f3j\u00e1t elint\u00e9zi a kor\u00e1bban l\u00e1tott kiindul\u00f3 builder.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#statikus-fajl-mw","title":"Statikus f\u00e1jl MW","text":"<p>Hozzunk l\u00e9tre a projekt gy\u00f6ker\u00e9be egy <code>wwwroot</code> nev\u0171 mapp\u00e1t (menu:jobbklikk a projekten[Add &gt; New Folder]) \u00e9s tegy\u00fcnk egy k\u00e9pf\u00e1jlt bele. (Ellophatjuk pl. a http://www.bme.hu honlap bal fels\u0151 sark\u00e1b\u00f3l a logo-t)</p> <p>A statikus f\u00e1jlkezel\u00e9st a teljes modularit\u00e1s jegy\u00e9ben egy k\u00fcl\u00f6n middleware-k\u00e9nt implement\u00e1lt\u00e1k a Microsoft.AspNetCore.StaticFiles oszt\u00e1lyk\u00f6nyvt\u00e1rban (az AspNetCore.App m\u00e1r f\u00fcgg\u0151s\u00e9gk\u00e9nt tartalmazza, \u00edgy nem kell k\u00fcl\u00f6n hivatkoznunk), csak hozz\u00e1 kell adnunk a pipeline-hoz.</p> <pre><code>app.UseStaticFiles();\napp.MapGet(\"/\", () =&gt; \"Hello World!\");\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>L\u00e1thatjuk hogy a localhost:port c\u00edmen m\u00e9g mindig a Hello World! sz\u00f6veg t\u0171nik fel, de amint a localhost:port/[k\u00e9pf\u00e1jln\u00e9v]-vel pr\u00f3b\u00e1lkozunk, a k\u00e9p t\u00f6lt\u0151dik be. A static file MW megszak\u00edtja a pipeline fut\u00e1s\u00e1t, ha egy \u00e1ltala ismert f\u00e1jlt\u00edpusra hivatkozunk, egy\u00e9bk\u00e9nt tov\u00e1bbh\u00edv a k\u00f6vetkez\u0151 MW-be. Az ilyen MW-eket \u00fan. termin\u00e1l\u00f3 MW-eknek h\u00edvjuk.</p> <p>Breakpoint a lambd\u00e1ban</p> <p>Ezt az egysoros endpoint logik\u00e1ra tett t\u00f6r\u00e9sponttal is szeml\u00e9ltethetj\u00fck. Figyelj\u00fcnk arra, hogy csak a Hello World! sz\u00f6vegre ker\u00fclj\u00f6n a t\u00f6r\u00e9spont \u00e9s ne az eg\u00e9sz <code>MapGet</code> sorra, illetve csak akkor n\u00e9zz\u00fck, hogy mi fut le, amikor a k\u00e9p URL-re h\u00edvunk.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#web-api","title":"Web API","text":"<p>Minden API-n\u00e1l nagyon magas szinten az a c\u00e9l, hogy egy k\u00e9r\u00e9s hat\u00e1s\u00e1ra egy szerveroldali k\u00f3dr\u00e9szlet megh\u00edv\u00f3djon. ASP.NET Core-ban a Minimap API megk\u00f6zel\u00edt\u00e9s mellett alkalmazhat\u00f3 az MVC keretrendszer is, ahol a k\u00f3dr\u00e9szleteket f\u00fcggv\u00e9nyekbe \u00edrjuk, a f\u00fcggv\u00e9nyek pedig \u00fan. kontrollerek-be ker\u00fclnek. Egy controller \u00e1ltal\u00e1ban az egy er\u0151forr\u00e1st\u00edpushoz kapcsol\u00f3d\u00f3 m\u0171veleteket fogja \u00f6ssze. \u00d6sszess\u00e9g\u00e9ben teh\u00e1t a c\u00e9l, hogy a webes k\u00e9r\u00e9s hat\u00e1s\u00e1ra egy kontroller egy f\u00fcggv\u00e9nye megh\u00edv\u00f3djon.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#dummycontroller","title":"DummyController","text":"<p>Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t Controllers n\u00e9ven. A mapp\u00e1ba hozzunk l\u00e9tre egy kontrollert (menu:jobbklikk a Controllers mapp\u00e1n[Add &gt; Controller\u2026 &gt; a bal oldali f\u00e1ban Common &gt; API &gt; jobb oldalon API Controller with read/write actions]) <code>DummyController</code> n\u00e9ven. A gener\u00e1lt kontroller\u00fcnk a Microsoft.AspNetCore.Mvc.Core csomagban tal\u00e1lhat\u00f3 <code>ControllerBase</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik. (Ezt a csomagot sem kell feltenn\u00fcnk, mivel az AspNetCore.App f\u00fcgg\u0151s\u00e9ge)</p> <p>Adjuk hozz\u00e1 a szolg\u00e1ltat\u00e1sokhoz a kontrollert\u00e1mogat\u00e1s szolg\u00e1ltat\u00e1st, \u00e9s adjuk hozz\u00e1 a cs\u0151vezet\u00e9khez a kontroller kezel\u0151 MW-t. Az egysoros MW-t kommentezz\u00fck ki. \u00cdgy n\u00e9z ki a teljes legfels\u0151 szint\u0171 k\u00f3d:</p> <pre><code>var builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddControllers(); // (1)!\nvar app = builder.Build();\n/*var app = WebApplication.Create();*/ // (2)!\napp.UseStaticFiles();\n/*app.MapGet(\"/\", () =&gt; \"Hello World!\");*/ // (3)!\napp.MapControllers();\napp.Run();\n</code></pre> <ol> <li>Kontrollert\u00e1mogat\u00e1s szolg\u00e1ltat\u00e1s regisztr\u00e1l\u00e1sa</li> <li>Mivel kell a kiindul\u00f3 builder, \u00edgy ezt az egysoros app inicializ\u00e1ci\u00f3t nem alkalmazhatjuk</li> <li>Egysoros MW kikommentezve</li> </ol> <p>Pr\u00f3b\u00e1ljuk ki.</p> <p>Az alapoldal \u00fcres, viszont ha az <code>/api/Dummy</code> c\u00edmre h\u00edvunk, akkor megjelenik a <code>DummyController.Get</code> \u00e1ltal visszaadott \u00e9rt\u00e9k. A routing szab\u00e1lyok szab\u00e1lyozz\u00e1k, hogy hogyan jut el a HTTP k\u00e9r\u00e9s alapj\u00e1n a v\u00e9grehajt\u00e1s a f\u00fcggv\u00e9nyig. Itt attrib\u00fatum alap\u00fa routing-ot haszn\u00e1lunk, azaz a kontroller oszt\u00e1lyra \u00e9s a f\u00fcggv\u00e9nyeire biggyesztett attrib\u00fatumok hat\u00e1rozz\u00e1k meg, hogy a HTTP k\u00e9r\u00e9s adata (pl. URL) alapj\u00e1n melyik f\u00fcggv\u00e9ny h\u00edv\u00f3dik meg.</p> <p>A <code>DummyController</code> oszt\u00e1lyon l\u00e9v\u0151 <code>Route</code> attrib\u00fatum az <code>\"api/[controller]\"</code> \u00fatvonalat defini\u00e1lja, melyb\u0151l a <code>[controller]</code> \u00fagynevezett token, ami jelen esetben a controller nev\u00e9re cser\u00e9l\u0151dik. Ezzel \u00f6sszess\u00e9g\u00e9ben megadtuk, hogy az <code>api/Dummy</code> \u00fatvonal a <code>DummyController</code>-t v\u00e1lasztja ki, de m\u00e9g nem tudjuk, hogy a f\u00fcggv\u00e9nyei k\u00f6z\u00fcl melyiket kell megh\u00edvni - ez a f\u00fcggv\u00e9nyekre tett attrib\u00fatumokb\u00f3l k\u00f6vetkezik. A <code>Get</code> f\u00fcggv\u00e9nyen lev\u0151 <code>HttpGet</code> mutatja, hogy ez a f\u00fcggv\u00e9ny akkor h\u00edvand\u00f3, ha a GET k\u00e9r\u00e9s URL-je nem folytat\u00f3dik - ellent\u00e9tben a <code>Get(int id)</code> f\u00fcggv\u00e9nnyel, ami az URL-ben m\u00e9g egy tov\u00e1bbi szegmenst v\u00e1r (ez\u00e9rt van egy <code>\"{id}\"</code> param\u00e9ter megadva az attrib\u00fatum konstruktorban), amit az <code>id</code> nev\u0171 f\u00fcggv\u00e9nyparam\u00e9terk\u00e9nt haszn\u00e1l fel.</p> <p>Routing lehet\u0151s\u00e9gek</p> <p>Az API-t publik\u00e1l\u00f3 alkalmaz\u00e1sokn\u00e1l az attrib\u00fatum alap\u00fa routing az aj\u00e1nlott, de emellett vannak m\u00e1s megk\u00f6zel\u00edt\u00e9sek is, p\u00e9ld\u00e1ul Razor alap\u00fa weboldalakn\u00e1l konvenci\u00f3 alap\u00fa routing az aj\u00e1nlott. B\u0151vebben a t\u00e9mak\u00f6rr\u0151l \u00e1ltal\u00e1nosan itt, illetve specifikusan webes API-k vonatkoz\u00e1s\u00e1ban itt lehet olvasni. A dokument\u00e1ci\u00f3 mennyis\u00e9g\u00e9b\u0151l l\u00e1that\u00f3, hogy a routing alrendszer nagyon szofisztik\u00e1lt \u00e9s sokat tud, szerencs\u00e9re az alap m\u0171k\u00f6d\u00e9s el\u00e9g egyszer\u0171 \u00e9s gyorsan megszokhat\u00f3.</p> <p>Ha van id\u0151nk, pr\u00f3b\u00e1ljuk ki az <code>/api/Dummy/[eg\u00e9sz sz\u00e1m]</code> c\u00edmet is. A <code>Get(int id)</code> f\u00fcggv\u00e9ny k\u00f3dj\u00e1nak megfelel\u0151en, b\u00e1rmit adunk meg, az eredm\u00e9ny a value sz\u00f6veg lesz.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#tipusos-beallitasok-ioptionst","title":"T\u00edpusos be\u00e1ll\u00edt\u00e1sok, <code>IOptions&lt;T&gt;</code>","text":"<p>Fentebb l\u00e1ttuk, hogy a konfigur\u00e1ci\u00f3t ki tudtuk olvasni az <code>IConfiguration</code> interf\u00e9szen kereszt\u00fcl, de m\u00e9g jobb lenne, ha csoportos\u00edtva \u00e9s csoportonk\u00e9nt k\u00fcl\u00f6n C# oszt\u00e1lyokon kereszt\u00fcl l\u00e1tn\u00e1nk \u0151ket.</p> <p>B\u0151v\u00edts\u00fck az appsettings.json-t egy saj\u00e1t be\u00e1ll\u00edt\u00e1scsoporttal (DummySettings):</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\", // a sor v\u00e9g\u00e9re beker\u00fclt egy vessz\u0151\n  \"DummySettings\": {\n    \"DefaultString\": \"My Value\",\n    \"DefaultInt\": 23,\n    \"SuperSecret\":  \"Spoiler Alert!!!\"\n  }\n}\n</code></pre> <p>Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t <code>Options</code> n\u00e9ven. A mapp\u00e1ba hozzunk l\u00e9tre egy sima oszt\u00e1lyt <code>DummySettings</code> n\u00e9ven, a szerkezete feleljen meg a JSON-ben le\u00edrt be\u00e1ll\u00edt\u00e1scsoportnak:</p> <pre><code>public class DummySettings\n{\n    public string? DefaultString { get; set; }\n    public int DefaultInt { get; set; }\n    public string? SuperSecret { get; set; }\n}\n</code></pre> <p>Regisztr\u00e1ljuk szolg\u00e1ltat\u00e1sk\u00e9nt a <code>DummySettings</code> kezel\u00e9s\u00e9t, \u00e9s adjuk meg, hogy a p\u00e9ld\u00e1nyt mi alapj\u00e1n kell inicializ\u00e1lni - a konfigur\u00e1ci\u00f3 megfelel\u0151 szekci\u00f3j\u00e1ra hivatkozzunk:</p> <pre><code>builder.Services.Configure&lt;DummySettings&gt;(\n    builder.Configuration.GetSection(nameof(DummySettings)));\n</code></pre> <p>A <code>builder.Services</code>-ben regisztr\u00e1lt szolg\u00e1ltat\u00e1sok val\u00f3j\u00e1ban egy dependency injection (DI) kont\u00e9nerbe ker\u00fclnek regisztr\u00e1l\u00e1sra. Ez t\u00f6bbek k\u00f6z\u00f6tt lehet\u0151v\u00e9 teszi, hogy az alkalmaz\u00e1son bel\u00fcl konstruktorban param\u00e9terk\u00e9nt ig\u00e9nyelj\u00fck a szolg\u00e1ltat\u00e1st. A param\u00e9ter \u00e9rt\u00e9k\u00e9t a DI alrendszer automatikusan t\u00f6lti ki a regisztr\u00e1lt szolg\u00e1ltat\u00e1sok alapj\u00e1n.</p> <p>DI minta prefer\u00e1l\u00e1sa</p> <p>ASP.NET Core k\u00f6rnyezetben (is) t\u00f6rekedj\u00fcnk arra, hogy lehet\u0151leg minden oszt\u00e1lyunk minden f\u00fcgg\u0151s\u00e9g\u00e9t a DI minta szerint a DI kont\u00e9ner kezelje. Ez nagyban hozz\u00e1j\u00e1rul a komponensek k\u00f6z\u00f6tti laza csatol\u00e1s \u00e9s a jobb tesztelhet\u0151s\u00e9g el\u00e9r\u00e9s\u00e9hez. B\u0151vebb inform\u00e1ci\u00f3 az ASP.NET Core DI alrendszer\u00e9r\u0151l a dokument\u00e1ci\u00f3ban tal\u00e1lhat\u00f3.</p> <p>Ig\u00e9nyelj\u00fcnk <code>DummySettings</code>-t a <code>DummyController</code> konstruktorban:</p> <pre><code>private readonly DummySettings _options;\n\npublic DummyController(IOptions&lt;DummySettings&gt; options)\n{\n    options = options.Value;\n}\n</code></pre> <p>IOptions&lt;&gt; \u00e9s t\u00e1rsai</p> <p>L\u00e1that\u00f3, hogy a be\u00e1ll\u00edt\u00e1s <code>IOptions</code>-ba burkolva \u00e9rkezik. Vannak az <code>IOptions</code>-n\u00e1l okosabb burkol\u00f3k is (pl. <code>IOptionsMonitor</code>), ami p\u00e9ld\u00e1ul jelzi, ha megv\u00e1ltozik valamilyen be\u00e1ll\u00edt\u00e1s. B\u0151vebb inform\u00e1ci\u00f3 az <code>IOptions</code> \u00e9s t\u00e1rsair\u00f3l a hivatalos dokument\u00e1ci\u00f3ban tal\u00e1lhat\u00f3.</p> <p>Az eg\u00e9sz sz\u00e1mot v\u00e1r\u00f3 <code>Get</code> v\u00e1ltozatban haszn\u00e1ljuk fel az \u00e9rt\u00e9keket:</p> <pre><code>[HttpGet(\"{id}\")]\npublic string Get(int id)\n{\n    return id % 2 == 0\n        ? (options.DefaultString ?? \"value\")\n        : options.DefaultInt.ToString();\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki, hogy az <code>/api/Dummy/[p\u00e1ros sz\u00e1m]</code>, illetve <code>/api/Dummy/[p\u00e1ratlan sz\u00e1m]</code> v\u00e9gpontok megh\u00edv\u00e1sakor a megfelel\u0151 \u00e9rt\u00e9ket kapjuk-e vissza.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#user-secrets","title":"User Secrets","text":"<p>A projekt k\u00f6nyvt\u00e1ra gyakran valamilyen verzi\u00f3kezel\u0151 (pl. Git) kezel\u00e9s\u00e9ben van. Ilyenkor gyakori probl\u00e9ma, hogy a konfigur\u00e1ci\u00f3s f\u00e1jlokba \u00edrt szenzit\u00edv inform\u00e1ci\u00f3k (API kulcsok, adatb\u00e1zis jelszavak) beker\u00fclnek a verzi\u00f3kezel\u0151be. Ha egy publikus projekten dolgozunk, p\u00e9ld\u00e1ul publikus GitHub projekt, akkor ez komoly biztons\u00e1gi kock\u00e1zat lehet.</p> <p>Szenzit\u00edv inform\u00e1ci\u00f3k</p> <p>Ne tegy\u00fcnk a verzi\u00f3kezel\u0151be szenzit\u00edv inform\u00e1ci\u00f3kat m\u00e9g priv\u00e1t rep\u00f3 eset\u00e9ben sem. Gondoljunk arra is, hogy a verzi\u00f3kezel\u0151 nem felejt! Ami egyszer m\u00e1r beker\u00fclt, azt vissza is lehet nyerni bel\u0151le (history).</p> <p>Ennek a probl\u00e9m\u00e1nak megold\u00e1s\u00e1ra egy eszk\u00f6z a User Secrets t\u00e1rol\u00f3. Jobbklikkelj\u00fcnk a projekten a Solution Explorer ablakban, majd v\u00e1lasszuk a Manage User Secrets men\u00fcpontot. Ennek hat\u00e1s\u00e1ra megny\u00edlik egy secrets.json nev\u0171 f\u00e1jl. Vizsg\u00e1ljuk meg, hol is van ez a f\u00e1jl: vigy\u00fck az egeret a f\u00e1jlf\u00fcl f\u00f6l\u00e9 - azt l\u00e1thatjuk, hogy a f\u00e1jl a felhaszn\u00e1l\u00f3nk saj\u00e1t k\u00f6nyvt\u00e1r\u00e1n bel\u00fcl van \u00e9s az \u00fatvonal r\u00e9sze egy GUID is. A projektf\u00e1jlba (.csproj) beker\u00fclt ugyanez a GUID (a UserSecretsId c\u00edmk\u00e9be).</p> <p>Vegy\u00fcnk fel egy \u00faj be\u00e1ll\u00edt\u00e1st a secrets.json-ba, ami a <code>SuperSecret</code> \u00e9rt\u00e9k\u00e9t \u00edrja fel\u00fcl:</p> <pre><code>{\n  \"DummySettings\": {\n    \"SuperSecret\": \"SECRET\"\n  }\n}\n</code></pre> <p>R\u00e9szleges fel\u00fcl\u00edr\u00e1s</p> <p>A secrets.json-ban csak azokat a json lev\u00e9l elemeket kell felvenni, amiket fel\u00fcl akarunk \u00edrni. Ez a m\u00f3dszer m\u0171k\u00f6dik a sima appsettings.json k\u00f6rnyezetf\u00fcgg\u0151 v\u00e1ltoz\u00f3ira is.</p> <p>T\u00f6r\u00e9spontot let\u00e9ve (pl. a <code>DummyController</code> konstruktor\u00e1nak v\u00e9g\u00e9n) ellen\u0151rizz\u00fck, hogy a titkos \u00e9rt\u00e9k melyik f\u00e1jlb\u00f3l j\u00f6n. Ehhez meg kell h\u00edvnunk b\u00f6ng\u00e9sz\u0151b\u0151l az <code>api/dummy</code> c\u00edmet.</p> <p>User Secrets csak Development m\u00f3dban</p> <p>Fontos tudni, hogy a User Secrets t\u00e1rol\u00f3 csak Development m\u00f3d eset\u00e9n jut \u00e9rv\u00e9nyre, \u00edgy figyelj\u00fcnk r\u00e1, hogy a megfelel\u0151 m\u00f3dot ind\u00edtsuk \u00e9s a k\u00f6rnyezeti v\u00e1ltoz\u00f3k is j\u00f3l legyenek be\u00e1ll\u00edtva.</p> <p>Ez az elj\u00e1r\u00e1s teh\u00e1t a futtat\u00f3 felhaszn\u00e1l\u00f3 saj\u00e1t k\u00f6nyvt\u00e1r\u00e1b\u00f3l a GUID alapj\u00e1n kikeresi a projekthez tartoz\u00f3 secrets.json-t, annak tartalm\u00e1t pedig fut\u00e1s k\u00f6zben \u00f6sszef\u00e9s\u00fcli az appsettings.json tartalm\u00e1val. \u00cdgy szenzit\u00edv adat nem ker\u00fcl a projekt k\u00f6nyvt\u00e1r\u00e1ba.</p> <p>Titkok \u00e9les k\u00f6rnyezetben</p> <p>Mivel a User Secrets t\u00e1rol\u00f3 csak Development m\u00f3d eset\u00e9n jut \u00e9rv\u00e9nyre, \u00edgy ha az \u00e9les v\u00e1ltozatnak sz\u00fcks\u00e9ge van ezekre a titkos \u00e9rt\u00e9kekre, akkor tov\u00e1bbi tr\u00fckk\u00f6kre van sz\u00fcks\u00e9g. Ilyen megold\u00e1s lehet, ha a felh\u0151s hosztol\u00e1s eset\u00e9n a felh\u0151b\u0151l (pl. Azure App Service Configuration) vagy felh\u0151beli titokt\u00e1rol\u00f3b\u00f3l (pl. Azure Key Vault) vagy a DevOps eszk\u00f6zb\u0151l (pl. Azure DevOps Pipeline Secrets) t\u00f6ltj\u00fck be a szenzit\u00edv be\u00e1ll\u00edt\u00e1sokat.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#epilogus-webapplicationbuilder","title":"Epil\u00f3gus - WebApplicationBuilder","text":"<p>Az eddigiekb\u0151l l\u00e1that\u00f3, hogy sz\u00e1mos alapszolg\u00e1ltat\u00e1s m\u00e1r a <code>CreateBuilder</code> h\u00edv\u00e1s \u00e1ltal visszaadott kiindul\u00f3 builderben konfigur\u00e1lva van. Ilyen az alap (<code>IOptions</code> n\u00e9lk\u00fcli) alkalmaz\u00e1sbe\u00e1ll\u00edt\u00e1sok kezel\u00e9se vagy a napl\u00f3z\u00e1s. A <code>CreateBuilder</code> a <code>WebApplicationBuilder</code> internal konstruktor\u00e1t h\u00edvja.</p> <p>A <code>WebApplicationBuilder</code> el\u0151dje az <code>IWebHostBuilder</code>, ez ut\u00f3bbinak a dokument\u00e1ci\u00f3j\u00e1t tanulm\u00e1nyozva \u00e9rthetj\u00fck meg, hogy mi mindent tud a kiindul\u00f3 builder.</p>"}]}