{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftverfejleszt\u00e9s .NET platformra","text":"<p>Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a Szoftverfejleszt\u00e9s .NET platformra c. t\u00e1rgyhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p> <p>A felhaszn\u00e1l\u00e1si felt\u00e9telekr\u0151l b\u0151vebben a repository LICENSE.md f\u00e1jlj\u00e1ban olvashatsz.</p>"},{"location":"homework/","title":"H\u00e1zi feladat tudnival\u00f3k","text":"<p>Az itteni szerkezetet k\u00f6vess\u00e9tek: p\u00e9lda specifik\u00e1ci\u00f3</p>"},{"location":"homework/#kovetelmenyek","title":"K\u00f6vetelm\u00e9nyek","text":"<p>Az al\u00e1bbiak k\u00f6z\u00fcl mindegyiknek teljes\u00fclnie kell az al\u00e1\u00edr\u00e1shoz:</p> <ul> <li>K\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll<ul> <li>szerver oldali HTTP alap\u00fa szolg\u00e1ltat\u00e1s</li> <li>egy vastag vagy v\u00e9kony kliens (szerveroldali renderel\u00e9s n\u00e9lk\u00fcl) alkalmaz\u00e1s, ami a szolg\u00e1ltat\u00e1st h\u00edvja<ul> <li>elfogadhat\u00f3 (p\u00e9ld\u00e1k): WPF, WinForms, MAUI, Swing, JavaFX, Blazor WebAssembly, Angular, React, Vue, Android (kotlin, java), iOS (swift, obj-c), stb.</li> <li>nem elfogadhat\u00f3: ASP.NET Core MVC Razor gener\u00e1lt weboldalakb\u00f3l \u00e1ll\u00f3 webalkalmaz\u00e1s, JSP, PHP, Blazor Server, vagy Blazor Static Render, sima HTML+JS+CSS</li> <li>kiv\u00e9tel: a felhaszn\u00e1l\u00f3kezel\u00e9shez szorosan kapcsol\u00f3d\u00f3 fel\u00fcletek (bel\u00e9p\u00e9s, regisztr\u00e1ci\u00f3, stb.) b\u00e1rmilyen fel\u00fcleti technol\u00f3gi\u00e1val k\u00e9sz\u00fclhetnek</li> </ul> </li> <li>a vastag/v\u00e9kony kliens kiv\u00e1lthat\u00f3 Postman klienssel</li> </ul> </li> <li>A kliens nem \u00e9ri el k\u00f6zvetlen\u00fcl az adatb\u00e1zist</li> <li>A kliens nem csak egym\u00e1st\u00f3l f\u00fcggetlen h\u00edv\u00e1sokat csin\u00e1l, hanem t\u00e9nylegesen v\u00e9gre is lehet hajtani a felhaszn\u00e1l\u00f3i folyamatokat. Pl. Postman kliens eset\u00e9ben, nem csak k\u00fcl\u00f6n\u00e1ll\u00f3 teszth\u00edv\u00e1sok vannak, hanem kollekci\u00f3kba rendezve h\u00edv\u00e1si sorozatok, ahol ez egyes h\u00edv\u00e1sok k\u00f6z\u00f6tt v\u00e1ltoz\u00f3kban \u00e1llapotot is t\u00e1rolunk.</li> <li>Adatel\u00e9r\u00e9s: Entity Framework Core v8.x</li> <li>Kommunik\u00e1ci\u00f3: ASP.NET Core v8.x<ul> <li>Az el\u0151bb megadott verzi\u00f3khoz k\u00e9pest k\u00e9s\u0151bbi verzi\u00f3k haszn\u00e1lhat\u00f3k - saj\u00e1t felel\u0151ss\u00e9gre</li> </ul> </li> <li>Minimum 3 \u00f6sszef\u00fcgg\u0151 t\u00e1bla haszn\u00e1lata, nem sz\u00e1molva a felhaszn\u00e1l\u00f3kezel\u00e9ssel kapcsolatos t\u00e1bl\u00e1kat</li> <li>A leadott specifik\u00e1ci\u00f3nak megfelel\u0151 funkcionalit\u00e1s</li> </ul>"},{"location":"homework/example-spec/","title":"Kisdoktori gener\u00e1tor","text":""},{"location":"homework/example-spec/#feladat","title":"Feladat <sup>1</sup>","text":"<p>Egy olyan alkalmaz\u00e1s k\u00e9sz\u00edt\u00e9se, mely t\u00f6rzsanyagokb\u00f3l disszert\u00e1ci\u00f3t \u00e1ll\u00edt el\u0151. T\u00f6rzsanyagokat lehet felvinni a rendszerbe, egy szerkeszt\u0151fel\u00fcleten megadni a gener\u00e1l\u00e1s param\u00e9tereit, majd a gener\u00e1lt dokumentumot k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1tumokba menteni.</p>"},{"location":"homework/example-spec/#a-kishaziban-elerheto-funkciok","title":"A kish\u00e1ziban el\u00e9rhet\u0151 funkci\u00f3k <sup>2</sup>","text":"<ul> <li>t\u00f6rzsanyagok felt\u00f6lt\u00e9se (csak .txt form\u00e1tumban), t\u00f6rl\u00e9se - a t\u00f6rzsanyag t\u00e9m\u00e1ja megadhat\u00f3.</li> <li>egyszer\u0171 szerkeszt\u0151fel\u00fclet - t\u00e9ma megad\u00e1sa, elv\u00e1rt sz\u00f3sz\u00e1m</li> <li>egyszer\u0171 gener\u00e1l\u00e1s - a t\u00e9ma alapj\u00e1n sz\u00f6vegek \u00f6sszev\u00e1logat\u00e1sa v\u00e9letlenszer\u0171en</li> <li>ment\u00e9s XML form\u00e1tumban, az egyes sz\u00f6vegr\u00e9szekhez megadva, hogy melyik forr\u00e1sm\u0171b\u0151l sz\u00e1rmaznak</li> <li>az el\u0151bbi XML bet\u00f6lt\u00e9se \u00e9s tartalm\u00e1nak megjelen\u00edt\u00e9se (az egyes sz\u00f6vegr\u00e9szekhez jelenjen meg, hogy melyik forr\u00e1sm\u0171b\u0151l val\u00f3)</li> </ul>"},{"location":"homework/example-spec/#adatbazis-entitasok","title":"Adatb\u00e1zis entit\u00e1sok <sup>3</sup>","text":"<ul> <li>t\u00f6rzsanyag</li> <li>dolgozat</li> <li>forr\u00e1shivatkoz\u00e1s</li> </ul>"},{"location":"homework/example-spec/#alkalmazott-alaptechnologiak","title":"Alkalmazott alaptechnol\u00f3gi\u00e1k <sup>4</sup>","text":"<ul> <li>adatel\u00e9r\u00e9s: Entity Framework Core v8</li> <li>kommunik\u00e1ci\u00f3, szerveroldal: ASP.NET Core v8</li> <li>kliensoldal: Blazor WebAssembly</li> </ul>"},{"location":"homework/example-spec/#tovabbfejlesztesi-tervek","title":"Tov\u00e1bbfejleszt\u00e9si tervek <sup>5</sup>","text":"<ul> <li>hosztol\u00e1s Azure-ban</li> <li>HiLo els\u0151dleges kulcs alkalmaz\u00e1sa</li> <li>logikai t\u00f6rl\u00e9s (soft delete) glob\u00e1lis sz\u0171r\u0151kkel</li> <li>OData szolg\u00e1ltat\u00e1s megval\u00f3s\u00edt\u00e1sa</li> </ul> <ol> <li> <p>2-3 mondatban foglald \u00f6ssze a feladatot!\u00a0\u21a9</p> </li> <li> <p>Adatm\u00f3dos\u00edt\u00e1ssal j\u00e1r\u00f3 is legyen benne\u00a0\u21a9</p> </li> <li> <p>min. 3 db.\u00a0\u21a9</p> </li> <li> <p>a szerver oldal mindenkinek ugyanez lesz, kliensoldal v\u00e1laszthat\u00f3. Verzi\u00f3sz\u00e1mok lehetnek nagyobbak, mint a lentiek\u00a0\u21a9</p> </li> <li> <p>opcion\u00e1lis, a pontrendszerb\u0151l \u00e9rdemes v\u00e1logatni. C\u00e9lja, hogy KHF bemutat\u00e1skor a felmer\u00fcl\u0151 k\u00e9rd\u00e9seket megbesz\u00e9lhess\u00fck\u00a0\u21a9</p> </li> </ol>"},{"location":"homework/hw-points/","title":"NagyHF pontrendszer","text":""},{"location":"homework/hw-points/#pontszerzesi-szabalyok","title":"Pontszerz\u00e9si szab\u00e1lyok","text":"<ul> <li>Egy jogc\u00edmen csak egyszer szerezhet\u0151 pont (pl. nem lehet 3 k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rral 21 pontot \u00f6sszeszedni), kiv\u00e9ve ahol ezt k\u00fcl\u00f6n jelezz\u00fck</li> <li>R\u00e9szpontsz\u00e1m nem adhat\u00f3, kiv\u00e9ve, ahol intervallum van megadva</li> <li>Kliensoldali megold\u00e1s\u00e9rt nem adhat\u00f3 pont</li> <li>A szoftvernek egys\u00e9ges funkci\u00f3halmazt kell ny\u00fajtania, k\u00fcl\u00f6n\u00e1ll\u00f3, egym\u00e1shoz nem kapcsol\u00f3d\u00f3 funkci\u00f3kb\u00f3l \u00e1ll\u00f3 szoftver nem elfogadhat\u00f3. Azaz k\u00fcl\u00f6n\u00e1ll\u00f3 tutorialok \u00f6sszef\u00e9rcel\u00e9s\u00e9t nem d\u00edjazzuk.</li> </ul> <p>Pontrendszer v\u00e9gleges\u00edt\u00e9s</p> <p>Jelenleg a 2024. tavaszif\u00e9l\u00e9vre nincs v\u00e9gleges\u00edtve a pontrendszer!</p> <p>V\u00e9gleges\u00edt\u00e9s ut\u00e1n csak a k\u00f6vetkez\u0151 t\u00edpus\u00fa v\u00e1ltoz\u00e1sok lehetnek</p> <ul> <li>hallgat\u00f3knak kedvez\u0151 v\u00e1ltoz\u00e1sok (pl. \u00faj jogc\u00edmek)</li> <li>el\u00edr\u00e1sok, megfogalmaz\u00e1sbeli pontos\u00edt\u00e1sok jav\u00edt\u00e1sa</li> <li>ellentmond\u00e1sok felold\u00e1sa</li> </ul>"},{"location":"homework/hw-points/#tarsadalmi-munka","title":"T\u00e1rsadalmi munka","text":"<ul> <li>a v\u00e9gleges\u00edtett pontrendszer vagy jegyzet jav\u00edt\u00e1sa, b\u0151v\u00edt\u00e9se, m\u00f3dos\u00edt\u00e1sa pull request-tel [0-2, max. 5]<ul> <li>Helyes\u00edr\u00e1si hiba is lehet, de az oktat\u00f3k d\u00f6ntenek, hogy h\u00e1ny pontot (0-2) \u00e9r a m\u00f3dos\u00edt\u00e1s</li> <li>T\u00f6bbsz\u00f6r is megszerezhet\u0151!</li> </ul> </li> </ul>"},{"location":"homework/hw-points/#aspnet-core-web-api","title":"ASP.NET Core Web API","text":"<ul> <li>HATEOAS linkek gener\u00e1l\u00e1sa a v\u00e1laszban [7]</li> <li>Web API Core \u00e1ltal alapb\u00f3l nem t\u00e1mogatott HTTP ige (verb) implement\u00e1l\u00e1sa [5-7]<ul> <li>pl. GET-hez hasonl\u00f3 m\u0171k\u00f6d\u00e9s 5</li> <li>pl. PATCH ige r\u00e9szleges m\u00f3dos\u00edt\u00e1shoz JSON Patch dokumentumok felk\u00fcld\u00e9s\u00e9vel 7</li> <li>pl. OPTIONS ige az er\u0151forr\u00e1s \u00e1ltal t\u00e1mogatott ig\u00e9k lek\u00e9rdez\u00e9s\u00e9hez 7</li> </ul> </li> <li>verzi\u00f3kezelt API. Szeml\u00e9ltet\u00e9s k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 verzi\u00f3s API egyidej\u0171 kiszolg\u00e1l\u00e1s\u00e1val. A k\u00edv\u00e1nt verzi\u00f3t HTTP fejl\u00e9c vagy p\u00e9ld\u00e1ul URL szegmens alapj\u00e1n v\u00e1laszthatja meg a kliens. [7]</li> <li>cache megval\u00f3s\u00edt\u00e1sa [3-9]<ul> <li>ETAG alap\u00fa: a kliens fel\u00fck\u00fcld egy E-TAG-et, szerver \u00f6sszeveti az adatb\u00e1zisb\u00f3l felolvasott verzi\u00f3val 3</li> <li>a szerver is mem\u00f3ria alap\u00fa cache-b\u0151l olvassa ki az aktu\u00e1lis verzi\u00f3t +3</li> <li>a szerver is elosztott alap\u00fa cache-b\u0151l olvassa ki az aktu\u00e1lis verzi\u00f3t pl.: Redis + <code>IDistributedCache</code> +3</li> </ul> </li> <li>Szerver oldali autentik\u00e1ci\u00f3. Saj\u00e1t token provider k\u00e9sz\u00edt\u00e9se, haszn\u00e1lata (DIY security) eset\u00e9n nem j\u00e1r pont. [7-15]<ul> <li>API (egy r\u00e9sz\u00e9nek) v\u00e9d\u00e9se felhaszn\u00e1l\u00f3 \u00e1ltal ig\u00e9nyelhet\u0151 API kulccsal 7</li> <li>ASP.NET Core Identity be\u00e9p\u00edtett megold\u00e1saival (s\u00fcti alap\u00fa) - csak b\u00f6ng\u00e9sz\u0151s/Postman kliens eset\u00e9n! 7</li> <li>OpenID Connect, JWT token alap\u00fa oszt\u00e1lyk\u00f6nyvt\u00e1rat integr\u00e1lva ASP.NET Core Identity + Duende IdentityServer / OpenIddict middleware-rel, interakt\u00edv flow<ul> <li>angular, react kliens eset\u00e9n 7</li> <li>Blazor WebAssembly kliens eset\u00e9n 10</li> <li>egy\u00e9b kliens eset\u00e9n 12</li> </ul> </li> <li>Azure AD B2C-re (ingyenes szint) \u00e9p\u00edtve 10</li> <li>norm\u00e1l Azure AD (nem B2C) 7</li> <li>LDAP alap\u00fa szolg\u00e1ltat\u00e1sra \u00e9p\u00edtve 10</li> <li>m\u00e1s Identity-as-a-Service szolg\u00e1ltat\u00e1ssal (pl. Auth0) 7</li> <li>legal\u00e1bb egy k\u00fcls\u0151 identity provider integr\u00e1l\u00e1sa (Google login, Windows login, stb.)  +3</li> </ul> </li> <li>szerver oldali hozz\u00e1f\u00e9r\u00e9s-szab\u00e1lyoz\u00e1s, az el\u0151bbi authentik\u00e1ci\u00f3ra \u00e9p\u00edtve  [2-5]<ul> <li>szerepk\u00f6r alap\u00fa hozz\u00e1f\u00e9r\u00e9s-szab\u00e1lyoz\u00e1s 2</li> <li>policy alap\u00fa hozz\u00e1f\u00e9r\u00e9s-szab\u00e1lyoz\u00e1s (pl.: Claim alapon) 5</li> </ul> </li> <li>k\u00fcls\u0151 online szolg\u00e1ltat\u00e1s (Twitter, Facebook, Google Maps, Bing Maps, stb.) integr\u00e1l\u00e1sa a szerveroldali alkalmaz\u00e1sba kliensk\u00f6nyvt\u00e1rral (pl. HttpClient) vagy SDK-val [7-10]<ul> <li>egyszer\u0171 REST API, SDK haszn\u00e1lat n\u00e9lk\u00fcl, egyszer\u0171 API kulcs alap\u00fa authentik\u00e1ci\u00f3 7</li> <li>SDK-val / REST API-val, authentik\u00e1ci\u00f3t (pl. OIDC) v\u00e9grehajtva 10</li> </ul> </li> <li>SignalR Core alkalmaz\u00e1sa val\u00f3s idej\u0171, szerver fel\u0151l \u00e9rkez\u0151 push jelleg\u0171 kommunik\u00e1ci\u00f3ra 7</li> <li>teljes szerveroldal hosztol\u00e1sa k\u00fcls\u0151 szolg\u00e1ltat\u00f3n\u00e1l [5-15]<ul> <li>Azure (ingyenes App Services - WebApp szolg\u00e1ltat\u00e1s) 7</li> <li>egy\u00e9b szolg\u00e1ltat\u00f3 5</li> <li>Automatiz\u00e1lt telep\u00edt\u00e9s (pl. GitHub Actions, Azure DevOps) +3</li> </ul> </li> <li>Publik\u00e1l\u00e1s docker kont\u00e9nerbe \u00e9s futtat\u00e1s kont\u00e9nerb\u0151l 5</li> <li>hosztol\u00e1s service-ben (Windows Service, Linux systemd) [3-5]<ul> <li>Windows service 3</li> <li>Linux systemd 5</li> </ul> </li> <li>OpenAPI le\u00edr\u00f3 (swagger) alap\u00fa dokument\u00e1ci\u00f3 [3-12]<ul> <li>minden v\u00e9gpont kliens szempontj\u00e1b\u00f3l relev\u00e1ns m\u0171k\u00f6d\u00e9se dokument\u00e1lt, minden lehets\u00e9ges v\u00e1laszk\u00f3ddal egy\u00fctt 3</li> <li>az API-nak egyidej\u0171leg t\u00f6bb t\u00e1mogatott verzi\u00f3ja van, mindegyik dokument\u00e1lt \u00e9s mindegyik t\u00e1mogatott verzi\u00f3 dokument\u00e1ci\u00f3ja el\u00e9rhet\u0151  +4</li> <li>A kliensen az OpenApi le\u00edr\u00f3 alapj\u00e1n gener\u00e1lt kliensk\u00f6nyvt\u00e1r haszn\u00e1lata +5<ul> <li>Command-line gener\u00e1tor eszk\u00f6z haszn\u00e1lata \u00e9s konfigur\u00e1l\u00e1sa +3</li> </ul> </li> </ul> </li> <li>Adatb\u00e1zis entit\u00e1s els\u0151dleges kulcs elrejt\u00e9se a kliens el\u0151l v\u00e9letlenszer\u0171en gener\u00e1lt, nem n\u00f6vekv\u0151 sorrendben kiosztott kulcsokkal. A kliens nem ismeri az adatb\u00e1zis entit\u00e1s kulcs \u00e9rt\u00e9k\u00e9t, helyette egy gener\u00e1lt kulcsot l\u00e1t csak. Az adatb\u00e1zis nem t\u00e1rolja a gener\u00e1lt kulcsot. Megval\u00f3s\u00edthat\u00f3 k\u00e9tir\u00e1ny\u00fa sz\u00e1m &lt;-&gt; gener\u00e1lt azonos\u00edt\u00f3 f\u00fcggv\u00e9nyek seg\u00edts\u00e9g\u00e9vel. 7</li> <li>K\u00f6zpontos\u00edtott hibakezel\u00e9s, a kliens sz\u00e1m\u00e1ra \u00e9rtelmezhet\u0151 <code>ProblemDetails</code> objektumok k\u00fcld\u00e9se hib\u00e1s k\u00e9r\u00e9sek eset\u00e9n. Teh\u00e1t nem a Controllerekben van try-catch, hanem a hib\u00e1k k\u00f6zpontilag vannak kezelve 5</li> <li>Minden bej\u00f6v\u0151 kliensr\u0151l \u00e9rkez\u0151 adat valid\u00e1ci\u00f3ja pl.: DataAnnotations, FluentValidation stb. haszn\u00e1lat\u00e1val \u00e9s <code>ValidationProblemDetails</code>-k\u00e9nt visszajelezve a kliens fel\u00e9 5</li> <li>D\u00e1tumok helyes kezel\u00e9se olyan esetben is, ha a kliens \u00e9s a szerver(ek) elt\u00e9r\u0151 id\u0151z\u00f3n\u00e1ban vannak. (tipikusan <code>DateTimeOffset</code> haszn\u00e1lata). Implement\u00e1ci\u00f3t nem kell bemutat\u00e1sk\u00f6r demonstr\u00e1lni, de a k\u00f3d alapj\u00e1n \u00e9rvelve bizony\u00edtani kell a helyes m\u0171k\u00f6d\u00e9st. 5</li> </ul>"},{"location":"homework/hw-points/#kommunikacio-halozatkezeles","title":"Kommunik\u00e1ci\u00f3, h\u00e1l\u00f3zatkezel\u00e9s","text":"<ul> <li>alacsony szint\u0171 kommunik\u00e1ci\u00f3 (soros port, HTTP alatti OSI r\u00e9teg, pl. k\u00e9tir\u00e1ny\u00fa TCP) 10</li> <li>HTTPS kommunik\u00e1ci\u00f3 (self-signed tan\u00fas\u00edtv\u00e1nnyal) az ASP.NET Web API \u00e9s a kliens k\u00f6z\u00f6tt, hosztol\u00e1s norm\u00e1l, nem fejleszt\u0151i webszerverben (pl. Apache, nginx, nem IIS Express) \u00e9s nem Kestrel-en, szeml\u00e9ltet\u00e9s Fiddler-rel/Postman-nel [5-10]<ul> <li>csak szerver oldali tan\u00fas\u00edtv\u00e1ny 5</li> <li>kliens is azonos\u00edtja mag\u00e1t tan\u00fas\u00edtv\u00e1nnyal a szerver fel\u00e9 +5</li> </ul> </li> <li>az API funkci\u00f3k egy r\u00e9sz\u00e9nek el\u00e9rhet\u0151v\u00e9 t\u00e9tele GraphQL h\u00edv\u00e1sokon kereszt\u00fcl, ASP.NET Core middleware seg\u00edts\u00e9g\u00e9vel (pl. GraphQL.NET vagy Hot Chocolate) az EF entit\u00e1smodellre \u00e9p\u00edtve. Szeml\u00e9ltet\u00e9s p\u00e9ldah\u00edv\u00e1sokkal a kliensb\u0151l. [7-10]<ul> <li>csak lek\u00e9rdez\u00e9s 7</li> <li>m\u00f3dos\u00edt\u00e1s vagy hozz\u00e1ad\u00e1s is (mut\u00e1ci\u00f3) +3</li> </ul> </li> <li>az API funkci\u00f3k egy r\u00e9sz\u00e9nek el\u00e9rhet\u0151v\u00e9 t\u00e9tele gRPC HTTP/2 vagy gRPC-Web h\u00edv\u00e1sokon kereszt\u00fcl. Szeml\u00e9ltet\u00e9s p\u00e9ldah\u00edv\u00e1sokkal kliensb\u0151l vagy gRPC teszteszk\u00f6zb\u0151l (pl. bloomrpc) Azure App Service-szel, IIS-sel, b\u00f6ng\u00e9sz\u0151s klienssel korl\u00e1tozottan kompatibilis! [7]</li> <li>az EF adatmodell kiaj\u00e1nl\u00e1sa OData szolg\u00e1ltat\u00e1s seg\u00edts\u00e9g\u00e9vel (Microsoft.AspNetCore.OData csomag). P\u00e9ldah\u00edv\u00e1s bemutat\u00e1sa a kliensb\u0151l OData v4 protokollt haszn\u00e1lva.  [7-10]<ul> <li>csak lek\u00e9rdez\u00e9s 7</li> <li>m\u00f3dos\u00edt\u00e1s vagy hozz\u00e1ad\u00e1s vagy t\u00f6rl\u00e9s is +3</li> </ul> </li> <li>Aszinkron kommunik\u00e1ci\u00f3 haszn\u00e1lata \u00fczenetsorral (pl.: RabbitMQ, Azure ServiceBus, Azure Queue Storage, AMQP, MQTT stb.) 7</li> </ul>"},{"location":"homework/hw-points/#entity-framework-core","title":"Entity Framework Core","text":"<ul> <li>lesz\u00e1rmaz\u00e1si hierarchia lek\u00e9pez\u00e9se Entity Framework-kel (legal\u00e1bb k\u00e9tszint\u0171, legal\u00e1bb 3 tag\u00fa hierarchia) [3-7]<ul> <li>TPH, a diszkrimin\u00e1tor mez\u0151 testreszab\u00e1s\u00e1val (saj\u00e1t mez\u0151n\u00e9v vagy saj\u00e1t \u00e9rt\u00e9kek) 3</li> <li>TPT-vel 5</li> <li>TPC-vel 7</li> </ul> </li> <li>MS SQL/Azure SQL/LocalDB-t\u0151l elt\u00e9r\u0151 adatb\u00e1ziskiszolg\u00e1l\u00f3 haszn\u00e1lata EF Core-ral (kiv\u00e9ve m\u00e9g: sqlite) [10-12]<ul> <li>Azure Cosmos DB (NoSQL!) 10</li> <li>egy\u00e9b, EF Core t\u00e1mogatott adatb\u00e1zis 5 </li> </ul> </li> <li>saj\u00e1t Code-First konvenci\u00f3 k\u00e9sz\u00edt\u00e9se 5</li> <li>saj\u00e1t t\u00f6bbessz\u00e1mos\u00edt\u00f3 (<code>IPluralizer</code>) - nem kell nyelvtanilag helyesnek lennie [7]</li> <li>automatikus \u00fajrapr\u00f3b\u00e1lkoz\u00e1s be\u00e1ll\u00edt\u00e1sa tranziens adatb\u00e1zishib\u00e1k (pl. connection timeout) ellen [2]</li> <li>Table splitting 5</li> <li>Entity splitting [5]</li> <li>alternat\u00edv kulcs [3-5]<ul> <li>alternat\u00edv kulcs bevezet\u00e9se valamelyik entit\u00e1sban 3</li> <li>m\u00e1s entit\u00e1s kapcsolattal hivatkozik az alternat\u00edv kulcsra +2</li> </ul> </li> <li>adatb\u00e1zis index konfigur\u00e1ci\u00f3ja az EF modellben [3]</li> <li>HiLo els\u0151dleges kulcs alkalmaz\u00e1sa [3]</li> <li>birtokolt t\u00edpus (owned type) haszn\u00e1lata [3]</li> <li>adatbet\u00f6lt\u00e9s (seeding) migr\u00e1ci\u00f3 seg\u00edts\u00e9g\u00e9vel (<code>HasData</code>) [3]</li> <li>\u00e9rt\u00e9kkonverter (value converter) alkalmaz\u00e1sa EF Core lek\u00e9pez\u00e9sben [3-5]<ul> <li>be\u00e9p\u00edtett, vagy k\u00fcls\u0151 komponensb\u0151l sz\u00e1rmaz\u00f3 value converter 3</li> <li>saj\u00e1t value converter 5</li> </ul> </li> <li>t\u00e9rbeli (spatial) adatok kezel\u00e9se EF Core \u00e9s NetTopologySuite seg\u00edts\u00e9g\u00e9vel. Legal\u00e1bb egy spatial oszlop kezel\u00e9se \u00e9s legal\u00e1bb egy spatial m\u0171velet (pl. <code>Contains</code>) alkalmaz\u00e1sa. Nem minden provider t\u00e1mogaja!  [7]</li> <li>id\u0151kezelt (temporal) t\u00e1bl\u00e1k kezel\u00e9se EF Core seg\u00edts\u00e9g\u00e9vel. Legal\u00e1bb egy id\u0151kezelt t\u00e1bla haszn\u00e1lata \u00e9s historikus adat\u00e1nak felhaszn\u00e1l\u00e1sa. Csak SQL Server/LocalDB/Azure SQL provider t\u00e1mogatja! [7]</li> <li>Egy\u00e9b EF Core funkci\u00f3 haszn\u00e1lata, ami nincs a list\u00e1ban [3-10] Gyakorlatvezet\u0151vel el\u0151re egyeztetend\u0151, hogy felker\u00fclj\u00f6n a list\u00e1ra.</li> </ul>"},{"location":"homework/hw-points/#net-reszfunkciok-alkalmazasa","title":".NET r\u00e9szfunkci\u00f3k alkalmaz\u00e1sa","text":"<ul> <li>az EF Core m\u0171k\u00f6d\u0151k\u00e9pess\u00e9g\u00e9t, az adatb\u00e1zis el\u00e9rhet\u0151s\u00e9g\u00e9t jelz\u0151 health check v\u00e9gpont publik\u00e1l\u00e1sa a Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore NuGet csomag haszn\u00e1lat\u00e1val [3]</li> <li>kifejez\u00e9sfa (ExpressionTree) \u00e9rtelmez\u00e9se/k\u00e9sz\u00edt\u00e9se/m\u00f3dos\u00edt\u00e1sa az Expression API haszn\u00e1lat\u00e1val [5-20]<ul> <li>pl. sz\u0171r\u00e9s dinamikusan, param\u00e9terb\u0151l \u00e9rkez\u0151 property neve alapj\u00e1n (pl. <code>o =&gt; o.Prop == propNev</code>) 5</li> <li>pl. keres\u00e9s kapcsol\u00f3d\u00f3 kollekci\u00f3ban dinamikusan (pl. <code>o =&gt; o.Coll.Any(e =&gt; e.Prop == propNev)</code>) 10</li> <li>saj\u00e1t LINQ provider - el\u0151zetes egyeztet\u00e9s sz\u00fcks\u00e9ges! 20</li> </ul> </li> <li>explicit k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s helyett ConcurretBag/ConcurrentQueue/ConcurrentStack/ConcurrentDictionary haszn\u00e1lata olyan r\u00e9tegben, ahol p\u00e1rhuzamos hozz\u00e1f\u00e9r\u00e9s val\u00f3ban el\u0151fordul [5]</li> <li>lock-free algoritmus implement\u00e1l\u00e1sa \u00e9s haszn\u00e1lata (k\u00f6nyvt\u00e1ri implement\u00e1ci\u00f3 felhaszn\u00e1l\u00e1sa n\u00e9lk\u00fcl, <code>Interlocked</code> f\u00fcggv\u00e9nyek haszn\u00e1lat\u00e1val) [10]</li> <li>automatiz\u00e1lt (unit vagy integr\u00e1ci\u00f3s) tesztek k\u00e9sz\u00edt\u00e9se  [7-14]<ul> <li>minimum 10 f\u00fcggv\u00e9nyhez/v\u00e9gponthoz 7</li> <li>a unit tesztekben a mock objektumok injekt\u00e1l\u00e1sa +3</li> <li>EF Core mem\u00f3ria-adatb\u00e1zis vagy sqlite (vagy in-memory sqlite) haszn\u00e1lata tesztel\u00e9shez +4</li> </ul> </li> <li>XML valid\u00e1l\u00e1s, alkalmazkod\u00e1s megl\u00e9v\u0151 XML form\u00e1tumhoz pl. publikus webes s\u00e9m\u00e1hoz (RSS, opml) [7]</li> <li>Optimista konkurenciakezel\u00e9s [5-15]<ul> <li>\u00fctk\u00f6z\u00e9sdetekt\u00e1l\u00e1s \u00e9s automatikus \u00fctk\u00f6z\u00e9sfelold\u00e1s 5</li> <li>\u00fctk\u00f6z\u00e9sfelold\u00e1s a felhaszn\u00e1l\u00f3 d\u00f6nt\u00e9se alapj\u00e1n: client wins vagy store wins felold\u00e1ssal. \u00dctk\u00f6z\u00e9s eset\u00e9n a felhaszn\u00e1l\u00f3t\u00f3l megk\u00e9rdezz\u00fck, hogy a k\u00e9t adatverzi\u00f3 k\u00f6z\u00fcl melyik legyen mentve az adatb\u00e1zisba: az aktu\u00e1lis felhaszn\u00e1l\u00f3\u00e9, a m\u00e1sik felhaszn\u00e1l\u00f3\u00e9. Bemutat\u00e1skor szeml\u00e9ltet\u00e9s egy p\u00e9ld\u00e1n kereszt\u00fcl. 10</li> <li>a felhaszn\u00e1l\u00f3 az eredeti \u00e9rt\u00e9ket is v\u00e1laszthatja (a m\u00f3dos\u00edt\u00e1sok el\u0151tti \u00e9rt\u00e9k vissza\u00e1ll\u00edt\u00e1sa) +5</li> </ul> </li> <li>pesszimista konkurenciakezel\u00e9s (adatb\u00e1zisobjektumok z\u00e1rol\u00e1sa) bizonyos entit\u00e1sok/funkci\u00f3k eset\u00e9n, nem kell a teljes alkalmaz\u00e1sban alkalmazni. Bemutat\u00e1skor szeml\u00e9ltet\u00e9s egy p\u00e9ld\u00e1n kereszt\u00fcl. [10]</li> <li>diagnosztika be\u00e9p\u00edtett vagy k\u00fcls\u0151 komponens seg\u00edts\u00e9g\u00e9vel [5-11]<ul> <li>legal\u00e1bb k\u00e9t c\u00e9lba, amib\u0151l legal\u00e1bb egy perzisztens (pl. f\u00e1jl vagy adatb\u00e1zis vagy k\u00fcls\u0151 szolg\u00e1ltat\u00e1s) 5</li> <li>strukt\u00far\u00e1lt napl\u00f3z\u00e1s (structured logging) +2</li> <li>f\u00e1jl c\u00e9l eset\u00e9n rolling log (minden napon/h\u00e9ten/10 MB-onk\u00e9nt \u00faj napl\u00f3f\u00e1jl) +2</li> <li>az egyik c\u00e9l egy k\u00fcls\u0151 napl\u00f3z\u00f3 szolg\u00e1ltat\u00e1s (pl. Azure Application Insights) +2</li> <li>Param\u00e9terezett nagy teljes\u00edtm\u00e9ny\u0171 k\u00f3dgener\u00e1lt napl\u00f3z\u00e1s haszn\u00e1lata legal\u00e1bb 2 helyen. +2</li> </ul> </li> <li>\u00e1th\u00edv\u00e1s nem fel\u00fcgyelt k\u00f6rnyezetbe (pl. nat\u00edv Win32, nat\u00edv linux) [7-12]<ul> <li>legal\u00e1bb egy nem egyszer\u0171 t\u00edpus \u00e1tad\u00e1sa/\u00e1tv\u00e9tele param\u00e9terk\u00e9nt 7</li> <li>saj\u00e1t nat\u00edv k\u00f3d haszn\u00e1lata, \u00f6sszetett t\u00edpus \u00e1tad\u00e1s\u00e1val 12</li> </ul> </li> <li>k\u00fcls\u0151 komponens haszn\u00e1lata DTO-k inicializ\u00e1l\u00e1s\u00e1ra [3]<ul> <li>Object mapper, pl. AutoMapper 3</li> <li>Explicit k\u00f3dgener\u00e1l\u00f3, pl. MappingGenerator (ingyenes v\u00e1ltozat) 3</li> </ul> </li> <li>logikai t\u00f6rl\u00e9s (soft delete) megval\u00f3s\u00edt\u00e1sa. A logikailag t\u00f6r\u00f6lt elemek alap\u00e9rtelmez\u00e9sben nem lek\u00e9rdezhet\u0151ek - ezen sz\u0171r\u00e9s megval\u00f3s\u00edt\u00e1sa glob\u00e1lis sz\u0171r\u0151kkel (Global Query Filter) [5]</li> <li>h\u00e1tt\u00e9rm\u0171velet(ek) megval\u00f3s\u00edt\u00e1sa [5-7]<ul> <li><code>IHostedService</code> / <code>BackgroundService</code> haszn\u00e1lat\u00e1val [5]</li> <li>nem be\u00e9p\u00edtett, k\u00fcls\u0151 h\u00e1tt\u00e9rfolyamat komponenssel, pl. Quartz.NET, Hangfire [7]</li> </ul> </li> <li>nem nullozhat\u00f3 referencia t\u00edpusok (NRT) k\u00e9nyszer\u00edt\u00e9se a nullable context bekapcsol\u00e1s\u00e1val minden szerveroldali projektre \u00e9s minden nullable context s\u00e9rt\u00e9s figyelmeztet\u00e9s hibak\u00e9nt kezel\u00e9se. Nullable context kikapcsol\u00e1sa projekten bel\u00fcl csak indokolt esetekben. [3]</li> <li>Entit\u00e1s specifikus els\u0151dleges kulcs t\u00edpusok haszn\u00e1lata (<code>entityA.Id = entityB.Id</code> ford\u00edt\u00e1si hiba, ha a k\u00e9t enti\u00e1s t\u00edpusa elt\u00e9r). A kliens oldalon, illetve a kontroller f\u00fcggv\u00e9nyek fejl\u00e9c\u00e9ben (pl. bemenetk\u00e9nt) nem kell, hogy megjelenjenek ezek a t\u00edpusok, csak a kontroller r\u00e9tegt\u0151l lefel\u00e9 (EF szinten is). Seg\u00e9dk\u00f6nyvt\u00e1r. [10]</li> <li>Szoftver funkci\u00f3inak ki/bekapcsolhat\u00f3s\u00e1ga FeatureFlagek kezel\u00e9s\u00e9vel [5-8] pl.: https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/feature-flags<ul> <li>config alap\u00fa 5</li> <li>felhaszn\u00e1l\u00f3i fel\u00fcletr\u0151l \u00e1ll\u00edthat\u00f3 +3</li> </ul> </li> <li>Szerver oldalon el\u0151fordul\u00f3 sz\u00f6veges er\u0151forr\u00e1sok lokaliz\u00e1l\u00e1sa, amik a kliensre eljuthatnak (pl.: hiba\u00fczenetek) [5]</li> </ul>"},{"location":"homework/hw-points/#kiegeszito-kapcsolodo-technologiak-alkalmazasa","title":"Kieg\u00e9sz\u00edt\u0151, kapcsol\u00f3d\u00f3 technol\u00f3gi\u00e1k alkalmaz\u00e1sa","text":"<ul> <li>Rx.NET haszn\u00e1lata (dokument\u00e1ci\u00f3) [7-10]<ul> <li>n\u00e9h\u00e1ny alap Rx oper\u00e1tor haszn\u00e1lata 7</li> <li>k\u00e9t k\u00fcls\u0151 adatforr\u00e1s integr\u00e1l\u00e1sa 10</li> </ul> </li> <li>F# modul k\u00e9sz\u00edt\u00e9se \u00e9s megh\u00edv\u00e1sa. Legal\u00e1bb az egyik legyen benne ezek k\u00f6z\u00fcl: pattern matching, async, magasabb rend\u0171 f\u00fcggv\u00e9ny [7]</li> <li>k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1r haszn\u00e1lata szerver oldalon. A k\u00fcls\u0151 komponens \u00e1ltal megval\u00f3s\u00edtott funkcionalit\u00e1s\u00e9rt, k\u00e9pess\u00e9g\u00e9rt tov\u00e1bbi pontsz\u00e1m nem adhat\u00f3. Nem sz\u00e1m\u00edt ide a projekt gener\u00e1l\u00e1sakor automatikusan beker\u00fcl\u0151, illetve a Microsoft \u00e1ltal k\u00e9sz\u00edtett, az alaptechnol\u00f3gi\u00e1k f\u00fcgg\u0151s\u00e9geit jelent\u0151 NuGet csomagok [7]</li> <li>platformf\u00fcggetlen k\u00f3db\u00e1zis\u00fa szerveralkalmaz\u00e1s k\u00e9sz\u00edt\u00e9se \u00e9s bemutat\u00e1sa legal\u00e1bb 2 oper\u00e1ci\u00f3s rendszeren az al\u00e1bbiak k\u00f6z\u00fcl: Windows, Linux, Mac, ARM alap\u00fa OS (pl. Raspberry Pi OS). K\u00f6zvetlen futtat\u00e1s fogadhat\u00f3 csak el, pl. kont\u00e9nerb\u0151l val\u00f3 futtat\u00e1s nem (arra van k\u00fcl\u00f6n jogc\u00edm). [3]</li> <li>NET Compiler platform (Roslyn) Diagnostic Analyzer [3-7]<ul> <li>egyszer\u0171 analyzer, pl. property n\u00e9v konvenci\u00f3k ellen\u0151rz\u00e9se 3</li> <li>bonyolultabb analyzer \u00e9s k\u00f3d fix is, pl. kiemel\u00e9s met\u00f3dusba 7</li> </ul> </li> <li>CQRS \u00e9s Medi\u00e1tor tervez\u00e9si minta haszn\u00e1lata a teljes alkalmaz\u00e1sban (MediatR) [5-11]<ul> <li>Commandok \u00e9s Queryk sz\u00e9tv\u00e1laszt\u00e1sa \u00e9s laz\u00e1n csatol\u00e1sa medi\u00e1torral 5</li> <li>Domain esem\u00e9nyek haszn\u00e1lata +3</li> <li>MediatR behavior pipeline kiterjeszt\u00e9se  +3</li> </ul> </li> </ul>"},{"location":"information/afterword/","title":"Z\u00e1rsz\u00f3","text":"<p>Jegyzet\u00fcnk - \u00e9s azt k\u00f6r\u00fcl\u00f6lel\u0151, Szoftverfejleszt\u00e9s .NET platformra tant\u00e1rgyunk - c\u00e9lja, hogy a .NET vil\u00e1ga ir\u00e1nt \u00e9rdekl\u0151d\u0151 hallgat\u00f3k \u00e9s fiatal szakemberek m\u00e9lyebben elsaj\u00e1t\u00edthass\u00e1k a .NET, Entity Framework Core \u00e9s ASP.NET Core ismereteiket. B\u00e1r a jegyzetben kisebb-nagyobb hib\u00e1k el\u0151fordulhatnak, rem\u00e9lj\u00fck, hogy t\u00e9nyszer\u0171 t\u00e9ved\u00e9seket nem v\u00e9tett\u00fcnk. Publik\u00e1l\u00e1s\u00e1val szeretn\u00e9nk, ha a .NET ir\u00e1nt \u00e9rdekl\u0151d\u0151k nagyobb k\u00f6re leln\u00e9 \u00f6r\u00f6m\u00e9t abban, hogy elm\u00e9ly\u00fclhet e leny\u0171g\u00f6z\u0151 \u00f6kosziszt\u00e9m\u00e1ban.</p> <p>A jegyzet publik\u00e1l\u00e1s\u00e1t kor\u00e1bbi hallgat\u00f3ink eredm\u00e9nyei, sikerei is nagyban inspir\u00e1lt\u00e1k.</p>"},{"location":"information/contributing/","title":"Hozz\u00e1j\u00e1rul\u00e1s az anyaghoz","text":"<p>Az anyag terjedelm\u00e9b\u0151l adand\u00f3an apr\u00f3bb hib\u00e1k esetenk\u00e9nt hi\u00e1nyoss\u00e1gok jelentkezhetnek a laborokban. Ha egy ilyennel tal\u00e1lkozol \u00e9s \u00fagy d\u00f6ntesz szeretn\u00e9l seg\u00edteni hallgat\u00f3t\u00e1rsaidnak, azt a k\u00f6vetkez\u0151kben le\u00edrtak alapj\u00e1n tudod megtenni.</p> <p>Plusz pont jegyzet jav\u00edt\u00e1s\u00e9rt</p> <p>M\u00e1s tant\u00e1rgyak mint\u00e1j\u00e1ra itt is szeretn\u00e9nk plusz pontot adni a jegyzet open-source hozz\u00e1j\u00e1rul\u00e1sai\u00e9rt. Akik a t\u00e1rgyat jelenleg hallgatj\u00e1k, pontokat kaphatnak hozz\u00e1j\u00e1rul\u00e1saik\u00e9rrt.</p> <p>A f\u00e9l\u00e9v sor\u00e1n max 3 db plusz pontot lehet szerezni fejenk\u00e9nt olyan jav\u00edt\u00e1sok\u00e9rt, amik a trivi\u00e1lis 1-2 bet\u0171 elg\u00e9pel\u00e9sen t\u00fal \u00e9rdemben jav\u00edtanak a githubon tal\u00e1lhat\u00f3 labor jegyzetek min\u0151s\u00e9g\u00e9n. Pl.: jelent\u0151s mennyis\u00e9g\u0171 elg\u00e9pel\u00e9s jav\u00edt\u00e1sa, egy\u00e9rtelm\u0171s\u00edt\u00e9sek, illusztr\u00e1ci\u00f3k kieg\u00e9sz\u00edt\u00e9sek k\u00e9sz\u00edt\u00e9se vagy ak\u00e1r egy teljes kieg\u00e9sz\u00edt\u0151 jegyzet \u00edr\u00e1sa  (term\u00e9szetesen nem azonos pont\u00e9rt\u00e9kkel).</p> <p>Persze a pont n\u00e9lk\u00fcl az 1-1 bet\u0171s elg\u00e9pel\u00e9seket is sz\u00edvesen fogadjuk, ami bemeleg\u00edt\u00e9snek is t\u00f6k\u00e9letes.</p>"},{"location":"information/contributing/#hibak-jelzese","title":"Hib\u00e1k jelz\u00e9se","text":"<p>Amennyiben hib\u00e1t tal\u00e1lsz az anyagban, vagy szeretn\u00e9d b\u0151v\u00edteni, de nem \u00e1ll m\u00f3dodban jav\u00edtani, nyithatsz egy issue-t amiben le\u00edrod a hib\u00e1t.</p> <ol> <li>N\u00e9zd meg, hogy valaki nem jelezte-e, amit szeretn\u00e9l.     Gyakran m\u00e1r l\u00e9tez\u0151 probl\u00e9m\u00e1kat tal\u00e1lnak, amire m\u00e1r van pull request,     \u00edgy miel\u0151tt b\u00e1rmit tenn\u00e9l n\u00e9zd meg valaki nem el\u0151z\u00f6tt-e meg</li> <li>Az issues tabon a new issue gombbal hozz l\u00e9tre egy \u00faj issue-t.     </li> <li>L\u00e1sd el a megfelel\u0151 c\u00edmk\u00e9kkel<ol> <li>A labor t\u00edpusa (<code>android</code> az androidos laborokn\u00e1l \u00e9s <code>web</code> a webes laborokn\u00e1l)</li> <li>A hiba t\u00edpusa (<code>clarification</code>, <code>typo</code>, <code>illustration</code> vagy <code>notes</code>)</li> </ol> </li> <li>\u00cdrd le, hogy mit k\u00e9ne tartalmaznia a jav\u00edt\u00e1snak</li> </ol> <p>Tip</p> <p>Az c\u00edme legyen r\u00f6vid \u00e9s l\u00e9nyegret\u00f6r\u0151, pl.: <code>Megfogalmaz\u00e1s pontos\u00edt\u00e1sa a 4. laborban</code> vagy <code>A 6. laborban a le\u00edrt k\u00f3d hib\u00e1san m\u0171k\u00f6dik Android 12-n</code></p> <p>A issue descriptionj\u00e9ben pedig fejtsd ki, hol tal\u00e1lhat\u00f3 a hi\u00e1nyoss\u00e1g, illetve ha van r\u00e1 \u00f6tleted, hogy lehetne orvosolni ezt. Ha ezeken t\u00fal m\u00e9g screenshotot is tudsz mell\u00e9kelni, az nagyban megseg\u00edti a probl\u00e9ma mihamarabbi jav\u00edt\u00e1s\u00e1t.</p> <p>Warning</p> <p>A github issues nem a laborfeladatok megold\u00e1s\u00e1val kapcsolatos probl\u00e9m\u00e1k helye, \u00edgy a \"Nem tudom megoldani hogy az \u00e9rtes\u00edt\u00e9s meg\u00e9rkezzen\" jelleg\u0171 probl\u00e9m\u00e1kat ne itt jelezz\u00e9tek, erre vannak a laboralkalmak.</p>"},{"location":"information/contributing/#valtoztatasok-javaslasa","title":"V\u00e1ltoztat\u00e1sok javasl\u00e1sa","text":"<p>Amennyiben a hozz\u00e1j\u00e1rul\u00e1sod meg tudod val\u00f3s\u00edtani ind\u00edts pull requestet</p> <ol> <li> <p>Forkold a repository-t a Githubon jobb fels\u0151 sarokban tal\u00e1lhat\u00f3 gombbal     </p> </li> <li> <p>V\u00e9gezd el a v\u00e1ltoztat\u00e1sokat.</p> <ol> <li> <p>Hozz l\u00e9tre egy branchet a saj\u00e1t forkodon, amin a v\u00e1ltoztat\u00e1sokat el fogod v\u00e9gezni.</p> </li> <li> <p>Ezen a branchen k\u00e9sz\u00edtsd el a jav\u00edt\u00e1sokat</p> </li> <li> <p>Ellen\u0151rizd, hogy ne ker\u00fclj\u00f6n bele a commitba olyan file, amit az editor gener\u00e1lt (pl.: <code>.idea</code> mappa) illetve olyan file aminek nem k\u00e9ne kiker\u00fclnie, pl.: Github Private Access Token</p> </li> <li> <p>Ha k\u00e9sz vagy ind\u00edts egy pull requestet a jegyzeteket tartalmaz\u00f3 rep\u00f3 f\u0151 \u00e1g\u00e1ra.</p> </li> <li> <p>A le\u00edr\u00e1sban r\u00e9szletezd v\u00e1ltoztat\u00e1sok ok\u00e1t.     Ne felejtsd el bele\u00edrni a NEPTUN k\u00f3dod a le\u00edr\u00e1sba, mert \u00edgy fogjuk tudni megadni a pontokat.</p> </li> </ol> </li> <li> <p>Valaki, akinek hozz\u00e1f\u00e9r\u00e9se van a repositoryhoz, ellen\u0151rzi a v\u00e1ltoztat\u00e1sok sz\u00fcks\u00e9gess\u00e9g\u00e9t, \u00e9s elb\u00edr\u00e1lja, hogy val\u00f3ban beker\u00fclhet az anyagba.</p> </li> <li>A v\u00e1ltoztat\u00e1sokra review-t ind\u00edtunk \u00e9s ha kell m\u00f3dos\u00edt\u00e1sokat fogunk k\u00e9rni.</li> <li>Ha minden k\u00e9rt v\u00e1ltoztat\u00e1s megt\u00f6rt\u00e9nt, a hozz\u00e1j\u00e1rul\u00e1sod beleker\u00fcl az anyagba.</li> </ol>"},{"location":"information/contributing/#code-style","title":"Code style","text":"<ul> <li>Markdown: Mivel az alap spec nem mindig a legtiszt\u00e1bban \u00e9rthet\u0151, a markdownlint szab\u00e1lyai alapj\u00e1n, az n\u00e9h\u00e1ny kiv\u00e9tel\u00e9vel. Ezeket a <code>.markdownlint.yaml</code>-ben tal\u00e1lod, ha VSCode-ot haszn\u00e1lsz automatikusan alkalmazza \u0151ket az editor \u00e9s jelzi ha nem megfelel\u0151 amit \u00edrsz.</li> </ul> <p>Ezek a st\u00edlusok a t\u00e1rgyban aj\u00e1nlott editorokban k\u00f6nnyen be\u00e1ll\u00edthat\u00f3ak.</p>"},{"location":"information/contributing/#vscode","title":"VSCode","text":"<p>Aj\u00e1nlott extension\u00f6k:</p> <ul> <li><code>yzhang.markdown-all-in-one</code>: MD szinkroniz\u00e1lt live preview</li> <li><code>DavidAnson.vscode-markdownlint</code>: MD form\u00e1z\u00e1s, szab\u00e1lyok stb.</li> <li>Prettier: HTML+CSS form\u00e1z\u00f3</li> <li>Error Lens: Kiemeli a hib\u00e1kat hogy gyorsabben megtal\u00e1ljuk \u0151ket</li> <li>Paste Image: egyszer\u0171s\u00edti a k\u00e9pek beilleszt\u00e9s\u00e9t markdownba</li> </ul> <p>Az editor be\u00e1ll\u00edt\u00e1s\u00e1hoz nyisd meg a repo-t a gy\u00f6ker\u00e9ben VSCode-al. A VSCode fel fogja aj\u00e1nlani a k\u00e9t markdown extension-t.</p> <p></p> <p>Ha ez megt\u00f6rt\u00e9nt, nyiss meg egy markdown dokumentumot, \u00e9s haszn\u00e1ld a Ctrl+Shift+P shortcutot, a command palette megnyit\u00e1s\u00e1hoz.</p> <p>Tip</p> <p>A command palette a VSCode parancsaihoz ny\u00fajt hozz\u00e1f\u00e9r\u00e9st, autocompleteeli a parancsokat \u00e9s egy minim\u00e1lis GUI-t is biztos\u00edt.</p> <p>A command palette-be keress\u00fck meg a <code>Format Document With...</code> men\u00fcpontot \u00e9s v\u00e1lasszuk ki. Ekkor egy almen\u00fcbe dob az editor \u00e9s kiv\u00e1laszthatjuk hogy melyik form\u00e1z\u00f3val form\u00e1zzuk a MD dokumentumokat. Legalul lesz egy <code>Configure Default Formatter</code>, v\u00e1lasszuk ezt. Ezut\u00e1n v\u00e1lasszuk a <code>markdownlint</code> extensiont, \u00e9s k\u00e9szen vagyunk.</p> <p>Megfelel\u0151 formatter kiv\u00e1laszt\u00e1sa</p> <p>Ne v\u00e1laszd ki a prettiert formatterk\u00e9nt, mert elt\u00f6ri a sz\u00f6vegbubor\u00e9kokat.</p> <p>Ezen fel\u00fcl \u00e9rdemes lehet bekapcsolni a ment\u00e9s el\u0151tti form\u00e1z\u00e1st.</p> <p>A Ctrl+, shortcuttal megnyitjuk a be\u00e1ll\u00edt\u00e1sokat, \u00e9s r\u00e1keres\u00fcnk arra, hogy format on save. Itt kipip\u00e1ljuk a checkboxot \u00e9s k\u00e9szen vagyunk.</p> <p>Ha ehhez nem lenne t\u00fcrelmed, itt a json amit a <code>settings.json</code>-ba illesztve be\u00e1ll\u00edt\u00f3dik minden.</p> <pre><code>{\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"DavidAnson.vscode-markdownlint\",\n    \"editor.formatOnSave\": true\n  }\n}\n</code></pre>"},{"location":"information/preface/","title":"Tudnival\u00f3k","text":""},{"location":"information/preface/#a-jegyzet-celja-es-celkozonsege","title":"A jegyzet c\u00e9lja \u00e9s c\u00e9lk\u00f6z\u00f6ns\u00e9ge","text":"<p>Ezen jegyzet els\u0151dlegesen a BME Villamosm\u00e9rn\u00f6ki \u00e9s Informatikai Kar\u00e1n oktatott Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgyhoz k\u00e9sz\u00fclt, c\u00e9lja, hogy seg\u00edts\u00e9get ny\u00fajtson egyr\u00e9szt a gyakorlatvezet\u0151nek a gyakorlat megtart\u00e1s\u00e1ban, m\u00e1sr\u00e9szt a kurzus hallgat\u00f3inak a gyakorlat otthoni ut\u00f3lagos megism\u00e9tl\u00e9s\u00e9hez, a tanult ismeretek \u00e1tism\u00e9tl\u00e9s\u00e9hez.</p> <p>Ebb\u0151l kifoly\u00f3lag nem tekinthet\u0151 egy teljesen kezd\u0151 szint\u0171 bevezet\u0151 C# tank\u00f6nyvnek, hiszen er\u0151teljesen \u00e9p\u00edt m\u00e1s kari t\u00e1rgyak (pl. Szoftvertechnik\u00e1k, Adatb\u00e1zisok) \u00e1ltal lefedett ismeretekre, de m\u00e9g ink\u00e1bb a Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgy el\u0151ad\u00e1saira.</p> <p>A felt\u00e9telezett el\u0151ismeretek:</p> <ul> <li>C# \u00e9s objektumorient\u00e1lt nyelvi alapok<ul> <li>oper\u00e1torok, v\u00e1ltoz\u00f3k, t\u00f6mb\u00f6k, strukt\u00far\u00e1k, f\u00fcggv\u00e9nyek fogalma</li> <li>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s \u00e9s f\u00fcggv\u00e9nyv\u00e1ltozatok</li> <li>alapvet\u0151 mem\u00f3riakezel\u00e9s (heap, stack), mutat\u00f3k fogalma, \u00e9rt\u00e9k \u00e9s referencia t\u00edpusok</li> <li>alapvet\u0151 vez\u00e9rl\u00e9si szerkezetek (ciklus, el\u00e1gaz\u00e1s, stb.), \u00e9rt\u00e9k- \u00e9s referencia szerinti param\u00e9ter\u00e1tad\u00e1s, rekurzi\u00f3</li> <li>oszt\u00e1ly, oszt\u00e1lyp\u00e9ld\u00e1ny fogalma, static, <code>new</code> oper\u00e1tor, oszt\u00e1ly szint\u0171 v\u00e1ltoz\u00f3k, generikus t\u00edpusok</li> <li>lesz\u00e1rmaz\u00e1s, virtu\u00e1lis tagf\u00fcggv\u00e9nyek</li> <li>C# esem\u00e9ny, delegate t\u00edpusok \u00e9s delegate p\u00e9ld\u00e1nyok</li> <li>Visual Studio haszn\u00e1lat\u00e1nak alapjai</li> <li>oper\u00e1ci\u00f3s rendszer kapcsolatok, folyamatok, sz\u00e1lak, parancssor, parancssori argumentumok, k\u00f6rnyezeti v\u00e1ltoz\u00f3k</li> </ul> </li> <li>SQL nyelvi alapok (SELECT, UPDATE, INSERT, DELETE utas\u00edt\u00e1sok), valamint alapvet\u0151 rel\u00e1ci\u00f3s adatmodell ismeretek (t\u00e1bl\u00e1k, els\u0151dleges- \u00e9s idegen kulcsok)</li> </ul> <p>A fentiek elsaj\u00e1t\u00edt\u00e1s\u00e1hoz seg\u00edts\u00e9get ny\u00fajthatnak Reiter Istv\u00e1n ingyenesen let\u00f6lthet\u0151 k\u00f6nyvei.</p> <p>A sz\u00f6vegben megtal\u00e1lhat\u00f3k a gyakorlatvezet\u0151knek sz\u00f3l\u00f3 kit\u00e9telek (\u201eR\u00f6viden mondjuk el\u2026\", \u201eMutassuk meg\u2026\", stb.). Ezeket mezei olvas\u00f3k\u00e9nt \u00e9rdemes figyelmen k\u00edv\u00fcl hagyni, illetve sz\u00fcks\u00e9g eset\u00e9n a kapcsol\u00f3d\u00f3 elm\u00e9leti ismereteket az el\u0151ad\u00e1sanyagb\u00f3l \u00e1tism\u00e9telni.</p>"},{"location":"information/preface/#a-jegyzet-naprakeszsege","title":"A jegyzet naprak\u00e9szs\u00e9ge","text":"<p>Az anyag gerinc\u00e9t ad\u00f3 .NET Core / .NET 5,6 platform jelenleg igen gyors \u00fctemben fejl\u0151dik. A .NET Core 1.0-s verzi\u00f3 \u00f3ta a k\u00e9sz\u00edt\u0151k t\u00f6rekednek a visszafel\u00e9 kompatibilit\u00e1sra, azonban az eszk\u00f6zk\u00e9szlet \u00e9s a korszer\u0171nek \u00e9s aj\u00e1nlottnak tekinthet\u0151 m\u00f3dszerek folyamatosan v\u00e1ltoznak, finomodnak.</p> <p>A jegyzet els\u0151dlegesen az al\u00e1bbi technol\u00f3giai verzi\u00f3khoz k\u00e9sz\u00fclt:</p> <ul> <li>C# 12</li> <li>.NET 8</li> <li>ASP.NET Core 8</li> <li>Visual Studio 2022</li> </ul> <p>Ahogyan a fenti verzi\u00f3k v\u00e1ltoznak, \u00fagy avulhatnak el a jegyzetben mutatott elj\u00e1r\u00e1sok.</p>"},{"location":"information/preface/#szoftverkornyezet","title":"Szoftverk\u00f6rnyezet","text":"<p>A gyakorlatok az al\u00e1bbi szoftverekb\u0151l \u00e1ll\u00f3 k\u00f6rnyezethez k\u00e9sz\u00fcltek:</p> <ul> <li>Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>Visual Studio 2022 (az ingyenes Community verzi\u00f3 el\u00e9g) az al\u00e1bbi workloadokkal:<ul> <li>.NET desktop development</li> <li>Data storage and processing</li> <li>ASP.NET and web development</li> <li>Azure Development</li> </ul> </li> <li>Telerik Fiddler Classic</li> <li>Postman</li> </ul> <p>A .NET (kor\u00e1bban .NET Core) sz\u00e9lesk\u00f6r\u0171 platformt\u00e1mogat\u00e1sa miatt bizonyos nem Windows platformokon is elv\u00e9gezhet\u0151k a gyakorlatok Visual Studio helyett Visual Studio Code haszn\u00e1lat\u00e1val - azonban a gyakorlatok sz\u00f6vege a Visual Studio haszn\u00e1lat\u00e1t felt\u00e9telezi.</p>"},{"location":"information/preface/#kodreszletek-valtozaskovetese","title":"K\u00f3dr\u00e9szletek v\u00e1ltoz\u00e1sk\u00f6vet\u00e9se","text":"<p>Az egyes gyakorlatok sor\u00e1n gyakori eset, hogy a C# k\u00f3d egy r\u00e9sz\u00e9t tov\u00e1bbfejlesztj\u00fck, megv\u00e1ltoztatjuk. Ilyen esetben a v\u00e1ltoz\u00f3 sorokat a jegyzetben kiemelt h\u00e1tt\u00e9rrel rendelkeznek. A t\u00f6r\u00f6lt k\u00f3dr\u00e9szleteket (amennyiben van seg\u00edti a meg\u00e9rt\u00e9st) kommentez\u00e9ssel jelezz\u00fck. Jel\u00f6lj\u00fck m\u00e9g a megl\u00e9v\u0151, de a jegyzetben nem megjelen\u00edtett k\u00f3dr\u00e9szleteket komment \u00e9s ... (<code>//...</code>) jellel.</p> <pre><code>using System; //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\nusing static System.Console; //ez \u00faj k\u00f3dsor\n\n//... megl\u00e9v\u0151 k\u00f3dr\u00e9szlet az el\u0151z\u0151 feladatokb\u00f3l\n\nforeach (var dog in dogs)    //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\n  /* Console.*/WriteLine(dog); //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n\n/* Console.*/ReadLine();     //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n</code></pre> <p>JSON kommentek</p> <p>A JSON form\u00e1tum alap\u00e9rtelmez\u00e9sben (RFC szerint) nem t\u00e1mogatja a kommenteket, \u00edgy ha JSON k\u00f3dr\u00e9szletet m\u00e1solunk, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy nem maradt-e a beillesztett k\u00f3dban komment, mert probl\u00e9m\u00e1t okozhat.</p>"},{"location":"seminar/01-csharp1/chapter1/","title":"C# alapok, szintaxis","text":"<p>C\u00e9lunk, hogy a hallgat\u00f3k legal\u00e1bb r\u00e9szben meg\u00e9rts\u00e9k \u00e9s r\u00e1\u00e9rezzenek a C# szintaktik\u00e1j\u00e1ra, megismerkedjenek alapvet\u0151 nyelvi elemekkel \u00e9s konstrukci\u00f3kkal.</p>"},{"location":"seminar/01-csharp1/chapter1/#hello-c","title":"Hello C#!","text":"<p>A Visual Studio ind\u00edt\u00f3ablak\u00e1ban v\u00e1lasszuk a <code>Create a new project</code> opci\u00f3t. Magyar\u00e1zzuk el, hogy van lehet\u0151s\u00e9g\u00fcnk el\u0151re gy\u00e1rtott sablonokb\u00f3l l\u00e9trehozni projekteket, illetve hogy</p> <ul> <li>egy C# projekt egy szerelv\u00e9nny\u00e9 fordul (.dll, .exe).</li> <li>a Solution dolga, hogy logikailag \u00f6sszefogja a Project-eket (t\u00f6bb-t\u00f6bbes kapcsolatban vannak).</li> <li>a projektek k\u00f6z\u00f6tt referenci\u00e1kat adhatunk m\u00e1sik projektekre \u00fagy, hogy a ford\u00edt\u00e1si mechanizmus figyelembe veszi a referenci\u00e1kat \u00e9s sz\u00fcks\u00e9g eset\u00e9n \u00fajraford\u00edtja a szerelv\u00e9nyeket.</li> <li>a projektek hivatkozhatnak k\u00fcls\u0151 forr\u00e1sb\u00f3l sz\u00e1rmaz\u00f3 szerelv\u00e9nyekre is NuGet csomagok form\u00e1j\u00e1ban. A NuGet egy egys\u00e9ges m\u00f3dszer szerelv\u00e9nyeink terjeszt\u00e9s\u00e9re.</li> </ul> <p>Hozzunk l\u00e9tre egy \u00faj C# Console Application-t! Ehhez keress\u00fck ki a sablonok k\u00f6z\u00fcl a Console App nev\u0171t (ne a .NET Framework-\u00f6set). A neve legyen HelloCSharp.</p> <p>New Project dialogusablak keres\u0151</p> <p>A kikeres\u00e9shez haszn\u00e1lhatjuk fel\u00fcl a sz\u00f6vegdobozos sz\u0171r\u0151t, illetve a leg\u00f6rd\u00fcl\u0151 list\u00e1s sz\u0171r\u0151ket is (Nyelv: C#, Platform: Windows, Projektt\u00edpus: Console)</p> <p>A sablon konfigur\u00e1ci\u00f3j\u00e1n\u00e1l adjunk meg egy olyan helyet, ahov\u00e1 van \u00edr\u00e1si jogunk. A Place solution and project in the same directory opci\u00f3t kapcsoljuk be, \u00edgy nem fog l\u00e9trej\u00f6nni egy felesleges mappa a k\u00f6nyvt\u00e1rszerkezetben. A .NET verzi\u00f3t \u00e1ll\u00edtsuk .NET 8-ra.</p> <p>\u00c9szrevehetj\u00fck, hogy az alkalmaz\u00e1s sablonok k\u00f6z\u00f6tt sima \u00e9s (.NET Framework) jel\u00f6l\u00e9s\u0171ek is vannak. A sim\u00e1k alapvet\u0151en a modernebb .NET Core/.NET 5-8 platformot c\u00e9lozz\u00e1k, a .NET Framework ezekhez k\u00e9pest egy r\u00e9gebbi platform.</p> <ul> <li>.NET Core: a .NET Framework modulariz\u00e1lt, moderniz\u00e1lt, cross-platform \u00e9s ny\u00edlt forr\u00e1sk\u00f3d\u00fa megval\u00f3s\u00edt\u00e1sa. Kisebb NuGet csomagokban \u00e9rhet\u0151 el a teljes .NET Framework funkcionalit\u00e1sa (Collections, Reflection, XML feldolgoz\u00e1s, stb.).</li> <li>.NET Framework: a \u201eklasszikus\u201d, teljes\u00e9rt\u00e9k\u0171 .NET keretrendszer, out-of-the-box t\u00e1mogatja a legelterjedtebb alkalmaz\u00e1sfejleszt\u00e9si lehet\u0151s\u00e9geket. A .NET Core megjelen\u00e9s\u00e9t k\u00f6vet\u0151en is t\u00e1mogatott, enterprise k\u00f6rnyezetekben haszn\u00e1latos, ugyanis n\u00e9h\u00e1ny enterprise technol\u00f3gia els\u0151dlegesen csak ebben t\u00e1mogatott (pl. szerver oldali WCF). Csak Windows-ra telep\u00edthet\u0151.</li> <li>.NET 5 \u00e9s f\u00f6l\u00f6tte: A .NET Core 3.1 ut\u00e1ni f\u0151 verzi\u00f3i. M\u00e1r elnevez\u00e9s\u00e9ben is jelzi, hogy ez egyben a kor\u00e1bbi .NET Core \u00e9s .NET Framework verzi\u00f3knak is ut\u00f3dja.</li> </ul> <p>Az al\u00e1bbi elemeket ismertethetj\u00fck, miel\u0151tt a k\u00f3d\u00edr\u00e1sba belekezd\u00fcnk:</p> <ul> <li>R\u00f6vid \u00e1ttekint\u00e9s az IDE-r\u0151l: men\u00fcs\u00e1v, Solution Explorer, Properties, Output, Error List ablakok, ablakoz\u00f3rendszer. Mutassuk meg, hogy drag-n-drop m\u0171veletekkel testreszabhat\u00f3 a fel\u00fclet, pl. helyezz\u00fck a Solution Explorert a k\u00e9perny\u0151 bal oldal\u00e1ra. Ha valaki v\u00e9letlen\u00fcl \u00e1trendezi az alap\u00e9rtelmezett elrendez\u00e9st, a menu:Window[Reset Window Layout] lehet\u0151s\u00e9ggel vissza\u00e1ll\u00edthatja.</li> <li>A projekt tulajdons\u00e1gok (menu:jobb klikk[Properties]) oldal\u00e1n az Application f\u00fcl\u00f6n megn\u00e9zhetj\u00fck, hogy az Output type \u00e9rt\u00e9ke hat\u00e1rozza meg, hogy milyen jelleg\u0171 (konzolos, Windows, oszt\u00e1lyk\u00f6nyvt\u00e1r) alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk.</li> <li>Mutassuk meg, hogy milyen alapvet\u0151 szerelv\u00e9nyekre adunk referenci\u00e1t a projektben!</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> f\u00e1jl tartalm\u00e1t \u00e9s fussuk \u00e1t a l\u00e1that\u00f3 elemeket!</li> <li>Magyar\u00e1zzuk el a <code>using</code> \u00e9s <code>namespace</code> kulcsszavak jelent\u00e9s\u00e9t, egym\u00e1shoz k\u00e9pesti viszonyukat! A n\u00e9vt\u00e9r \u00e9rt\u00e9ke egy \u00fajonnan l\u00e9trehozott f\u00e1jln\u00e1l alap\u00e9rtelmezetten Projektn\u00e9v.Mappaszerkezet alak\u00fa, \u00e9rdemes konvencion\u00e1lisan ezt k\u00f6vetni. Sok hallgat\u00f3n\u00e1l nem tiszta, hogy hogyan viszonyul egym\u00e1shoz a n\u00e9vt\u00e9r \u00e9s a szerelv\u00e9ny fogalma, ez\u00e9rt pr\u00f3b\u00e1ljuk meg ezt tiszt\u00e1zni!</li> <li>Utaljunk arra, hogy alapvet\u0151en kiz\u00e1r\u00f3lag objektumorient\u00e1ltan tudunk k\u00f3dot \u00edrni, \u00edgy a <code>Program</code> egy oszt\u00e1ly, a <code>Main</code> bel\u00e9p\u00e9si pont pedig egy statikus met\u00f3dus.</li> <li>Besz\u00e9lj\u00fcnk r\u00f6viden a C# elnevez\u00e9si konvenci\u00f3kr\u00f3l! A publikus elemeket (pl. Java-val \u00e9s JavaScripttel ellent\u00e9tben) \u00e9s minden met\u00f3dust \u00f6k\u00f6lszab\u00e1lyk\u00e9nt PascalCasing elnevez\u00e9si konvenci\u00f3 k\u00f6vet, a nem publikus elemekn\u00e9l camelCasing (ezek k\u00f6z\u00fcl vannak kiv\u00e9telek \u00e9s m\u00e1s konvenci\u00f3k, de ez egy gyakori megk\u00f6zel\u00edt\u00e9s).</li> </ul> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> met\u00f3dust az al\u00e1bbi k\u00f3dr\u00e9szlettel, k\u00f6zben h\u00edvjuk fel a figyelmet az IntelliSense haszn\u00e1lat\u00e1ra:</p> <pre><code>int a = 5;\nint b = 7;\nConsole.WriteLine(a + b);\nConsole.ReadLine();\n</code></pre> <p>Az IntelliSense-t demonstr\u00e1lhatjuk az al\u00e1bbi m\u00f3don:</p> <ul> <li>A k\u00f3dban b\u00e1rmely logikus helyen haszn\u00e1lhat\u00f3 az IntelliSense a Ctrl+Space billenty\u0171kombin\u00e1ci\u00f3val, ezen k\u00edv\u00fcl alap\u00e9rtelmezetten felugrik k\u00f3d\u00edr\u00e1s k\u00f6zben is.</li> <li>\u00cdrjuk be a <code>Console</code> \u00e9s a <code>.WriteLine()</code> elemeket \u00fagy, hogy g\u00e9pel\u00e9s k\u00f6zben az IntelliSense leg\u00f6rd\u00fcl\u0151b\u0151l v\u00e1lasszuk ki az elemet, majd Tab billenty\u0171vel v\u00e9gleges\u00edts\u00fck a v\u00e1laszt\u00e1st.</li> <li>Haszn\u00e1ljuk a <code>cw</code> code snippetet, amit az IntelliSense is jelez, azaz \u00edrjuk be: <code>cw</code> majd nyomjunk k\u00e9tszer Tab-ot.</li> <li>Ha a <code>Console.ReadLine()</code> helyett <code>Console.Readline()</code>-t \u00edrunk, els\u0151k\u00e9nt az IDE azonnal jav\u00edtja a hib\u00e1t. Ha ezt a jav\u00edt\u00e1st visszavonjuk Ctrl+Z), lehet\u0151s\u00e9g\u00fcnk van a jav\u00edt\u00e1sra a Ctrl+. haszn\u00e1lat\u00e1val: a fejleszt\u0151eszk\u00f6z \u00e9szreveszi, hogy hib\u00e1t v\u00e9tett\u00fcnk, \u00e9s felk\u00edn\u00e1lja a gyakori megold\u00e1sokat.</li> <li>Overload-ok: jel\u00f6lj\u00fck ki a <code>WriteLine</code> h\u00edv\u00e1s nyit\u00f3 z\u00e1r\u00f3jel\u00e9t, \u00e9s \u00edrjuk be ism\u00e9t a nyit\u00f3 z\u00e1r\u00f3jelet. \u00cdgy el\u0151j\u00f6n az overload-ok list\u00e1ja, amik k\u00f6z\u00fcl a megfelel\u0151t a f\u00f6l/le ir\u00e1nybillenty\u0171kkel v\u00e1laszthatjuk ki. Az overload list\u00e1t megnyithatjuk \u00fagy is, hogy a z\u00e1r\u00f3jelben b\u00e1rhova \u00edrunk egy vessz\u0151 karaktert. Az overload azt jelenti, hogy ugyanazzal a f\u00fcggv\u00e9nyn\u00e9vvel t\u00f6bb, k\u00fcl\u00f6nb\u00f6z\u0151 szignat\u00far\u00e1j\u00fa met\u00f3dust is felvehet\u00fcnk, a megfelel\u0151 f\u00fcggv\u00e9ny kiv\u00e1laszt\u00e1sa a megadott param\u00e9terek sz\u00e1ma \u00e9s t\u00edpusa alapj\u00e1n t\u00f6rt\u00e9nik.</li> </ul> <p>Ind\u00edtsuk el az alkalmaz\u00e1st! Ehhez a fent tal\u00e1lhat\u00f3 Start lehet\u0151s\u00e9get haszn\u00e1lhatjuk, de mondjuk el, hogy ez a men\u00fc menu:Debug[Start Debugging] (F5) lehet\u0151s\u00e9ggel ekvivalens.</p> <p>Mutassuk be a <code>for</code> \u00e9s <code>foreach</code> vez\u00e9rl\u00e9si szerkezeteket! A projekt Properties oldal\u00e1n (kbd:[Alt+Enter] a projekt kijel\u00f6l\u00e9se ut\u00e1n) adjunk meg a Debug f\u00fcl\u00f6n a Start Options blokkn\u00e1l legal\u00e1bb \u00f6t tetsz\u0151leges parancssori argumentumot (sz\u00f3k\u00f6zzel elv\u00e1lasztva), pl. kutya alma b\u00e9ka ban\u00e1n l\u00f3.</p> <p> .NET projektbe\u00e1ll\u00edt\u00e1sok</p> <pre><code>for (int i = 0; i &lt; args.Length; i++)\n    Console.WriteLine(args[i]);\n\nforeach (string arg in args)\n    Console.WriteLine(arg);\n\nConsole.ReadLine();\n</code></pre> <p>Ind\u00edtsuk el, \u00e9s gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk.</p>"},{"location":"seminar/01-csharp1/chapter1/#debug","title":"Debug","text":"<p>Rakjunk egy breakpointot (F9), vagy klikkelj\u00fcnk baloldalon a f\u00fcgg\u0151leges s\u00e1von a k\u00f3d sorsz\u00e1ma mellett) a <code>Console.WriteLine(args[i]);</code> sorra, majd ind\u00edtsuk \u00fajra az alkalmaz\u00e1st! Amikor a breakpointon meg\u00e1ll az alkalmaz\u00e1s fut\u00e1sa, a sor s\u00e1rga sz\u00edn\u0171 lesz. Ekkor vigy\u00fck az egeret az <code>i</code>, az <code>args</code> \u00e9s az <code>args.Length</code> elemek fel\u00e9, \u00e9s mutassuk meg, hogy l\u00e1thatjuk az aktu\u00e1lis \u00e9rt\u00e9keiket, komplexebb objektumok eset\u00e9n be tudjuk j\u00e1rni az objektumgr\u00e1fot. A Watch ablakba is \u00edrhatunk kifejez\u00e9seket, \u00e9s megmutathatjuk a Locals ablakot is. F10-zel (vagy a men\u00fcsoron a Step Over elemmel) l\u00e9pj\u00fcnk tov\u00e1bb, n\u00e9zz\u00fck meg, milyen sorrendben \u00e9rt\u00e9kel\u0151dik ki a <code>for</code> ciklus. Az F5-tel tov\u00e1bbengedhetj\u00fck az alkalmaz\u00e1s fut\u00e1s\u00e1t, majd z\u00e1rjuk is be.</p> <p>Mutassuk meg a Conditional Breakpoint haszn\u00e1lat\u00e1t is. Tegy\u00fcnk m\u00e9g egy breakpointot a m\u00e1sik <code>Console.WriteLine</code>-ra is. menu:Jobb eg\u00e9r gomb az els\u0151 breakpointon[Conditions\u2026], majd adjuk meg az al\u00e1bbiakat: Conditional Expression Is true <code>(i == 3)</code>. A m\u00e1sik breakpointon is adjunk meg felt\u00e9telt: Hit Count = 4. Mindk\u00e9t alkalommal a 4. elemen (ban\u00e1n) \u00e1llunk meg. Megjegyezhetj\u00fck, hogy a Conditional Breakpoint haszn\u00e1lat\u00e1val nem \u00e9rdemes mell\u00e9khat\u00e1st okoz\u00f3 m\u0171veleteket megadni, illetve hogy jelent\u0151sen le tudja cs\u00f6kkenteni a debuggol\u00e1s sebess\u00e9g\u00e9t.</p>"},{"location":"seminar/01-csharp1/chapter1/#tulajdonsagok-property-k","title":"Tulajdons\u00e1gok (Property-k)","text":"<p>Hozzuk l\u00e9tre a <code>Person</code> adatoszt\u00e1lyt! Ehhez menu: jobb katt a projekten[Add &gt; Class], a f\u00e1jl neve legyen <code>Person</code> (a kiterjeszt\u00e9st automatikusan hozz\u00e1biggyeszti a Visual Studio, ha nem adjuk meg). .NET-ben nincs megk\u00f6t\u00e9s arra, hogy a k\u00f3dokat tartalmaz\u00f3 f\u00e1jlok \u00e9s az egyes t\u00edpusok sz\u00e1moss\u00e1ga hogyan viszonyul egym\u00e1shoz: lehets\u00e9ges egy k\u00f3df\u00e1jlba is \u00edrnunk a teljes alkalmaz\u00e1s-k\u00f3dot, illetve egy oszt\u00e1lyt is sz\u00e9tdarabolhatunk t\u00f6bb f\u00e1jlra (ehhez a <code>partial</code> kulcssz\u00f3t haszn\u00e1ljuk).</p> <p>A C# tulajdons\u00e1g (property) egy szintaktikai \u00e9des\u00edt\u0151szer, amely egy objektump\u00e9ld\u00e1ny (vagy oszt\u00e1ly) egy explicit (mem\u00f3riabeli) vagy implicit (sz\u00e1rmaztatott vagy indirekt) jellemz\u0151j\u00e9t \u00edrja le. Egy tulajdons\u00e1ggal k\u00e9t m\u0171velet v\u00e9gezhet\u0151: lek\u00e9rdez\u00e9s (get) \u00e9s \u00e9rt\u00e9kad\u00e1s (set); ezeknek megadhat\u00f3 k\u00fcl\u00f6n a l\u00e1that\u00f3s\u00e1ga, \u00e9s a kett\u0151 k\u00f6z\u00fcl elegend\u0151 egy implement\u00e1l\u00e1sa. A legt\u00f6bb C# szintaktikai \u00e9des\u00edt\u0151szer a boilerplate k\u00f3dok \u00edr\u00e1s\u00e1nak elker\u00fcl\u00e9se v\u00e9gett k\u00e9sz\u00fclt, \u00edgy kevesebb k\u00f3dol\u00e1ssal \u00e9rj\u00fck el ugyanazt az eredm\u00e9nyt (sokszor az IL k\u00f3d nem is v\u00e1ltozik, gyakorlatilag hasonl\u00f3 a k\u00f3dgener\u00e1l\u00e1shoz).</p> <p>A <code>Person</code> oszt\u00e1lyban hozzuk l\u00e9tre a <code>string Name</code> property-t, <code>name</code> oszt\u00e1lyv\u00e1ltoz\u00f3val (field). Ehhez haszn\u00e1ljuk a <code>propfull</code> code snippetet (<code>propf</code>, majd Tab+Tab, ezut\u00e1n Tab-bal lehet l\u00e9pkedni a m\u00f3dos\u00edtand\u00f3 elemek k\u00f6z\u00f6tt):</p> <pre><code>public class Person\n{\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        private set { name = value; }\n    }\n\n    public Person(string name)\n    {\n        this.name = name;\n    }\n}\n</code></pre> <p>L\u00e1that\u00f3s\u00e1g</p> <p>Figyelj\u00fcnk az oszt\u00e1ly l\u00e1that\u00f3s\u00e1g\u00e1ra is, alapb\u00f3l nem publikusk\u00e9nt gener\u00e1l\u00f3dik!</p> <p>Igaz\u00e1b\u00f3l csak k\u00e9t tov\u00e1bbi (k\u00f3dban nem l\u00e1that\u00f3) met\u00f3dust hozunk l\u00e9tre, mintha egy-egy <code>GetName</code> \u00e9s <code>SetName</code> met\u00f3dust k\u00e9sz\u00edten\u00e9nk, viszont haszn\u00e1lat szempontj\u00e1b\u00f3l ugyanolyannak t\u0171nik, mintha egy sima mez\u0151 lenne. A settert priv\u00e1t l\u00e1that\u00f3s\u00e1g\u00fara tessz\u00fck, ez\u00e9rt csak egy <code>Person</code> p\u00e9ld\u00e1nyon bel\u00fclr\u0151l tudjuk \u00e1ll\u00edtani a <code>Name</code> property \u00e9rt\u00e9k\u00e9t. Jegyezz\u00fck meg, hogy a getterben \u00e9s setterben teljesen m\u00e1s jelleg\u0171 m\u0171veleteket is v\u00e9gezhet\u00fcnk (pl. els\u00fcthet\u00fcnk egy esem\u00e9nyt, hogy megv\u00e1ltozott a felhaszn\u00e1l\u00f3 neve, napl\u00f3zhatjuk, h\u00e1nyszor k\u00e9rt\u00e9k le a nev\u00e9t, stb.). A property egyik nagy er\u00e9nye, hogy oszt\u00e1lyon k\u00edv\u00fclr\u0151l az oszt\u00e1lyv\u00e1ltoz\u00f3kn\u00e1l megszokott szintaxissal haszn\u00e1lhatjuk.</p> <p>A <code>Main</code> f\u00fcggv\u00e9nybe \u00edrhatjuk p\u00e9ld\u00e1ul:</p> Program.cs<pre><code>Person p = new Person(\"Eric Lippert\");\np.Name = \"Mads Torgersen\";\nConsole.WriteLine(p.Name);\n</code></pre> <p>Debuggerrel figyelj\u00fck meg, hogy az els\u0151 sor a konstruktort, m\u00edg a m\u00e1sodik a property setter\u00e9t, v\u00e9g\u00fcl a harmadik sor ugyanazon property getter\u00e9t h\u00edvja.</p> <p>Mivel a backing field \u00e1ll\u00edt\u00e1s\u00e1n k\u00edv\u00fcl nem csin\u00e1lunk semmit a property k\u00f3dban, ez\u00e9rt haszn\u00e1lhatjuk a <code>propg</code> code snippetet is:</p> Person.cs<pre><code>public string Name { get; private set; }\n</code></pre> <p>Ez az \u00fan. auto-implement\u00e1lt property szintaxis. A property \u00e1ltal lek\u00e9rdezhet\u0151-be\u00e1ll\u00edthat\u00f3 field gener\u00e1l\u00f3dik, arra a k\u00f3dban nem is tudunk hivatkozni - ez az egys\u00e9gbe z\u00e1r\u00e1s miatt el\u0151ny\u00f6s.</p> <p>A l\u00e1that\u00f3s\u00e1g miatt a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben a setter h\u00edv\u00e1s m\u00e1r nem fordul, kommentezz\u00fck ki.</p> Person.cs<pre><code>//p.Name = \"Mads Torgersen\";\n</code></pre> <p>L\u00e9tezik m\u00e9g a <code>prop</code> code snippet is, ami mindk\u00e9t m\u00f3dos\u00edt\u00f3sz\u00f3t publikusan hagyja. L\u00e1that\u00f3s\u00e1gi m\u00f3dos\u00edt\u00f3sz\u00f3t a <code>get</code> \u00e9s <code>set</code> k\u00f6z\u00fcl csak az egyik el\u00e9 tehet\u00fcnk ki, \u00e9s az is csak szigor\u00edthat a k\u00fcls\u0151 l\u00e1that\u00f3s\u00e1gon (ekkor a m\u00e1sik a k\u00fcls\u0151t kapja meg).</p> <p>Ez a megold\u00e1s az el\u0151z\u0151vel teljes m\u00e9rt\u00e9kben ekvivalens (csak nem l\u00e1tjuk a gener\u00e1lt backing fieldet, de val\u00f3j\u00e1ban ott van). Ha van id\u0151nk, akkor vizsg\u00e1ljuk meg decompilerben (pl. Telerik JustDecompile), hogy val\u00f3ban \u00edgy van.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3an vegy\u00fck fel a sz\u00fclet\u00e9si d\u00e1tumot is. A sz\u00fclet\u00e9si d\u00e1tum nem v\u00e1ltozhat, gyakorlatilag <code>readonly</code> mez\u0151r\u0151l van sz\u00f3. Ha egy tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t az objektum is csak a konstruktorban tudja megadni, akkor a setter teljes m\u00e9rt\u00e9kben elhagyhat\u00f3:</p> Person.cs<pre><code>public DateTime DateOfBirth { get; }\n\npublic Person(string name, DateTime dateOfBirth)\n{\n    Name = name;\n    DateOfBirth = dateOfBirth;\n}\n</code></pre> <p>Ez a szintaktika megegyezik azzal, mintha egy <code>readonly</code> mez\u0151t haszn\u00e1ln\u00e1nk, azaz a mez\u0151 \u00e9rt\u00e9ke legk\u00e9s\u0151bb a konstruktorban inicializ\u00e1land\u00f3.</p> <p>Vegy\u00fcnk fel neki egy azonos\u00edt\u00f3t, ami egy <code>Guid</code> strukt\u00fara t\u00edpus\u00fa legyen:</p> Person.cs<pre><code>public Guid Id { get; } = Guid.NewGuid();\n</code></pre> <p>Ez egy csak lek\u00e9rdezhet\u0151 tulajdons\u00e1g, ami konstru\u00e1l\u00e1skor inicializ\u00e1l\u00f3dik egy \u00faj v\u00e9letlenszer\u0171 azonos\u00edt\u00f3 \u00e9rt\u00e9kre.</p> <p>Megadhatjuk a kort, mint implicit/sz\u00e1m\u00edtott tulajdons\u00e1got:</p> Person.cs<pre><code>public int Age { get { return DateTime.Now.Subtract(DateOfBirth).Days / 365; } }\n</code></pre> <p>Mivel a f\u00fcggv\u00e9ny\u00fcnk t\u00f6rzse egyetlen kifejez\u00e9ssel megadhat\u00f3, ez\u00e9rt elhagyva a sallangot (<code>return</code>, kapcsos z\u00e1r\u00f3jelek, stb.) expression bodied property szintaxissal is \u00edrhatjuk:</p> Person.cs<pre><code>public int Age =&gt; DateTime.Now.Subtract(DateOfBirth).Days / 365;\n</code></pre> <p>Tip</p> <p>Alkalmaz\u00e1sok fejleszt\u00e9sekor a legfontosabb els\u0151 l\u00e9p\u00e9sek egyike, hogy az objektummodell\u00fcnk \u00e1tl\u00e1that\u00f3, karbantarthat\u00f3 \u00e9s egy\u00e9rtelm\u0171 legyen. A C# v\u00e1ltozatos szintaxisa nagyon sokat seg\u00edt ezen c\u00e9lok el\u00e9r\u00e9s\u00e9ben.</p>"},{"location":"seminar/01-csharp1/chapter1/#generikus-kollekcio","title":"Generikus kollekci\u00f3","text":"<p>A <code>Main</code> met\u00f3dusban vegy\u00fcnk fel n\u00e9h\u00e1ny <code>Person</code> objektumot, \u00e9s list\u00e1zzuk ki a relev\u00e1ns tulajdons\u00e1gaikat! Ehhez egy <code>Person</code> list\u00e1ban t\u00e1roljuk a szem\u00e9lyeket. A <code>List</code> generikus kollekci\u00f3, azaz t\u00edpusparam\u00e9tert v\u00e1r, t\u00edpusokkal param\u00e9terezhet\u0151. A <code>List</code> t\u00edpusparam\u00e9tere jelzi, hogy milyen t\u00edpus\u00fa objektumokat t\u00e1rol. Met\u00f3dusok, tulajdons\u00e1gok, t\u00edpusok lehetnek generikusak. A genericit\u00e1s fontos a k\u00f3dunk \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1ga \u00e9s karbantarthat\u00f3s\u00e1ga \u00e9rdek\u00e9ben.</p> <pre><code>static void Main(string[] args)\n{\n    List&lt;Person&gt; people = new List&lt;Person&gt;();\n    people.Add(new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)));\n    people.Add(new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)));\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n\n    foreach (Person person in people)\n        Console.WriteLine(person);\n\n    Console.ReadLine();\n}\n</code></pre> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, mi t\u00f6rt\u00e9nik! Annyiszor \u00edr\u00f3dik ki a <code>Person</code> oszt\u00e1lyunk teljes neve (fully qualified type name), ah\u00e1ny elem van a list\u00e1ban.</p>"},{"location":"seminar/01-csharp1/chapter1/#leszarmazas-string-interpolacio","title":"Lesz\u00e1rmaz\u00e1s, string interpol\u00e1ci\u00f3","text":"<p>Ha a <code>WriteLine</code> f\u00f6l\u00e9 vissz\u00fck az egeret, l\u00e1that\u00f3, hogy az overload-ok k\u00f6z\u00fcl az h\u00edv\u00f3dik meg, amelyik objektumot v\u00e1r param\u00e9ter\u00fcl. Ebben az esetben a param\u00e9ter <code>ToString</code> met\u00f3dus\u00e1t h\u00edvja meg a <code>WriteLine</code>, ami alap\u00e9rtelmez\u00e9s szerint az objektum t\u00edpus\u00e1nak teljes nev\u00e9t adj\u00e1k vissza. Tegy\u00fck szebb\u00e9 a ki\u00edr\u00e1st, defini\u00e1ljuk fel\u00fcl az alap\u00e9rtelmezett <code>ToString</code> implement\u00e1ci\u00f3t a <code>Person</code> oszt\u00e1lyban:</p> Person.cs<pre><code>public override string ToString()\n{\n    return string.Format(\"{0} ({1}) [ID: {2}]\", Name, Age, Id);\n}\n</code></pre> <p>A <code>Person</code> oszt\u00e1lynak nincs explicit megadva \u0151soszt\u00e1lya, m\u00e9gis van fel\u00fcldefini\u00e1lhat\u00f3 f\u00fcggv\u00e9nye. Ezeket az <code>Object</code> oszt\u00e1ly defini\u00e1lja. Ha egy referencia t\u00edpusnak nincs megadva \u0151soszt\u00e1lya, akkor az <code>Object</code> lesz az.</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1ra m\u00e1s szintaktikai \u00e9des\u00edt\u0151szereket is haszn\u00e1lhatunk:</p> Person.cs<pre><code>public override string ToString() =&gt; $\"{Name} ({Age}) [ID: {Id}]\";\n</code></pre> <p>A k\u00e9t implement\u00e1ci\u00f3 ekvivalens, a m\u00e1sodik implement\u00e1ci\u00f3 az \u00fan. expression bodied method \u00e9s a string interpol\u00e1ci\u00f3 kombin\u00e1l\u00e1s\u00e1b\u00f3l ad\u00f3dik.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st!</p> <p>Hozzuk l\u00e9tre a <code>Student</code> oszt\u00e1lyt, ami sz\u00e1rmazik a <code>Person</code> oszt\u00e1lyb\u00f3l!</p> <pre><code>public class Student : Person\n{\n    public string Neptun { get; set; }\n\n    public string Major { get; set; }\n\n    public Student(string name, DateTime dateOfBirth)\n        : base(name, dateOfBirth)\n    {\n    }\n\n    public override string ToString() =&gt; $\"{base.ToString()} Neptun: {Neptun} Major: {Major}\";\n}\n</code></pre> <p>Ez az oszt\u00e1ly m\u00e1s megk\u00f6zel\u00edt\u00e9ssel k\u00e9sz\u00fclt, mint a sz\u00fcl\u0151je, az \u00e1llapota nem a konstruktor megh\u00edv\u00e1sakor t\u00f6lt\u0151dik fel, ut\u00f3lag lehet megadni setter h\u00edv\u00e1sokkal. Ez egyr\u00e9szt k\u00e9nyelmes, mert nem kell sokparam\u00e9teres konstruktorokkal k\u00fczdeni, m\u00e1sr\u00e9szt fel kell k\u00e9sz\u00fcln\u00fcnk arra, hogy bizonyos adatokat nem t\u00f6ltenek ki.</p> <p>\u0150s konstruktora</p> <p>Ha az \u0151soszt\u00e1lynak nincs param\u00e9ter n\u00e9lk\u00fcli konstruktora (a <code>Person</code> oszt\u00e1lynak nincs), akkor k\u00f6telesek vagyunk a gyerek konstruktorban az \u0151soszt\u00e1ly valamelyik konstruktor\u00e1t megh\u00edvni a <code>base</code> kulcssz\u00f3val.</p>"},{"location":"seminar/01-csharp1/chapter1/#objektum-inicializalok","title":"Objektum inicializ\u00e1l\u00f3k","text":"<p>Az object initializer seg\u00edts\u00e9g\u00e9vel az objektum l\u00e9trehoz\u00e1s\u00e1t (konstruktor h\u00edv\u00e1s) \u00e9s a property setterek megh\u00edv\u00e1s\u00e1val t\u00f6rt\u00e9n\u0151 inicializ\u00e1l\u00e1s\u00e1t int\u00e9zhetj\u00fck egy f\u00fcst alatt.  Az objektum inicializ\u00e1l\u00f3 csak konstruktorh\u00edv\u00e1s eset\u00e9n haszn\u00e1lhat\u00f3, \u00edgy pl. factory met\u00f3dus \u00e1ltal gy\u00e1rtott objektump\u00e9ld\u00e1ny eset\u00e9n nem.</p> <p>A <code>Main</code> met\u00f3dusban \u00edrhatjuk az al\u00e1bbi p\u00e9ld\u00e1t:</p> <pre><code>static void Main(string[] args)\n{\n    /*...*/\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n    Student elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major = \"Info BSc\"\n    };\n    /*...*/\n}\n</code></pre> <p>Konstruktor szintaktik\u00e1k</p> <p>Objektum inicializ\u00e1l\u00e1s sor\u00e1n, param\u00e9ter n\u00e9lk\u00fcli konstruktor eset\u00e9n a <code>()</code> is elhagyhat\u00f3.</p> <p>T\u00f6bb sorba t\u00f6rdel\u00e9s</p> <p>\u00c1ltal\u00e1ban 1-2 tulajdons\u00e1g eset\u00e9n lehet egy sorba is \u00edrni az inicializ\u00e1ci\u00f3t, t\u00f6bb eset\u00e9n viszont \u00e1ltal\u00e1ban t\u00f6bb sorba \u00e9rdemes t\u00f6rdelni az olvashat\u00f3s\u00e1g \u00e9rdek\u00e9ben.</p> <p>L\u00e1thatjuk, hogy csak az aktu\u00e1lis kontextusban egy\u00e9bk\u00e9nt is l\u00e1that\u00f3 \u00e9s be\u00e1ll\u00edthat\u00f3 tulajdons\u00e1gokat \u00e1ll\u00edthatjuk be, egyik \u00edgy be\u00e1ll\u00edtott tulajdons\u00e1g sem k\u00f6telez\u0151 jelleg\u0171.</p> <p>Az object initializer val\u00f3ban csak az egyes tulajdons\u00e1gokat \u00e1ll\u00edtja be, teh\u00e1t csak szintaktikailag k\u00fcl\u00f6nb\u00f6zik az els\u0151 defin\u00edci\u00f3 az al\u00e1bbit\u00f3l:</p> <p>Note</p> <p>Nem kell be\u00edrni, csak szeml\u00e9ltet\u00e9s.</p> <pre><code>Student _elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10));\n_elek.Neptun = \"ABC123\";\n_elek.Major = \"Info BSc\";\nStudent elek = _elek;\n</code></pre> <p>A h\u00e1tt\u00e9rben t\u00e9nyleg egy (sz\u00e1munkra nem l\u00e1that\u00f3) tempor\u00e1lis v\u00e1ltoz\u00f3ban fog t\u00f6rt\u00e9nni az inicializ\u00e1ci\u00f3, ugyanis, ha az object initializer kiv\u00e9telt dob (az egyik setter \u00e1ltal), az objektumunk nem veszi fel a k\u00edv\u00e1nt \u00e9rt\u00e9ket.</p> <p>Objektum inicializ\u00e1l\u00f3 haszna</p> <p>Ebb\u0151l l\u00e1tszik az objektum inicializ\u00e1l\u00f3 els\u0151dleges haszna, m\u00e9gpedig, hogy nem kell \u00e1lland\u00f3an ki\u00edrogatni, hogy melyik p\u00e9ld\u00e1nyra gondolunk (\u00edgy elrontani sem tudjuk).</p>"},{"location":"seminar/01-csharp1/chapter1/#kollekcio-inicializacio","title":"Kollekci\u00f3 inicializ\u00e1ci\u00f3","text":"<p>Az egyszer\u0171s\u00edtett kollekci\u00f3 inicializ\u00e1ci\u00f3 szintaxissal a lista teljes felt\u00f6lt\u00e9se j\u00f3val kevesebb k\u00f3ddal \u00e9s j\u00f3val olvashat\u00f3bban megadhat\u00f3. R\u00e1ad\u00e1sul a kollekci\u00f3 elemeit l\u00e9trehozhatjuk az objektum inicializ\u00e1ci\u00f3s szintaxissal is. A teljes lista l\u00e9trehoz\u00e1st \u00e9s -felt\u00f6lt\u00e9s r\u00e9szt cser\u00e9lj\u00fck le az al\u00e1bbira.</p> <pre><code>List&lt;Person&gt; people = new List&lt;Person&gt;\n{\n    new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)),\n    new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)),\n    new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)),\n    new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major=\"Info BSc\"\n    },\n    new Student(\"Hi\u00e1ny \u00c1ron\", new DateTime(2000, 02, 13))\n};\n</code></pre> <p>Nem kell az <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1st \u00e9s a lista referenci\u00e1t ki\u00edrni, egy\u00e9rtelm\u0171, hogy melyik list\u00e1hoz adunk hozz\u00e1.</p> <p>Add</p> <p>Ez a forma is ugyanolyan <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokra fordul, mint az eredeti v\u00e1ltozatban.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! L\u00e1thatjuk, hogy a konstruktoron kereszt\u00fcl teljesen inicializ\u00e1lhat\u00f3 <code>Person</code> p\u00e9ld\u00e1nyok eset\u00e9ben a ki\u00edr\u00e1s teljes, viszont vannak olyan <code>Student</code> p\u00e9ld\u00e1nyok, ahol a ki\u00edr\u00e1s \u00fcres \u00e9rt\u00e9keket tal\u00e1l. Ezzel a jelens\u00e9ggel a k\u00f6vetkez\u0151 gyakorlatokon tov\u00e1bb foglalkozunk.</p> <p>C# \u00faj verzi\u00f3j\u00e1ban megjelent a Collection Expression szintaxis is, amivel a kollekci\u00f3 inicializ\u00e1l\u00e1s m\u00e9g egyszer\u0171bb\u00e9 v\u00e1lik, aminek a szintaxisa a <code>[]</code> k\u00f6z\u00f6tt megadott elemekb\u0151l \u00e1ll. Itt nem kell megadni a t\u00edpust sem, a ford\u00edt\u00f3 automatikusan kital\u00e1lja azt a bal oldalb\u00f3l, \u00e9s m\u0171k\u00f6dik a legt\u00f6bb kollekci\u00f3 t\u00edpussal \u00e9s t\u00f6mbbel is.</p> <pre><code>List&lt;Person&gt; people =\n[\n    new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)),\n    new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)),\n    new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)),\n    new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major=\"Info BSc\"\n    },\n    new Student(\"Hi\u00e1ny \u00c1ron\", new DateTime(2000, 02, 13))\n];\n</code></pre> <p>Tov\u00e1bb\u00e1 van lehet\u0151s\u00e9g kollekci\u00f3k \u00f6sszef\u0171z\u00e9s\u00e9re is a <code>..</code> oper\u00e1torral.</p> <pre><code>List&lt;Person&gt; people2 = [ .. people, new Person(\"Kov\u00e1cs B\u00e9la\", new DateTime(1995, 01, 01)) ];\n</code></pre>"},{"location":"seminar/02-csharp2/chapter2/","title":"C# alapok II.","text":""},{"location":"seminar/02-csharp2/chapter2/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt hozzunk l\u00e9tre egy .NET C# konzolalkalmaz\u00e1st: a projektsablon sz\u0171r\u0151ben v\u00e1lasszuk a C# nyelv - Windows platform - Console projektt\u00edpust. A sz\u0171rt list\u00e1ban v\u00e1lasszuk a Console App sablont (ne a .NET Framework-\u00f6s legyen). A neve legyen HelloCSharp2. A solutiont ne tegy\u00fck k\u00fcl\u00f6n mapp\u00e1ba (Place solution and project in the same directory legyen bekapcsolva). A megc\u00e9lzott framework verzi\u00f3 legyen .NET 8.</p>"},{"location":"seminar/02-csharp2/chapter2/#legfelso-szintu-utasitasok-implicit-globalis-nevter-hivatkozasok","title":"Legfels\u0151 szint\u0171 utas\u00edt\u00e1sok, implicit glob\u00e1lis n\u00e9vt\u00e9r-hivatkoz\u00e1sok","text":"<p>Csod\u00e1lkozzunk r\u00e1, hogy a gener\u00e1lt projekt mind\u00f6ssze egyetlen \u00e9rdemi sort tartalmaz.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\n</code></pre> <p>C# 10 \u00f3ta a program bel\u00e9p\u00e9si pontj\u00e1t ad\u00f3 forr\u00e1sf\u00e1jlt jelent\u0151sen ler\u00f6vid\u00edthetj\u00fck:</p> <ul> <li>a f\u00e1jl tetej\u00e9n l\u00e9v\u0151 using-okat elhagyhatjuk, ha azok implicit hivatkozva vannak. Az implicit hivatkozott using-ok projektt\u00edpust\u00f3l f\u00fcggenek \u00e9s a dokument\u00e1ci\u00f3b\u00f3l olvashatjuk ki</li> <li>a <code>Main</code> f\u00fcggv\u00e9nyt tartalmaz\u00f3 oszt\u00e1ly deklar\u00e1ci\u00f3j\u00e1t (<code>namespace</code> blokk, <code>class</code> blokk) elhagyhatjuk, ezt a ford\u00edt\u00f3 gener\u00e1lja nek\u00fcnk</li> <li>a <code>Main</code> f\u00fcggv\u00e9ny deklar\u00e1ci\u00f3j\u00e1t szint\u00e9n gener\u00e1lja a ford\u00edt\u00f3. A met\u00f3dus neve nem defini\u00e1lt, nem (biztos, hogy) <code>Main</code>. A met\u00f3dus szignat\u00far\u00e1ja att\u00f3l f\u00fcgg, milyen utas\u00edt\u00e1sokat adunk meg a forr\u00e1sf\u00e1jlban. P\u00e9ld\u00e1ul, ha nincs return, akkor <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. A param\u00e9tere viszont mindig <code>string[] args</code>.</li> <li>a f\u00fcggv\u00e9ny blokkba nem foglalt k\u00f3d a gener\u00e1lt bel\u00e9p\u00e9si pont f\u00fcggv\u00e9ny belsej\u00e9be ker\u00fcl. F\u00fcggv\u00e9nyt is \u00edrhatunk, az a bel\u00e9p\u00e9si pontot tartalmaz\u00f3 gener\u00e1lt oszt\u00e1ly tagf\u00fcggv\u00e9nye lesz.</li> <li>t\u00edpusokat, oszt\u00e1lyokat is defini\u00e1lhatunk, de csak a legfels\u0151 szint\u0171 k\u00f3dot k\u00f6vet\u0151en</li> </ul> <p>Warning</p> <p>Fontos \u00e9szrev\u00e9tel a fentiekb\u0151l: ezen k\u00e9pess\u00e9g nem v\u00e1ltoztatja meg a C# semmilyen alapvet\u0151 jellemz\u0151j\u00e9t, p\u00e9ld\u00e1ul ugyan\u00fagy minden f\u00fcggv\u00e9nynek oszt\u00e1lyon bel\u00fcl kell lennie. A ford\u00edt\u00e1s sor\u00e1n a legfels\u0151 szint\u0171 utas\u00edt\u00e1sok k\u00f3dja \u00fagy eg\u00e9sz\u00fcl ki, ami m\u00e1r minden szab\u00e1lynak megfelel.</p> <p>L\u00e1that\u00f3s\u00e1g</p> <p>A legfels\u0151 szint\u0171 k\u00f3d olyan, amit a program m\u00e1s r\u00e9sz\u00e9r\u0151l nem tudunk h\u00edvni, hiszen nem is ismerj\u00fck a burkol\u00f3 oszt\u00e1ly nev\u00e9t. Emiatt nincs \u00e9rtelme legfels\u0151 szint\u0171 k\u00f3dban l\u00e1that\u00f3s\u00e1gi be\u00e1ll\u00edt\u00e1snak (<code>private</code>, <code>protected</code> stb.) vagy propertynek.</p> <p>Akad\u00e1lyozzuk meg a program azonnali lefut\u00e1s\u00e1t egy blokkol\u00f3 h\u00edv\u00e1ssal.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\nConsole.ReadLine();\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a gener\u00e1lt projektet mindenf\u00e9le egy\u00e9b v\u00e1ltoztat\u00e1s n\u00e9lk\u00fcl, ford\u00edt\u00e1s (menu:projekten jobbklikk[Build]) ut\u00e1n. N\u00e9zz\u00fcnk bele a kimeneti k\u00f6nyvt\u00e1rba (menu:projekten jobbklikk[Open Folder in File Explorer], majd menu:bin[Debug &gt; net8.0]): l\u00e1that\u00f3, hogy az alkalmaz\u00e1sunkb\u00f3l a ford\u00edt\u00e1s sor\u00e1n egy cross-platform bin\u00e1ris (\\&lt;projektn\u00e9v&gt;.dll) \u00e9s .NET Core v3 \u00f3ta egy platform specifikus futtathat\u00f3 \u00e1llom\u00e1ny (Windows eset\u00e9n \\&lt;projektn\u00e9v&gt;.exe) is gener\u00e1l\u00f3dik. Kipr\u00f3b\u00e1lhatjuk, hogy az exe a szokott m\u00f3don ind\u00edthat\u00f3 (pl. duplaklikkel), m\u00edg a dll a <code>dotnet</code> paranccsal.</p> <pre><code>dotnet &lt;projektn\u00e9v.dll&gt;\n</code></pre> <p>Parancssor aktu\u00e1lis mapp\u00e1ja</p> <p>A dotnet parancshoz a dll k\u00f6nyvt\u00e1r\u00e1ban kell lenn\u00fcnk. Ehhez a legegyszer\u0171bb, ha a Windows f\u00e1jlkezel\u0151ben a megfelel\u0151 k\u00f6nyvt\u00e1rban \u00e1llva az el\u00e9r\u00e9si \u00fatvonal mez\u0151t \u00e1t\u00edrjuk a <code>cmd</code> sz\u00f6vegre, majd Enter-t nyomunk.</p> <p>Adjunk a l\u00e9trej\u00f6v\u0151 projekthez egy <code>Dog</code> oszt\u00e1lyt Dog.cs n\u00e9ven, ez lesz az adatmodell\u00fcnk:</p> <pre><code>public class Dog\n{\n    public string Name { get; set; }\n    public Guid Id { get; } = Guid.NewGuid();\n    public DateTime DateOfBirth { get; set; }\n    private int AgeInDays =&gt; DateTime.Now.Subtract(DateOfBirth).Days;\n    public int Age =&gt; AgeInDays / 365;\n    public int AgeInDogYears =&gt; AgeInDays * 7 / 365;\n    public override string ToString() =&gt;\n            $\"{Name} ({Age} | {AgeInDogYears}) [ID: {Id}]\";\n}\n</code></pre> <p>Az adatmodell az el\u0151z\u0151 \u00f3r\u00e1n l\u00e9trehozotthoz nagyon hasonl\u00edt, ennek viszont nincsen explicit konstruktora \u00e9s a <code>Name</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gok publikusan is \u00e1ll\u00edthat\u00f3k.</p> <p>Hozzunk l\u00e9tre egy <code>Dog</code> p\u00e9ld\u00e1nyt objektum inicializ\u00e1ci\u00f3s szintaxissal, majd \u00edrjuk ki ezt a p\u00e9ld\u00e1nyt a kezdeti k\u00f6sz\u00f6nt\u0151 sz\u00f6veg helyett:</p> <pre><code>Dog banan = new Dog\n{\n    Name = \"Ban\u00e1n\",\n    DateOfBirth = new DateTime(2014, 06, 10)\n};\nConsole.WriteLine(banan);\n</code></pre> <p>Ezzel k\u00e9sz a kiindul\u00f3 projekt\u00fcnk.</p>"},{"location":"seminar/02-csharp2/chapter2/#implicit-tipusdeklaracio","title":"Implicit t\u00edpusdeklar\u00e1ci\u00f3","text":"<p>A <code>var</code> kulcssz\u00f3 jelent\u0151s\u00e9ge: ha a ford\u00edt\u00f3 ki tudja tal\u00e1lni a kontextusb\u00f3l az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n \u00e1ll\u00f3 \u00e9rt\u00e9k t\u00edpus\u00e1t, nem sz\u00fcks\u00e9ges a t\u00edpus nev\u00e9t explicit megadnunk, az implicit k\u00f6vetkezik a k\u00f3db\u00f3l. Ebben az esetben a t\u00edpus egy\u00e9rtelm\u0171en <code>Dog</code>. Ha csak deklar\u00e1lni szeretn\u00e9nk egy v\u00e1ltoz\u00f3t (nem adunk \u00e9rt\u00e9k\u00fcl a v\u00e1ltoz\u00f3nak semmit), akkor nem haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t, ugyanis nem k\u00f6vetkezik a k\u00f3db\u00f3l a v\u00e1ltoz\u00f3 t\u00edpusa. Ekkor explicit meg kell adnunk a t\u00edpust.</p> <pre><code>Dog banan = new Dog\n{\n   Name = \"Ban\u00e1n\",\n   DateOfBirth = new DateTime(2014, 06, 10)\n};\nvar watson = new Dog { Name = \"Watson\" };\n\nvar unnamed = new Dog { DateOfBirth = new DateTime(2017, 02, 10) };\nvar unknown = new Dog { };\n//watson = 3; // (1)\n//var error;  // (2)\n\nConsole.WriteLine(banan);\nConsole.ReadLine();\n</code></pre> <ol> <li>Ford\u00edt\u00e1si hiba: a <code>watson</code> deklar\u00e1ci\u00f3jakor eld\u0151lt, hogy \u0151 <code>Dog</code> t\u00edpus, ut\u00f3lag nem lehet megv\u00e1ltoztatni \u00e9s p\u00e9ld\u00e1ul sz\u00e1m\u00e9rt\u00e9ket \u00e9rt\u00e9k\u00fcl adni. Ez nem JavaScript.</li> <li>Ford\u00edt\u00e1si hiba: implicit t\u00edpust csak \u00fagy lehet deklar\u00e1lni, ha egy\u00fattal inicializ\u00e1ljuk is. Az inicializ\u00e1ci\u00f3s kifejez\u00e9s alapj\u00e1n d\u0151l el (implicit) a p\u00e9ld\u00e1ny t\u00edpusa.</li> </ol> <p>Pr\u00f3b\u00e1ljuk ki a nem fordul\u00f3 sorokat, n\u00e9zz\u00fck meg a ford\u00edt\u00f3 hiba\u00fczeneteit!</p> <p>Er\u0151ss t\u00edpusos\u00e1g</p> <p>A <code>var</code> nem a gyenge t\u00edpusoss\u00e1g jele a C#-ban, nem \u00fagy, mint pl. JavaScript-ben. Az inicializ\u00e1ci\u00f3s sor ut\u00e1n a t\u00edpus egy\u00e9rtelm\u0171en eld\u0151l, ut\u00e1na m\u00e1r csak ennek a t\u00edpusnak megfelel\u0151 m\u0171veletek v\u00e9gezhet\u0151k, p\u00e9ld\u00e1ul egy \u00e9rt\u00e9kad\u00e1ssal nem v\u00e1ltoztathatjuk meg a t\u00edpust.</p> <p>A <code>var</code>-t tipikusan akkor alkalmazzuk, ha:</p> <ul> <li>hossz\u00fa t\u00edpusneveket nem akarunk ki\u00edrni</li> <li>feleslegesnek tartjuk az inicializ\u00e1ci\u00f3 mindk\u00e9t oldal\u00e1n ki\u00edrni ugyanazt a t\u00edpust</li> <li>anonim t\u00edpusokat haszn\u00e1lunk (k\u00e9s\u0151bb)</li> </ul>"},{"location":"seminar/02-csharp2/chapter2/#init-only-setter","title":"Init-only setter","text":"<p>Az objektum inicializ\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9hez sz\u00fcks\u00e9ges a megfelel\u0151 l\u00e1that\u00f3s\u00e1g\u00fa setter. Viszont egy ilyen settert nem csak objektum inicializ\u00e1ci\u00f3kor lehet haszn\u00e1lni, hanem b\u00e1rmikor \u00e1t\u00e1ll\u00edthatjuk egy p\u00e9ld\u00e1ny adat\u00e1t (mut\u00e1ci\u00f3).</p> <p>Az al\u00e1bbi p\u00e9lda egy ilyen ut\u00f3lagos m\u00f3dos\u00edt\u00e1sra / mut\u00e1ci\u00f3ra.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nwatson.Name = \"Sherlock\";\n</code></pre> <p>Ez \u00edgy hiba n\u00e9lk\u00fcl lefordul.</p> <p>Kiz\u00e1r\u00f3lag az inicializ\u00e1ci\u00f3ra korl\u00e1tozhatjuk a setter megh\u00edv\u00e1s\u00e1t az init-only setterrel (<code>init</code> kulcssz\u00f3).</p> <pre><code>public class Dog\n{\n    public string Name { get; init; }\n    //...\n}\n</code></pre> <p>Ezut\u00e1n az inicializ\u00e1ci\u00f3s sor tov\u00e1bbra is lefordul, de a n\u00e9v\u00e1t\u00edr\u00e1sos m\u00e1r nem. Ez ut\u00f3bbi sort kommentezz\u00fck ki.</p> <p>Init-only setter konstruktorb\u00f3l</p> <p>Init-only settert az oszt\u00e1ly konstruktor\u00e1b\u00f3l is meg lehet h\u00edvni - hiszen az is inicializ\u00e1ci\u00f3.</p> <p>Haszn\u00e1lata</p> <p>Init-only settert t\u00f6bb okb\u00f3l kifoly\u00f3lag is haszn\u00e1lhatunk, p\u00e9ld\u00e1ul a t\u00edpus p\u00e9ld\u00e1nyainak immut\u00e1bilis kezel\u00e9s\u00e9t akarjuk kik\u00e9nyszer\u00edteni, vagy csak inicializ\u00e1ci\u00f3ra akarjuk korl\u00e1tozni a propertyk be\u00e1ll\u00edt\u00e1s\u00e1t, de nem akarunk ehhez konstruktort \u00edrni.</p> <p>Jelen form\u00e1j\u00e1ban az init-only setter nem tudja helyettes\u00edteni a k\u00f6telez\u0151 konstruktor param\u00e9tert, mert nem k\u00f6telez\u0151 kit\u00f6lteni ezt a propertyt. Erre a megold\u00e1s a C# 11-ben bevezetett <code>required</code> kulcssz\u00f3 a property el\u0151tt.</p> <pre><code>public class Dog\n{\n    public required string Name { get; init;  }\n    //...\n}\n</code></pre> <p>Ezzel k\u00f6telez\u0151v\u00e9 v\u00e1lik a <code>Name</code> kit\u00f6lt\u00e9se, ha a <code>Dog</code> p\u00e9ld\u00e1nyt inicializ\u00e1ljuk.</p>"},{"location":"seminar/02-csharp2/chapter2/#indexer-operator-nameof-operator-index-inicializalo","title":"Indexer oper\u00e1tor, nameof oper\u00e1tor, index inicializ\u00e1l\u00f3","text":"<p>A collection initializer anal\u00f3gi\u00e1j\u00e1ra j\u00f6tt l\u00e9tre az index initializer nyelvi elem, ami a kor\u00e1bbihoz hasonl\u00f3an sorban h\u00edv meg egy oper\u00e1tort, hogy m\u00e1r inicializ\u00e1lt objektumot kapjunk vissza. A k\u00fcl\u00f6nbs\u00e9g egyr\u00e9szt a szintaxis, m\u00e1sr\u00e9szt az ilyenkor megh\u00edvott met\u00f3dus, ami az index oper\u00e1tor.</p> <p>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s</p> <p>Saj\u00e1t t\u00edpusainkban lehet\u0151s\u00e9g\u00fcnk van defini\u00e1lni \u00e9s fel\u00fcldefini\u00e1lni oper\u00e1torokat, mint pl. +, -, indexel\u00e9s, implicit cast, explicit cast, stb.</p> <p>Tegy\u00fck fel, hogy egy kuty\u00e1hoz b\u00e1rmilyen, \u00fczleti logik\u00e1ban nem felhaszn\u00e1lt inform\u00e1ci\u00f3 ker\u00fclhet, amire \u00e1ltal\u00e1nos strukt\u00far\u00e1t szeretn\u00e9nk. Vegy\u00fcnk fel a <code>Dog</code> oszt\u00e1lyba egy <code>string-object</code> sz\u00f3t\u00e1rat, amiben b\u00e1rmilyen tov\u00e1bbi inform\u00e1ci\u00f3t t\u00e1rolhatunk! Ezen fel\u00fcl \u00e1ll\u00edtsuk be a <code>Dog</code> indexer\u00e9t, hogy az a <code>Metadata</code> indexel\u00e9s\u00e9t v\u00e9gezze:</p> <pre><code>public class Dog\n{\n    //...\n    public Dictionary&lt;string, object&gt;  Metadata { get; } = new();\n    public object this[string key]\n    {\n        get =&gt; Metadata[key];\n        set =&gt; Metadata[key] = value;\n    }\n}\n</code></pre> <p>Konstruktor t\u00edpus n\u00e9lk\u00fcl</p> <p>A <code>new</code> oper\u00e1tor ut\u00e1ni konstruktorh\u00edv\u00e1s sok esetben elhagyhat\u00f3, ha a bal oldal alapj\u00e1n am\u00fagy is tudhat\u00f3 a t\u00edpus.</p> <p>n\u00e9vt\u00e9r hivatkoz\u00e1sok</p> <p>Az \u00fajabb projektsablonok sokkal kevesebb n\u00e9vt\u00e9rdeklar\u00e1ci\u00f3t (<code>using</code>) gener\u00e1lnak alapb\u00f3l. Ha kell, vegy\u00fck fel a sz\u00fcks\u00e9geseket a fel nem oldott n\u00e9ven \u00e1llva a gyorsm\u0171velet (villanyk\u00f6rte) eszk\u00f6zzel (Ctrl+.)</p> <p>Az objektum inicializ\u00e1l\u00f3 \u00e9s az index inicializ\u00e1l\u00f3 vegy\u00edthet\u0151, \u00edgy az al\u00e1bbi m\u00f3don tudunk felvenni tov\u00e1bbi tulajdons\u00e1gokat a kuty\u00e1khoz a legfels\u0151 szint\u0171 k\u00f3dba:</p> <pre><code>var pimpedli = new Dog\n{\n    Name = \"Pimpedli\",\n    DateOfBirth = new DateTime(2006, 06, 10),\n    [\"Chip azonos\u00edt\u00f3\"] = \"123125AJ\"\n};\n</code></pre> <p>Mivel indexelni \u00e1ltal\u00e1ban kollekci\u00f3kat szok\u00e1s (t\u00f6mb, lista, sz\u00f3t\u00e1r), ez\u00e9rt ezekben az esetekben igen j\u00f3 eszk\u00f6z lehet az index inicializ\u00e1l\u00f3. Vegy\u00fcnk fel egy \u00faj kutyasz\u00f3t\u00e1rt a kuty\u00e1k kiteny\u00e9szt\u00e9se ut\u00e1n:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [\"banan\"] = banan,\n    [\"watson\"] = watson,\n    [\"unnamed\"] = unnamed,\n    [\"unknown\"] = unknown,\n    [\"pimpedli\"] = pimpedli\n};\n\nforeach (var dog in dogs)\n{\n    Console.WriteLine($\"{dog.Key} - {dog.Value}\");\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki - minden n\u00e9v-kutya p\u00e1rt ki kell \u00edrnia a sz\u00f3t\u00e1rb\u00f3l.</p> <p>Els\u0151re j\u00f3 \u00f6tletnek t\u0171nhet kiv\u00e1ltani a sz\u00f6vegliter\u00e1lokat a <code>Name</code> property haszn\u00e1lat\u00e1val.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [banan.Name] = banan,\n    [watson.Name] = watson,\n    [unnamed.Name] = unnamed,\n    [unknown.Name] = unknown,\n    [pimpedli.Name] = pimpedli\n};\n//ArgumentNullException!\n</code></pre> <p>Ez azonban kiv\u00e9telt okoz, amikor a kutya neve nincs kit\u00f6ltve, azaz <code>null</code> \u00e9rt\u00e9k\u0171. Eset\u00fcnkben el\u00e9g lenne az adott v\u00e1ltoz\u00f3 neve sz\u00f6vegk\u00e9nt. Erre j\u00f3 a <code>nameof</code> oper\u00e1tor.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [nameof(banan)] = banan,\n    [nameof(watson)] = watson,\n    [nameof(unnamed)] = unnamed,\n    [nameof(unknown)] = unknown,\n    [nameof(pimpedli)] = pimpedli\n};\n</code></pre> <p>Ez a v\u00e1ltozat m\u00e1r nem fog kiv\u00e9telt okozni.</p> <p>A <code>nameof</code> oper\u00e1tor sokfajta nyelvi elemet t\u00e1mogat, vissza tudja adni egy v\u00e1ltoz\u00f3, egy t\u00edpus, egy property vagy egy f\u00fcggv\u00e9ny nev\u00e9t is.</p> <p>A sz\u00f3t\u00e1r felt\u00f6lt\u00e9s\u00e9t meg\u00edrhatjuk kollekci\u00f3 inicializ\u00e1ci\u00f3val is. Ehhez kihaszn\u00e1ljuk, hogy a sz\u00f3t\u00e1r t\u00edpus rendelkezik egy <code>Add</code> met\u00f3dussal, amelyik egyszer\u0171en egy kulcsot \u00e9s egy hozz\u00e1tartoz\u00f3 \u00e9rt\u00e9ket v\u00e1r:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    { nameof(banan), banan },\n    { nameof(watson), watson },\n    { nameof(unnamed), unnamed },\n    { nameof(unknown), unknown },\n    { nameof(pimpedli), pimpedli }\n};\n</code></pre>"},{"location":"seminar/02-csharp2/chapter2/#using-static","title":"Using static","text":"<p>Ha egy oszt\u00e1ly statikus tagjait vagy egy statikus oszt\u00e1lyt szeretn\u00e9nk haszn\u00e1lni, lehet\u0151s\u00e9g\u00fcnk van a <code>using static</code> kulcsszavakkal az oszt\u00e1lyt bevonni a n\u00e9vfelold\u00e1si logik\u00e1ba. Ha a <code>Console</code> oszt\u00e1lyt refer\u00e1ljuk ilyen m\u00f3don, lehet\u0151s\u00e9g\u00fcnk van a rajta lev\u0151 met\u00f3dusok megh\u00edv\u00e1s\u00e1ra az aktu\u00e1lis kontextusunkban an\u00e9lk\u00fcl, hogy az oszt\u00e1ly nev\u00e9t ki\u00edrn\u00e1nk:</p> <pre><code>using System;\nusing static System.Console;\n//..\nforeach (var dog in dogs)\n    /*Console.*/WriteLine($\"{dog.Key} - {dog.Value}\");\n/*Console.*/WriteLine(banan);\n/*Console.*/ReadLine();\n</code></pre> <p>n\u00e9vfelold\u00e1s</p> <p>Az \u00e1ltal\u00e1nos n\u00e9vfelold\u00e1si szab\u00e1ly tov\u00e1bbra is \u00e9l: ha egy\u00e9rtelm\u0171en feloldhat\u00f3 a hivatkoz\u00e1s, akkor nem sz\u00fcks\u00e9ges kitenni a megk\u00fcl\u00f6nb\u00f6ztet\u0151 el\u0151tagot (itt: oszt\u00e1ly), k\u00fcl\u00f6nben igen.</p>"},{"location":"seminar/02-csharp2/chapter2/#nullozhato-tipusok","title":"Nullozhat\u00f3 t\u00edpusok","text":"<p>Term\u00e9szetesen a referenciat\u00edpusok mind olyan t\u00edpusok, melyek vehetnek fel <code>null</code> \u00e9rt\u00e9ket, viszont esetenk\u00e9nt j\u00f3 volna, ha a <code>null</code> \u00e9rt\u00e9ket egy\u00e9bk\u00e9nt felvenni nem k\u00e9pes t\u00edpusok is lehet\u00e9nek ilyen \u00e9rt\u00e9k\u0171ek, ezzel pl. jelezv\u00e9n, hogy egy \u00e9rt\u00e9k be van-e \u00e1ll\u00edtva vagy sem. Pl. egy sz\u00e1m eset\u00e9n a 0 egy konkr\u00e9t, helyes \u00e9rt\u00e9k lehet a domain modell\u00fcnkben, a <code>null</code> viszont azt jelenthetn\u00e9, hogy nem vett fel \u00e9rt\u00e9ket.</p> <p>Vizsg\u00e1ljuk meg, hogy a konzolra t\u00f6rt\u00e9n\u0151 ki\u00edr\u00e1skor mi\u00e9rt lesz az aktu\u00e1lis \u00e9v Watson kutya \u00e9letkora! Valamelyik <code>Console.WriteLine</code> sorhoz vegy\u00fcnk fel egy t\u00f6r\u00e9spontot (F9), majd debuggol\u00e1s k\u00f6zben a Locals ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Locals]) figyelj\u00fck meg az egyes p\u00e9ld\u00e1nyok adatait. Watsont kinyitva l\u00e1thatjuk, hogy a turpiss\u00e1g abb\u00f3l fakad, hogy a <code>DateOfBirth</code> adat t\u00edpusa, a <code>DateTime</code> nem referenciat\u00edpus, \u00e9s alap\u00e9rtelmez\u00e9s szerinti \u00e9rt\u00e9ket veszi fel, ami 0001. 01. 01. 00:00:00 - hiszen nem \u00e1ll\u00edtottunk be m\u00e1st.</p> <p>Ismeretlen sz\u00fclet\u00e9si d\u00e1tum\u00fa, kor\u00fa egyedek helyes t\u00e1rol\u00e1s\u00e1hoz az <code>Age</code> tulajdons\u00e1g t\u00edpus\u00e1t v\u00e1ltoztassuk <code>int?</code>-re! Az <code>int?</code> szintaktikai \u00e9des\u00edt\u0151szere a <code>Nullable&lt;int&gt;</code>-nek, egy olyan strukt\u00far\u00e1nak, ami egy <code>int</code> \u00e9rt\u00e9ket t\u00e1rol, \u00e9s t\u00e1rolja, hogy az be van-e \u00e1ll\u00edtva vagy sem. A <code>Nullable&lt;int&gt;</code> szignat\u00far\u00e1it megmutathatjuk, hogyha a kurzort a t\u00edpusra helyezve F12-t nyomunk.</p> <p>M\u00f3dos\u00edtsuk a <code>Dog</code> <code>Age</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gait is, hogy tudjuk, be vannak-e \u00e1ll\u00edtva az \u00e9rt\u00e9keik:</p> <pre><code>public class Dog\n{\n    //...\n\n    public DateTime? DateOfBirth { get; set; }\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    //...\n}\n</code></pre> <p>Aritmentikai oper\u00e1torok</p> <p>\u00d6rvendezz\u00fcnk, hogy az alap aritmetikai oper\u00e1torok pont \u00fagy m\u0171k\u00f6dnek, ahogy szeretn\u00e9nk (<code>null</code> bemenetre <code>null</code> eredm\u00e9ny), nem kellett semmilyen tr\u00fckk.</p> <p>Az <code>AgeInDays</code> akkor ad vissza <code>null</code> \u00e9rt\u00e9ket, ha a <code>DateOfBirth</code> maga is <code>null</code> volt. Teh\u00e1t ha nincs megadva sz\u00fclet\u00e9si d\u00e1tumunk, nem tudunk \u00e9letkort sem sz\u00e1m\u00edtani. Ennek kifejez\u00e9s\u00e9re haszn\u00e1lhatjuk a <code>?.</code> (Elvis, magyarban Kozs\u00f3 - <code>null</code> conditional operator) oper\u00e1tort: a ki\u00e9rt\u00e9kelend\u0151 \u00e9rt\u00e9k jobb oldal\u00e1t adja vissza, ha a bal oldal nem <code>null</code>, k\u00fcl\u00f6nben <code>null</code>-t. A kifejez\u00e9st meg kellett v\u00e1ltoztatnunk, hogy a <code>DateOfBirth</code>-b\u0151l vonjuk ki a jelenlegi d\u00e1tumot \u00e9s ezt neg\u00e1ljuk, ugyanis a <code>null</code> vizsg\u00e1land\u00f3 \u00e9rt\u00e9k a bin\u00e1ris oper\u00e1tor bal oldal\u00e1n kell, hogy elhelyezkedjen.</p> Elvis oper\u00e1tor <p>Az Elvis oper\u00e1tor nev\u00e9nek eredet\u00e9re t\u00f6bb magyar\u00e1zatot is lehet tal\u00e1lni, a forr\u00e1sok annyiban nagyr\u00e9szt megegyeznek, hogy a k\u00e9rd\u0151jel tekered\u0151 r\u00e9sze az \u00e9nekes jellegzetes bodorod\u00f3 hajviselet\u00e9re eml\u00e9keztet, a pontok pedig a szemeket jel\u00f6lik, \u00edgy v\u00e9g\u00fclis a ?. egy Elvis emotikonk\u00e9nt foghat\u00f3 fel. Ezen logika ment\u00e9n ad\u00f3dik a magyar megfelel\u0151, a Kozs\u00f3 oper\u00e1tor, hiszen a szem k\u00f6r\u00fcl tekerg\u0151z\u0151 legikonikusabb hajtincs a magyar zenei kult\u00far\u00e1ban Kozs\u00f3 nev\u00e9hez k\u00f6thet\u0151.</p> <p>Ha \u00edgy futtatjuk az alkalmaz\u00e1st, az <code>AgeInDays</code> \u00e9s a sz\u00e1rmaztatott tulajdons\u00e1gok \u00e9rt\u00e9ke <code>null</code> (vagy ki\u00edrva \u00fcres) lesz, ha a sz\u00fclet\u00e9si d\u00e1tum nincs megadva.</p>"},{"location":"seminar/02-csharp2/chapter2/#rekord-tipus","title":"Rekord t\u00edpus","text":"<p>A rekord t\u00edpusok speci\u00e1lis t\u00edpusok, melyek:</p> <ul> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n \u00e9rt\u00e9k t\u00edpusokra jellemz\u0151 logik\u00e1t k\u00f6vetnek, azaz k\u00e9t p\u00e9ld\u00e1ny akkor egyenl\u0151, ha adataik egyenl\u0151ek</li> <li>k\u00f6nnyen immut\u00e1biliss\u00e1 tehet\u0151k, k\u00f6nnyen kezelhet\u0151k immut\u00e1bilis t\u00edpusk\u00e9nt</li> </ul> <p>A <code>Dog</code> t\u00edpus ezzel szemben jelenleg:</p> <ul> <li>nem immut\u00e1bilis, hiszen a sz\u00fclet\u00e9si d\u00e1tum b\u00e1rmikor m\u00f3dos\u00edthat\u00f3 (sima setter)</li> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n a norm\u00e1l referencia szerinti \u00f6sszehasonl\u00edt\u00e1st k\u00f6vet</li> </ul> <p>Az automatikusan gener\u00e1l\u00f3d\u00f3 egyedi azonos\u00edt\u00f3t iktassuk ki a <code>Dog</code> oszt\u00e1lyb\u00f3l, hogy az adat alap\u00fa \u00f6sszehasonl\u00edt\u00e1st k\u00f6nnyebben tesztelhess\u00fck.</p> <pre><code>public Guid Id { get; } = Guid.Empty;\n</code></pre> <p>Vegy\u00fcnk fel egy logikailag megegyez\u0151 p\u00e9ld\u00e1nyt.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nvar watson2 = new Dog { Name = watson.Name };\n</code></pre> <p>Ism\u00e9t \u00e1lljunk meg debug sor\u00e1n valamelyik <code>WriteLine</code> soron. A Locals ablakban n\u00e9zz\u00fck meg, hogy a k\u00e9t p\u00e9ld\u00e1ny minden adata megegyezik. A Watch ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Watch &gt; Watch 1]) \u00e9rt\u00e9kelj\u00fck ki a <code>watson == watson2</code> kifejez\u00e9st. L\u00e1thatjuk, hogy ez az egyenl\u0151s\u00e9gvizsg\u00e1lat hamist ad, ami technikailag helyes, mert k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 mem\u00f3riater\u00fcletr\u0151l van sz\u00f3, a referenci\u00e1k nem ugyanoda mutatnak a mem\u00f3ri\u00e1ban. Sok esetben azonban nem ezt szeretn\u00e9nk, hanem p\u00e9ld\u00e1ul a dupla r\u00f6gz\u00edt\u00e9s elker\u00fcl\u00e9s\u00e9re az adatok alapj\u00e1n t\u00f6rt\u00e9n\u0151 \u00f6sszehasonl\u00edt\u00e1st, ami \u00e9rt\u00e9k t\u00edpusokn\u00e1l van. Referencia t\u00edpusokn\u00e1l klasszikusan ezt a <code>GetHashCode</code>, <code>Equals</code> f\u00fcggv\u00e9nyek fel\u00fcldefini\u00e1l\u00e1s\u00e1val \u00e9rt\u00fck el (vagy az <code>IComparable&lt;T&gt;</code>, <code>IComparer&lt;T&gt;</code> interf\u00e9szre \u00e9p\u00fcl\u0151 logik\u00e1kkal). Egy \u00fajabb lehet\u0151s\u00e9g a rekord t\u00edpus haszn\u00e1lata.</p>"},{"location":"seminar/02-csharp2/chapter2/#pozicio-alapu-megadas","title":"Poz\u00edci\u00f3 alap\u00fa megad\u00e1s","text":"<p>Vegy\u00fcnk fel a <code>Dog</code> t\u00edpus adatainak megfelel\u0151 rekord t\u00edpust, mind\u00f6ssze egy kifejez\u00e9sk\u00e9nt. A <code>Dog</code> t\u00edpus al\u00e1:</p> <pre><code>public record class DogRec(\n    Guid Id,\n    string Name,\n    DateTime? DateOfBirth=null,\n    Dictionary&lt;string, object&gt; Metadata=null\n);\n</code></pre> <p>Note</p> <p>A <code>record class</code> jel\u00f6l\u0151b\u0151l a <code>class</code> elhagyhat\u00f3.</p> <p>Ez az \u00fan. poz\u00edci\u00f3 alap\u00fa megad\u00e1si forma, ami a legink\u00e1bb r\u00f6vid\u00edtett megad\u00e1si form\u00e1ja a rekord t\u00edpusnak. Ebb\u0151l a r\u00f6vid form\u00e1b\u00f3l, mindenfajta extra k\u00f3d \u00edr\u00e1sa n\u00e9lk\u00fcl a ford\u00edt\u00f3 sz\u00e1mos dolgot gener\u00e1l:</p> <ul> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1sb\u00f3l konstruktort \u00e9s dekonstruktort</li> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1s alapj\u00e1n propertyket <code>get</code> \u00e9s <code>init</code> tagf\u00fcggv\u00e9nyekkel</li> <li>alap\u00e9rtelmezett logik\u00e1t az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1shoz</li> <li>kl\u00f3noz\u00f3 \u00e9s m\u00e1sol\u00f3 konstruktor logik\u00e1kat</li> <li>alap\u00e9rtelmezett form\u00e1zott ki\u00edr\u00e1st, sz\u00f6veges reprezent\u00e1ci\u00f3t (<code>ToString</code> implement\u00e1ci\u00f3t)</li> </ul> <p>\u00cdgy egy k\u00f6nnyen kezelhet\u0151, immut\u00e1bilis, az \u00f6sszehasonl\u00edt\u00e1sokban \u00e9rt\u00e9k t\u00edpusk\u00e9nt viselked\u0151 adatoszt\u00e1lyunk lesz.</p> <p>Warning</p> <p>Az <code>Id</code>-nek nem tudjuk be\u00e1ll\u00edtani ebben a form\u00e1ban az alap\u00e9rtelmezett <code>Guid.Empty</code> \u00e9rt\u00e9ket vagy a <code>Metadata</code>-nak az \u00faj p\u00e9ld\u00e1nyt, mert az egyenl\u0151s\u00e9gjeles kifejez\u00e9sekb\u0151l alap\u00e9rtelmezett konstruktorparam\u00e9ter-\u00e9rt\u00e9kek lesznek, amik csak statikus, ford\u00edt\u00e1si id\u0151ben ki\u00e9rt\u00e9kelhet\u0151 kifejez\u00e9sek lehetnek.</p> <p>Vegy\u00fcnk fel a t\u00f6bbi Watson p\u00e9ld\u00e1ny mell\u00e9 k\u00e9t \u00fajabbat, de itt m\u00e1r az \u00faj rekord t\u00edpusunkat haszn\u00e1ljuk.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\");\n</code></pre> <p>A fentebbi Watch ablakos m\u00f3dszerrel ellen\u0151rizz\u00fck a <code>watson3 == watson4</code> kifejez\u00e9s \u00e9rt\u00e9k\u00e9t. Ez m\u00e1r igaz \u00e9rt\u00e9k lesz az adatmez\u0151 alap\u00fa \u00f6sszehasonl\u00edt\u00e1si logika miatt.</p> <p>Pr\u00f3b\u00e1ljuk ki ugyanezt a ki\u00e9rt\u00e9kel\u00e9st az al\u00e1bbi v\u00e1ltozattal:</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\n</code></pre> <p>Ez hamis \u00e9rt\u00e9ket ad, az egyenl\u0151s\u00e9gnek minden mez\u0151re teljes\u00fclnie kell, nem csak a mindkett\u0151ben kit\u00f6lt\u00f6ttekre.</p> <p>A <code>DogRec</code> t\u00edpus alapvet\u0151en immut\u00e1bilis, a p\u00e9ld\u00e1nyainak alapadatai inicializ\u00e1l\u00e1s ut\u00e1n nem m\u00f3dos\u00edthat\u00f3k. Pr\u00f3b\u00e1ljuk fel\u00fcl\u00edrni a nevet.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nwatson4.Name = watson3.Name + \"_2\"; //&lt;= nem fordul\n</code></pre> <p>Nem fog lefordulni, mert minden property init-only t\u00edpus\u00fa. A sor jobboldala egy\u00e9bk\u00e9nt lefordulna, teh\u00e1t a lek\u00e9rdez\u00e9s (getter h\u00edv\u00e1s) m\u0171k\u00f6dne.</p> <p>Ha immut\u00e1bilis t\u00edpusokkal dolgozunk, akkor mut\u00e1ci\u00f3 helyett \u00faj p\u00e9ld\u00e1nyt hozunk l\u00e9tre megv\u00e1ltoztatott adatokkal. Alapvet\u0151en ezt az OO nyelvekben m\u00e1sol\u00f3 konstruktorral oldjuk meg. A rekord t\u00edpusn\u00e1l enn\u00e9l is tov\u00e1bbmenve m\u00e1sol\u00f3 kifejez\u00e9st haszn\u00e1lhatunk.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\n</code></pre> <p>Futtat\u00e1skor a konzolban gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk a rekord t\u00edpusok alap\u00e9rtelmezetten is olvashat\u00f3 sz\u00f6veges ki\u00edr\u00e1s\u00e1ban.</p> <p>A m\u00e1sol\u00f3 kifejez\u00e9sben a <code>with</code> oper\u00e1tor el\u0151tt megadjuk, melyik p\u00e9ld\u00e1nyt kl\u00f3nozn\u00e1nk, majd az inicializ\u00e1ci\u00f3 r\u00e9szek\u00e9nt milyen \u00e9rt\u00e9keket \u00e1ll\u00edtan\u00e1nk \u00e1t, ehhez az objektum inicializ\u00e1ci\u00f3s szintaxist haszn\u00e1lhatjuk. Fontos esz\u00fcnkbe v\u00e9sni, hogy a m\u00e1sol\u00e1s eredm\u00e9nyek\u00e9nt \u00faj p\u00e9ld\u00e1ny j\u00f6n l\u00e9tre, \u00faj mem\u00f3riater\u00fclet foglal\u00f3dik le. Gondoljunk erre akkor, amikor egy ciklusban haszn\u00e1ljuk ezt a m\u00f3dszert sok egym\u00e1st k\u00f6vet\u0151 m\u00f3dos\u00edt\u00e1sra.</p> <p>Mire is j\u00f3 a rekord t\u00edpus</p> <p>Mire j\u00f3 a rekord t\u00edpus, az immutabilit\u00e1s? Az immut\u00e1bilis t\u00edpussokkal val\u00f3 hat\u00e9kony \u00e9s eredm\u00e9nyes munka m\u00e1sfajta, az imperat\u00edv nyelvekhez szokott fejleszt\u0151k sz\u00e1m\u00e1ra szokatlan m\u00f3dszereket k\u00edv\u00e1n. Vannak ter\u00fcletek, ahol ez a befektet\u00e9s megt\u00e9r\u00fcl, ilyen p\u00e9ld\u00e1ul a t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezet. A legt\u00f6bb sz\u00e1lkezel\u00e9ssel kapcsolatos probl\u00e9ma ugyanis a sz\u00e1lak \u00e1ltal k\u00f6z\u00f6sen haszn\u00e1lt adatstrukt\u00far\u00e1k mut\u00e1ci\u00f3j\u00e1ra vezethet\u0151 vissza (\u00fan. race condition, versenyhelyzet). Nincs mut\u00e1ci\u00f3 - nincs probl\u00e9ma. (No mutation - no cry)</p>"},{"location":"seminar/02-csharp2/chapter2/#kitero-a-szotar-visszavag","title":"Kit\u00e9r\u0151: a sz\u00f3t\u00e1r visszav\u00e1g","text":"<p>A rekord t\u00edpus \u00e1ltal biztos\u00edtott kellemes tulajdons\u00e1gok csak akkor \u00e9rv\u00e9nyesek, ha nem keverj\u00fck hagyom\u00e1nyos referencia t\u00edpusokkal.</p> <p>A szok\u00e1sos m\u00f3dszerrel ellen\u0151rizz\u00fck le, hogy a <code>watson5 == watson6</code> kifejez\u00e9s igaz-e. Igen, hiszen minden kit\u00f6lt\u00f6tt adatuk egyezik.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nvar watson6 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Vigy\u00fcnk be egy \u00e1rtatlan inicializ\u00e1ci\u00f3t a <code>Metadata</code> propertyre.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson6 = watson4 with { Name = \"Sherlock\", Metadata= new Dictionary&lt;string, object&gt;() };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Ezzel el\u00e9gg\u00e9 illogikus m\u00f3don hamisra v\u00e1ltozik a <code>watson5 == watson6</code> kifejez\u00e9s. Az oka az, hogy a <code>Metadata</code> sz\u00f3t\u00e1r egy klasszikus referencia t\u00edpus, az \u00f6sszehasonl\u00edt\u00e1sn\u00e1l a klasszikus mem\u00f3riac\u00edm-\u00f6sszehasonl\u00edt\u00e1s t\u00f6rt\u00e9nik, viszont az a k\u00e9t \u00faj sz\u00f3t\u00e1r p\u00e9ld\u00e1ny eset\u00e9ben elt\u00e9r\u0151 lesz. A form\u00e1zott sz\u00f6veges ki\u00edr\u00e1sba is belerond\u00edt a sz\u00f3t\u00e1r, mert ott is a sz\u00f3t\u00e1r t\u00edpus alap\u00e9rtelmezett sz\u00f6veges reprezent\u00e1ci\u00f3ja jut \u00e9rv\u00e9nyre, ami a t\u00edpus neve.</p> <p>Kl\u00f3nozzunk tov\u00e1bb, azt\u00e1n pr\u00f3b\u00e1ljunk mut\u00e1ci\u00f3t v\u00e9grehajtani a <code>Metadata</code> sz\u00f3t\u00e1ron.</p> <pre><code>var watson6 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson7 = watson6 with { Name = \"Watson\" };\nwatson7.Metadata.Add(\"Chip azonos\u00edt\u00f3\", \"12345QQ\");\nWriteLine(watson4);\n</code></pre> <p>Ez lefordul, pedig ez mut\u00e1ci\u00f3. A Locals ablakban figyelj\u00fck meg a <code>watson6</code> \u00e9s <code>watson7</code> sz\u00f3t\u00e1rait: mindkett\u0151be beker\u00fclt a chip azonos\u00edt\u00f3. Ez az \u00fan. shallow copy jelens\u00e9g, amikor nem a sz\u00f3t\u00e1r mem\u00f3riater\u00fclete kl\u00f3noz\u00f3dik, csak a r\u00e1 mutat\u00f3 referencia, ami azt eredm\u00e9nyezi, hogy a k\u00e9t p\u00e9ld\u00e1nynak k\u00f6z\u00f6s sz\u00f3t\u00e1ra lesz.</p> <p>\u00d6sszess\u00e9g\u00e9ben az adatstrukt\u00far\u00e1nkban megjelen\u0151 klasszikus referencia t\u00edpus elrontja:</p> <ul> <li>az immutabilit\u00e1st</li> <li>az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1st</li> <li>a form\u00e1zott sz\u00f6veges megjelen\u00e9st</li> <li>a kl\u00f3noz\u00e1st</li> </ul> <p>Immutabilit\u00e1s</p> <p>Immut\u00e1bilis k\u00f6rnyezetben t\u00f6rekedj\u00fcnk arra, hogy a teljes adatstrukt\u00far\u00e1nk t\u00e1mogassa az immut\u00e1bilis kezel\u00e9st.</p>"},{"location":"seminar/02-csharp2/chapter2/#normal-megadas","title":"Norm\u00e1l megad\u00e1s","text":"<p>Ha nincs sz\u00fcks\u00e9g\u00fcnk a kik\u00e9nyszer\u00edtett immutabilit\u00e1sra, akkor haszn\u00e1lhatjuk a rekord norm\u00e1l megad\u00e1s\u00e1t. Fogjuk a <code>Dog</code> oszt\u00e1lyt, m\u00e1soljuk le a k\u00f3dj\u00e1t, adjunk neki m\u00e1s nevet \u00e9s <code>class</code> helyett <code>record</code> jel\u00f6l\u0151t.</p> <p>A <code>Dog</code> oszt\u00e1ly f\u00f6l\u00e9:</p> <pre><code>public record DogRecExt\n{\n    public string Name { get; init; }\n    public Guid Id { get; } = Guid.Empty;\n    public DateTime? DateOfBirth { get; set; }\n    public Dictionary&lt;string, object&gt; Metadata { get; } = new();\n\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>ToString</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1t elhagytuk az el\u0151z\u0151 szakaszban eml\u00edtettek miatt.</p> <p>A <code>Program.cs</code>-be:</p> <pre><code>var watson8 = new DogRecExt { Name = \"Watson\" };\nwatson8.DateOfBirth = DateTime.Now.AddYears(-15);\nvar watson9 = watson8 with { };\nWriteLine(watson8);\nWriteLine(watson9);\n</code></pre> <p>Ellen\u0151rizz\u00fck le a rekord tulajdons\u00e1gokat:</p> <ul> <li>A konzol kimeneten a form\u00e1z\u00e1st, tov\u00e1bb\u00e1 a mut\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9t, azaz a <code>watson8</code> sz\u00fclet\u00e9si d\u00e1tuma a be\u00e1ll\u00edtott lesz.</li> <li>Ez nem csoda, hiszen a property deklar\u00e1ci\u00f3ban engedt\u00fck a mut\u00e1ci\u00f3t.</li> <li>A konzol kimeneten megfigyelt p\u00e9ld\u00e1nyadatokon a kl\u00f3noz\u00f3 kifejez\u00e9s m\u0171k\u00f6d\u00e9s\u00e9t. Semmi k\u00fcl\u00f6n\u00f6s, ugyan\u00fagy m\u0171k\u00f6dik, mint a t\u00f6m\u00f6r form\u00e1n\u00e1l.</li> <li>A Watch ablakban <code>watson8 == watson9</code> egyenl\u0151s\u00e9get. Ez igaz, mert minden adattagjuk egyezik.</li> </ul> <p>record struct</p> <p>A rekordoknak tov\u00e1bbi v\u00e1lfajai vannak, ugyanis strukt\u00fara is lehet rekord, ilyenkor a <code>record struct</code> kulcssz\u00f3 p\u00e1rt haszn\u00e1ljuk a t\u00edpus deklar\u00e1ci\u00f3j\u00e1n\u00e1l. S\u0151t, a <code>readonly record struct</code> egy immut\u00e1bilis <code>record struct</code>. Ezen v\u00e1lfajok nyilv\u00e1n k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek, mely viselked\u00e9seket itt most nem r\u00e9szletezz\u00fck, de a dokument\u00e1ci\u00f3ban megtal\u00e1lhat\u00f3k.</p>"},{"location":"seminar/03-linq/chapter3/","title":"LINQ","text":""},{"location":"seminar/03-linq/chapter3/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>A gyakorlat kezdet\u00e9n kl\u00f3nozzuk le a kiindul\u00f3 projektet az al\u00e1bbi paranccsal:</p> <pre><code>git clone https://github.com/bmeviauav23/Linq-lab.git\n</code></pre> <p>Nyissuk meg Visual Studio-ban a HelloLinq.sln solution f\u00e1jlt.</p> <p>Megnyit\u00e1s ut\u00e1n tekints\u00fck \u00e1t a kiindul\u00f3 projektben lev\u0151 f\u00e1jlokat:</p> <ul> <li>Program.cs: a legfels\u0151 szint\u0171 k\u00f3dot tartalmaz\u00f3 oszt\u00e1ly. Tal\u00e1lhat\u00f3 benne egy <code>Dogs</code> v\u00e1ltoz\u00f3, ami a <code>Dog</code> oszt\u00e1ly statikus <code>Repository</code> tulajdons\u00e1g\u00e1ba h\u00edv \u00e1t.</li> <li>Dog.cs: a kor\u00e1bbi gyakorlatokon haszn\u00e1lt adatmodell (apr\u00f3bb m\u00f3dos\u00edt\u00e1sokkal).<ul> <li>Beker\u00fclt egy <code>Siblings</code> tulajdons\u00e1g, a <code>ToString</code> pedig ki\u00edrja a kuty\u00e1hoz tartoz\u00f3 testv\u00e9rek sz\u00e1m\u00e1t is (ehhez a <code>TrimPad</code> b\u0151v\u00edt\u0151 met\u00f3dust haszn\u00e1lja).</li> <li>A statikus <code>Repository</code> tulajdons\u00e1g m\u00f6g\u00f6tt egy lust\u00e1n inicializ\u00e1lt <code>Lazy&lt;T&gt; RepositoryHolder</code> tal\u00e1lhat\u00f3, ami egy megfelel\u0151en form\u00e1zott bemeneti CSV f\u00e1jlb\u00f3l elk\u00e9sz\u00edti sz\u00e1munkra az adatmodellt, amivel a k\u00e9s\u0151bbiekben dolgozunk. Ennek implement\u00e1ci\u00f3j\u00e1t el\u00e9g a gyakorlat v\u00e9g\u00e9n megn\u00e9zni. Az <code>Import</code> \u00e9s <code>Export</code> f\u00fcggv\u00e9nyek a kuty\u00e1k soros\u00edt\u00e1s\u00e1t v\u00e9gzik el mindk\u00e9t ir\u00e1nyban.</li> </ul> </li> <li>Extensions/StringExtensions.cs: ez az oszt\u00e1ly tartalmaz egy seg\u00e9dmet\u00f3dust a form\u00e1zott ki\u00edr\u00e1shoz. A <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel. A b\u0151v\u00edt\u0151 met\u00f3dusos r\u00e9szben lesz jelent\u0151s\u00e9ge.</li> <li>dogs.csv: egy pontosvessz\u0151vel tagolt adathalmaz, amelyben 100 darab el\u0151re felvett kutya adata tal\u00e1lhat\u00f3. Innen pusk\u00e1zhatunk, ha ellen\u0151rizni akarjuk, hogy helyesek-e a programunk eredm\u00e9nyei.</li> </ul> <p>A kiindul\u00f3 projektben a glob\u00e1lis implicit n\u00e9vt\u00e9rhivatkoz\u00e1sok ki vannak kapcsolva. A csproj f\u00e1jlban megn\u00e9zhetj\u00fck (menu:jobb klikk a projekten[Edit Project File]):</p> <pre><code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;\n</code></pre>"},{"location":"seminar/03-linq/chapter3/#lambda-kifejezesek-delegatok","title":"Lambda kifejez\u00e9sek, deleg\u00e1tok","text":"<p>Gyakori feladat, hogy objektumok kollekci\u00f3j\u00e1val kell dolgoznunk. K\u00e9pesek vagyunk olyan jelleg\u0171 seg\u00e9df\u00fcggv\u00e9nyeket k\u00e9sz\u00edteni, amik p\u00e9ld\u00e1ul egy kollekci\u00f3ban kikeresik az \u00f6sszes olyan elemet, amely egy megadott felt\u00e9telnek eleget tesz.</p> <p>A <code>Program.cs</code> f\u00e1jlban l\u00e1that\u00f3 ennek a kezdeti naiv v\u00e1ltozata, szemrev\u00e9telezz\u00fck:</p> <pre><code>static List&lt;Dog&gt; ListDogsByNamePrefix(IEnumerable&lt;Dog&gt; dogs, string prefix)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (dog.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>A k\u00f3d m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3. Ha b\u00e1rmi m\u00e1s alapj\u00e1n szeretn\u00e9nk keresni a kuty\u00e1k k\u00f6z\u00f6tt (pl. a neve tartalmaz-e egy adott sz\u00f6vegr\u00e9szt), mindig egy \u00faj seg\u00e9df\u00fcggv\u00e9nyt kell k\u00e9sz\u00edten\u00fcnk, ami rontja a k\u00f3d \u00fajrahasznos\u00edthat\u00f3s\u00e1g\u00e1t.</p> <p>Oldjuk meg \u00fagy, hogy az \u00e1ltal\u00e1nos probl\u00e9m\u00e1t is megoldjuk! Ehhez az sz\u00fcks\u00e9ges, hogy a kollekci\u00f3nk egyes elemein ki\u00e9rt\u00e9kelhess\u00fcnk egy, a h\u00edv\u00f3 \u00e1ltal megadott predik\u00e1tumot. K\u00e9sz\u00edts\u00fck el az \u00e1ltal\u00e1nosabb v\u00e1ltozatot, ehhez felhaszn\u00e1lhatjuk a <code>ListDogsByNamePrefix</code> k\u00f3dj\u00e1t.</p> <pre><code>static List&lt;Dog&gt; ListDogsByPredicate(\n    IEnumerable&lt;Dog&gt; dogs, Predicate&lt;Dog&gt; predicate)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (predicate(dog))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>A legfels\u0151 szint\u0171 k\u00f3dban \u00edgy h\u00edvhatjuk meg (felhaszn\u00e1lhatjuk az eredeti ciklust):</p> <pre><code>foreach(var dog in ListDogsByPredicate(Dogs, delegate (Dog d) \n    {\n        return d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n    })\n)\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Egy egy bemen\u0151 param\u00e9ter\u0171 \u00e9s egy logikai (<code>bool</code>) \u00e9rt\u00e9ket visszad\u00f3 f\u00fcggv\u00e9nyt defini\u00e1lunk helyben (inline) \u00e9s ezt (illetve a referenci\u00e1j\u00e1t) adjuk \u00e1t. Haszn\u00e1ljunk ink\u00e1bb lambda kifejez\u00e9st, az j\u00f3val r\u00f6videbben le\u00edrhat\u00f3 - egyel\u0151re csak n\u00e9zz\u00fck meg, de ne integr\u00e1ljuk a k\u00f3dba:</p> <pre><code>d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Lambda kifejez\u00e9sek szintaktik\u00e1ja</p> <p>Lambda kifejez\u00e9ssel az egyetlen kifejez\u00e9sb\u0151l \u00e1ll\u00f3 f\u00fcggv\u00e9nyeket adhatjuk meg nagyon kompakt m\u00f3don. A <code>=&gt;</code>-t\u00f3l balra elnevezz\u00fck a bemen\u0151 param\u00e9tereket, jobbra pedig felhaszn\u00e1l(hat)juk. A <code>return</code>, <code>{}</code> \u00e9s egy\u00e9b sallangokat elhagyhatjuk.</p> <p>Vess\u00fck \u00f6ssze, hogy az els\u0151 esetben explicit megadtuk, hogy a bemen\u0151 param\u00e9ter\u00fcnk <code>Dog</code>, most viszont nem. Ezt a ford\u00edt\u00f3 statikus k\u00f3danal\u00edzis alapj\u00e1n el tudja d\u00f6nteni: a <code>d</code> v\u00e1ltoz\u00f3nk nem lehet m\u00e1s, csak <code>Dog</code> (statikus) t\u00edpus\u00fa, ez\u00e9rt csak \u00edgy haszn\u00e1lhatjuk, viszont nem kell ki\u00edrnunk a t\u00edpust.</p> <p>A lambda kifejez\u00e9sek egy lehets\u00e9ges m\u00f3dja a deleg\u00e1tok le\u00edr\u00e1s\u00e1nak. A deleg\u00e1t k\u00f3dot reprezent\u00e1l, viszont a k\u00f3dot kezelhetj\u00fck adatk\u00e9nt is.</p> <p>Pr\u00f3b\u00e1ljuk meg a deleg\u00e1tunkat kivenni egy implicit t\u00edpus\u00fa v\u00e1ltoz\u00f3ba a ciklus el\u0151tt:</p> <pre><code>// ford\u00edt\u00e1si hiba!\nvar predicate = \n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\nforeach (var dog in ListDogsByPredicate(Dogs, predicate))\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Ford\u00edt\u00e1si hib\u00e1t kapunk, lambda kifejez\u00e9s t\u00edpusa nem lehet implicit eld\u00f6nthet\u0151 az inicializ\u00e1ci\u00f3s sorban: sem a bemen\u0151 param\u00e9ter pontos t\u00edpus\u00e1t nem tudjuk (<code>Dog</code>? <code>Puppy</code>?), sem a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket (<code>bool</code>? <code>object</code>? <code>void</code>?). Teh\u00e1t explicit meg kell adnunk a t\u00edpust:</p> <pre><code>Predicate&lt;Dog&gt; predicate =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Ezut\u00e1n fordul \u00e9s fut is az alkalmaz\u00e1sunk.</p> <p>Predicate be\u00e9p\u00edtett deleagate t\u00edpus</p> <p>Ehhez tudnunk kellett, hogy a <code>Predicate&lt;T&gt;</code> megfelel\u0151 szignat\u00far\u00e1j\u00fa. Mutassuk meg ezen t\u00edpus dokument\u00e1ci\u00f3j\u00e1t vagy tegy\u00fck a kurzort a t\u00edpusra \u00e9s nyomjunk F12-t.</p>"},{"location":"seminar/03-linq/chapter3/#func-action","title":"<code>Func&lt;&gt;</code>, <code>Action&lt;&gt;</code>","text":"<p>Ismerkedj\u00fcnk meg a <code>Func</code> \u00e9s <code>Action</code> \u00e1ltal\u00e1nos deleg\u00e1tt\u00edpusokkal. Ezzel a k\u00e9t generikus t\u00edpussal (pontosabban a v\u00e1ltozataikkal) gyakorlatilag az \u00f6sszes gyakorlatban el\u0151fordul\u00f3 f\u00fcggv\u00e9nyszignat\u00far\u00e1t le lehet fedni. P\u00e9ld\u00e1ul a fenti sz\u0171r\u0151logik\u00e1t is \u00e1t\u00edrhatn\u00e1nk erre:</p> <pre><code>Func&lt;Dog, bool&gt; dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A <code>dogFunc</code> \u00e9s a <code>predicate</code> kompatibilisnek t\u0171nhetnek (elv\u00e9gre a jobboldaluk ugyanaz), \u00e1m ha lecser\u00e9ln\u00e9nk pl. a <code>ListDogsByPredicate(Dogs, predicate)</code> h\u00edv\u00e1sban a <code>predicate</code>-et <code>dogFunc</code>-ra, a k\u00f3d nem fordulna, ugyanis a k\u00e9t deleg\u00e1tt\u00edpus nem kompatibilis.</p> <p>Az <code>Action&lt;&gt;</code> hasonl\u00f3 elven m\u0171k\u00f6dik, visszat\u00e9r\u00e9si \u00e9rt\u00e9k n\u00e9lk\u00fcli f\u00fcggv\u00e9nyekre.</p> <p>Egy\u00e9b delegate t\u00edpusok</p> <p>Ha minden esetre j\u00f3k, mi\u00e9rt vannak haszn\u00e1latban <code>Action&lt;&gt;</code> \u00e9s <code>Func&lt;&gt;</code>-on k\u00edv\u00fcl m\u00e1s deleg\u00e1tt\u00edpusok? Egyr\u00e9szt t\u00f6rt\u00e9nelmi okok miatt. K\u00e9s\u0151bb jelentek meg, mint a specifikusak, p\u00e9ld\u00e1ul a <code>Predicate&lt;T&gt;</code>. M\u00e1sr\u00e9szt a specifikusabbak a nev\u00fckkel kifejez\u0151bbek lehetnek.</p> <p>Tiszta f\u00fcggv\u00e9nyek</p> <p>A fenti predik\u00e1tumv\u00e1ltozataink mind nem tiszta f\u00fcggv\u00e9nyek (pure function), ugyanis olyan adatt\u00f3l is f\u00fcgg a visszat\u00e9r\u00e9si \u00e9rt\u00e9ke, ami nem szerepel a param\u00e9terlist\u00e1j\u00e1n - ez eset\u00fcnkben a <code>searchText</code> v\u00e1ltoz\u00f3. A k\u00f3dunk az\u00e9rt m\u0171k\u00f6dik, mert a deleg\u00e1t megad\u00e1sakor a <code>searchText</code> aktu\u00e1lis \u00e9rt\u00e9k\u00e9t elkapjuk (capture), belerakjuk a f\u00fcggv\u00e9nylogik\u00e1ba.</p> <p>Pr\u00f3b\u00e1ljuk a <code>dogFunc</code>-ot <code>var</code>-k\u00e9nt deklar\u00e1lni.</p> <pre><code>//Ford\u00edt\u00e1si hiba!\nvar dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A ford\u00edt\u00f3 nem tudja meghat\u00e1rozni a <code>d</code> param\u00e9ter t\u00edpus\u00e1t, ez\u00e9rt kapjuk a ford\u00edt\u00e1si hib\u00e1t. Adjuk meg explicit a param\u00e9ter t\u00edpus\u00e1t.</p> <pre><code>var dogFunc =\n    (Dog d) =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Debugger-rel ellen\u0151rizhetj\u00fck, hogy a <code>dogFunc</code> val\u00f3di t\u00edpusa <code>Func&lt;Dog, bool&gt;</code> lesz.</p>"},{"location":"seminar/03-linq/chapter3/#ienumerablet-bovito-metodusok","title":"IEnumerable\\&lt;T&gt; b\u0151v\u00edt\u0151 met\u00f3dusok","text":"<p>Vigy\u00fck tov\u00e1bb az \u00e1ltal\u00e1nos\u00edt\u00e1st. \u00cdrjunk olyan logik\u00e1kat, mely nem csak kuty\u00e1k list\u00e1j\u00e1ra, hanem b\u00e1rmilyen felsorolhat\u00f3 (enumer\u00e1lhat\u00f3) kollekci\u00f3ra m\u0171k\u00f6dik. \u00cdrjunk <code>IEnumerable&lt;T&gt;</code> t\u00edpuson m\u0171k\u00f6d\u0151 seg\u00e9df\u00fcggv\u00e9nyeket.</p> <p>Hozzunk l\u00e9tre egy <code>EnumerableExtensions</code> (I bet\u0171 n\u00e9lk\u00fcl, az ugyanis interf\u00e9szre utal) nev\u0171 f\u00e1jlt az <code>Extensions</code> mapp\u00e1ban! Els\u0151k\u00e9nt val\u00f3s\u00edtsuk meg az \u00f6sszegz\u0151 logik\u00e1t.</p> <pre><code>namespace HelloLinq.Extensions.Enumerable;\n\npublic static class EnumerableExtensions\n{\n    public static int Sum&lt;T&gt;(IEnumerable&lt;T&gt;  source, Func&lt;T, int&gt;  sumSelector)\n    {\n        var result = 0;\n        foreach (var elem in source)\n        {\n            result += sumSelector(elem);\n        }\n        return result;\n    }\n}\n</code></pre> <p>H\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3db\u00f3l.</p> <pre><code>using HelloLinq.Extensions.Enumerable;\n\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\nforeach (var dog in Dogs)\n{\n    Console.WriteLine(dog);\n}\n\nConsole.WriteLine(\n    \"\u00c9letkorok \u00f6sszege: \" \n    + $\"{EnumerableExtensions.Sum(Dogs, d =&gt; d.Age ?? 0)}\");\n\nstring searchText;\n</code></pre> <p>A seg\u00e9df\u00fcggv\u00e9nyek h\u00e1tr\u00e1nya, hogy ismern\u00fcnk kell a seg\u00e9doszt\u00e1ly nev\u00e9t. Tov\u00e1bb\u00e1 jobb lenne, ha a kollekci\u00f3n k\u00f6zvetlen\u00fcl h\u00edvhatn\u00e1nk az \u00f6sszegz\u0151 f\u00fcggv\u00e9nyt. Erre megold\u00e1s a b\u0151v\u00edt\u0151 met\u00f3dus.</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok:</p> <ul> <li>statikus oszt\u00e1lyban defini\u00e1lhat\u00f3k</li> <li>statikus f\u00fcggv\u00e9nyek</li> <li>els\u0151 param\u00e9tere el\u0151tt <code>this</code> jel\u00f6li, hogy melyik t\u00edpust b\u0151v\u00edtik</li> </ul> <p>Az els\u0151 param\u00e9ter el\u00e9 tegy\u00fck be a <code>this</code> jel\u00f6l\u0151t.</p> <pre><code>public static int Sum&lt;T&gt; (\n    this IEnumerable&lt;T&gt;  source,\n    Func&lt;T, int&gt;  sumSelector)\n    {\n        // ...\n    }\n</code></pre> <p>Most m\u00e1r haszn\u00e1lhatjuk azt a szintaxist, mintha a kollekci\u00f3nak eleve lenne \u00f6sszegz\u0151 f\u00fcggv\u00e9nye:</p> <pre><code>Console.WriteLine($\"\u00c9letkorok \u00f6sszege: {Dogs.Sum(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>OO egys\u00e9gbez\u00e1r\u00e1si elv</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok semmilyen m\u00f3don nem bontj\u00e1k meg a t\u00edpusok egys\u00e9gbez\u00e1r\u00e1si k\u00e9pess\u00e9geit. A f\u00fcggv\u00e9nyek implement\u00e1ci\u00f3i a b\u0151v\u00edtend\u0151 t\u00edpusok k\u00edv\u00fclr\u0151l is el\u00e9rhet\u0151 f\u00fcggv\u00e9nyeit, propertyjeit haszn\u00e1lhatj\u00e1k, priv\u00e1t adattagokhoz, f\u00fcggv\u00e9nyekhez nem f\u00e9rnek hozz\u00e1.</p> <p>Oszt\u00e1ly nev\u00e9nek felold\u00e1sa</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok alkalmaz\u00e1sakor nagyon fontos, hogy b\u00e1r a b\u0151v\u00edt\u0151 met\u00f3dus oszt\u00e1ly\u00e1nak nev\u00e9t nem \u00edrjuk ki, az oszt\u00e1ly nev\u00e9nek feloldhat\u00f3nak kell lennie, azaz az oszt\u00e1ly n\u00e9vter\u00e9t <code>using</code> direkt\u00edv\u00e1val be kell hivatkoznunk. Egy pr\u00f3ba erej\u00e9ig kommentezz\u00fck ki a <code>using HelloLinq.Extensions.Enumerable;</code> sort \u00e9s ellen\u0151rizz\u00fck, hogy nem fordul a k\u00f3dunk, a b\u0151v\u00edt\u0151 met\u00f3dus nev\u00e9t a ford\u00edt\u00f3 nem tudja feloldani.</p> <p>Gyakorl\u00e1sk\u00e9ppen \u00edrhatunk tov\u00e1bbi gyakori adatfeldolgoz\u00e1si m\u0171veletekre f\u00fcggv\u00e9nyeket, mint amilyen az \u00e1tlagsz\u00e1m\u00edt\u00e1s, min-max keres\u00e9s.</p> Megold\u00e1s <pre><code>public static class EnumerableExtensions\n{\n    //...\n\n    public static double Average&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; sumSelector)\n    {\n        var result = 0.0; // Az oszt\u00e1s m\u0171velet miatt double\n        var elements = 0;\n        foreach (var elem in source)\n        {\n            elements++;\n            result += sumSelector(elem);\n        }\n        return result / elements;\n    }\n\n    public static int Min&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n    {\n        int value = int.MaxValue;\n        foreach (var elem in source)\n        {\n            var currentValue = valueSelector(elem);\n            if (currentValue &lt; value)\n            {\n                value = currentValue;\n            }\n        }\n        return value;\n    }\n\n    public static int Max&lt;T&gt; (this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n        =&gt; -source.Min(e =&gt; -valueSelector(e));\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az \u00faj f\u00fcggv\u00e9nyeket. Mivel a <code>Dogs</code> t\u00edpusa <code>IEnumerable&lt;Dog&gt;</code>, \u00edgy a b\u0151v\u00edt\u0151 met\u00f3dusok b\u0151v\u00edtend\u0151 t\u00edpusa illeszkedik r\u00e1.</p> <pre><code>Console.WriteLine($\"\u00c1tlagos \u00e9letkor: {Dogs.Average(d =&gt; d.Age ?? 0)}\");\nConsole.WriteLine(\n    $\"Minimum-maximum \u00e9letkor: \" +\n    $\"{Dogs.Min(d =&gt; d.Age ?? 0)} | {Dogs.Max(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>StringExtensions.cs</p> <p>A <code>StringExtensions</code> oszt\u00e1lyban egy lambdak\u00e9nt megval\u00f3s\u00edtott b\u0151v\u00edt\u0151 met\u00f3dust l\u00e1thatunk, ami egy sz\u00f6veget adott hosszra (sz\u00e9less\u00e9gre) eg\u00e9sz\u00edt ki sz\u00f3k\u00f6z\u00f6kkel. A f\u00fcggv\u00e9nyt a <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel.</p>"},{"location":"seminar/03-linq/chapter3/#gyakori-lekerdezo-muveletek-yield-return","title":"Gyakori lek\u00e9rdez\u0151 m\u0171veletek, yield return","text":"<p>Gyakran el\u0151fordul, hogy egy list\u00e1t sz\u0171rni vagy projekt\u00e1lni szeretn\u00e9nk. \u00cdrjunk saj\u00e1t gener\u00e1tort ezekhez a m\u0171veletekhez is az <code>EnumerableExtensions</code>-be:</p> <pre><code>public static IEnumerable&lt;T&gt; Where&lt;T&gt;(\n    this IEnumerable&lt;T&gt;  source, Predicate&lt;T&gt;  predicate)\n{\n    foreach (var elem in source)\n    {\n        if (predicate(elem))\n        {\n            yield return elem;\n        }\n    }\n}\n\npublic static IEnumerable&lt;TValue&gt; Select&lt;T, TValue&gt;(\n    this IEnumerable&lt;T&gt;  source, Func&lt;T, TValue&gt; selector)\n{\n    foreach (var elem in source)\n    {\n        yield return selector(elem);\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n, v\u00e1lasszuk ki a 2010 el\u0151tt sz\u00fcletett kuty\u00e1k nev\u00e9t \u00e9s kor\u00e1t egy stringbe:</p> <pre><code>foreach (var text in Dogs\n    .Where(d =&gt; d.DateOfBirth?.Year &lt; 2010)\n    .Select(d =&gt; $\"{d.Name} ({d.Age})\"))\n{\n    Console.WriteLine(text);\n}\n</code></pre> <p>A yield return haszna</p> <p>A <code>yield return</code> egy hasznos eszk\u00f6z, ha IEnumerable-t kell produk\u00e1lnunk visszat\u00e9r\u00e9si \u00e9rt\u00e9kk\u00e9nt. Seg\u00edts\u00e9g\u00e9vel mindig csak akkor \u00e1ll\u00edtjuk el\u0151 a k\u00f6vetkez\u0151 elemet, amikor a h\u00edv\u00f3 k\u00e9ri. A m\u0171k\u00f6d\u00e9s\u00e9t debuggerrel is figyelj\u00fck meg: tegy\u00fcnk breakpointot a k\u00e9t <code>yield return</code> sorra, majd F10-zel k\u00f6vess\u00fck v\u00e9gig, ahogy a <code>foreach</code> elk\u00e9ri a <code>Select</code>-t\u0151l a k\u00f6vetkez\u0151 elemet, ami emiatt elk\u00e9ri a <code>Where</code>-t\u0151l, majd \u00fajraindul a ciklus. A h\u00edv\u00e1sok \u00e1llapotg\u00e9pk\u00e9nt m\u0171k\u00f6dnek, a k\u00f6vetkez\u0151 megh\u00edv\u00e1skor onnan folytat\u00f3dnak, ahonnan az el\u0151z\u0151 <code>yield return</code>-n\u00e9l kil\u00e9pt\u00fcnk.</p> <p>Nem nagy meglepet\u00e9s, hogy az \u00e1ltalunk meg\u00edrt <code>Sum</code>, <code>Average</code> (melyek egyedi visszat\u00e9r\u00e9s\u0171ek), <code>Select</code> \u00e9s <code>Where</code> (amik szekvenci\u00e1lis visszat\u00e9r\u00e9s\u0171ek, gener\u00e1torok) met\u00f3dusok mind a .NET keretrendszer r\u00e9sz\u00e9t k\u00e9pezik (a <code>System.Linq.Enumerable</code> statikus oszt\u00e1lyban defini\u00e1lt b\u0151v\u00edt\u0151 met\u00f3dusok). A LINQ\u2009\u2014\u2009**L**anguage **IN**tegrated **Q**uery\u2009\u2014\u2009ezeket a m\u0171veleteket teszi lehet\u0151v\u00e9 <code>IEnumerable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 objektumokon. A LINQ f\u00fcggv\u00e9nyek b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt lettek hozz\u00e1adva meglev\u0151 funkcionalit\u00e1shoz (kollekci\u00f3khoz, lek\u00e9rdez\u00e9sekhez), s\u0151t, k\u00fcls\u0151 library-k is adnak saj\u00e1t LINQ b\u0151v\u00edt\u0151 met\u00f3dusokat.</p> <p>Cser\u00e9lj\u00fck le a <code>Program.cs</code>-ben a <code>using HelloLinq.Extensions.Enumerable</code> hivatkoz\u00e1st <code>using System.Linq</code>-re: az \u00e1ltalunk meg\u00edrt k\u00f3d tov\u00e1bbra is ugyanazt az eredm\u00e9nyt produk\u00e1lja! N\u00e9zz\u00fck meg, hogy hol vannak defini\u00e1lva ezek a f\u00fcggv\u00e9nyek a keretrendszeren bel\u00fcl: a kurzort tegy\u00fck a k\u00f3dban oda, ahol valamelyik kor\u00e1bban meg\u00edrt f\u00fcggv\u00e9ny\u00fcnket h\u00edvn\u00e1nk, majd nyomjunk F12-t. Pr\u00f3b\u00e1ljuk ki, hogy tov\u00e1bbra is az elv\u00e1rt m\u00f3don m\u0171k\u00f6dik-e a programunk.</p> <p>Implicit usings</p> <p>A n\u00e9vt\u00e9rcsere helyett bekapcsolhatjuk a glob\u00e1lis implicit n\u00e9vt\u00e9r funkci\u00f3t, mert a <code>System.Linq</code> n\u00e9vt\u00e9r is egy implicit hivatkozott n\u00e9vt\u00e9r. Ehhez a projektf\u00e1jlban az <code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;</code> be\u00e1ll\u00edt\u00e1st \u00edrjuk \u00e1t <code>enable</code>-re, majd a <code>using HelloLinq</code> -en k\u00edv\u00fcl minden n\u00e9vt\u00e9rhivatkoz\u00e1st t\u00f6r\u00f6lj\u00fcnk a <code>Program.cs</code>-b\u0151l.</p>"},{"location":"seminar/03-linq/chapter3/#anonim-tipusok","title":"Anonim t\u00edpusok","text":"<p>Lek\u00e9rdez\u00e9sekn\u00e9l gyakran haszn\u00e1latosak az anonim t\u00edpusok, amelyeket jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9nek ideiglenes, t\u00edpusos t\u00e1rol\u00e1s\u00e1ra haszn\u00e1lunk. Az anonim t\u00edpusokkal lehet\u0151s\u00e9g\u00fcnk van inline defini\u00e1lni olyan oszt\u00e1lyokat, amelyek jellemz\u0151en csak dobozol\u00e1sra \u00e9s adattov\u00e1bb\u00edt\u00e1sra haszn\u00e1ltak. Vegy\u00fck az al\u00e1bbi p\u00e9ld\u00e1kat a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n:</p> <pre><code>var dolog1 = new { Name = \"Alma\", Weight = 100, Size = 10 };\nvar dolog2 = new { Name = \"K\u00f6rte\", Weight = 90 };\n</code></pre> <p>Kor\u00e1bban m\u00e1r eml\u00edtett\u00fck a <code>var</code> kulcssz\u00f3t, amellyel implicit t\u00edpus\u00fa, lok\u00e1lis v\u00e1ltoz\u00f3k defini\u00e1lhat\u00f3k. Az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n defini\u00e1lunk egy-egy anonim t\u00edpust, amelynek felvesz\u00fcnk n\u00e9h\u00e1ny tulajdons\u00e1got. A tulajdons\u00e1gok mind t\u00edpusosak maradnak, a t\u00edpusrendszer\u00fcnk tov\u00e1bbra is s\u00e9rtetlen. Az implicit statikus t\u00edpusoss\u00e1g nem csak a <code>var</code> kulcssz\u00f3ban jelenik meg teh\u00e1t, hanem az egyes tulajdons\u00e1gok t\u00edpus\u00e1ban is.</p> <p>Az anonim t\u00edpusok:</p> <ul> <li>csak referencia t\u00edpus\u00faak lehetnek (objektumok, nem pedig strukt\u00far\u00e1k),</li> <li>csak publikusan l\u00e1that\u00f3, csak olvashat\u00f3 tulajdons\u00e1gokat tartalmazhatnak,</li> <li>esem\u00e9nyeket \u00e9s met\u00f3dusokat nem tartalmazhatnak (delegate p\u00e9ld\u00e1nyokat tulajdons\u00e1gban viszont igen),</li> <li>szerelv\u00e9nyen bel\u00fcl l\u00e1that\u00f3k (<code>internal</code>) \u00e9s nem sz\u00e1rmazhat bel\u0151l\u00fck m\u00e1sik t\u00edpus (<code>sealed</code>)</li> <li>t\u00edpusnev\u00e9t nem ismerj\u00fck, \u00edgy hivatkozni sem tudunk r\u00e1, csak a <code>var</code>-t tudjuk haszn\u00e1lni</li> <li>nem haszn\u00e1lhat\u00f3k ott, ahol a <code>var</code> t\u00edpus se haszn\u00e1lhat\u00f3, t\u00f6bbek k\u00f6z\u00f6tt nem adhatjuk \u00e1t f\u00fcggv\u00e9nynek \u00e9s nem lehet visszat\u00e9r\u00e9si \u00e9rt\u00e9k sem</li> </ul> <p>Ha az egeret a <code>var</code> kulcsszavak vagy egyes tulajdons\u00e1gnevek f\u00f6l\u00e9 vissz\u00fck, l\u00e1thatjuk, hogy val\u00f3ban ford\u00edt\u00e1si idej\u0171 t\u00edpusokr\u00f3l van sz\u00f3.</p> <p>IntelliSense</p> <p>Figyelj\u00fck meg, hogy az IntelliSense is m\u0171k\u00f6dik ezekre a t\u00edpusokra, felk\u00edn\u00e1lja a t\u00edpus property-jeit.</p> <p>A ford\u00edt\u00f3 \u00fajra is hasznos\u00edtja az egyes t\u00edpusokat:</p> <pre><code>var dolgok = new { Name = \"Gy\u00fcm\u00f6lcs\u00f6k\", Contents = new[] { dolog1, dolog2 } };\n</code></pre> <p>A <code>Contents</code> tulajdons\u00e1g t\u00edpusa a fenti anonim objektumaink t\u00f6mbje, ez\u00e9rt nem is adhatn\u00e1nk meg m\u00e1sk\u00e9ppen (nem tudjuk a nev\u00e9t, amivel hivatkozhatunk r\u00e1). A ford\u00edt\u00f3 most panaszkodik, ugyanis a k\u00e9t dolog t\u00edpusa nem implicit k\u00f6vetkeztethet\u0151. Ha felvessz\u00fck a <code>Size</code> tulajdons\u00e1got a <code>dolog2</code> defin\u00edci\u00f3j\u00e1ba, m\u00e1ris fordul.</p> <pre><code>var dolog2 = new { Name = \"K\u00f6rte\", Weight = 90, Size = 12 };\n</code></pre> <p>Ha v\u00e9gezt\u00fcnk az anonim t\u00edpusokkal val\u00f3 ismerked\u00e9ssel, az ezekkel kapcsolatos k\u00f3dsorokat kikommentezhetj\u00fck.</p>"},{"location":"seminar/03-linq/chapter3/#linq-szintaxisok","title":"LINQ szintaxisok","text":"<p>Az el\u0151z\u0151 r\u00e9szben ismertetett jelleg\u0171 lek\u00e9rdez\u00e9sek nagyban hasonl\u00edtanak azokhoz, amiket adatb\u00e1zis-lek\u00e9rdez\u00e9sekben alkalmazunk. A k\u00fcl\u00f6nbs\u00e9g itt az, hogy imperat\u00edv szintaxist haszn\u00e1lunk, szemben pl. az SQL-lel, ami deklarat\u00edvat. Ez\u00e9rt is van jelen a C# nyelvben az \u00fan. query syntax, amely j\u00f3val hasonlatosabb az SQL szintaxis\u00e1hoz, \u00edgy az adatb\u00e1zisokban j\u00e1rtas fejleszt\u0151k is k\u00f6nnyebben \u00edrhatnak lek\u00e9rdez\u00e9seket. Ugyanakkor nem minden lek\u00e9rdez\u00e9st tudunk query syntax-szal le\u00edrni.</p> <p>Mi\u00e9rt nem lehet mindent meg\u00edrni query syntaxban?</p> <p>Ennek oka, hogy az oper\u00e1torok bevezet\u00e9se egy nyelvben el\u00e9g dr\u00e1ga - le kell p\u00e9l\u00e1dul foglalni az oper\u00e1tor nev\u00e9t, amit ut\u00e1na korl\u00e1tozottan lehet csak haszn\u00e1lni m\u00e1sra. Ez\u00e9rt sem csin\u00e1lt\u00e1k meg minden LINQ f\u00fcggv\u00e9nynek az oper\u00e1tor p\u00e1rj\u00e1t, csak az SQL-ben gyakrabban haszn\u00e1latosabbaknak.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3 lek\u00e9rdez\u00e9st meg\u00edrhatunk az al\u00e1bbi m\u00f3don query syntax haszn\u00e1lat\u00e1val:</p> <pre><code>using HelloLinq.Extensions;\n\n//...\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\n\nvar query = from d in Dogs\n            where d.DateOfBirth?.Year &lt; 2010\n            select new\n            {\n                Dog = d,\n                AverageSiblingAge = d.Siblings.Average(s =&gt; s.Age ?? 0)\n            };\nforeach (var meta in query)\n{\n    Console.WriteLine(\n        $\"{meta.Dog.Name} - {meta.AverageSiblingAge}\");\n}\n</code></pre> <p>A query szintaxis v\u00e9g\u00fcl a kor\u00e1bban is haszn\u00e1lt, \u00fan. *fluent szintaxis*s\u00e1 fordul. Ennek igazol\u00e1s\u00e1ra n\u00e9zz\u00fck meg F12-vel, hogy hol vannak defini\u00e1lva az \u00fajonnan megismert oper\u00e1torok (<code>select</code>, <code>where</code>). A k\u00e9t szintaxist szok\u00e1s \u00f6tv\u00f6zni is, jellemz\u0151en akkor, ha query szintaxisban \u00edrjuk a lek\u00e9rdez\u00e9st, \u00e9s a hi\u00e1nyz\u00f3 funkcionalit\u00e1st fluent szintaxissal p\u00f3toljuk.</p> <p>Fluent szintaxis</p> <p>A fluent szintaxist olyan kialak\u00edt\u00e1s\u00fa API-kn\u00e1l alkalmazhatjuk, ahol a f\u00fcggv\u00e9nyek a tartalmaz\u00f3 t\u00edpust v\u00e1rj\u00e1k (egyik) bemenetk\u00e9nt \u00e9s azonos (vagy lesz\u00e1rmazott) t\u00edpust adnak vissza. A LINQ-n\u00e9l ez a t\u00edpus az <code>IEnumerable&lt;&gt;</code>.</p> <p>Ezen az \u00f3r\u00e1n mem\u00f3riabeli adatforr\u00e1sokkal dolgoztunk (konkr\u00e9tan a <code>Dogs</code> nev\u0171 <code>Dictionary&lt;,&gt;</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3val), a LINQ oper\u00e1torok k\u00f6z\u00fcl a mem\u00f3riabeli list\u00e1kon dolgoz\u00f3kat haszn\u00e1ltuk, melyeket az <code>IEnumerable&lt;&gt;</code> interf\u00e9szre biggyesztettek r\u00e1 b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt. Ezt a LINQ API-t teljes nev\u00e9n *LINQ-to-Objects*nek h\u00edvj\u00e1k, de gyakran csak LINQ-k\u00e9nt hivatkozz\u00e1k.</p>"},{"location":"seminar/03-linq/chapter3/#kitekinto-expression-linq-providerek","title":"Kitekint\u0151: Expression\\&lt;&gt;, LINQ providerek","text":"<p>Vegy\u00fck az al\u00e1bbi nagyon egyszer\u0171 delegate-et \u00e9s ennek <code>Expression&lt;&gt;</code>-\u00f6s p\u00e1rj\u00e1t.</p> <pre><code>Func&lt;int, int&gt;  f = x =&gt; x + 1;\nExpression&lt;Func&lt;int, int&gt;&gt; e = x =&gt; x + 1;\n</code></pre> <p>N\u00e9zz\u00fck meg debuggol\u00e1s k\u00f6zben a Watch ablakban a fenti k\u00e9t v\u00e1ltoz\u00f3t. Az <code>f</code> egy delegate, leford\u00edtott k\u00f3d*ra mutat\u00f3 referencia, az <code>Expression</code> a jobb oldali kifejez\u00e9sb\u0151l \u00e9p\u00edtett (fa strukt\u00far\u00e1j\u00fa) *adat.</p> <p>A f\u00e1t k\u00f3dd\u00e1 ford\u00edthatjuk a <code>Compile</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel, mely a leford\u00edtott f\u00fcggv\u00e9ny referenci\u00e1j\u00e1t (deleg\u00e1t p\u00e9ld\u00e1ny) adja vissza, amit a f\u00fcggv\u00e9nyh\u00edv\u00e1s szintaxissal h\u00edvhatunk meg. Ebb\u0151l \u00e1ll \u00f6ssze az al\u00e1bbi fura kin\u00e9zet\u0171 kifejez\u00e9s:</p> <pre><code>Console.WriteLine(e.Compile()(5));\n</code></pre> <p>B\u00e1r az <code>Expression&lt;&gt;</code> emiatt okosabb v\u00e1laszt\u00e1snak t\u0171nik, \u00e1m a LINQ-to-Objects alapinterf\u00e9sz\u00e9nek (ami a lek\u00e9rdez\u0151f\u00fcggv\u00e9nyeket biztos\u00edtja) f\u00fcggv\u00e9nyei <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code> deleg\u00e1tokat v\u00e1rnak. Ami nem csoda, hiszen mem\u00f3riabeli list\u00e1kat \u00e1ltal\u00e1ban sima programk\u00f3ddal dolgozunk fel, nincs \u00e9rtelme fel\u00e9p\u00edteni kifejez\u00e9sf\u00e1t csak az\u00e9rt, hogy ut\u00e1na egyb\u0151l k\u00f3dd\u00e1 ford\u00edtsuk. Emellett m\u00e1s, mem\u00f3riabeli adatokon dolgoz\u00f3 LINQ technol\u00f3gia is l\u00e9tezik, pl. LINQ-to-XML saj\u00e1t API-val (nem <code>IEnumerable&lt;&gt;</code> alapt\u00edpussal).</p> <p>A nem mem\u00f3riabeli adatokon, hanem p\u00e9ld\u00e1ul k\u00fcls\u0151 adatb\u00e1zisb\u00f3l dolgoz\u00f3 LINQ provider-ek viszont <code>IQueryable&lt;&gt;</code>-t val\u00f3s\u00edtanak meg. Az <code>IQueryable&lt;&gt;</code> az <code>IEnumerable&lt;&gt;</code>-b\u00f3l sz\u00e1rmazik, \u00edgy neki is vannak <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code>-\u00f6s f\u00fcggv\u00e9nyei, de emellett <code>Expression&lt;&gt;</code>-\u00f6sek is. Ez ut\u00f3bbiak teszik lehet\u0151v\u00e9, hogy ne csak .NET k\u00f3dot gener\u00e1ljanak a lambda kifejez\u00e9sekb\u0151l, hanem helyette pl. SQL kifejez\u00e9st - hiszen egy rel\u00e1ci\u00f3s adatb\u00e1zis adatfeldolgoz\u00f3 nyelve nem .NET, hanem valamilyen SQL dialektus.</p>"},{"location":"seminar/03-linq/chapter3/#a-linq-providerek-altalanos-mukodese","title":"A LINQ providerek \u00e1ltal\u00e1nos m\u0171k\u00f6d\u00e9se","text":"<p>Bemenet\u00fck: query f\u00fcggv\u00e9nyeknek (<code>IQueryable&lt;&gt;</code> vagy <code>IEnumerable&lt;&gt;</code> f\u00fcggv\u00e9nyei vagy pl. <code>XDocument</code>) param\u00e9ter\u00fcl adott lambd\u00e1k (<code>Func&lt;&gt;</code> vagy <code>Expression&lt;&gt;</code>)</p> <p>Kimenet\u00fck: az adatforr\u00e1snak megfelel\u0151 nyelv\u0171, a query-t v\u00e9grehajt\u00f3 k\u00f3d (.NET k\u00f3d vagy SQL).</p> <p>LINQ-to-Objects eset\u00e9n nincs val\u00f3di LINQ provider (a provider az <code>IQueryable.Provider</code>-en kereszt\u00fcl \u00e9rhet\u0151 el, de a <code>List&lt;&gt;</code> nem <code>IQueryable</code>!), hiszen nincs feladata: k\u00f3dot kap bemenet\u00fcl, ugyanazt kellene kimenet\u00fcl adnia. A LINQ-to-XML is hasonl\u00f3 elven m\u0171k\u00f6dik.</p> <p>Val\u00f3di LINQ providert val\u00f3s\u00edt meg p\u00e9ld\u00e1ul az Entity Framework Core, de ezt a technol\u00f3gi\u00e1t k\u00e9s\u0151bb t\u00e1rgyaljuk.</p>"},{"location":"seminar/04-csharp4/chapter4/","title":"C# alapok IV.","text":"<p>Ezen a gyakorlaton t\u00f6bb k\u00fcl\u00f6nf\u00e9le nyelvi konstrukci\u00f3t tekint\u00fcnk \u00e1t, vegyesfelv\u00e1gott jelleggel. Az egyes f\u0151 t\u00e9mak\u00f6r\u00f6ket k\u00fcl\u00f6n projektk\u00e9nt dolgozzuk ki. A projekteket hozz\u00e1adhatjuk az els\u0151k\u00e9nt l\u00e9trehozott projekt solutionj\u00e9hez (menu:jobbklikk a solution-\u00f6n[Add &gt; New project]). Hozz\u00e1ad\u00e1s ut\u00e1n ne felejts\u00fck el \u00e1t\u00e1ll\u00edtani a futtatand\u00f3 projektet: menu:jobbklikk a projekten[Set as Startup Project].</p>"},{"location":"seminar/04-csharp4/chapter4/#bejarasi-problemak","title":"Bej\u00e1r\u00e1si probl\u00e9m\u00e1k","text":"<p>Enumer\u00e1torok haszn\u00e1lata eset\u00e9n k\u00e9t alapvet\u0151 probl\u00e9m\u00e1ba \u00fctk\u00f6z\u00fcnk: az egyik a m\u00f6g\u00f6ttes kollekci\u00f3 m\u00f3dosul\u00e1sa bej\u00e1r\u00e1s sor\u00e1n, a m\u00e1sik pedig a k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9sb\u0151l ad\u00f3d\u00f3 mell\u00e9khat\u00e1sok kezel\u00e9se.</p>"},{"location":"seminar/04-csharp4/chapter4/#kollekcio-modosulasa-bejarasa-soran","title":"Kollekci\u00f3 m\u00f3dosul\u00e1sa bej\u00e1r\u00e1sa sor\u00e1n","text":"<p>Sz\u0171rj\u00fcnk le egy sz\u00e1mokat tartalmaz\u00f3 kollekci\u00f3t csak azokra az elemekre, amik megfelelnek egy felt\u00e9telnek, \u00e9s ezeket t\u00e1vol\u00edtsuk el a kollekci\u00f3b\u00f3l!</p> <pre><code>var numbers = Enumerable.Range(1, 8).ToList();\nforeach (var p in numbers)\n{\n    if (p % 2 == 0)\n    {\n        numbers.Remove(p);\n    }\n}\nnumbers.ForEach(Console.WriteLine);\n</code></pre> <p>Futtat\u00e1skor kiv\u00e9telt kapunk. Mi a probl\u00e9ma? A kollekci\u00f3t bej\u00e1r\u00e1s k\u00f6zben szerett\u00fck volna m\u00f3dos\u00edtani, viszont ez k\u00f6nnyen nem v\u00e1rt m\u0171k\u00f6d\u00e9st (t\u00falc\u00edmz\u00e9st, nemdeterminisztikus bej\u00e1r\u00e1st) tenne lehet\u0151v\u00e9, ez\u00e9rt kiv\u00e9telt kapunk. Oldjuk meg a probl\u00e9m\u00e1t: nem m\u00f3dos\u00edthatjuk a forr\u00e1s objektumot bej\u00e1r\u00e1s k\u00f6zben, teh\u00e1t ne azt a kollekci\u00f3t j\u00e1rjuk be, m\u00e1soljuk le!</p> <pre><code>foreach (var p in numbers.ToList()) // a ToList beker\u00fclt\n{\n    // ...\n}\n</code></pre> <p>Ez megoldja a probl\u00e9m\u00e1t, siker\u00fcl elt\u00e1vol\u00edtani az elemeket a kollekci\u00f3b\u00f3l. De mi\u00e9rt? A <code>ToList</code> <code>IEnumerable</code> b\u0151v\u00edt\u0151, teh\u00e1t bej\u00e1rhatja a kollekci\u00f3t, ezut\u00e1n pedig egy m\u00e1sik <code>List&lt;&gt;</code> objektumban t\u00e1rolja az elemeket. \u00cdgy teh\u00e1t k\u00e9t list\u00e1nk lesz (a <code>numbers</code> \u00e9s a <code>numbers.ToList</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9ke), amik kezdetben egym\u00e1s kl\u00f3njai, menet k\u00f6zben az egyikb\u0151l vesz\u00fcnk ki, a m\u00e1sikon pedig iter\u00e1lunk.</p> <p>Kiv\u00e9telek</p> <p>B\u00e1r a fenti az \u00e1ltal\u00e1nos szab\u00e1ly, bizonyos kollekci\u00f3k bizonyos m\u00f3dos\u00edt\u00f3 m\u0171veletei m\u00e9gsem dobnak kiv\u00e9telt, ilyen p\u00e9ld\u00e1ul a <code>Dictionary&lt;,&gt;</code> <code>Remove</code> \u00e9s <code>Clear</code> m\u0171veletei.</p>"},{"location":"seminar/04-csharp4/chapter4/#azonnali-es-kesleltetett-kiertekeles","title":"Azonnali \u00e9s k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s","text":"<p>Amennyiben egy met\u00f3dus gener\u00e1tor (<code>IEnumerable</code> vagy <code>IEnumerable&lt;&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171), az egyes elemeken t\u00f6rt\u00e9n\u0151 iter\u00e1ci\u00f3 a gener\u00e1torok egym\u00e1sba \u00e1gyaz\u00e1s\u00e1t jelenti, azaz az egyes gener\u00e1torokban a <code>yield return</code> \u00e1ltal visszaadott \u00e9rt\u00e9ket fogja az enumer\u00e1tor <code>MoveNext</code> met\u00f3dusa visszaadni. Am\u00edg az <code>IEnumerable</code>-re van referenci\u00e1nk, \u00e9s nem j\u00e1rjuk azt k\u00f6zvetlen\u00fcl be, addig k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9sr\u0151l besz\u00e9l\u00fcnk.</p> <p>Az eddigiek al\u00e1:</p> <pre><code>var i = 0;\nforeach (var n in numbers\n    .Where(p =&gt; p &gt; 2)\n    .Select(p =&gt; new { p, x = ++i }))\n{\n    Console.WriteLine($\"{n} - {i}\");\n}\n\nConsole.WriteLine();\n\ni = 0;\nforeach (var n in numbers\n    .Where(p =&gt; p &gt; 2)\n    .Select(p =&gt; new { p, x = ++i })\n    .ToList())\n{\n    Console.WriteLine($\"{n} - {i}\");\n}\n</code></pre> <p>A <code>ToList</code> h\u00edv\u00e1sunk el\u0151sz\u00f6r bej\u00e1rja az iter\u00e1tort \u00e9s visszaad egy list\u00e1t, amelybe \u00f6sszegy\u0171jti az <code>IEnumerable</code> elemeit. Ez\u00e9rt az <code>i</code> v\u00e1ltoz\u00f3nk a m\u00e1sodik esetben nem egy\u00fctt inkrement\u00e1l\u00f3dik a bej\u00e1r\u00e1ssal, mert az k\u00e9tszer t\u00f6rt\u00e9nik meg. Az els\u0151 bej\u00e1r\u00e1skor (a <code>ToList</code> h\u00edv\u00e1sakor) inkrement\u00e1l\u00f3dik az <code>i</code> \u00e9rt\u00e9ke, m\u00e1sodj\u00e1ra pedig m\u00e1r csak bej\u00e1rjuk a kapott list\u00e1t. Eddigre az <code>i</code> \u00e9rt\u00e9ke m\u00e1r meg van n\u00f6velve.</p> <p>Ezzel a megk\u00f6zel\u00edt\u00e9ssel fut\u00e1sid\u0151ben is \u00e1ll\u00edthatunk \u00f6ssze egy id\u0151ben v\u00e1ltoz\u00f3 lek\u00e9rdez\u00e9st, amit majd egyszer, a k\u00e9s\u0151bbiekben fogunk bej\u00e1rni (pl. soros\u00edt\u00e1skor).</p>"},{"location":"seminar/04-csharp4/chapter4/#aszinkron-mukodes","title":"Aszinkron m\u0171k\u00f6d\u00e9s","text":"<p>T\u00f6lts\u00fcnk le egy HTML oldalt, \u00e9s ezen a probl\u00e9m\u00e1n kereszt\u00fcl bemutatjuk az aszinkron programoz\u00e1si modellt. A <code>HttpClient</code> m\u0171k\u00f6d\u00e9s\u00e9nek a r\u00e9szletesebb ismertet\u00e9se most nem t\u00e9ma, csak a legalapvet\u0151bb funkci\u00f3kat fogjuk haszn\u00e1lni.</p> <p>A f\u0151 gond, hogy a hosszan fut\u00f3 m\u0171veletek blokkolhatj\u00e1k a f\u0151/UI/aktu\u00e1lis sz\u00e1l fut\u00e1s\u00e1t, mindez kliens alkalmaz\u00e1sok eset\u00e9ben \u00fagy jelentkezik, hogy nem lesz az alkalmaz\u00e1sunk reszponz\u00edv a felhaszn\u00e1l\u00f3i bemenetekre; szerveralkalmaz\u00e1sok eset\u00e9ben pedig az adott k\u00e9r\u00e9st kiszolg\u00e1l\u00f3 sz\u00e1l feleslegesen blokkol\u00f3dik, amikor esetleg m\u00e1ssal is tudna foglalkozni.</p> <p>\u00d6tlet: a hosszan tart\u00f3 m\u0171veleteket v\u00e9gezz\u00fck aszinkron m\u00f3don, \u00e9s ha az befejez\u0151d\u00f6tt az eredm\u00e9nyr\u0151l valamilyen m\u00f3don \u00e9rtes\u00fclj\u00fcnk. A keretrendszer t\u00f6bbf\u00e9le mint\u00e1t k\u00edn\u00e1l erre:</p> <ul> <li>Asynchronous Programming Model (APM),</li> <li>Event-based Asynchronous Pattern (EAP),</li> <li>Task-based Asynchronous Pattern (TAP).</li> </ul> <p>Mi most a legut\u00f3bbival foglalkozunk csak, a t\u00f6bbi j\u00f3r\u00e9szt elavultnak sz\u00e1m\u00edt ma m\u00e1r.</p>"},{"location":"seminar/04-csharp4/chapter4/#tap-es-asyncawait-alapjai","title":"TAP \u00e9s async/await alapjai","text":"<p>A TAP-ra m\u00e1r C# nyelvi t\u00e1mogat\u00e1st is kapunk az <code>async</code>/<code>await</code> kulcsszavakon kereszt\u00fcl. Vegy\u00fcnk fel egy \u00faj met\u00f3dust \u00e9s h\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3dban. A meg\u00edrt met\u00f3dus \u00edr\u00e1sa sor\u00e1n hivatkozzuk be a <code>System.Net.Http</code> n\u00e9vteret. A k\u00f3d semmi m\u00e1st nem csin\u00e1l, csak elind\u00edt aszinkron m\u00f3don egy HTTP GET k\u00e9r\u00e9st a megadott URL-re, illetve a v\u00e1lasz tartalm\u00e1t is aszinkron m\u00f3don kiolvassa \u00e9s egy r\u00e9sz\u00e9t ki\u00edrja a konzolra.</p> <pre><code>LoadWebPageAsync();\nConsole.WriteLine(\"Ez a v\u00e9ge\");\nConsole.ReadKey();\n\nstatic async void LoadWebPageAsync()\n{\n    using var client = new HttpClient();\n\n    var response = await client.GetAsync(new Uri(\"http://www.bing.com\"));\n    Console.WriteLine(response.StatusCode.ToString());\n\n    var content = await response.Content.ReadAsStringAsync();\n    Console.WriteLine(content.Take(1000).ToArray());\n}\n</code></pre> <p>await: Mindig egy <code>Task</code> <code>await</code>-elhet\u0151 (vagy taszk szer\u0171 dolog: vagyis van neki <code>GetAwaiter</code> met\u00f3dusa, ami meghat\u00e1rozott met\u00f3dusokkal rendelkez\u0151 objektummal t\u00e9r vissza)! Ak\u00e1r l\u00e9tre is hozhatunk egy <code>Task</code>-ot, amit egy lok\u00e1lis v\u00e1ltoz\u00f3ban t\u00e1rolunk, akkor azt is tudjuk <code>await</code>-elni.</p> <p>async: Ha await-elni akarunk, akkor musz\u00e1j <code>async</code>-nak lennie a tartalmaz\u00f3 met\u00f3dusnak, mert ilyenkor \u00e9p\u00edti fel a ford\u00edt\u00f3 az aszinkron v\u00e9grehajt\u00e1shoz sz\u00fcks\u00e9ges \u00e1llapotg\u00e9pet.</p> <p>Debuggoljuk ki! Minden <code>Console</code>, <code>async</code> sorra tegy\u00fcnk t\u00f6r\u00e9spontot, debuggol\u00e1s sor\u00e1n (F5) k\u00f6vess\u00fck v\u00e9gig, milyen sorrendben \u00e9ri el \u0151ket a v\u00e9grehajt\u00e1s. N\u00e9zz\u00fck meg, melyik r\u00e9sz milyen sz\u00e1lon fut le (debug k\u00f6zben menu:Debug[Windows &gt; Threads]). A <code>LoadWebPageAsync</code> ut\u00e1ni r\u00e9sz el\u0151bb fog lefutni, mint az els\u0151 <code>await</code> ut\u00e1ni r\u00e9sz. Az <code>await</code> ut\u00e1ni r\u00e9sz nem a Main Thread-en fut. Figyelj\u00fck meg azt is, hogy az Ez a v\u00e9ge sz\u00f6veg hamarabb ki\u00edr\u00f3dik, mint a HTML oldal let\u00f6lt\u00e9se.</p> <p>Pr\u00f3b\u00e1ljuk ki a <code>Console.ReadKey</code>-t kikommentezve is, ilyenkor j\u00f3 es\u00e9llyel hamarabb le\u00e1ll a process, minthogy a <code>Task</code> befejez\u0151dne. Az ilyen fire-and-forget t\u00edpus\u00fa h\u00edv\u00e1sokn\u00e1l nem figyel arra senki, hogy itt m\u00e9g valami h\u00e1tt\u00e9rm\u0171velet folyik.</p> <p>async void ker\u00fclend\u0151</p> <p>Az <code>async void</code> \u00e1ltal\u00e1ban helytelen k\u00f3d, mert nem lehet bev\u00e1rni a h\u00e1tt\u00e9rm\u0171velet v\u00e9g\u00e9t. Az <code>async Task</code> m\u00e1ris jobb a bev\u00e1rhat\u00f3s\u00e1g \u00e9s a hibakezel\u00e9s miatt, \u00e9s alig kell m\u00f3dos\u00edtani a k\u00f3dot. Kiv\u00e9tel, amikor valami\u00e9rt k\u00f6telez\u0151 a <code>void</code>, p\u00e9ld\u00e1ul, ha esem\u00e9ny vagy interf\u00e9sz el\u0151\u00edrja.</p>"},{"location":"seminar/04-csharp4/chapter4/#az-oldalletoltes-bevarasa","title":"Az oldallet\u00f6lt\u00e9s bev\u00e1r\u00e1sa","text":"<p>M\u00f3dos\u00edtsuk \u00fagy a k\u00f3dot, hogy a <code>LoadWebPageAsync</code> ut\u00e1ni r\u00e9sz v\u00e1rja meg a let\u00f6lt\u00e9s befejez\u0151d\u00e9s\u00e9t. Ez akkor j\u00f3 p\u00e9ld\u00e1ul, ha a let\u00f6lt\u00e9s ut\u00e1n valamit m\u00e9g szeretn\u00e9k elv\u00e9gezni a h\u00edv\u00f3 f\u00fcggv\u00e9nyben.</p> <p>M\u00f3dos\u00edtsuk a <code>LoadWebPageAsync</code> fejl\u00e9c\u00e9t, hogy taszkot adjon vissza:</p> <pre><code>public static async Task LoadWebPageAsync() //void helyett Task\n</code></pre> <p>V\u00e1rjuk be az aszinkron m\u0171velet v\u00e9g\u00e9t a legfels\u0151 szint\u0171 k\u00f3dban.</p> <pre><code>await LoadWebPageAsync(); //await beker\u00fclt\nConsole.WriteLine(\"Ez a v\u00e9ge\");\n/*Console.ReadKey();*/\n</code></pre> <p>Figyelj\u00fck meg, hogy \u00edgy m\u00e1r az Ez a v\u00e9ge felirat m\u00e1r a let\u00f6lt\u00e9s ut\u00e1n jelenik meg.</p> <p><code>await</code>-et haszn\u00e1ltunk a legfels\u0151 szint\u0171 k\u00f3dban, ilyenkor automatikusan <code>async</code> kulcssz\u00f3val ell\u00e1tott <code>Main</code> gener\u00e1l\u00f3dik - valami hasonl\u00f3, mint az al\u00e1bbi k\u00f3dr\u00e9szlet.</p> <pre><code>await LoadWebPageAsync();\nConsole.WriteLine(\"Ez a v\u00e9ge\");\n//Console.ReadKey();\n</code></pre>"},{"location":"seminar/04-csharp4/chapter4/#hattermuvelet-eredmenyenek-visszaadasa","title":"H\u00e1tt\u00e9rm\u0171velet eredm\u00e9ny\u00e9nek visszaad\u00e1sa","text":"<p>Alak\u00edtsuk \u00e1t, hogy a weboldal tartalm\u00e1nak ki\u00edrat\u00e1sa a legfels\u0151 szint\u0171 k\u00f3dban t\u00f6rt\u00e9njen, \u00e9s a <code>LoadWebPageAsync</code> csak adja vissza a tartalmat <code>string</code>-k\u00e9nt. Ehhez m\u00f3dos\u00edtsuk a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket <code>Task&lt;string&gt;</code>-re, \u00edgy az <code>await</code> m\u00e1r eredm\u00e9nnyel fog tudni visszat\u00e9rni.</p> <pre><code>var content = await LoadWebPageAsync();\nConsole.WriteLine(content);\nConsole.WriteLine(\"Ez a v\u00e9ge\");\nConsole.ReadKey();\nstatic async Task&lt;string&gt; LoadWebPageAsync() //generikus param\u00e9ter\n{\n    using var client = new HttpClient();\n\n    var response = await client.GetAsync(new Uri(\"http://www.bing.com\"));\n    Console.WriteLine(response.StatusCode.ToString());\n\n    var content = await response.Content.ReadAsStringAsync();\n    return new string(content.Take(1000).ToArray());\n}\n</code></pre> <p>A <code>return</code> val\u00f3j\u00e1ban ezen <code>Task</code> eredm\u00e9ny\u00e9t \u00e1ll\u00edtja be <code>async</code> met\u00f3dusok eset\u00e9ben, \u00e9s nem egy nemgenerikus <code>Task</code> objektummal kell visszat\u00e9rj\u00fcnk.</p>"},{"location":"seminar/04-csharp4/chapter4/#nemigazan-nullozhato-referencia-tipusok","title":"Nem(igaz\u00e1n) nullozhat\u00f3 referencia t\u00edpusok","text":"<p>Kor\u00e1bban l\u00e1ttuk, hogy hogyan lehet egy \u00e9rt\u00e9k t\u00edpusnak null \u00e9rt\u00e9ket adni (<code>Nullable&lt;T&gt;</code>). Az \u00e9rem m\u00e1sik oldala a C# 8-ban megjelent nem nullozhat\u00f3 referencia t\u00edpusok. Nem egy \u00faj t\u00edpust vezettek be, hanem az eddig megszokott t\u00edpusneveket \u00e9rtelmezi m\u00e1shogyan a ford\u00edt\u00f3. A projektf\u00e1jlban az al\u00e1bbi be\u00e1ll\u00edt\u00e1s kapcsolja be ezt a funkci\u00f3t.</p> <pre><code>&lt;Nullable&gt;enable&lt;/Nullable&gt;\n</code></pre> <p>Egy\u00e9b konfigur\u00e1ci\u00f3s lehet\u0151s\u00e9gek</p> <p>Ezen k\u00edv\u00fcl m\u00e9g preprocessor direkt\u00edv\u00e1kkal is szab\u00e1lyozhatjuk a m\u0171k\u00f6d\u00e9st.</p> <p>Induljunk ki egy egyszer\u0171 szem\u00e9lyeket nyilv\u00e1ntart\u00f3 adatoszt\u00e1lyb\u00f3l, ahol elhat\u00e1rozzuk, hogy a k\u00f6z\u00e9ps\u0151 n\u00e9v kiv\u00e9tel\u00e9vel a t\u00f6bbi n\u00e9vdarab nem nullozhat\u00f3 sz\u00f6veg lesz.</p> <pre><code>Console.WriteLine(\"Hello World!\");\nclass Person\n{\n    public string FirstName { get; set; } // Not null\n    public string? MiddleName { get; set; } // May be null\n    public string LastName { get; set; } // Not null\n}\n</code></pre> <p>Ez m\u00e1ris sz\u00e1mos figyelmeztet\u00e9st gener\u00e1l. A nem nullozhat\u00f3 referencia t\u00edpusok bekapcsol\u00e1s\u00e1val alapesetben nem hib\u00e1k, csak \u00faj figyelmeztet\u00e9sek gener\u00e1l\u00f3dnak. A vezet\u00e9kn\u00e9v \u00e9s keresztn\u00e9v adatoknak nem szabadna <code>null</code> \u00e9rt\u00e9k\u0171nek lennie (a sima <code>string</code> t\u00edpus nem nullozhat\u00f3 t\u00edpust jelent), viszont \u00edgy az alap\u00e9rt\u00e9k nem egy\u00e9rtelm\u0171, explicit inicializ\u00e1lnunk kellene.</p> <p>Fontos meg\u00e9rten\u00fcnk, hogy a string t\u00edpus fizikailag tov\u00e1bbra is lehet null \u00e9rt\u00e9k\u0171, mind\u00f6ssze a ford\u00edt\u00f3 sz\u00e1m\u00e1ra jelezz\u00fck, hogy sz\u00e1nd\u00e9kunk szerint sohasem szabadna <code>null</code> \u00e9rt\u00e9ket felvennie. A ford\u00edt\u00f3 cser\u00e9be figyelmeztet, ha ezt megs\u00e9rt\u0151 k\u00f3dot detekt\u00e1l.</p> <p>Az egyik legk\u00e9zenfekv\u0151bb megold\u00e1s (az inline inicializ\u00e1ci\u00f3 mellett), ha konstruktorban inicializ\u00e1lunk konstruktorparam\u00e9ter alapj\u00e1n. Adjunk konstruktort a t\u00edpusnak:</p> <pre><code>public Person(string fname, string lname, string? mname)\n{\n    FirstName = fname;\n    LastName = lname;\n    MiddleName = mname;\n}\n</code></pre> <p>Rebuild</p> <p>Ha biztosan l\u00e1tni akarjuk az \u00f6sszes figyelmeztet\u00e9st, akkor sima Build m\u0171velet helyett haszn\u00e1ljuk a Rebuild-et.</p> <p>Ezzel meg is oldottunk minden figyelmeztet\u00e9st.</p> <p>Konstruktorok</p> <p>Sajnos a k\u00f6telez\u0151en konstruktoron kereszt\u00fcli inicializ\u00e1ci\u00f3 nem mindig m\u0171k\u00f6dik, p\u00e9ld\u00e1ul a soros\u00edt\u00f3k \u00e1ltal\u00e1ban nem szeretik, ha nincs alap\u00e9rtelmezett konstruktor. Ez\u00e9rt c\u00e9lszer\u0171bb a k\u00f6telez\u0151 tulajdons\u00e1gokat <code>required</code> kulcssz\u00f3val ell\u00e1tni.</p> <p>Mennyire okos a ford\u00edt\u00f3 a <code>null</code> \u00e9rt\u00e9k detekt\u00e1l\u00e1s\u00e1ban? N\u00e9zz\u00fcnk p\u00e1r p\u00e9ld\u00e1t! Az al\u00e1bbi statikus f\u00fcggv\u00e9nyt tegy\u00fck bele a <code>Person</code> oszt\u00e1lyunkba \u00e9s vegy\u00fck fel a <code>using static System.Console;</code> n\u00e9vt\u00e9rhivatkoz\u00e1st is.</p> <pre><code>static void M(string? ns)\n{\n    WriteLine(ns.Length); // (1)!\n    if (ns != null)\n    {\n        WriteLine(ns.Length); // (2)!\n    }\n    if (ns == null)\n    {\n        return;\n    }\n    WriteLine(ns.Length); // (3)!\n    ns = null;\n    WriteLine(ns.Length); // (4)!\n    string s = default(string); // (5)!\n    string[] a = new string[10]; // (6)!\n}\n</code></pre> <ol> <li>Figyelmeztet\u00e9s lehets\u00e9ges <code>null</code> \u00e9rt\u00e9kre, mert a t\u00edpusa szerint nullozhat\u00f3.</li> <li>Ha egy egyszer\u0171 <code>if</code>-fel levizsg\u00e1ljuk, akkor m\u00e1ris ok. Pedig pl. t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben az <code>if</code> ki\u00e9rt\u00e9kel\u00e9se \u00e9s ezen sor v\u00e9grehajt\u00e1sa k\u00f6z\u00f6tt a v\u00e1ltoz\u00f3 ak\u00e1r <code>null</code> \u00e9rt\u00e9kre is be\u00edr\u00f3dhat.</li> <li>Az el\u0151tte l\u00e9v\u0151 r\u00f6vidz\u00e1r is megnyugtatja a ford\u00edt\u00f3t, \u00edgy itt sincs figyelmeztet\u00e9s.</li> <li>Ezt az el\u0151z\u0151 sor alapj\u00e1n figyelmeztet\u00e9ssel jutalmazza.</li> <li>Ez is figyelmeztet\u00e9s, a <code>default</code> oper\u00e1tor \u00e1ltal adott \u00e9rt\u00e9kkel (<code>null</code>) nem inicializ\u00e1lhatunk.</li> <li>Ez viszont nem figyelmeztet\u00e9s, pedig egy csom\u00f3 <code>null</code> j\u00f6n l\u00e9tre. Ha ez figyelmeztet\u00e9s lenne, az ar\u00e1nytalanul megnehez\u00edten\u00e9 a t\u00f6mb\u00f6k kezel\u00e9s\u00e9t.</li> </ol> <p>L\u00e1that\u00f3, hogy az egyszer\u0171bb eseteket j\u00f3l kezeli a ford\u00edt\u00f3, de kor\u00e1ntsem mindenhat\u00f3, illetve nem mindig sz\u00f3l akkor sem, amikor egy\u00e9bk\u00e9nt sz\u00f3lhatna.</p> <p>A tov\u00e1bbi p\u00e9ld\u00e1khoz vegy\u00fcnk fel p\u00e1r seg\u00e9df\u00fcggv\u00e9nyt a <code>Person</code> oszt\u00e1lyba:</p> <pre><code>private Person GetAnotherPerson()\n{\n    return new Person(LastName, FirstName, MiddleName ?? string.Empty);\n}\n\nprivate void ResetFields()\n{\n    FirstName = default!;\n    LastName = null!;\n    MiddleName = null;\n}\n</code></pre> <p>L\u00e1that\u00f3, hogy vannak megker\u00fcl\u0151 megold\u00e1sok arra, hogy r\u00e1er\u0151szakoljuk a ford\u00edt\u00f3ra az akaratunkat, a felki\u00e1lt\u00f3jel haszn\u00e1lat\u00e1val be\u00edrhatunk <code>null</code> \u00e9rt\u00e9keket nem nullozhat\u00f3 v\u00e1ltoz\u00f3kba (ez az \u00fan. null forgiving operator ). Illetve <code>string</code> eset\u00e9n null helyett haszn\u00e1lhatjuk az \u00fcres <code>string</code> \u00e9rt\u00e9ket - ami nem biztos, hogy sokkal jobb a <code>null</code> \u00e9rt\u00e9kn\u00e9l. Mindenesetre ezek a f\u00fcggv\u00e9nyek nem okoznak \u00fajabb figyelmeztet\u00e9seket.</p> <p>N\u00e9zz\u00fck meg, hogy mennyire tudja lek\u00f6vetni a fenti f\u00fcggv\u00e9nyek m\u0171k\u00f6d\u00e9s\u00e9t a ford\u00edt\u00f3. Vegy\u00fcnk fel ennek tesztel\u00e9s\u00e9re egy \u00fajabb f\u00fcggv\u00e9nyt a <code>Person</code> oszt\u00e1lyba:</p> <pre><code>void M(Person p)\n{\n    if (p.MiddleName != null)\n    {\n        p.ResetFields();\n        WriteLine(p.MiddleName.Length); // (1)!\n\n        p = GetAnotherPerson();\n        WriteLine(p.MiddleName.Length); // (2)!\n    }\n    p.FirstName = null;          // (3)!\n    p.LastName = p.MiddleName;   // (4)!\n}\n</code></pre> <ol> <li>A ford\u00edt\u00f3 nem k\u00f6veti le, hogy a <code>ResetFields</code> vesz\u00e9lyes m\u00f3don v\u00e1ltoztatja az \u00e1llapotot, csak azt n\u00e9zi, hogy az <code>if</code> m\u00e1r kiv\u00e9dte a vesz\u00e9lyt.</li> <li>Ez egy fals pozit\u00edvnak t\u0171n\u0151 eset, az el\u0151z\u0151 sorban l\u00e9v\u0151 f\u00fcggv\u00e9ny alapj\u00e1n a <code>p.MiddleName</code> nem lehetne <code>null</code>, de a ford\u00edt\u00f3 csak azt figyeli, hogy a beburkol\u00f3 <code>if</code> ellen\u0151rz\u00e9se a <code>p</code> megv\u00e1ltoz\u00e1sa miatt m\u00e1r nem \u00e9rv\u00e9nyes.</li> <li>Egy\u00e9rtelm\u0171en jogos figyelmeztet\u00e9s.</li> <li>Jogos a figyelmeztet\u00e9s, mert nem kezelj\u00fck a <code>p.MiddleName == null</code> esetet.</li> </ol> <p>Strukt\u00faratagok eset\u00e9n is a fals negat\u00edv eset j\u00f6n el\u0151. Pr\u00f3b\u00e1ljuk ki, ak\u00e1r a <code>Person</code> oszt\u00e1lyba \u00edrva:</p> <pre><code>struct PersonHandle\n{\n    public Person person;\n}\n</code></pre> <p>Nem kapunk figyelmeztet\u00e9st.</p> <p>A felki\u00e1lt\u00f3jeles r\u00e1er\u0151szakol\u00e1st a <code>ResetFields</code>-ben l\u00e1that\u00f3 \u00e1mokfut\u00e1s helyett ink\u00e1bb a fals pozit\u00edv esetek kezel\u00e9s\u00e9re haszn\u00e1ljuk. Jav\u00edtsuk ki a <code>GetAnotherPerson</code> h\u00edv\u00e1s miatti fals pozit\u00edv esetet az <code>M(Person)</code> f\u00fcggv\u00e9nyben:</p> <pre><code>p = GetAnotherPerson();\nWriteLine(p.MiddleName!.Length); //beker\u00fclt egy '!'\n</code></pre> <p>Figyelj\u00fck meg, ahogy a figyelmeztet\u00e9s elt\u0171nik.</p> <p>Ha igaz\u00e1n elk\u00f6telezettek vagyunk a <code>null</code> kiirt\u00e1sa mellett, akkor bekapcsolhatjuk, hogy minden, a <code>null</code> kezel\u00e9s miatti, ford\u00edt\u00f3 \u00e1ltal detekt\u00e1lt figyelmeztet\u00e9s legyen hiba. A projekt be\u00e1ll\u00edt\u00e1si k\u00f6z\u00f6tt (menu:a projekten jobbklikk[Properties]), a Build lapon adjuk meg a Treat specific warnings as errors opci\u00f3nak a <code>nullable</code> \u00e9rt\u00e9ket. (Ha t\u00f6bb \u00e9rt\u00e9ket akarunk megadni, akkor a <code>;</code> elv\u00e1laszt\u00f3t alkalmazhatjuk.)</p> <p>Ellen\u0151rizz\u00fck, hogy t\u00e9nyleg hibak\u00e9nt jelennek-e meg az eddigi <code>null</code> kezel\u00e9s miatti figyelmeztet\u00e9sek.</p> <p>Mivel ez csak egy p\u00e9ldak\u00f3d, ne jav\u00edtsuk ki a hib\u00e1kat, csak t\u00e1vol\u00edtsuk el a projektet a solutionb\u0151l (menu:a projekten jobbklikk[Remove]).</p>"},{"location":"seminar/04-csharp4/chapter4/#tuple-nyelvi-szinten-lokalis-fuggvenyek-dispose-minta","title":"Tuple nyelvi szinten, lok\u00e1lis f\u00fcggv\u00e9nyek, Dispose minta","text":""},{"location":"seminar/04-csharp4/chapter4/#tuple-nyelvi-szinten-lokalis-fuggvenyek","title":"Tuple nyelvi szinten, lok\u00e1lis f\u00fcggv\u00e9nyek","text":"<p>K\u00e9sz\u00edts\u00fcnk Fibonacci sz\u00e1msor kisz\u00e1mol\u00e1s\u00e1ra alkalmas f\u00fcggv\u00e9nyt, ahol haszn\u00e1ljuk ki az al\u00e1bbi k\u00e9t \u00faj nyelvi elemet. Term\u00e9szetesen nagyon sokf\u00e9lek\u00e9ppen meg lehetne val\u00f3s\u00edtani ezt a met\u00f3dust, de most kifejezetten a tuple-\u00f6k nyelvi t\u00e1mogat\u00e1s\u00e1t \u00e9s lok\u00e1lis f\u00fcggv\u00e9nyeket szeretn\u00e9nk demonstr\u00e1lni.</p> <ul> <li>Lok\u00e1lis f\u00fcggv\u00e9nyek: ezek a f\u00fcggv\u00e9nyek csak adott met\u00f3dusban l\u00e1that\u00f3k. K\u00e9t esetben \u00e9rdemes \u0151ket haszn\u00e1lni: ha nem szeretn\u00e9nk \u201eszennyezni\u201d a k\u00f6rnyez\u0151 oszt\u00e1lyt k\u00fcl\u00f6nf\u00e9le priv\u00e1t seg\u00e9dmet\u00f3dusokkal, vagy ha egy m\u00e9lyebb, komplexebb h\u00edv\u00e1si l\u00e1ncban nem szeretn\u00e9nk a param\u00e9tereket folyamatosan tov\u00e1bbpasszolni, ugyanis ezek a met\u00f3dusok el\u00e9rik a k\u00fcls\u0151 scope-on tal\u00e1lhat\u00f3 v\u00e1ltoz\u00f3kat is (a lenti esetben p\u00e9ld\u00e1ul az <code>x</code>-et).</li> <li>Value tuple t\u00edpus: a tuple (ennes) t\u00f6bb \u00f6sszetartoz\u00f3 \u00e9rt\u00e9k \u00f6sszefog\u00e1sa, ami gyors, nyelvi szinten t\u00e1mogatott adattov\u00e1bb\u00edt\u00e1st tesz lehet\u0151v\u00e9 - gyakorlatilag inline, neves\u00edtetlen strukt\u00farat\u00edpust hozunk \u00edgy l\u00e9tre. Publikus API-kon, f\u00fcggv\u00e9nyeken nem \u00e9rdemes haszn\u00e1lni, viszont priv\u00e1t, bels\u0151 haszn\u00e1latn\u00e1l sebess\u00e9gn\u00f6veked\u00e9st \u00e9s API tisztul\u00e1st \u00e9rhet\u00fcnk vele el. \u00c9rt\u00e9k t\u00edpus.</li> </ul> <p>Referencia t\u00edpus\u00fa Tuple&lt;&gt;</p> <p>L\u00e9teznek generikus <code>Tuple&lt;&gt;</code> t\u00edpusok is. Ezek referencia t\u00edpusok, hasonl\u00f3 szerepet t\u00f6ltenek be, viszont az egyes \u00e9rt\u00e9keiket az el\u00e9g semmitmond\u00f3 <code>Item1</code>, <code>Item2</code>\u2026 neveken lehet el\u00e9rni.</p> <pre><code>static long Fibonacci(long x)\n{\n    (long Current, long Previous) Fib(long i) // (1)!\n    {\n        if (i == 0) return (1, 0);\n        var (curr, prev) = Fib(i - 1); // (2)!\n        Thread.Sleep(100); // (3)!\n        return (curr + prev, curr);\n    }\n\n    return x &lt; 0\n        ? throw new ArgumentException(\"Less negativity please!\", nameof(x))\n        : Fib(x).Current;\n}\n</code></pre> <ol> <li>Neves\u00edtett tuple visszat\u00e9r\u00e9s. Ez egy lok\u00e1lis f\u00fcggv\u00e9ny, szintaxist tekintve f\u00fcggv\u00e9nyen bel\u00fcli f\u00fcggv\u00e9ny.</li> <li>Az eredm\u00e9ny elt\u00e1rol\u00e1sa egy tuple v\u00e1ltoz\u00f3ban. Ezzel felbontjuk (Deconstruct), darabokra szedj\u00fck a tuple-t, mert <code>curr</code>, <code>prev</code> v\u00e1ltoz\u00f3n kereszt\u00fcl el\u00e9rj\u00fck a k\u00e9t <code>long</code> alkot\u00f3r\u00e9szt. Ugyanezen sorban t\u00f6rt\u00e9nik a rekurz\u00edv h\u00edv\u00e1s is.</li> <li>Lass\u00fa m\u0171velet szimul\u00e1ci\u00f3ja mesters\u00e9ges k\u00e9sleltet\u00e9ssel.</li> </ol> <p>Dekonstrukci\u00f3</p> <p>A dekonstrukci\u00f3s szintaxis a kor\u00e1bbi gyakorlaton megismert rekord t\u00edpusok eset\u00e9n is m\u0171k\u00f6dik.</p>"},{"location":"seminar/04-csharp4/chapter4/#dispose-minta","title":"Dispose minta","text":"<p>A Dispose minta az er\u0151forr\u00e1s-felszabad\u00edt\u00e1s megfelel\u0151 megval\u00f3s\u00edt\u00e1s\u00e1hoz k\u00e9sz\u00fclt. Hasonl\u00f3 elv ment\u00e9n \u00fczemel, mint a destruktor, viszont a minta nem felt\u00e9tlen\u00fcl k\u00f6t\u00f6tt az objektum \u00e9letciklus\u00e1nak elej\u00e9hez \u00e9s v\u00e9g\u00e9hez. Amennyiben egy objektum megval\u00f3s\u00edtja az <code>IDisposable</code> interf\u00e9szt, van <code>Dispose</code> met\u00f3dusa. A met\u00f3dus megh\u00edv\u00e1s\u00e1val az objektum \u00e1ltal haszn\u00e1lt, nem a keretrendszer \u00e1ltal menedzselt er\u0151forr\u00e1sokat szabad\u00edtjuk fel. Nem csak mem\u00f3riafoglal\u00e1sra kell gondolni, hanem lehetnek nyitott f\u00e1jlrendszeri handle-\u00f6k, adatkapcsolatok, stream-ek, vagy \u00fczleti er\u0151forr\u00e1sok, tranzakci\u00f3k.</p> <p>M\u00e9rj\u00fck meg az els\u0151 p\u00e1r Fibonacci sz\u00e1m kisz\u00e1m\u00edt\u00e1s\u00e1t (a mesters\u00e9ges k\u00e9sleltet\u00e9ssel):</p> <pre><code>var sw = Stopwatch.StartNew();\nforeach (var n in Enumerable.Range(1, 15))\n{\n  Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n}\nsw.Stop();\nConsole.WriteLine($\"Elapsed: {sw.ElapsedMilliseconds}\");\nConsole.ReadKey();\n</code></pre> <p>Ez \u00edgy j\u00f3, m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3 ez az id\u0151m\u00e9r\u00e9si mechanizmus.</p> <p>K\u00e9sz\u00edts\u00fcnk egy saj\u00e1t id\u0151m\u00e9r\u0151 oszt\u00e1lyt <code>StopwatchWrapper</code> n\u00e9ven, ami a <code>Stopwatch</code> haszn\u00e1lat\u00e1t egyszer\u0171s\u00edti a Dispose mint\u00e1n kereszt\u00fcl.</p> <pre><code>public class StopwatchWrapper : IDisposable\n{\n    public Stopwatch Stopwatch { get; }\n\n    public string Title { get; }\n\n    public StopwatchWrapper(string? title = default)\n    {\n        Title = title ?? Guid.NewGuid().ToString();\n        Console.WriteLine($\"Task {title} starting at {DateTime.Now}.\");\n        Stopwatch = Stopwatch.StartNew();\n    }\n}\n</code></pre> <p>Ha k\u00e9rj\u00fck a villanyk\u00f6rte seg\u00edts\u00e9g\u00e9t az <code>IDisposable</code>-\u00f6n, akkor 2x2 lehet\u0151s\u00e9g\u00fcnk van: megval\u00f3s\u00edtjuk az interf\u00e9szt implicit vagy explicit, illetve megval\u00f3s\u00edtjuk-e az interf\u00e9szt a Dispose mint\u00e1t alkalmazva. Val\u00f3s\u00edtsuk meg implicit a Dispose mint\u00e1t!</p> <p> Dispose minta implement\u00e1l\u00e1sa IntelliSense seg\u00edts\u00e9g\u00e9vel</p> <p>Fussuk \u00e1t a gener\u00e1lt k\u00f3dot, ami sz\u00e9pen kommentezett. A pattern l\u00e9nyege, hogy a nem menedzselt er\u0151forr\u00e1sokat (unmanaged objects / resources) sz\u00fcks\u00e9ges felszabad\u00edtanunk, amit a <code>Dispose</code> met\u00f3dusokban, illetve menedzselt k\u00f3d eset\u00e9n a kommentekkel kijel\u00f6lt helyen \u00e9rdemes elv\u00e9gezn\u00fcnk. K\u00e9sz\u00edts\u00fck el az id\u0151m\u00e9r\u0151 mechanizmust!</p> <pre><code>protected virtual void Dispose(bool disposing)\n{\n    if (!disposedValue)\n    {\n        if (disposing)\n        {\n            Stopwatch.Stop();\n            Console.WriteLine(\n                $\"Task {Title} completed in { Stopwatch.ElapsedMilliseconds} ms \"+\n                $\"at { DateTime.Now}\");\n        }\n        disposedValue = true;\n    }\n}\n</code></pre> <p>Csak fel\u00fcgyelt er\u0151forr\u00e1sokkal (managed objects) dolgozunk, \u00edgy csak egy helyen kellett a le\u00e1ll\u00edt\u00f3 logik\u00e1t megadnunk.</p> <p>Az <code>IDisposable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 elemekkel haszn\u00e1lhatjuk a <code>using</code> konstrukci\u00f3t:</p> <pre><code>using (new StopwatchWrapper(\"Fib 1-15\"))\n{\n    foreach (var n in Enumerable.Range(1, 15))\n    {\n        Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n    }\n}\n</code></pre> <p>Teh\u00e1t a <code>using</code> haszn\u00e1lat\u00e1val a blokk elej\u00e9t \u00e9s v\u00e9g\u00e9t tudjuk kezelni. Gyakorlatilag egy <code>try-finally</code>-val ekvivalens a minta, a <code>finally</code>-ben megh\u00edv\u00f3dik a <code>Dispose</code> met\u00f3dus.</p> <p>Jelenleg csak a folyamat v\u00e9g\u00e9n kapunk jelent\u00e9st az eltelt id\u0151r\u0151l. R\u00e9szid\u0151k ki\u00edr\u00e1s\u00e1hoz k\u00e9sz\u00edts\u00fcnk egy seg\u00e9df\u00fcggv\u00e9nyt a <code>StopwatchWrapper</code>-be:</p> <pre><code>public void Snapshot(string text) =&gt;\n    Console.WriteLine(\n        $\"Task {Title} snapshot {text}:\"\n        + \"{Stopwatch.ElapsedMilliseconds} ms\"\n    );\n</code></pre> <p>H\u00edvjuk meg a <code>foreach</code> ciklusb\u00f3l:</p> <pre><code>using (var sw = new StopwatchWrapper(\"Fib 1-15\"))\n{\n    foreach (var n in Enumerable.Range(1, 15))\n    {\n        sw.Snapshot(n.ToString());\n        Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n    }\n}\n</code></pre>"},{"location":"seminar/05-aspnetcore1/chapter5/","title":"ASP.NET Core alapszolg\u00e1ltat\u00e1sok","text":""},{"location":"seminar/05-aspnetcore1/chapter5/#projekt-letrehozasa","title":"Projekt l\u00e9trehoz\u00e1sa","text":"<p>Ezen a gyakorlaton nem a be\u00e9p\u00edtett API projektsablont fogjuk felhaszn\u00e1lni, hanem egy \u00fcres ASP.NET Core projektb\u0151l pr\u00f3b\u00e1ljuk fel\u00e9p\u00edteni \u00e9s meg\u00e9rteni azt a funkcionalit\u00e1st, amit egy\u00e9bk\u00e9nt az el\u0151re elk\u00e9sz\u00edtett VS projektsablonok adn\u00e1nak k\u00e9szen a kez\u00fcnkbe.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#generalas","title":"Gener\u00e1l\u00e1s","text":"<p>Hozzunk l\u00e9tre a Visual Studioban egy \u00faj, C# nyelv\u0171 projektet az ASP.NET Core Empty sablonnal, a neve legyen HelloAspNetCore. Megc\u00e9lzott keretrendszerk\u00e9nt adjuk meg a .NET 8-at. Minden extra opci\u00f3 legyen kikapcsolva, a docker \u00e9s a HTTPS is (a laborg\u00e9pek miatt).</p> Kit\u00e9r\u0151: NuGet \u00e9s a keretrendszert alkot\u00f3 komponensek helye <p>A .NET 8 \u00e9s az ASP.NET Core gyakorlatilag teljes m\u00e9rt\u00e9kben publikusan el\u00e9rhet\u0151 komponensekb\u0151l \u00e9p\u00fcl fel. A komponensek kezel\u00e9s\u00e9nek infrastrukt\u00far\u00e1j\u00e1t a NuGet csomagkezel\u0151 szolg\u00e1ltatja. A csomagkezel\u0151n kereszt\u00fcl el\u00e9rhet\u0151 csomagokat a nuget.org list\u00e1zza \u00e9s ig\u00e9ny eset\u00e9n a NuGet kliens, illetve a .NET Core eszk\u00f6z\u00f6k (dotnet.exe, Visual Studio) is innen t\u00f6ltik le.</p> <p>A fejleszt\u0151knek teljes\u00edtm\u00e9nyszempontb\u00f3l nem \u00e9rn\u00e9 meg az alap keretrendszert alkot\u00f3 csomagokat \u00e1lland\u00f3an let\u00f6lt\u00f6getni, \u00edgy a klasszikus keretrendszerekhez hasonl\u00f3an a .NET 8 telep\u00edt\u00e9sekor egy k\u00f6nyvt\u00e1rba (Windows-on ide: C:\\Program Files (x86)\\dotnet, illetve C:\\Program Files\\dotnet) beker\u00fclnek az alap keretrendszert alkot\u00f3 komponensek - l\u00e9nyeg\u00e9ben egy csom\u00f3 .dll k\u00fcl\u00f6nb\u00f6z\u0151 alk\u00f6nyvt\u00e1rakban.</p> <p>A futtat\u00e1shoz sz\u00fcks\u00e9ges szerelv\u00e9nyek a shared alk\u00f6nyvt\u00e1rba telep\u00fclnek, ezek az \u00fan. Shared Framework-\u00f6k. A g\u00e9pen fut\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 .NET Core/8 alkalmaz\u00e1sok k\u00f6z\u00f6sen haszn\u00e1lhatj\u00e1k ezeket.</p> <p>A fejleszt\u00e9shez az alapvet\u0151 f\u00fcgg\u0151s\u00e9geket a packs alk\u00f6nyvt\u00e1rb\u00f3l hivatkozhatjuk.</p> <p>Nem fejleszt\u0151i, p\u00e9ld\u00e1ul v\u00e9gfelhaszn\u00e1l\u00f3i vagy szerver k\u00f6rnyezetben- ahol nem is biztos, hogy fel van telep\u00edtve az SDK, nem felt\u00e9tlen\u00fcl \u00edgy biztos\u00edtjuk a f\u00fcgg\u0151s\u00e9geket, de ennek a boncolgat\u00e1sa nem t\u00e9m\u00e1ja ennek a gyakorlatnak.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#eredmeny","title":"Eredm\u00e9ny","text":"<p>N\u00e9zz\u00fck meg, milyen projekt gener\u00e1l\u00f3dott:</p> <ul> <li>.csproj: (menu:Projekten jobb gomb[Edit Project File]) a projekt ford\u00edt\u00e1s\u00e1hoz sz\u00fcks\u00e9ges be\u00e1ll\u00edt\u00e1sokat tartalmazza. El\u0151z\u0151 verzi\u00f3khoz k\u00e9pest itt er\u0151sen \u00e9p\u00edtenek az alap\u00e9rtelmezett \u00e9rt\u00e9kekre, hogy min\u00e9l karcs\u00fabbra tudj\u00e1k fogni ezt az \u00e1llom\u00e1nyt.<ul> <li>Project SDK: projekt t\u00edpusa (Microsoft.NET.Sdk.Web), az eszk\u00f6zk\u00e9szlet funkci\u00f3it szab\u00e1lyozza, meghat\u00e1rozza a futtat\u00e1shoz haszn\u00e1latos shared framework-\u00f6t, illetve meghat\u00e1rozza a megc\u00e9lzott keretrendszert is(l\u00e1sd lentebb).</li> <li>TargetFramework: net8.0. Ezzel jelezz\u00fck, hogy .NET 8-os API-kat haszn\u00e1lunk az alkalmaz\u00e1sban.</li> </ul> </li> <li>Connected Services: k\u00fcls\u0151 szolg\u00e1ltat\u00e1sok, amiket haszn\u00e1l a projekt\u00fcnk, most nincs ilyen\u00fcnk.</li> <li>Dependencies: a keretrendszer alapf\u00fcgg\u0151s\u00e9gei \u00e9s egy\u00e9b NuGet csomagf\u00fcgg\u0151s\u00e9gek szerepelnek itt. Egyel\u0151re csak keretrendszer f\u00fcgg\u0151s\u00e9geink vannak.<ul> <li>Frameworks: k\u00e9t alk\u00f6nyvt\u00e1rat (Microsoft.AspNetCore.App, Microsoft.NETCore.App) hivatkozunk a .NET SDK packs alk\u00f6nyvt\u00e1r\u00e1b\u00f3l. Ezek a f\u00fcgg\u0151s\u00e9gek k\u00fcls\u0151 NuGet csomagk\u00e9nt is el\u00e9rhet\u0151ek, de ahogy fentebb jelezt\u00fck, nem \u00e9rdemes \u00fagy hivatkozni \u0151ket.</li> <li>Analyzers: speci\u00e1lis komponensek, amik k\u00f3danal\u00edzist v\u00e9gzenek, de egy\u00e9bk\u00e9nt ugyan\u00fagy k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9gk\u00e9nt (NuGet csomag) kezelhetj\u00fck \u0151ket. Ha kibontjuk az egyes analiz\u00e1torokat, akkor l\u00e1thatjuk, hogy miket ellen\u0151riznek. Ezek a f\u00fcgg\u0151s\u00e9gek a fut\u00e1shoz nem sz\u00fcks\u00e9gesek.</li> </ul> </li> <li>Properties: duplakattra el\u0151j\u00f6n a klasszikus projektbe\u00e1ll\u00edt\u00f3 fel\u00fclet.<ul> <li>launchSettings.json: a k\u00fcl\u00f6nb\u00f6z\u0151 ind\u00edt\u00e1si konfigur\u00e1ci\u00f3khoz tartoz\u00f3 be\u00e1ll\u00edt\u00e1sok (l\u00e1sd k\u00e9s\u0151bb).</li> </ul> </li> <li>appsettings.json: fut\u00e1sidej\u0171 be\u00e1ll\u00edt\u00e1sok helye. Kibonthat\u00f3, kibontva a k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f6rnyezetekre specifikus konfigur\u00e1ci\u00f3k tal\u00e1lhat\u00f3ak (l\u00e1sd k\u00e9s\u0151bb).</li> </ul>"},{"location":"seminar/05-aspnetcore1/chapter5/#legfelso-szintu-kod-minimal-api","title":"Legfels\u0151 szint\u0171 k\u00f3d, minim\u00e1l API","text":"<p>Az el\u0151z\u0151 ASP.NET verzi\u00f3val ellent\u00e9tben, itt m\u00e1r az ASP.NET Core alkalmaz\u00e1sok a sz\u00fclet\u00e9s\u00fckt\u0151l fogva klasszikus konzolos alkalmaz\u00e1sk\u00e9nt is ind\u00edthat\u00f3k, ekkor az alkalmaz\u00e1s alap\u00e9rtelmezett bel\u00e9p\u00e9si pontja a legfels\u0151 szint\u0171 k\u00f3d (esetleg a <code>Main</code> met\u00f3dus). Az ASP.NET Core 6-os verzi\u00f3ban megjelent \u00fan. minim\u00e1l API seg\u00edts\u00e9g\u00e9vel m\u00e1r nem csak a konfigur\u00e1ci\u00f3t tartalmazhatja ez a k\u00f3d, hanem (egyszer\u0171) kiszolg\u00e1l\u00f3 logik\u00e1t is.</p> <p>Eset\u00fcnkben a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket v\u00e9gzi el a gener\u00e1lt k\u00f3d:</p> <ul> <li>a hosztol\u00e1si k\u00f6rnyezetet \u00e9s az alkalmaz\u00e1s alapszolg\u00e1ltat\u00e1sait konfigur\u00e1l\u00f3 builder objektum \u00f6ssze\u00e1ll\u00edt\u00e1sa (<code>CreateBuilder</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> <li>a builder objektum alapj\u00e1n a hosztol\u00e1si k\u00f6rnyezet \u00e9s az alkalmaz\u00e1s szerkezet\u00e9nek fel\u00e1ll\u00edt\u00e1sa (<code>Build</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> <li>v\u00e9gpontot defini\u00e1l az alkalmaz\u00e1s gy\u00f6k\u00e9rc\u00edm\u00e9re minim\u00e1l API seg\u00edts\u00e9g\u00e9vel. A v\u00e9gpont a megh\u00edv\u00e1s\u00e1ra a Hello World! sz\u00f6veget adja vissza.</li> <li>a fel\u00e1ll\u00edtott szerkezet futtat\u00e1sa (<code>Run</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> </ul> <p>Az igaz\u00e1n munk\u00e1s feladat a builder megalkot\u00e1sa lenne, igen sok mindent lehetne benne konfigur\u00e1lni, ez a k\u00f3dban a <code>CreateBuilder</code>-ben t\u00f6rt\u00e9nik, ami egy szokv\u00e1nyos, az eg\u00e9sz webalkalmaz\u00e1s m\u0171k\u00f6d\u00e9si k\u00f6rnyezet\u00e9t meghat\u00e1roz\u00f3 be\u00e1ll\u00edt\u00e1sokat elv\u00e9gz\u0151 kiindul\u00f3 buildert \u00e1ll\u00edt el\u0151. Ha valamit a kiindul\u00f3 builderben megadott\u00f3l elt\u00e9r\u0151en szeretn\u00e9nk, vagy \u00faj be\u00e1ll\u00edt\u00e1sokat adn\u00e1nk meg, akkor a kiindul\u00f3 builder objektumon t\u00f6rt\u00e9n\u0151 f\u00fcggv\u00e9nyh\u00edv\u00e1sokkal tehetn\u00e9nk meg.</p> <p>Mivel a kiindul\u00f3 builderen nem v\u00e9gz\u00fcnk semmilyen ut\u00f3lagos konfigur\u00e1l\u00e1st, \u00edgy ak\u00e1r egy utas\u00edt\u00e1ssal is megkaphatn\u00e1nk az alkalmaz\u00e1sszerkezetet reprezent\u00e1l\u00f3 <code>WebApplication</code> p\u00e9ld\u00e1nyt.</p> <pre><code>//var builder = WebApplication.CreateBuilder(args);\n//var app = builder.Build();\n\nvar app = WebApplication.Create();\n</code></pre>"},{"location":"seminar/05-aspnetcore1/chapter5/#vegrehajtasi-pipeline-middleware-ek","title":"V\u00e9grehajt\u00e1si pipeline, middleware-ek","text":"<p>Az ASP.NET Core-ban egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa \u00fagy t\u00f6rt\u00e9nik, hogy a k\u00e9r\u00e9s egy cs\u0151vezet\u00e9ken halad (v\u00e9gig). A cs\u0151vezet\u00e9k middleware-ekb\u0151l (MW) \u00e1ll. Az al\u00e1bbi \u00e1bra szeml\u00e9lteti a middleware pipeline m\u0171k\u00f6d\u00e9s\u00e9t.</p> <p> ASP.NET Core pipeline Forr\u00e1s</p> <p>Az ASP.NET Core alkalmaz\u00e1s alapszerkezete, hogy a befut\u00f3 HTTP k\u00e9r\u00e9s (v\u00e9gig)fusson a middleware-ekb\u0151l \u00e1ll\u00f3 cs\u0151vezet\u00e9ken \u00e9s valamelyik (alapesetben az utols\u00f3) middleware el\u0151\u00e1ll\u00edtja a v\u00e1laszt, ami visszair\u00e1nyban halad v\u00e9gig a cs\u0151vezet\u00e9ken. A cs\u0151vezet\u00e9k adja teh\u00e1t az alkalmaz\u00e1s szerkezet\u00e9t. A kiindul\u00f3 cs\u0151vezet\u00e9ket a <code>WebApplication.Create</code> vagy a <code>builder.Build</code> \u00e9p\u00edti fel, ezt ut\u00e1na <code>app.UseX</code> (X= MW neve) h\u00edv\u00e1sokkal testreszabhatjuk, kieg\u00e9sz\u00edthetj\u00fck.</p> <p>Eset\u00fcnkben a kiindul\u00f3 cs\u0151vezet\u00e9kben h\u00e1rom MW van:</p> <ul> <li>kiv\u00e9telkezel\u0151 middleware (<code>UseDeveloperExceptionPage</code>), ami az \u0151t k\u00f6vet\u0151 middleware-ek hib\u00e1it k\u00e9pes elkapni \u00e9s ennek megfelel\u0151en egy a fejleszt\u0151knek sz\u00f3l\u00f3 hibaoldalt jelen\u00edt meg. Ez csak opcion\u00e1lisan ker\u00fcl beregisztr\u00e1l\u00e1sra att\u00f3l f\u00fcgg\u0151en, hogy most \u00e9ppen Development m\u00f3dban futtatjuk-e az alkalmaz\u00e1st vagy sem. (l\u00e1sd k\u00e9s\u0151bb)</li> <li>routing middleware (<code>UseRouting</code>), aminek a feladata, hogy a bej\u00f6v\u0151 k\u00e9r\u00e9s \u00e9s a v\u00e9gpontok (l\u00e1sd lentebb) \u00e1ltal adott inform\u00e1ci\u00f3k alapj\u00e1n kital\u00e1lja, hogy melyik endpoint fel\u00e9 tov\u00e1bb\u00edtsa a bej\u00f6v\u0151 k\u00e9r\u00e9st.</li> <li>v\u00e9gpontok middleware (<code>UseEndpoints</code>), ami a kiv\u00e1lasztott endpoint defin\u00edci\u00f3j\u00e1ban megadott logika t\u00e9nyleges lefuttat\u00e1s\u00e1\u00e9rt felel</li> </ul> <p>P\u00e9lda middleware regisztr\u00e1ci\u00f3ra</p> <p>A kiindul\u00f3 cs\u0151vezet\u00e9k regisztr\u00e1l\u00e1s\u00e1t megfigyelhetj\u00fck a <code>WebApplicationBuilder</code> forr\u00e1sk\u00f3dj\u00e1ban - keress\u00fck az <code>app.UseX</code> sorokat.</p> <p>A kiindul\u00f3 projekt nem v\u00e1ltoztat a kiindul\u00f3 cs\u0151vezet\u00e9ken, csak egy v\u00e9gpont defin\u00edci\u00f3t ad meg (<code>app.MapGet</code> sor).</p> <p>Fontos a sorrend</p> <p>A middleware-ek sorrendje fontos. Ha nem megfelel\u0151 sorrendben regisztr\u00e1ljuk \u0151ket, nem megfelel\u0151 m\u0171k\u00f6d\u00e9s lehet az eredm\u00e9ny. A dokument\u00e1ci\u00f3 \u00e1ltal\u00e1ban tartalmazza, hogy melyik middleware hova illeszthet\u0151 be.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#hosztolasi-lehetosegek-a-fejlesztoi-gepen","title":"Hosztol\u00e1si lehet\u0151s\u00e9gek a fejleszt\u0151i g\u00e9pen","text":"<p>Pr\u00f3b\u00e1ljuk ki IIS Expressen kereszt\u00fcl futtatva, azaz a VS-ben az ind\u00edt\u00f3gomb (z\u00f6ld ny\u00edl) mellett az IIS Express felirat legyen! Ha nem ez a felirat van, \u00e1ll\u00edtsuk \u00e1t az ind\u00edt\u00f3gomb jobb sz\u00e9l\u00e9n l\u00e9v\u0151 men\u00fct lenyitva.</p> <p>K\u00e9t dolog is t\u00f6rt\u00e9nik: az alkalmaz\u00e1sunk IIS Express webkiszolg\u00e1l\u00f3ban hosztolva kezd futni \u00e9s egy b\u00f6ng\u00e9sz\u0151 is elindul, hogy ki tudjuk pr\u00f3b\u00e1lni. Figyelj\u00fck meg az \u00e9rtes\u00edt\u00e9si ter\u00fcleten (az \u00f3ra mellett) megjelen\u0151 IIS Express ikont, \u00e9s azon jobbklikkelve a hosztolt alkalmaz\u00e1s c\u00edm\u00e9t (menu:jobbklikk[Show All Applications]).</p> <p>A b\u00f6ng\u00e9sz\u0151 az alkalmaz\u00e1s gy\u00f6k\u00e9rc\u00edm\u00e9re navig\u00e1l (a c\u00edm csak localhost:port-b\u00f3l \u00e1ll), \u00edgy a Hello World! sz\u00f6veg jelenik meg.</p> <p>B\u00f6ng\u00e9sz\u0151 v\u00e1laszt\u00e1sa</p> <p>A ind\u00edt\u00f3gomb leg\u00f6rd\u00fcl\u0151j\u00e9ben a b\u00f6ng\u00e9sz\u0151 t\u00edpus\u00e1t is \u00e1ll\u00edthatjuk.</p> <p>IIS Express</p> <p>Az IIS Express a Microsoft webszerver\u00e9nek (IIS) fejleszt\u0151i c\u00e9lra optimaliz\u00e1lt v\u00e1ltozata. Alapvet\u0151en csak ugyanarr\u00f3l a g\u00e9pr\u0151l \u00e9rkez\u0151 (localhost) k\u00e9r\u00e9seket szolg\u00e1l ki.</p> <p>A m\u00e1sik lehet\u0151s\u00e9g, ha k\u00f6zvetlen\u00fcl a konzolos alkalmaz\u00e1st szeretn\u00e9nk futtatni, akkor ezt az ind\u00edt\u00f3gombot lenyitva a projekt nev\u00e9t kiv\u00e1lasztva tehetj\u00fck meg. Ebben az esetben egy be\u00e1gyazott webszerverhez (Kestrel) futnak be a k\u00e9r\u00e9sek. Pr\u00f3b\u00e1ljuk ki a Kestrelt k\u00f6zvetlen\u00fcl futtatva!</p> <p>Most is k\u00e9t dolog t\u00f6rt\u00e9nik: az alkalmaz\u00e1sunk konzolos alkalmaz\u00e1sk\u00e9nt kezd futni, illetve az el\u0151z\u0151 esethez hasonl\u00f3an a b\u00f6ng\u00e9sz\u0151 is elindul. Figyelj\u00fck meg a konzolban megjelen\u0151 napl\u00f3\u00fczeneteket.</p> <p>\u00c9les hosting</p> <p>B\u00e1r ezek a hosztol\u00e1si opci\u00f3k fejleszt\u0151i k\u00f6rnyezetben nagyon k\u00e9nyelmesek, \u00e9rdemes \u00e1ttekinteni az \u00e9les hosztol\u00e1si opci\u00f3kat itt. A Kestrel ugyan jelenleg m\u00e1r alkalmas arra, hogy kipublik\u00e1ljuk k\u00f6zvetlen\u00fcl a vil\u00e1gh\u00e1l\u00f3ra, de mivel nem rendelkezik olyan sz\u00e9les konfigur\u00e1ci\u00f3s \u00e9s biztons\u00e1gi be\u00e1ll\u00edt\u00e1sokkal, mint a m\u00e1r bej\u00e1ratott webszerverek, \u00edgy \u00e9rdemes lehet egy ilyen webszervert a Kestrel el\u00e9 rakni proxy gyan\u00e1nt, p\u00e9ld\u00e1ul az IIS-t vagy nginx-et.</p> <p>Rakjunk most a kiszolg\u00e1l\u00f3 logik\u00e1nkba egy kiv\u00e9tel dob\u00e1st a ki\u00edr\u00e1s helyett, hogy kipr\u00f3b\u00e1ljuk a hibakezel\u0151 MW-t.</p> <pre><code>app.MapGet(\"/\", () =&gt;\n{\n    throw new Exception(\"hiba\");\n    //return \"Hello World!\"\n});\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki debugger n\u00e9lk\u00fcl (Ctrl+F5)!</p> <p>L\u00e1thatjuk, hogy a kiv\u00e9telt a hibakezel\u0151 middleware elkapja \u00e9s egy hibaoldalt jelen\u00edt\u00fcnk meg, s\u0151t m\u00e9g a konzolon is megjelenik napl\u00f3bejegyz\u00e9sk\u00e9nt.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#alkalmazasbeallitasok-vs-inditasi-profilok","title":"Alkalmaz\u00e1sbe\u00e1ll\u00edt\u00e1sok vs. ind\u00edt\u00e1si profilok","text":"<p>Figyelj\u00fck meg, hogy most Development konfigur\u00e1ci\u00f3ban fut az alkalmaz\u00e1s (konzolban a Hosting environment kezdet\u0171 sor). Ezt az inform\u00e1ci\u00f3t a keretrendszer k\u00f6rnyezeti v\u00e1ltoz\u00f3 alapj\u00e1n \u00e1llap\u00edtja meg. Ha a lauchSettings.json \u00e1llom\u00e1nyt megn\u00e9zz\u00fck, akkor l\u00e1thatjuk, hogy az <code>ASPNETCORE_ENVIRONMENT</code> k\u00f6rnyezeti v\u00e1ltoz\u00f3 <code>Development</code>-re van \u00e1ll\u00edtva.</p> <p>Pr\u00f3b\u00e1ljuk ki Visual Studio-n k\u00edv\u00fclr\u0151l futtatni. menu:Projekten jobb klikk[Open Folder in File Explorer]. Ezut\u00e1n a c\u00edmsorba mindent kijel\u00f6lve <code>cmd</code> + Enter, a parancssorba <code>dotnet run</code>.</p> <p>Ugyan\u00fagy fog indulni, mint VS-b\u0151l, mert az \u00fajabb .NET verzi\u00f3kban m\u00e1r a dotnet run is figyelembe veszi a launchSettings.json-t. A b\u00f6ng\u00e9sz\u0151t magunknak kell ind\u00edtani (most m\u00e9g) \u00e9s elnavig\u00e1lni a napl\u00f3ban szerepl\u0151 c\u00edmre (Now listening on: http://localhost:port \u00fczenetet keress\u00fcnk).</p> <p>Ha nem akarjuk ezt, akkor a <code>--no-launch-profile</code> kapcsol\u00f3t haszn\u00e1lhatjuk a dotnet run futtat\u00e1s\u00e1n\u00e1l.</p> <p>Most az alkalmaz\u00e1sunk Production m\u00f3dban indul el, \u00e9s ha a localhost:5000-es oldalt megnyitjuk a b\u00f6ng\u00e9sz\u0151ben, akkor nem kapunk hibaoldalt, de a konzolon tov\u00e1bbra is megjelenik a napl\u00f3bejegyz\u00e9s.</p> <p>Le\u00e1ll\u00edt\u00e1s</p> <p>A dotnet run fut\u00e1s\u00e1t Ctrl+C-vel \u00e1ll\u00edthatjuk le.</p> <p>K\u00f6rnyezeti v\u00e1ltoz\u00f3k felv\u00e9tele</p> <p>A konzolban a <code>setx ENV_NAME Value</code> utas\u00edt\u00e1ssal tudunk felvenni k\u00f6rnyezeti v\u00e1ltoz\u00f3t \u00fagy, hogy az permanensen megmaradjon, \u00e9s ne csak a konzolablak bez\u00e1r\u00e1s\u00e1ig maradjon \u00e9rv\u00e9nyben. (Admin/nem admin, illetve powershell konzolok k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek)</p> <p>Az eredeti logik\u00e1nkat kommentezz\u00fck vissza.</p> <pre><code>app.MapGet(\"/\", () =&gt;\n{\n    //throw new Exception(\"hiba\");\n    return \"Hello World!\";\n});\n</code></pre> <p>Az alkalmaz\u00e1s sz\u00e1m\u00e1ra a k\u00fcl\u00f6nb\u00f6z\u0151 be\u00e1ll\u00edt\u00e1sokat JSON \u00e1llom\u00e1nyokban t\u00e1rolhatjuk, amelyek ak\u00e1r k\u00f6rnyezetenk\u00e9nt k\u00fcl\u00f6nb\u00f6z\u0151ek is lehetnek. A gener\u00e1lt projekt\u00fcnkben ez az appsettings.json, n\u00e9zz\u00fcnk bele - f\u0151leg napl\u00f3z\u00e1si be\u00e1ll\u00edt\u00e1sok vannak benne. A f\u00e1jl a Solution Explorer ablakban kinyithat\u00f3, alatta megtal\u00e1ljuk az appsettings.Development.json-t. Ebben a Development nev\u0171 konfigur\u00e1ci\u00f3ra vonatkoz\u00f3 be\u00e1ll\u00edt\u00e1sok vannak. Alap\u00e9rtelmez\u00e9sben az appsettings.\\&lt;ind\u00edt\u00e1si konfigur\u00e1ci\u00f3 neve&gt;.json be\u00e1ll\u00edt\u00e1sai jutnak \u00e9rv\u00e9nyre, fel\u00fcl\u00edrva a sima appsettings.json egyez\u0151 \u00e9rt\u00e9keit (a pontosabb logik\u00e1t l\u00e1sd lentebb).</p> <p>\u00c1ll\u00edtsunk Development m\u00f3dban r\u00e9szletesebb napl\u00f3z\u00e1st. Az appsettings.Development.json-ben minden napl\u00f3z\u00e1si szintet \u00edrjunk <code>Debug</code>-ra.</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Debug\"\n    }\n  }\n}\n</code></pre> <p>Napl\u00f3z\u00e1si szintek</p> <p>A napl\u00f3z\u00e1si szintek sorrendje itt tal\u00e1lhat\u00f3.</p> <p>Pr\u00f3b\u00e1ljuk ki, hogy \u00edgy az alkalmaz\u00e1sunk fut\u00e1sakor minden b\u00f6ng\u00e9sz\u0151beli friss\u00edt\u00e9s\u00fcnk (F5) megjelenik a konzolon.</p> <p>VS-b\u0151l is tudjuk \u00e1ll\u00edtani a k\u00f6rnyezeti v\u00e1ltoz\u00f3kat, nem kell a launchSettings.json-ben k\u00e9zzel var\u00e1zsolni. A projekt tulajdons\u00e1gok Debug lapj\u00e1n az Open debug launch profiles UI sz\u00f6vegre kattintva egy dial\u00f3gusablak ugrik fel, itt tudunk \u00faj ind\u00edt\u00e1si profilt megadni, illetve a megl\u00e9v\u0151eket m\u00f3dos\u00edtani. V\u00e1lasszuk ki az aktu\u00e1lisan haszn\u00e1lt profilunkat (projektneves), majd \u00edrjuk \u00e1t az <code>ASPNETCORE_ENVIRONMENT</code> k\u00f6rnyezeti v\u00e1ltoz\u00f3 \u00e9rt\u00e9k\u00e9t az Environment Variables r\u00e9szen mondjuk Production-re.</p> <p>Ind\u00edtsuk ezzel a profillal \u00e9s figyelj\u00fck meg, hogy m\u00e1r nem jelennek meg az egyes k\u00e9r\u00e9sek a napl\u00f3ban, b\u00e1rhogy is friss\u00edtgetj\u00fck a b\u00f6ng\u00e9sz\u0151t. Oka: nincs appsettings.Production.json, \u00edgy az \u00e1ltal\u00e1nos appsettings.json jut \u00e9rv\u00e9nyre.</p> <p>Konfigur\u00e1ci\u00f3k forr\u00e1sa</p> <p>Sz\u00e1mos forr\u00e1sb\u00f3l lehet konfigur\u00e1ci\u00f3t megadni: parancssor, k\u00f6rnyezeti v\u00e1ltoz\u00f3, f\u00e1jl (ezt l\u00e1ttuk most), felh\u0151 (Azure Key Vault) stb. Ezek k\u00f6z\u00fcl t\u00f6bbet is haszn\u00e1lhatunk egyszerre, a k\u00fcl\u00f6nb\u00f6z\u0151 forr\u00e1sok konfigur\u00e1ci\u00f3ja a k\u00f6z\u00f6s kulcsok ment\u00e9n \u00f6sszef\u00e9s\u00fcl\u0151dik. A forr\u00e1sok (configuration provider-ek) k\u00f6z\u00f6tt sorrendet adhatunk meg, amikor regisztr\u00e1ljuk \u0151ket, a legutols\u00f3k\u00e9nt regisztr\u00e1lt provider konfigur\u00e1ci\u00f3ja a leger\u0151sebb. Az alap\u00e9rtelmezett provider-ek regisztr\u00e1ci\u00f3j\u00e1t elint\u00e9zi a kor\u00e1bban l\u00e1tott kiindul\u00f3 builder.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#statikus-fajl-mw","title":"Statikus f\u00e1jl MW","text":"<p>Hozzunk l\u00e9tre a projekt gy\u00f6ker\u00e9be egy <code>wwwroot</code> nev\u0171 mapp\u00e1t (menu:jobbklikk a projekten[Add &gt; New Folder]) \u00e9s tegy\u00fcnk egy k\u00e9pf\u00e1jlt bele. (Ellophatjuk pl. a http://www.bme.hu honlap bal fels\u0151 sark\u00e1b\u00f3l a logo-t)</p> <p>A statikus f\u00e1jlkezel\u00e9st a teljes modularit\u00e1s jegy\u00e9ben egy k\u00fcl\u00f6n middleware-k\u00e9nt implement\u00e1lt\u00e1k a Microsoft.AspNetCore.StaticFiles oszt\u00e1lyk\u00f6nyvt\u00e1rban (az AspNetCore.App m\u00e1r f\u00fcgg\u0151s\u00e9gk\u00e9nt tartalmazza, \u00edgy nem kell k\u00fcl\u00f6n hivatkoznunk), csak hozz\u00e1 kell adnunk a pipeline-hoz.</p> <pre><code>app.UseStaticFiles();\napp.MapGet(\"/\", () =&gt; \"Hello World!\");\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>L\u00e1thatjuk hogy a localhost:port c\u00edmen m\u00e9g mindig a Hello World! sz\u00f6veg t\u0171nik fel, de amint a localhost:port/[k\u00e9pf\u00e1jln\u00e9v]-vel pr\u00f3b\u00e1lkozunk, a k\u00e9p t\u00f6lt\u0151dik be. A static file MW megszak\u00edtja a pipeline fut\u00e1s\u00e1t, ha egy \u00e1ltala ismert f\u00e1jlt\u00edpusra hivatkozunk, egy\u00e9bk\u00e9nt tov\u00e1bbh\u00edv a k\u00f6vetkez\u0151 MW-be. Az ilyen MW-eket \u00fan. termin\u00e1l\u00f3 MW-eknek h\u00edvjuk.</p> <p>Breakpoint a lambd\u00e1ban</p> <p>Ezt az egysoros endpoint logik\u00e1ra tett t\u00f6r\u00e9sponttal is szeml\u00e9ltethetj\u00fck. Figyelj\u00fcnk arra, hogy csak a Hello World! sz\u00f6vegre ker\u00fclj\u00f6n a t\u00f6r\u00e9spont \u00e9s ne az eg\u00e9sz <code>MapGet</code> sorra, illetve csak akkor n\u00e9zz\u00fck, hogy mi fut le, amikor a k\u00e9p URL-re h\u00edvunk.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#web-api","title":"Web API","text":"<p>Minden API-n\u00e1l nagyon magas szinten az a c\u00e9l, hogy egy k\u00e9r\u00e9s hat\u00e1s\u00e1ra egy szerveroldali k\u00f3dr\u00e9szlet megh\u00edv\u00f3djon. ASP.NET Core-ban a Minimap API megk\u00f6zel\u00edt\u00e9s mellett alkalmazhat\u00f3 az MVC keretrendszer is, ahol a k\u00f3dr\u00e9szleteket f\u00fcggv\u00e9nyekbe \u00edrjuk, a f\u00fcggv\u00e9nyek pedig \u00fan. kontrollerek-be ker\u00fclnek. Egy controller \u00e1ltal\u00e1ban az egy er\u0151forr\u00e1st\u00edpushoz kapcsol\u00f3d\u00f3 m\u0171veleteket fogja \u00f6ssze. \u00d6sszess\u00e9g\u00e9ben teh\u00e1t a c\u00e9l, hogy a webes k\u00e9r\u00e9s hat\u00e1s\u00e1ra egy kontroller egy f\u00fcggv\u00e9nye megh\u00edv\u00f3djon.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#dummycontroller","title":"DummyController","text":"<p>Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t Controllers n\u00e9ven. A mapp\u00e1ba hozzunk l\u00e9tre egy kontrollert (menu:jobbklikk a Controllers mapp\u00e1n[Add &gt; Controller\u2026 &gt; a bal oldali f\u00e1ban Common &gt; API &gt; jobb oldalon API Controller with read/write actions]) <code>DummyController</code> n\u00e9ven. A gener\u00e1lt kontroller\u00fcnk a Microsoft.AspNetCore.Mvc.Core csomagban tal\u00e1lhat\u00f3 <code>ControllerBase</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik. (Ezt a csomagot sem kell feltenn\u00fcnk, mivel az AspNetCore.App f\u00fcgg\u0151s\u00e9ge)</p> <p>Adjuk hozz\u00e1 a szolg\u00e1ltat\u00e1sokhoz a kontrollert\u00e1mogat\u00e1s szolg\u00e1ltat\u00e1st, \u00e9s adjuk hozz\u00e1 a cs\u0151vezet\u00e9khez a kontroller kezel\u0151 MW-t. Az egysoros MW-t kommentezz\u00fck ki. \u00cdgy n\u00e9z ki a teljes legfels\u0151 szint\u0171 k\u00f3d:</p> <pre><code>var builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddControllers(); // (1)!\nvar app = builder.Build();\n/*var app = WebApplication.Create();*/ // (2)!\napp.UseStaticFiles();\n/*app.MapGet(\"/\", () =&gt; \"Hello World!\");*/ // (3)!\napp.MapControllers();\napp.Run();\n</code></pre> <ol> <li>Kontrollert\u00e1mogat\u00e1s szolg\u00e1ltat\u00e1s regisztr\u00e1l\u00e1sa</li> <li>Mivel kell a kiindul\u00f3 builder, \u00edgy ezt az egysoros app inicializ\u00e1ci\u00f3t nem alkalmazhatjuk</li> <li>Egysoros MW kikommentezve</li> </ol> <p>Pr\u00f3b\u00e1ljuk ki.</p> <p>Az alapoldal \u00fcres, viszont ha az <code>/api/Dummy</code> c\u00edmre h\u00edvunk, akkor megjelenik a <code>DummyController.Get</code> \u00e1ltal visszaadott \u00e9rt\u00e9k. A routing szab\u00e1lyok szab\u00e1lyozz\u00e1k, hogy hogyan jut el a HTTP k\u00e9r\u00e9s alapj\u00e1n a v\u00e9grehajt\u00e1s a f\u00fcggv\u00e9nyig. Itt attrib\u00fatum alap\u00fa routing-ot haszn\u00e1lunk, azaz a kontroller oszt\u00e1lyra \u00e9s a f\u00fcggv\u00e9nyeire biggyesztett attrib\u00fatumok hat\u00e1rozz\u00e1k meg, hogy a HTTP k\u00e9r\u00e9s adata (pl. URL) alapj\u00e1n melyik f\u00fcggv\u00e9ny h\u00edv\u00f3dik meg.</p> <p>A <code>DummyController</code> oszt\u00e1lyon l\u00e9v\u0151 <code>Route</code> attrib\u00fatum az <code>\"api/[controller]\"</code> \u00fatvonalat defini\u00e1lja, melyb\u0151l a <code>[controller]</code> \u00fagynevezett token, ami jelen esetben a controller nev\u00e9re cser\u00e9l\u0151dik. Ezzel \u00f6sszess\u00e9g\u00e9ben megadtuk, hogy az <code>api/Dummy</code> \u00fatvonal a <code>DummyController</code>-t v\u00e1lasztja ki, de m\u00e9g nem tudjuk, hogy a f\u00fcggv\u00e9nyei k\u00f6z\u00fcl melyiket kell megh\u00edvni - ez a f\u00fcggv\u00e9nyekre tett attrib\u00fatumokb\u00f3l k\u00f6vetkezik. A <code>Get</code> f\u00fcggv\u00e9nyen lev\u0151 <code>HttpGet</code> mutatja, hogy ez a f\u00fcggv\u00e9ny akkor h\u00edvand\u00f3, ha a GET k\u00e9r\u00e9s URL-je nem folytat\u00f3dik - ellent\u00e9tben a <code>Get(int id)</code> f\u00fcggv\u00e9nnyel, ami az URL-ben m\u00e9g egy tov\u00e1bbi szegmenst v\u00e1r (ez\u00e9rt van egy <code>\"{id}\"</code> param\u00e9ter megadva az attrib\u00fatum konstruktorban), amit az <code>id</code> nev\u0171 f\u00fcggv\u00e9nyparam\u00e9terk\u00e9nt haszn\u00e1l fel.</p> <p>Routing lehet\u0151s\u00e9gek</p> <p>Az API-t publik\u00e1l\u00f3 alkalmaz\u00e1sokn\u00e1l az attrib\u00fatum alap\u00fa routing az aj\u00e1nlott, de emellett vannak m\u00e1s megk\u00f6zel\u00edt\u00e9sek is, p\u00e9ld\u00e1ul Razor alap\u00fa weboldalakn\u00e1l konvenci\u00f3 alap\u00fa routing az aj\u00e1nlott. B\u0151vebben a t\u00e9mak\u00f6rr\u0151l \u00e1ltal\u00e1nosan itt, illetve specifikusan webes API-k vonatkoz\u00e1s\u00e1ban itt lehet olvasni. A dokument\u00e1ci\u00f3 mennyis\u00e9g\u00e9b\u0151l l\u00e1that\u00f3, hogy a routing alrendszer nagyon szofisztik\u00e1lt \u00e9s sokat tud, szerencs\u00e9re az alap m\u0171k\u00f6d\u00e9s el\u00e9g egyszer\u0171 \u00e9s gyorsan megszokhat\u00f3.</p> <p>Ha van id\u0151nk, pr\u00f3b\u00e1ljuk ki az <code>/api/Dummy/[eg\u00e9sz sz\u00e1m]</code> c\u00edmet is. A <code>Get(int id)</code> f\u00fcggv\u00e9ny k\u00f3dj\u00e1nak megfelel\u0151en, b\u00e1rmit adunk meg, az eredm\u00e9ny a value sz\u00f6veg lesz.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#konfiguracios-beallitasok-dependency-injection","title":"Konfigur\u00e1ci\u00f3s be\u00e1ll\u00edt\u00e1sok, Dependency Injection","text":"<p>B\u0151v\u00edts\u00fck az appsettings.json-t egy saj\u00e1t be\u00e1ll\u00edt\u00e1scsoporttal (<code>DummySettings</code>):</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\", // a sor v\u00e9g\u00e9re beker\u00fclt egy vessz\u0151\n  \"DummySettings\": {\n    \"DefaultString\": \"My Value\",\n    \"DefaultInt\": 23,\n    \"SuperSecret\":  \"Spoiler Alert!!!\"\n  }\n}\n</code></pre> <p>K\u00e9rj\u00fck le a be\u00e1ll\u00edt\u00e1sokat a <code>DummyController</code>-ben, a <code>Get</code> f\u00fcggv\u00e9nyekben \u00edrjuk ki a <code>DefaultString</code> \u00e9s <code>DefaultInt</code> \u00e9rt\u00e9k\u00e9t.</p> <p>Ehhez viszont el kell k\u00e9rj\u00fck a <code>IConfiguration</code> interf\u00e9szt a konstruktorban a Dependency Injection (DI) mechanizmuson kereszt\u00fcl a DI kont\u00e9nert\u0151l. Ez t\u00f6bbek k\u00f6z\u00f6tt lehet\u0151v\u00e9 teszi, hogy az alkalmaz\u00e1son bel\u00fcl konstruktorban param\u00e9terk\u00e9nt ig\u00e9nyelj\u00fck a szolg\u00e1ltat\u00e1st. A param\u00e9ter \u00e9rt\u00e9k\u00e9t a DI alrendszer automatikusan t\u00f6lti ki a regisztr\u00e1lt szolg\u00e1ltat\u00e1sok alapj\u00e1n.</p> <pre><code>private readonly IConfiguration _configuration;\n\npublic DummyController(IConfiguration configuration)\n{\n    _configuration = configuration;\n}\n\n[HttpGet]\npublic string Get()\n{\n    return $\"string: {_configuration.GetValue&lt;string&gt;(\"DummySettings:DefaultString\")}\" +\n           $\"int: {_configuration.GetValue&lt;int&gt;(\"DummySettings:DefaultInt\")}\" +\n           $\"secret: {_configuration.GetValue&lt;string&gt;(\"DummySettings:SuperSecret\")}\";\n}\n</code></pre> <p>DI minta prefer\u00e1l\u00e1sa</p> <p>ASP.NET Core k\u00f6rnyezetben (is) t\u00f6rekedj\u00fcnk arra, hogy lehet\u0151leg minden oszt\u00e1lyunk minden f\u00fcgg\u0151s\u00e9g\u00e9t a DI minta szerint a DI kont\u00e9ner kezelje. Ez nagyban hozz\u00e1j\u00e1rul a komponensek k\u00f6z\u00f6tti laza csatol\u00e1s \u00e9s a jobb tesztelhet\u0151s\u00e9g el\u00e9r\u00e9s\u00e9hez. B\u0151vebb inform\u00e1ci\u00f3 az ASP.NET Core DI alrendszer\u00e9r\u0151l a dokument\u00e1ci\u00f3ban tal\u00e1lhat\u00f3.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#tipusos-beallitasok-ioptionst","title":"T\u00edpusos be\u00e1ll\u00edt\u00e1sok, <code>IOptions&lt;T&gt;</code>","text":"<p>Fentebb l\u00e1ttuk, hogy a konfigur\u00e1ci\u00f3t ki tudtuk olvasni az <code>IConfiguration</code> interf\u00e9szen kereszt\u00fcl, de m\u00e9g jobb lenne, ha csoportos\u00edtva \u00e9s csoportonk\u00e9nt k\u00fcl\u00f6n C# oszt\u00e1lyokon kereszt\u00fcl l\u00e1tn\u00e1nk \u0151ket.</p> <p>Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t <code>Options</code> n\u00e9ven.</p> <p>A mapp\u00e1ba hozzunk l\u00e9tre egy sima oszt\u00e1lyt <code>DummySettings</code> n\u00e9ven, a szerkezete feleljen meg a JSON-ben le\u00edrt be\u00e1ll\u00edt\u00e1scsoportnak:</p> <pre><code>public class DummySettings\n{\n    public string? DefaultString { get; set; }\n    public int DefaultInt { get; set; }\n    public string? SuperSecret { get; set; }\n}\n</code></pre> <p>Regisztr\u00e1ljuk szolg\u00e1ltat\u00e1sk\u00e9nt a <code>DummySettings</code> kezel\u00e9s\u00e9t, \u00e9s adjuk meg, hogy a p\u00e9ld\u00e1nyt mi alapj\u00e1n kell inicializ\u00e1lni - a konfigur\u00e1ci\u00f3 megfelel\u0151 szekci\u00f3j\u00e1ra hivatkozzunk:</p> <pre><code>builder.Services.Configure&lt;DummySettings&gt;(\n    builder.Configuration.GetSection(nameof(DummySettings)));\n</code></pre> <p>A <code>builder.Services</code>-ben regisztr\u00e1lt szolg\u00e1ltat\u00e1sok val\u00f3j\u00e1ban egy dependency injection (DI) kont\u00e9nerbe ker\u00fclnek regisztr\u00e1l\u00e1sra.</p> <p>Ig\u00e9nyelj\u00fcnk <code>DummySettings</code>-t a <code>DummyController</code> konstruktorban az <code>IConfiguration</code> helyett:</p> <pre><code>private readonly DummySettings _options;\n\npublic DummyController(IOptions&lt;DummySettings&gt; options)\n{\n    _options = options.Value;\n}\n</code></pre> <p>IOptions&lt;&gt; \u00e9s t\u00e1rsai</p> <p>L\u00e1that\u00f3, hogy a be\u00e1ll\u00edt\u00e1s <code>IOptions</code>-ba burkolva \u00e9rkezik. Vannak az <code>IOptions</code>-n\u00e1l okosabb burkol\u00f3k is (pl. <code>IOptionsMonitor</code>), ami p\u00e9ld\u00e1ul jelzi, ha megv\u00e1ltozik valamilyen be\u00e1ll\u00edt\u00e1s. B\u0151vebb inform\u00e1ci\u00f3 az <code>IOptions</code> \u00e9s t\u00e1rsair\u00f3l a hivatalos dokument\u00e1ci\u00f3ban tal\u00e1lhat\u00f3.</p> <p>Az eg\u00e9sz sz\u00e1mot v\u00e1r\u00f3 <code>Get</code> v\u00e1ltozatban haszn\u00e1ljuk fel az \u00e9rt\u00e9keket:</p> <pre><code>[HttpGet]\npublic string Get()\n{\n    return $\"string: {_options.DefaultString}\" +\n           $\"int: {_options.DefaultInt}\" +\n           $\"secret: {_options.SuperSecret}\";\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki, hogy a v\u00e9gpont megh\u00edv\u00e1sakor a megfelel\u0151 \u00e9rt\u00e9keket kapjuk-e vissza.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#user-secrets","title":"User Secrets","text":"<p>A projekt k\u00f6nyvt\u00e1ra gyakran valamilyen verzi\u00f3kezel\u0151 (pl. Git) kezel\u00e9s\u00e9ben van. Ilyenkor gyakori probl\u00e9ma, hogy a konfigur\u00e1ci\u00f3s f\u00e1jlokba \u00edrt szenzit\u00edv inform\u00e1ci\u00f3k (API kulcsok, adatb\u00e1zis jelszavak) beker\u00fclnek a verzi\u00f3kezel\u0151be. Ha egy publikus projekten dolgozunk, p\u00e9ld\u00e1ul publikus GitHub projekt, akkor ez komoly biztons\u00e1gi kock\u00e1zat lehet.</p> <p>Szenzit\u00edv inform\u00e1ci\u00f3k</p> <p>Ne tegy\u00fcnk a verzi\u00f3kezel\u0151be szenzit\u00edv inform\u00e1ci\u00f3kat m\u00e9g priv\u00e1t rep\u00f3 eset\u00e9ben sem. Gondoljunk arra is, hogy a verzi\u00f3kezel\u0151 nem felejt! Ami egyszer m\u00e1r beker\u00fclt, azt vissza is lehet nyerni bel\u0151le (history).</p> <p>Ennek a probl\u00e9m\u00e1nak megold\u00e1s\u00e1ra egy eszk\u00f6z a User Secrets t\u00e1rol\u00f3. Jobbklikkelj\u00fcnk a projekten a Solution Explorer ablakban, majd v\u00e1lasszuk a Manage User Secrets men\u00fcpontot. Ennek hat\u00e1s\u00e1ra megny\u00edlik egy secrets.json nev\u0171 f\u00e1jl. Vizsg\u00e1ljuk meg, hol is van ez a f\u00e1jl: vigy\u00fck az egeret a f\u00e1jlf\u00fcl f\u00f6l\u00e9 - azt l\u00e1thatjuk, hogy a f\u00e1jl a felhaszn\u00e1l\u00f3nk saj\u00e1t k\u00f6nyvt\u00e1r\u00e1n bel\u00fcl van \u00e9s az \u00fatvonal r\u00e9sze egy GUID is. A projektf\u00e1jlba (.csproj) beker\u00fclt ugyanez a GUID (a UserSecretsId c\u00edmk\u00e9be).</p> <p>Vegy\u00fcnk fel egy \u00faj be\u00e1ll\u00edt\u00e1st a secrets.json-ba, ami a <code>SuperSecret</code> \u00e9rt\u00e9k\u00e9t \u00edrja fel\u00fcl:</p> <pre><code>{\n  \"DummySettings\": {\n    \"SuperSecret\": \"SECRET\"\n  }\n}\n</code></pre> <p>R\u00e9szleges fel\u00fcl\u00edr\u00e1s</p> <p>A secrets.json-ban csak azokat a json lev\u00e9l elemeket kell felvenni, amiket fel\u00fcl akarunk \u00edrni. Ez a m\u00f3dszer m\u0171k\u00f6dik a sima appsettings.json k\u00f6rnyezetf\u00fcgg\u0151 v\u00e1ltoz\u00f3ira is.</p> <p>T\u00f6r\u00e9spontot let\u00e9ve (pl. a <code>DummyController</code> konstruktor\u00e1nak v\u00e9g\u00e9n) ellen\u0151rizz\u00fck, hogy a titkos \u00e9rt\u00e9k melyik f\u00e1jlb\u00f3l j\u00f6n. Ehhez meg kell h\u00edvnunk b\u00f6ng\u00e9sz\u0151b\u0151l az <code>api/dummy</code> c\u00edmet.</p> <p>User Secrets csak Development m\u00f3dban</p> <p>Fontos tudni, hogy a User Secrets t\u00e1rol\u00f3 csak Development m\u00f3d eset\u00e9n jut \u00e9rv\u00e9nyre, \u00edgy figyelj\u00fcnk r\u00e1, hogy a megfelel\u0151 m\u00f3dot ind\u00edtsuk \u00e9s a k\u00f6rnyezeti v\u00e1ltoz\u00f3k is j\u00f3l legyenek be\u00e1ll\u00edtva.</p> <p>Ez az elj\u00e1r\u00e1s teh\u00e1t a futtat\u00f3 felhaszn\u00e1l\u00f3 saj\u00e1t k\u00f6nyvt\u00e1r\u00e1b\u00f3l a GUID alapj\u00e1n kikeresi a projekthez tartoz\u00f3 secrets.json-t, annak tartalm\u00e1t pedig fut\u00e1s k\u00f6zben \u00f6sszef\u00e9s\u00fcli az appsettings.json tartalm\u00e1val. \u00cdgy szenzit\u00edv adat nem ker\u00fcl a projekt k\u00f6nyvt\u00e1r\u00e1ba.</p> <p>Titkok \u00e9les k\u00f6rnyezetben</p> <p>Mivel a User Secrets t\u00e1rol\u00f3 csak Development m\u00f3d eset\u00e9n jut \u00e9rv\u00e9nyre, \u00edgy ha az \u00e9les v\u00e1ltozatnak sz\u00fcks\u00e9ge van ezekre a titkos \u00e9rt\u00e9kekre, akkor tov\u00e1bbi tr\u00fckk\u00f6kre van sz\u00fcks\u00e9g. Ilyen megold\u00e1s lehet, ha a felh\u0151s hosztol\u00e1s eset\u00e9n a felh\u0151b\u0151l (pl. Azure App Service Configuration) vagy felh\u0151beli titokt\u00e1rol\u00f3b\u00f3l (pl. Azure Key Vault) vagy a DevOps eszk\u00f6zb\u0151l (pl. Azure DevOps Pipeline Secrets) t\u00f6ltj\u00fck be a szenzit\u00edv be\u00e1ll\u00edt\u00e1sokat.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#epilogus-webapplicationbuilder","title":"Epil\u00f3gus - WebApplicationBuilder","text":"<p>Az eddigiekb\u0151l l\u00e1that\u00f3, hogy sz\u00e1mos alapszolg\u00e1ltat\u00e1s m\u00e1r a <code>CreateBuilder</code> h\u00edv\u00e1s \u00e1ltal visszaadott kiindul\u00f3 builderben konfigur\u00e1lva van. Ilyen az alap (<code>IOptions</code> n\u00e9lk\u00fcli) alkalmaz\u00e1sbe\u00e1ll\u00edt\u00e1sok kezel\u00e9se vagy a napl\u00f3z\u00e1s. A <code>CreateBuilder</code> a <code>WebApplicationBuilder</code> internal konstruktor\u00e1t h\u00edvja.</p> <p>A <code>WebApplicationBuilder</code> el\u0151dje az <code>IWebHostBuilder</code>, ez ut\u00f3bbinak a dokument\u00e1ci\u00f3j\u00e1t tanulm\u00e1nyozva \u00e9rthetj\u00fck meg, hogy mi mindent tud a kiindul\u00f3 builder.</p>"},{"location":"seminar/06-efcore/chapter6/","title":"Entity Framework Core I-II.","text":""},{"location":"seminar/06-efcore/chapter6/#az-entity-framework-lekepezesi-modszerei","title":"Az Entity Framework lek\u00e9pez\u00e9si m\u00f3dszerei","text":"<p>Az objektum-rel\u00e1ci\u00f3s (OR) lek\u00e9pz\u00e9s (mapping) k\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll: az egyik az adatb\u00e1zis s\u00e9ma, a m\u00e1sik pedig egy menedzselt k\u00f3db\u00e9li objektummodell. Eset\u00fcnkben a C# k\u00f3dban l\u00e9v\u0151 oszt\u00e1lyokat k\u00e9pezz\u00fck le adatb\u00e1zisbeli objektumokk\u00e1, ezt h\u00edvjuk Code-First mapping m\u00f3dszernek. A m\u00e1sik ir\u00e1ny is lehets\u00e9ges, ha m\u00e1r van egy adatb\u00e1zis s\u00e9m\u00e1nk, akkor azt is lek\u00e9pezhetj\u00fck Code-First modell\u00e9. Ezt a folyamatot Reverse Engineered Code-First nek vagy scaffolding--nak h\u00edvjuk (ez ut\u00f3bbival nem foglalkozunk ezen gyakorlat keret\u00e9ben).</p> <p>Ak\u00e1rhogy is, az Entity Framework Core (EF) mint OR lek\u00e9pez\u0151 eszk\u00f6z (ORM) haszn\u00e1lat\u00e1hoz az al\u00e1bbi \u00f6sszetev\u0151kre van sz\u00fcks\u00e9g:</p> <ul> <li>objektummodell k\u00f3dban</li> <li>rel\u00e1ci\u00f3s modell az adatb\u00e1zisban</li> <li>lek\u00e9pez\u00e9s (mapping) az el\u0151bbi kett\u0151 k\u00f6z\u00f6tt, szint\u00e9n k\u00f3dban megadva</li> <li>maga az Entity Framework Core, mint (NuGet) komponens</li> <li>Entity Framework Core kompatibilis adatb\u00e1zis driver (provider)</li> <li>adatb\u00e1zis kapcsol\u00f3d\u00e1si adatok, connection string form\u00e1tumban</li> </ul>"},{"location":"seminar/06-efcore/chapter6/#a-code-first-lekepezesi-modszer","title":"A Code-First lek\u00e9pez\u00e9si m\u00f3dszer","text":"<p>A Code-First m\u00f3dszer l\u00e9nyege, hogy els\u0151k\u00e9nt az OO entit\u00e1sokat defini\u00e1ljuk egyszer\u0171en programk\u00f3dban, majd a lek\u00e9pez\u00e9st szint\u00e9n programk\u00f3dban. A lek\u00e9pez\u00e9s alapj\u00e1n az EF eszk\u00f6z\u00f6k k\u00e9pesek az adatb\u00e1zis l\u00e9trehoz\u00e1s\u00e1ra, inicializ\u00e1l\u00e1s\u00e1ra \u00e9s a s\u00e9ma v\u00e1ltoz\u00e1sk\u00f6vet\u00e9s\u00e9re is (l\u00e1sd lentebb a Code-First Migrations r\u00e9szt).</p>"},{"location":"seminar/06-efcore/chapter6/#az-entitasok-definialasa","title":"Az entit\u00e1sok defini\u00e1l\u00e1sa","text":"<p>K\u00e9sz\u00edts\u00fcnk egy .NET 8 konzolos alkalmaz\u00e1st (csak ne EF legyen a neve), majd a projekten bel\u00fcl hozzunk l\u00e9tre egy Entities nev\u0171 mapp\u00e1t. Adjunk hozz\u00e1 a mapp\u00e1hoz egyszer\u0171 oszt\u00e1lyokat az al\u00e1bbi s\u00e9m\u00e1nak megfelel\u0151en:</p> <ul> <li><code>Product</code> (<code>Id</code>: <code>int</code>, <code>Name</code>: <code>string</code>, <code>UnitPrice</code>: <code>int</code>)</li> <li><code>Order</code> (<code>Id</code>: <code>int</code>, <code>OrderDate</code>: <code>DateTime</code>)</li> <li><code>Category</code> (<code>Id</code>: <code>int</code>, <code>Name</code>: <code>string</code>)</li> </ul> <p>Az oszt\u00e1lyok legyenek publikusak, az attrib\u00fatumok pedig egyszer\u0171 auto-implement\u00e1lt propertyk (prop snippet).</p> <p>A <code>string</code> t\u00edpus\u00fa property-k eset\u00e9n figyelmeztet a ford\u00edt\u00f3, hogy nem nullozhat\u00f3 referencia t\u00edpus\u00fa property inicializ\u00e1ci\u00f3 ut\u00e1n is <code>null</code> \u00e9rt\u00e9k\u0171 lehet. Ennek kiv\u00e9d\u00e9s\u00e9re az aj\u00e1nlott m\u00f3dszer a <code>required</code> kulcssz\u00f3 haszn\u00e1lata a property el\u0151tt, ezzel kiv\u00e1lthat\u00f3ak a felesleges konstruktorok, amelyben csak a k\u00f6telez\u0151s\u00e9g miatt v\u00e1runk el param\u00e9tereket \u00e9s \u00e1ll\u00edtjuk be a propertyk \u00e9rt\u00e9k\u00e9t.</p>"},{"location":"seminar/06-efcore/chapter6/#mapping-es-egyeb-metaadatok-megadasa-i","title":"Mapping \u00e9s egy\u00e9b metaadatok megad\u00e1sa I.","text":"<p>Eddig megadtuk az entit\u00e1s nev\u00e9t, a rel\u00e1ci\u00f3s attrib\u00fatumok nev\u00e9t \u00e9s t\u00edpus\u00e1t, azonban ezen fel\u00fcl m\u00e9g sok mindent lehet/kell megadni: az entit\u00e1s els\u0151dleges kulcsa, idegen kulcsok, rel\u00e1ci\u00f3k, k\u00e9nyszerek \u00e9s egy\u00e9b mapping inform\u00e1ci\u00f3k (pl. hogy mi legyen a rel\u00e1ci\u00f3s attrib\u00fatum oszlopneve az adatb\u00e1zisban). A Code-First strat\u00e9gia k\u00e9tfajta m\u00f3dszert is k\u00edn\u00e1l ezek megad\u00e1s\u00e1ra. Az egyik m\u00f3dszer, hogy C# attrib\u00fatumokat helyez\u00fcnk az entit\u00e1soszt\u00e1lyok k\u00fcl\u00f6nb\u00f6z\u0151 r\u00e9szeire, a m\u00e1sik, hogy \u00fan. fluent jelleg\u0171 k\u00f3dot alkalmazunk. Ez ut\u00f3bbi m\u00f3dszer els\u0151re furcs\u00e1n n\u00e9z ki, de t\u00f6bbet tud (van, amit attrib\u00fatummal nem lehet megadni).</p> <p>A fenti k\u00e9t m\u00f3dszert kieg\u00e9sz\u00edti a konvenci\u00f3 alap\u00fa konfigur\u00e1ci\u00f3, amikor az EF a rendelkez\u00e9sekre \u00e1ll\u00f3 adatokb\u00f3l automatikusan k\u00f6vetkezteti ki a metaadatokat: p\u00e9ld\u00e1ul gyakori, hogy az els\u0151dleges kulcs neve tartalmazza az id sz\u00f6veget. Az EF teh\u00e1t a konvenci\u00f3 alapj\u00e1n kital\u00e1lhatja, hogy melyik ez els\u0151dleges kulcs oszlop. Ha valamit rosszul tal\u00e1lna ki, vagy v\u00e1ltoztatni akarunk a kital\u00e1lt neveken, akkor azt az attrib\u00fatumos vagy a fluent megad\u00e1ssal tehetj\u00fck meg.</p> <p>Saj\u00e1t konvenci\u00f3k</p> <p>EF Core 7 \u00f3ta saj\u00e1t konvenci\u00f3kat is megadhatunk l\u00e1sd b\u0151vebben.</p> <p>Els\u0151k\u00e9nt azt fogjuk megn\u00e9zni, hogy mit tal\u00e1l ki az EF, ha semmi plusz adatot nem adunk meg.</p>"},{"location":"seminar/06-efcore/chapter6/#relaciok","title":"Rel\u00e1ci\u00f3k","text":"<p>A f\u0151 entit\u00e1sok k\u00f6z\u00f6tti kapcsolatokat mutatja sematikusan az al\u00e1bbi \u00e1bra:</p> <p></p> <p>A rel\u00e1ci\u00f3kat idegen kulcs propertyk \u00e9s navig\u00e1ci\u00f3s propertyk reprezent\u00e1lj\u00e1k. Az idegen kulcs propertyk t\u00edpusa a kapcsolat m\u00e1sik v\u00e9g\u00e9n l\u00e9v\u0151 entit\u00e1s kulcs\u00e1nak t\u00edpusa. A navig\u00e1ci\u00f3s propertyk t\u00edpusa pedig a kapcsolat m\u00e1sik v\u00e9g\u00e9n l\u00e9v\u0151 entit\u00e1s t\u00edpusa vagy ilyen t\u00edpus\u00fa kollekci\u00f3.</p> <p>Egy konkr\u00e9t kapcsolat eset\u00e9ben: a <code>Product</code>-<code>Category</code> egy-t\u00f6bbes kapcsolathoz egy idegen kulcs property \u00e9s egy navig\u00e1ci\u00f3s property tartozik a <code>Product</code> oszt\u00e1lyban \u00e9s egy kollekci\u00f3 t\u00edpus\u00fa navig\u00e1ci\u00f3s property a <code>Category</code>-ban. A t\u00f6bbes navig\u00e1ci\u00f3s property-k legyenek csak olvashat\u00f3k \u00e9s a t\u00edpusuk legyen <code>ICollection&lt;&gt;</code>.</p> <p>Navig\u00e1ci\u00f3s propertyk</p> <p>\u00c1ltal\u00e1noss\u00e1gban nem k\u00f6telez\u0151 egy kapcsolat mindk\u00e9t oldal\u00e1n navig\u00e1ci\u00f3s property-t vagy k\u00fcls\u0151 kulcsot felvenni, de er\u0151sen javasolt \u00e9s mindig j\u00f3, ha van. Az entit\u00e1son v\u00e9gzend\u0151 m\u0171veleteket egyszer\u0171s\u00edti, illetve a konvenci\u00f3s logika is k\u00f6vetkeztet bel\u0151le.</p> <p>A navig\u00e1ci\u00f3s propertyk referencia t\u00edpus\u00faak, \u00edgy foglalkoznunk kell a nullozhat\u00f3s\u00e1g k\u00e9rd\u00e9s\u00e9vel.</p> <p>Ha a kapcsolat modellez\u00e9si szempontb\u00f3l nem k\u00f6telez\u0151 (p\u00e9ld\u00e1ul ha nem v\u00e1rn\u00e1nk el, hogy minden term\u00e9knek legyen megadva a kateg\u00f3ri\u00e1ja), akkor a navig\u00e1ci\u00f3s property t\u00edpusa is legyen \u00e9rtelemszer\u0171en nullozhat\u00f3.</p> <p>Ha a kapcsolat k\u00f6telez\u0151, akkor az aj\u00e1nlott elj\u00e1r\u00e1s, hogy a navig\u00e1ci\u00f3s property t\u00edpusa ne legyen nullozhat\u00f3 - viszont ekkor kezdeti \u00e9rt\u00e9ket kell adnunk. Gyakori eset, hogy egy entit\u00e1st bet\u00f6lt\u00fcnk adatb\u00e1zisb\u00f3l, de a hozz\u00e1 kapcsol\u00f3d\u00f3 entit\u00e1s(oka)t nem, ilyenkor m\u00e9gis a <code>null</code> \u00e9rt\u00e9k lenne a megfelel\u0151. Emiatt az egyik aj\u00e1nlott m\u00f3dszer, ha a propertyt null forgiving oper\u00e1torral inicializ\u00e1ljuk <code>null</code> \u00e9rt\u00e9kre.</p> <p>P\u00e9lda: <code>public Category Category { get; set; } = null!;</code>.</p> <p>Az <code>Order</code>-<code>Product</code> t\u00f6bb-t\u00f6bbes kapcsolatokhoz hozzuk l\u00e9tre a kapcsol\u00f3t\u00e1bl\u00e1nak megfelel\u0151 entit\u00e1st is, ami egy-egy <code>Product</code> \u00e9s <code>Order</code> k\u00f6z\u00f6tti kapcsolatot reprezent\u00e1lja.</p> <ul> <li><code>OrderItem</code> (<code>Id</code>: <code>int</code>, <code>ProductId</code>: <code>int</code>, <code>OrderId</code>: <code>int</code>, <code>Quantity</code>: <code>int</code>)</li> </ul> <p>Kapcsol\u00f3 entit\u00e1s</p> <p>Nem k\u00f6telez\u0151 l\u00e9trehozni oszt\u00e1lyt a kapcsol\u00f3t\u00e1bl\u00e1nak, konfigur\u00e1ci\u00f3val is lehet \u00e9rni, hogy a kapcsol\u00f3t\u00e1bla l\u00e9trej\u00f6jj\u00f6n \u00e9s az EF megfelel\u0151en haszn\u00e1lja. Ezt a m\u00f3dszert akkor \u00e9rdemes k\u00f6vetni, ha a kapcsol\u00f3t\u00e1bla csup\u00e1n technikai tehert\u00e9tel, de ha p\u00e9ld\u00e1ul extra adatot is t\u00e1rol, eset\u00fcnkben a rendelt mennyis\u00e9get (<code>Quantity</code>), akkor jobban k\u00f6vethet\u0151 k\u00f3dot eredm\u00e9nyez, ha explicit l\u00e9trehozzuk a kapcsol\u00f3t\u00e1bl\u00e1nak megfelel\u0151 entit\u00e1st\u00edpust.</p> <p>Az \u00edgy kialakult modell:</p> <p></p> <p>K\u00f3dk\u00e9nt:</p> <pre><code>public class Category\n{\n    public int Id { get; set; }\n\n    public required string Name { get; set; }\n\n    public ICollection&lt;Product&gt; Products { get; } = new List&lt;Product&gt;();\n}\n\npublic class Order\n{\n    public int Id { get; set; }\n\n    public required DateTime OrderDate { get; set; }\n\n    public ICollection&lt;OrderItem&gt; OrderItems { get; } = new List&lt;OrderItem&gt;();\n}\n\npublic class Product\n{\n    public int Id { get; set; }\n\n    public required string Name { get; set; }\n    public int UnitPrice { get; set; }\n\n    public int CategoryId { get; set; }\n    public Category Category { get; set; } = null!;\n\n    public ICollection&lt;OrderItem&gt; ProductOrders { get; } = new List&lt;OrderItem&gt;();\n}\n\npublic class OrderItem\n{\n    public int Id { get; set; }\n\n    public required int Quantity { get; set; }\n\n    public int ProductId { get; set; }\n    public Product Product { get; set; } = null!;\n\n    public int OrderId { get; set; }\n    public Order Order { get; set; } = null!;\n}\n</code></pre> <p>Vegy\u00fck \u00e9szre, hogy eddig semmilyen EF specifikus k\u00f3dot nem \u00edrtunk, a modell\u00fcnk sima \u00fan. POCO oszt\u00e1lyokb\u00f3l \u00e1ll.</p>"},{"location":"seminar/06-efcore/chapter6/#kapcsolat-az-adatbazissal","title":"Kapcsolat az adatb\u00e1zissal","text":""},{"location":"seminar/06-efcore/chapter6/#dbcontext-nuget","title":"DbContext - NuGet","text":"<p>Az entit\u00e1sokat defini\u00e1ltuk, a mapping-et az EF esz\u00e9re b\u00edztuk, a k\u00f6vetkez\u0151 l\u00e9p\u00e9s az adatb\u00e1ziss\u00e9ma l\u00e9trehoz\u00e1sa a mapping alapj\u00e1n, amit k\u00e9pes az EF migr\u00e1ci\u00f3s eszk\u00f6ze megoldani. M\u0171veletet az \u00fan. kontext-en kereszt\u00fcl tudunk v\u00e9gezni. \u00c9rdemes saj\u00e1t kontext t\u00edpust l\u00e9trehozni, amit az alap <code>DbContext</code>-b\u0151l sz\u00e1rmaztatunk.</p> <p>Eddig m\u00e9g nem is \u00edrtunk semmilyen EF specifikus k\u00f3dot, most viszont m\u00e1r kell a <code>DbContext</code> t\u00edpus, \u00edgy NuGet-b\u0151l hozz\u00e1 kell adnunk a Microsoft.EntityFrameworkCore.SqlServer csomagot. Nem ez a csomag tartalmazza a <code>DbContext</code>-et, viszont f\u00fcgg\u0151s\u00e9gk\u00e9nt hivatkozza (Microsoft.EntityFrameworkCore).</p> <p>NuGet csomagok telep\u00edt\u00e9se</p> <p>A NuGet csomagok telep\u00edt\u00e9s\u00e9hez seg\u00edts\u00e9g a dokument\u00e1ci\u00f3ban.</p> <p>NuGet verzi\u00f3k</p> <p>Olyan csomagokn\u00e1l, ahol a verzi\u00f3sz\u00e1moz\u00e1s k\u00f6veti az alap keretrendszer verzi\u00f3sz\u00e1moz\u00e1s\u00e1t, t\u00f6rekedj\u00fcnk arra, hogy a csomagok verzi\u00f3i konzisztensek legyenek egym\u00e1ssal \u00e9s a keretrendszer verzi\u00f3j\u00e1val is - akkor is, ha egy\u00e9bk\u00e9nt a f\u00fcgg\u0151s\u00e9gi szab\u00e1lyok engedn\u00e9k a verzi\u00f3k kever\u00e9s\u00e9t. Ha a projekt\u00fcnk p\u00e9ld\u00e1ul .NET 8-os keretrendszert haszn\u00e1l, akkor az Entity Framework Core \u00e9s egy\u00e9b extra ASP.NET Core csomagok k\u00f6z\u00fcl is olyan verzi\u00f3t v\u00e1lasszunk, ahol legal\u00e1bb a f\u0151verzi\u00f3 egyezik, teh\u00e1t valamilyen 8.x verzi\u00f3t. Ez nem azt jelenti, hogy az inkonzisztens verzi\u00f3k mindig hib\u00e1t eredm\u00e9nyeznek, ink\u00e1bb a projekt \u00e1ltal\u00e1ban stabilabb, ha a f\u0151verzi\u00f3k k\u00f6z\u00f6tti v\u00e1lt\u00e1st egyszerre, k\u00fcl\u00f6n migr\u00e1ci\u00f3s folyamat (p\u00e9lda) keret\u00e9ben v\u00e9gezz\u00fck.</p> <p>Az Entity Framework \u00f6nmag\u00e1ban f\u00fcggetlen az adatb\u00e1zis implement\u00e1ci\u00f3kt\u00f3l, azokhoz k\u00fcl\u00f6nb\u00f6z\u0151, adatb\u00e1zisgy\u00e1rt\u00f3-specifikus adatb\u00e1zis providereken kereszt\u00fcl kapcsol\u00f3dik. A Microsoft.EntityFrameworkCore.SqlServer csomag hivatkozza az EF absztrakt rel\u00e1ci\u00f3s komponens\u00e9t (EntityFrameworkCore.Relational), \u00e9s tartalmazza az MS SQL Server-hez tartoz\u00f3 providert. A providert a <code>DbContext</code> <code>OnConfiguring</code> met\u00f3dus\u00e1ban adhatjuk meg, eset\u00fcnkben a <code>UseSqlServer</code> met\u00f3dussal, ami egy connection stringet v\u00e1r.</p> <p>MS SQL Server helyett a LocalDB nev\u0171 fejleszt\u0151i adatb\u00e1zist haszn\u00e1ljuk, mely fejleszt\u0151i szempontb\u00f3l gyakorlatilag egy lebut\u00edtott MS SQL Server-rel megegyez\u0151. A LocalDB a Visual Studio-val egy\u00fctt telep\u00fcl, minden Windows felhaszn\u00e1l\u00f3nak k\u00fcl\u00f6n LocalDB p\u00e9ld\u00e1ny ind\u00edthat\u00f3 el. A Visual Studio az SQL Server Object Explorer ablak megnyit\u00e1sakor automatikusan l\u00e9trehozza a felhaszn\u00e1l\u00f3nkhoz tartoz\u00f3, MSSQLLocalDB nev\u0171 p\u00e9ld\u00e1nyt.</p> <p>Localdb</p> <p>A LocalDB k\u00fcl\u00f6n is let\u00f6lthet\u0151, illetve a vele egy\u00fctt telep\u00fcl\u0151 <code>sqllocaldb</code> parancs seg\u00edts\u00e9g\u00e9vel egyszer\u0171en kezelhet\u0151. Minderr\u0151l b\u0151vebb inform\u00e1ci\u00f3 a dokument\u00e1ci\u00f3ban olvashat\u00f3.</p> <p>Adjunk hozz\u00e1 \u00faj oszt\u00e1lyt a projekthez <code>LabDbContext</code> n\u00e9ven, ebben defini\u00e1ljuk majd, hogy milyen entit\u00e1skollekci\u00f3kon lehet m\u0171veleteket v\u00e9gezni.</p> <p>Az automatikusan l\u00e9trej\u00f6v\u0151 MSSQLLocalDB nev\u0171 LocalDB p\u00e9ld\u00e1ny connection stringj\u00e9t adjuk meg, pontosabban az SQL Server Object Explorer ablak seg\u00edt\u00e9s\u00e9vel m\u00e1soljuk ki: menu:SQL Server-t kibontva[(localdb)\\MSSQLLocalDB-n jobbklikk &gt; Properties &gt; Connection String].</p> <p>A kim\u00e1solt stringben az Initial Catalog \u00e9rt\u00e9k\u00e9t (a DB nev\u00e9t) a master-r\u0151l v\u00e1ltoztassuk meg valamilyen m\u00e1s n\u00e9vre, p\u00e9ld\u00e1ul a Neptun k\u00f3dunkra. Ha nincs a stringben Initial Catalog r\u00e9sz, akkor \u00edrjuk a string v\u00e9g\u00e9re, hogy <code>;Initial Catalog=neptunkod</code>.</p> <p> Connection string megszerz\u00e9se az SQL Server Object Explorer-b\u0151l</p> <p>K\u00fcl\u00f6nleges karakterek</p> <p>A connection stringben k\u00fcl\u00f6nleges karakterek (pl. \\) vannak. Ha a kim\u00e1solt connection k\u00e9t \" k\u00f6z\u00e9 illesztj\u00fck be, a VS automatikusan escape-eli a k\u00fcl\u00f6nleges karaktereket. Ellenkez\u0151 esetben (ha pl. a k\u00e9t \" a beilleszt\u00e9s ut\u00e1n ker\u00fcl elhelyez\u00e9sre a sz\u00f6veg k\u00f6r\u00e9) az automatikus escape-el\u00e9s nem t\u00f6rt\u00e9nik meg, ilyenkor ne felejts\u00fck el a <code>@</code>-ot a string el\u00e9 \u00edrni, vagy manu\u00e1lisan escape-elni a sz\u00fcks\u00e9ges karaktereket!</p> <pre><code>public class LabDbContext : DbContext\n{\n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlServer(\"&lt;connstring&gt;\");\n    }\n\n    public DbSet&lt;Product&gt; Products =&gt; Set&lt;Product&gt;();\n    public DbSet&lt;Category&gt; Categories =&gt; Set&lt;Category&gt;();\n    public DbSet&lt;Order&gt; Orders =&gt; Set&lt;Order&gt;();\n}\n</code></pre> <p>Connection String helye</p> <p>A nagyobb rugalmass\u00e1g \u00e9rdek\u00e9ben \u00e9rdemes a connection stringet konfigur\u00e1ci\u00f3s f\u00e1jlba helyezni, majd az ASP.NET Core konfigur\u00e1ci\u00f3s megold\u00e1saival felolvasni. Erre egy k\u00e9s\u0151bbi gyakorlaton n\u00e9z\u00fcnk p\u00e9ld\u00e1t.</p> <p><code>DbSet</code> property-k szerepe</p> <p>A <code>DbSet&lt;&gt;</code> t\u00edpus\u00fa tulajdons\u00e1goknak l\u00e1tsz\u00f3lag csak k\u00e9nyelmi funkci\u00f3juk van, a <code>Set&lt;&gt;()</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokat egyszer\u0171s\u00edtik, azonban val\u00f3j\u00e1ban nagyobb a jelent\u0151s\u00e9g\u00fck. T\u00f6bbek k\u00f6z\u00f6tt ezek alapj\u00e1n der\u00edti fel az EF, hogy melyek az entit\u00e1soszt\u00e1lyok, hiszen alapvet\u0151en nincsen semmilyen megk\u00fcl\u00f6nb\u00f6ztet\u0151 jellemz\u0151j\u00fck. Alapvet\u0151en a <code>DbSet&lt;&gt;</code> t\u00edpus\u00fa property-k t\u00edpusparam\u00e9terei \u00e9s az \u00edgy felder\u00edtett entit\u00e1st\u00edpusokban l\u00e9v\u0151 navig\u00e1ci\u00f3s propertyk t\u00edpusa alapj\u00e1n \u00e1ll \u00f6ssze az entit\u00e1st\u00edpusok k\u00f6re.</p> <p>Az els\u0151 verzi\u00f3s adatel\u00e9r\u00e9si (DAL) r\u00e9teg\u00fcnk ezzel k\u00e9sz is van.</p>"},{"location":"seminar/06-efcore/chapter6/#semamodositas","title":"S\u00e9mam\u00f3dos\u00edt\u00e1s","text":""},{"location":"seminar/06-efcore/chapter6/#code-first-migrations","title":"Code-First Migrations","text":"<p>A k\u00f3dban t\u00f6rt\u00e9n\u0151 s\u00e9mam\u00f3dos\u00edt\u00e1sokat k\u00f6vetni tudja a keretrendszer, \u00e9s a v\u00e1ltoz\u00e1sok alapj\u00e1n friss\u00edteni tudja az adatb\u00e1zis s\u00e9m\u00e1j\u00e1t lefele, illetve felfele ir\u00e1nyban is. Ezt a mechanizmust nevezz\u00fck migr\u00e1ci\u00f3nak. Eset\u00fcnkben a s\u00e9ma null\u00e1r\u00f3l felh\u00faz\u00e1sa is m\u00e1r m\u00f3dos\u00edt\u00e1snak sz\u00e1m\u00edt.</p> <p>A migr\u00e1ci\u00f3 elv\u00e9gz\u00e9s\u00e9re parancssoros utas\u00edt\u00e1sokat kell ig\u00e9nybe venn\u00fcnk. Itt k\u00e9tfajta megk\u00f6zel\u00edt\u00e9s is adott: vannak PowerShell \u00e9s vannak klasszikus cmd (dotnet cli) parancsaink. Fel kell telep\u00edts\u00fck a projekt\u00fcnkbe valamelyik NuGet csomagot:</p> <ul> <li>PowerShell: Microsoft.EntityFrameworkCore.Tools (telep\u00edts\u00fck fel most ezt)</li> <li>Parancssor: Microsoft.EntityFrameworkCore.Tools.DotNet</li> </ul> <p>Hozzuk el\u0151 a Package Manager Console-t. (menu:Tools[NuGet Package Manager &gt; Package Manager Console]). Ellen\u0151rizz\u00fck, hogy a Default Project leg\u00f6rd\u00fcl\u0151ben a mi projekt\u00fcnk van-e kiv\u00e1lasztva. Az <code>Add-Migration &lt;n\u00e9v&gt;</code> paranccsal tudunk k\u00e9sz\u00edteni egy \u00faj migr\u00e1ci\u00f3s l\u00e9p\u00e9st, \u00edgy az els\u0151 migr\u00e1ci\u00f3nk a kiindul\u00f3 s\u00e9m\u00e1nk migr\u00e1ci\u00f3j\u00e1t fogja tartalmazni.</p> <pre><code>Add-Migration Init\n</code></pre> <p>Figyelj\u00fck meg, mit gener\u00e1lt a projekt\u00fcnkbe ez a parancs. Itt a migr\u00e1ci\u00f3hoz egy oszt\u00e1lyt k\u00e9sz\u00edt, ami tartalmazza azokat az utas\u00edt\u00e1sokat (<code>Up</code> f\u00fcggv\u00e9ny), amikkel a modell\u00fcnknek megfelel\u0151 t\u00e1bl\u00e1kat fel lehet venni. Emellett k\u00fcl\u00f6n f\u00fcggv\u00e9nyben (<code>Down</code>) olyan utas\u00edt\u00e1sok is vannak, melyek ugyanezen t\u00e1bl\u00e1kat eldobj\u00e1k.</p> <p>Ford\u00edt\u00e1s ut\u00e1n adjuk ki az <code>Update-Database</code> parancsot, amivel egy adott migr\u00e1ci\u00f3s \u00e1llapotig pr\u00f3b\u00e1lja friss\u00edteni a s\u00e9m\u00e1t. Ha nem adunk meg s\u00e9manevet akkor a legfrissebb migr\u00e1ci\u00f3ig friss\u00edt:</p> <pre><code>Update-Database Init\n</code></pre> <p>Localdb migr\u00e1ci\u00f3s hiba</p> <p>Bizonyos LocalDB verzi\u00f3kn\u00e1l hib\u00e1ra futhat az adatb\u00e1zisl\u00e9trehoz\u00e1s (CREATE FILE encountered operating system error 5(Access is denied.)), mert rossz helyen pr\u00f3b\u00e1lja l\u00e9trehozni az adatb\u00e1zisf\u00e1jlt. Ilyenkor az SQL Server Object Explorer ablakban bontsuk ki a LocalDB p\u00e9ld\u00e1nyunk, alatta a menu:Databases mapp\u00e1n jobbklikk[Add New Database]. A megjelen\u0151 ablakban adjuk meg n\u00e9vk\u00e9nt ugyanazt az adatb\u00e1zisnevet, amit kor\u00e1bban a connection string-ben a master helyett megadtunk.</p> <p>Ellen\u0151rizz\u00fck le az adatb\u00e1zis s\u00e9m\u00e1j\u00e1t az SQL Server Object Explorer ablakban. N\u00e9zz\u00fck meg, hogy puszt\u00e1n konvenci\u00f3k alapj\u00e1n milyen tulajdons\u00e1gokat tal\u00e1lt ki az EF.</p> <p>Migr\u00e1ci\u00f3 k\u00f3db\u00f3l</p> <p>K\u00f3db\u00f3l is legener\u00e1lhatn\u00e1nk az adatb\u00e1zist az aktu\u00e1lis s\u00e9m\u00e1val a <code>DbContext.Database.EnsureCreated</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel, viszont ez a k\u00e9s\u0151bbiekben megnehez\u00edti a tov\u00e1bbi s\u00e9mam\u00f3dos\u00edt\u00e1st, mivel mindig el kellene dobjuk az adatb\u00e1zist, illetve a migr\u00e1ci\u00f3t sem k\u00f6nny\u0171 ut\u00f3lag bevezetni.</p>"},{"location":"seminar/06-efcore/chapter6/#lekepezes-es-egyeb-metaadatok-megadasa-ii-fluent-es-attributum-alapu-lekepezes","title":"Lek\u00e9pez\u00e9s \u00e9s egy\u00e9b metaadatok megad\u00e1sa II.\u2009\u2014\u2009fluent \u00e9s attrib\u00fatum alap\u00fa lek\u00e9pez\u00e9s","text":"<p>Defini\u00e1ljuk fel\u00fcl a kontext\u00fcnkben az \u0151s <code>OnModelCreating</code> met\u00f3dus\u00e1t \u00e9s itt \u00e1ll\u00edtsunk be p\u00e1r mapping inform\u00e1ci\u00f3t.</p> <pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    base.OnModelCreating(modelBuilder);\n\n    modelBuilder.Entity&lt;Category&gt;()\n        .Property(c =&gt; c.Name)\n        .HasMaxLength(15);\n}\n</code></pre> <p>Ezzel a <code>Name</code> property hossz\u00e1t \u00e1ll\u00edtottuk be.</p> <p>A fluent mellett pr\u00f3b\u00e1ljuk ki az attrib\u00fatumos konfigur\u00e1ci\u00f3t is. \u00c1ll\u00edtsunk \u00e1t egy oszlopnevet a <code>Product</code> oszt\u00e1lyban a <code>Column</code> attrib\u00fatummal.</p> <pre><code>[Column(\"ProductName\")]\npublic string Name { get; set; }\n</code></pre> <p>POCO</p> <p>A fenti miatt az entit\u00e1smodell\u00fcnk m\u00e1r nem POCO, mert EF specifikus attrib\u00fatum jelent meg a k\u00f3dj\u00e1ban.</p> <p>T\u00f6bbessz\u00e1mok kezel\u00e9se</p> <p>\u00c9rdemes megfigyelni a t\u00e1blanevek kapcs\u00e1n, hogy eleve t\u00f6bbessz\u00e1mos\u00edtott neveket tal\u00e1lunk az adatb\u00e1zisban. Ezt az <code>IPluralizer</code> service v\u00e9gzi, melyhez saj\u00e1t implement\u00e1ci\u00f3 is \u00edrhat\u00f3.</p> <p>Mivel m\u00e1r l\u00e9tezik az adatb\u00e1zisunk, migr\u00e1ci\u00f3 seg\u00edts\u00e9g\u00e9vel kell friss\u00edts\u00fck az adatb\u00e1zis s\u00e9m\u00e1j\u00e1t. K\u00e9sz\u00edts\u00fcnk egy \u00faj migr\u00e1ci\u00f3s l\u00e9p\u00e9st az <code>Add-Migration</code> utas\u00edt\u00e1ssal \u00e9s friss\u00edts\u00fck a s\u00e9m\u00e1t az <code>Update-Database</code> paranccsal.</p> <pre><code>Add-Migration CategoryName_ProductName\nUpdate-Database CategoryName_ProductName\n</code></pre> <p>Migr\u00e1ci\u00f3s SQL script</p> <p>Megn\u00e9zhetj\u00fck az adatb\u00e1zison futtatott SQL-t is a Script-Migration paranccsal. P\u00e9ld\u00e1ul ez mutatja a legut\u00f3bbi m\u00f3dos\u00edt\u00e1st \u00e9rv\u00e9nyes\u00edt\u0151 SQL-t: <code>Script-Migration -From Init</code></p> <p>Migr\u00e1ci\u00f3 vesz\u00e9lyei</p> <p>Term\u00e9szetesen mivel m\u00e9g nincsenek adataink az adatb\u00e1zisban, ak\u00e1r el is dobhatn\u00e1nk az adatb\u00e1zist \u00e9s \u00fajra legener\u00e1lhatn\u00e1nk null\u00e1r\u00f3l a s\u00e9m\u00e1t, de most kifejezetten a migr\u00e1ci\u00f3t szeretn\u00e9nk gyakorolni. Az <code>Add-Migration</code> kimenete figyelmeztet, hogy adatveszt\u00e9s is t\u00f6rt\u00e9nhet. Vannak vesz\u00e9lyes migr\u00e1ci\u00f3s m\u0171veletek, ez\u00e9rt \u00e9rdemes \u00e1tn\u00e9zni a gener\u00e1l\u00f3d\u00f3 migr\u00e1ci\u00f3s k\u00f3dot.</p> <p>Migr\u00e1ci\u00f3k szinkronban tart\u00e1sa</p> <p>Ha valamilyen okb\u00f3l nem megfelel\u0151 a migr\u00e1ci\u00f3nk, ne t\u00f6r\u00f6lj\u00fck k\u00e9zzel a gener\u00e1lt C# k\u00f3df\u00e1jlokat. Haszn\u00e1ljuk helyette a <code>Remove-Migration</code> parancsot (mindenfajta param\u00e9ter n\u00e9lk\u00fcl), ami a legut\u00f3bbi migr\u00e1ci\u00f3t t\u00f6rli.</p> <p>N\u00e9zz\u00fck meg, milyen migr\u00e1ci\u00f3s oszt\u00e1lyt gener\u00e1ltunk, \u00e9s hogy ez milyen utas\u00edt\u00e1sokat tartalmaz.</p> <p>Ellen\u0151rizz\u00fck, hogy a <code>Name</code> oszlop most m\u00e1r az \u00faj k\u00e9nyszereknek megfelel\u0151en lett-e felv\u00e9ve, \u00e9s hogy a term\u00e9kn\u00e9v oszlop neve is megv\u00e1ltozott-e.</p> <p>Ezzel k\u00e9sz a DAL r\u00e9teg\u00fcnk konfigur\u00e1ci\u00f3ja, egy\u00fattal mindent kipip\u00e1ltunk az anyagr\u00e9sz elej\u00e9n l\u00e9v\u0151 felsorol\u00e1sb\u00f3l.</p>"},{"location":"seminar/06-efcore/chapter6/#adatbazis-naplozas","title":"Adatb\u00e1zis napl\u00f3z\u00e1s","text":"<p>A k\u00f6vetkez\u0151 feladat k\u00f6nnyebb k\u00f6vethet\u0151s\u00e9ge \u00e9rdek\u00e9ben \u00e1ll\u00edtsuk be a napl\u00f3z\u00e1st az Entity Framework kapcs\u00e1n. A kontext oszt\u00e1lyba:</p> <pre><code>protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n{\n    optionsBuilder.UseSqlServer(\"&lt;connstring&gt;\") // ; t\u00f6r\u00f6lve\n        .LogTo(Console.WriteLine, LogLevel.Information);\n}\n</code></pre> <p>Napl\u00f3z\u00e1s m\u00e1shova</p> <p>Ha nem a konzolt szeretn\u00e9nk teleszemetelni, akkor ak\u00e1r a Debug kimenetre (Output ablak) is \u00edrhatunk. Ehhez a <code>LogTo</code>-nak adjuk meg param\u00e9terk\u00e9nt a <code>m =&gt; Debug.WriteLine(m)</code> deleg\u00e1tot.</p>"},{"location":"seminar/06-efcore/chapter6/#beszuras","title":"Besz\u00far\u00e1s","text":"<p>\u00cdrjunk egy egyszer\u0171 besz\u00far\u00f3 k\u00f3dot a <code>Program.cs</code>-be. V\u00e1rjunk param\u00e9ter\u00fcl egy kontext-et, \u00e9s csak akkor sz\u00farjunk be az adatb\u00e1zisba b\u00e1rmit, ha m\u00e9g \u00fcres.</p> <pre><code>static void SeedDatabase(LabDbContext ctx)\n{\n    if (ctx.Products.Any())\n    {\n        return;\n    }\n\n    var drink = new Category() { Name = \"Ital\" };\n    var food = new Category() { Name = \"\u00c9tel\" };\n\n    ctx.Categories.Add(drink);\n    ctx.Categories.Add(food);\n\n    ctx.Products.Add(new Product() { Name = \"S\u00f6r\", UnitPrice = 50, Category = drink });\n    ctx.Products.Add(new Product() { Name = \"Bor\", Category = drink });\n    ctx.Products.Add(new Product() { Name = \"Tej\", CategoryId = drink.Id });\n\n    ctx.SaveChanges();\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy kevert\u00fck a kapcsolatok be\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l a navig\u00e1ci\u00f3s property szerinti, illetve a sima <code>Id</code> \u00e9rt\u00e9k be\u00e1ll\u00edt\u00e1st.</p> <p>H\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3db\u00f3l \u00e9s pr\u00f3b\u00e1ljuk meg lek\u00e9rdezni az els\u0151 term\u00e9ket. Rakjunk a k\u00f3d v\u00e9g\u00e9re egy <code>Console.ReadKey</code>-t, hogy legyen id\u0151nk megn\u00e9zni a napl\u00f3t.</p> <pre><code>using var ctx = new LabDbContext();\nSeedDatabase(ctx);\nvar p = ctx.Products.FirstOrDefault();\n\nConsole.ReadKey();\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>Hib\u00e1ra fut, mert besz\u00far\u00e1sn\u00e1l az <code>Id</code> \u00e9rt\u00e9kes hivatkoz\u00e1s alap\u00e9rtelmezett <code>int</code>, azaz 0 \u00e9rt\u00e9k\u0171 lesz, hiszen a kateg\u00f3ria is \u00faj. Az \u00faj elemekn\u00e9l gyakori, hogy az adatb\u00e1zis osztja ki az els\u0151dleges kulcs \u00e9rt\u00e9ket, addig az alap\u00e9rtelmezett \u00e9rt\u00e9k\u0171. Konvenci\u00f3 szerint a mi <code>Id</code> oszlopaink is ilyenek lesznek (\u00fan. IDENTITY oszlopok). A term\u00e9k besz\u00far\u00e1sakor viszont a 0 \u00e9rt\u00e9k m\u00e1r nem lesz helyes, hiszen addigra a kateg\u00f3ria kapott valamilyen kulcs \u00e9rt\u00e9ket. Mindezt a probl\u00e9m\u00e1t navig\u00e1ci\u00f3s property-s hivatkoz\u00e1ssal elker\u00fclhetj\u00fck.</p> <p>Figyelj\u00fck meg a konzol napl\u00f3ban, hogy a <code>Category</code> besz\u00far\u00e1sa m\u00e9g megt\u00f6rt\u00e9nik, de az egyik <code>Product</code> hozz\u00e1ad\u00e1sa m\u00e1r elsz\u00e1ll. A debuggerrel, ha meg\u00e1llunk a <code>SaveChanges</code> h\u00edv\u00e1son, akkor l\u00e1that\u00f3, hogy a <code>CategoryId</code> property \u00e9rt\u00e9ke 0.</p> <p>Figyelj\u00fck meg azt is, hogy a <code>SaveChanges</code> h\u00edv\u00e1sig nem t\u00f6rt\u00e9nik m\u00f3dos\u00edt\u00f3 adatb\u00e1zism\u0171velet. Az EF mem\u00f3ri\u00e1ban gy\u0171jti a v\u00e1ltoz\u00e1sokat, amiket a <code>SaveChanges</code>-szel szinkroniz\u00e1lunk az adatb\u00e1zisba.</p> <p>Itt l\u00e1thatjuk az alap\u00e9rtelmezett tranzakci\u00f3kezel\u00e9s m\u0171k\u00f6d\u00e9s\u00e9t is. Egy h\u00edv\u00e1sban t\u00f6bb elemet kell besz\u00farni, ha b\u00e1rmelyik m\u0171velet meghi\u00fasul, akkor semmilyen v\u00e1ltoz\u00e1s nem \u00e9rv\u00e9nyes\u00fcl az adatb\u00e1zisban. \u00c1ltal\u00e1nosan igaz, hogy egy <code>SaveChanges</code> vagy minden v\u00e1ltoz\u00e1st \u00e9rv\u00e9nyes\u00edt vagy semmit sem.</p> <p>Jav\u00edtsuk ki:</p> <pre><code>ctx.Products.Add(new Product(\"Tej\")\n{\n    Name = \"Tej\",\n    Category = drink //navig\u00e1ci\u00f3s property-re v\u00e1ltottunk\n});\nctx.SaveChanges();\n</code></pre> <p>Ennek m\u00e1r le kell futnia. N\u00e9zz\u00fck meg a konzolon az SQL utas\u00edt\u00e1sokat \u00e9s a v\u00e1ltoz\u00e1sokat az adatb\u00e1zisban. Param\u00e9terezett <code>INSERT</code> utas\u00edt\u00e1sokat haszn\u00e1l az EF, \u00edgy elker\u00fclve az SQL injection t\u00e1mad\u00e1st.</p> <p>\u00c1tmeneti azonos\u00edt\u00f3k</p> <p>A h\u00e1tt\u00e9rben az EF minden \u00faj entit\u00e1snak kioszt egy \u00e1tmeneti azonos\u00edt\u00f3t, amit felhaszn\u00e1lhatunk a fenti hiba elker\u00fcl\u00e9s\u00e9re, ha semmik\u00e9pp sem akarjuk a navig\u00e1ci\u00f3s property-ket haszn\u00e1lni. \u00cdgy tudn\u00e1nk a context-t\u0151l elk\u00e9rni: <code>ctx.Entry(cat_drink).Property(e =&gt; e.Id).CurrentValue</code></p> <p>Azonos\u00edt\u00f3k kezel\u00e9se</p> <p>Ha egyszerre t\u00f6bb egym\u00e1sra hivatkoz\u00f3 elemet sz\u00farunk be \u00e9s azonos\u00edt\u00f3 alapj\u00e1n k\u00f6tj\u00fck \u0151ket \u00f6ssze, mindig gondoljuk \u00e1t, hogy a t\u00e9nyleges adatb\u00e1zisbeli azonos\u00edt\u00f3k biztosan rendelkez\u00e9sre \u00e1llnak-e, mert k\u00fcl\u00f6nben fut\u00e1sidej\u0171 kiv\u00e9telt kaphatunk, a ford\u00edt\u00f3 nem fog figyelmeztetni.</p>"},{"location":"seminar/06-efcore/chapter6/#osfeltoltes-seeding-elvart-adattartalom-megadasaval","title":"\u0150sfelt\u00f6lt\u00e9s (seeding) elv\u00e1rt adattartalom megad\u00e1s\u00e1val","text":"<p>A kontextuskonfigur\u00e1ci\u00f3 r\u00e9szek\u00e9nt megadhatjuk, hogy milyen adattartalmat szeretn\u00e9nk az egyes t\u00e1bl\u00e1kban l\u00e1tni. A kontext <code>OnModelCreating</code> f\u00fcggv\u00e9ny\u00e9nek v\u00e9g\u00e9re:</p> <pre><code>modelBuilder.Entity&lt;Category&gt;().HasData(\n    new Category() { Name = \"Ital\", Id = 1 }\n);\n\nmodelBuilder.Entity&lt;Product&gt;().HasData(\n    new Product() { Name = \"S\u00f6r\", Id = 1, UnitPrice = 50, CategoryId = 1 },\n    new Product() { Name = \"Bor\", Id = 2, UnitPrice = 550, CategoryId = 1 },\n    new Product() { Name = \"Tej\", Id = 3, UnitPrice = 260, CategoryId = 1 }\n);\n</code></pre> <p>HasData kulcsok</p> <p>Fontos, hogy ezen m\u00f3dszer eset\u00e9n mindenk\u00e9pp k\u00e9zzel meg kell adnunk az els\u0151dleges kulcs \u00e9rt\u00e9keket. Ford\u00edt\u00e1s ut\u00e1n gener\u00e1ltassunk \u00faj migr\u00e1ci\u00f3t \u00e9s friss\u00edts\u00fck is az adatb\u00e1zist - ez ut\u00f3bbi hib\u00e1ra fog futni:</p> <pre><code>Add-Migration Seed\nUpdate-Database\n</code></pre> <p>A <code>HasData</code> alapj\u00e1n gener\u00e1lt migr\u00e1ci\u00f3s k\u00f3d nem veszi figyelembe az id\u0151k\u00f6zben beker\u00fclt adatokat, csak a modellt \u00e9s a t\u00f6bbi migr\u00e1ci\u00f3t n\u00e9zi. Ha megn\u00e9zz\u00fck a gener\u00e1lt k\u00f3dot, l\u00e1thatjuk, hogy csak sima besz\u00far\u00e1sok. Mivel mi k\u00f6zben j\u00f3l \u00f6sszeszemetelt\u00fck az adatb\u00e1zist, a migr\u00e1ci\u00f3 \u00e1ltal kiadott besz\u00far\u00f3 m\u0171veletek j\u00f3 es\u00e9llyel hib\u00e1ra futnak.</p> <p>Ha szeretn\u00e9nk tiszta lappal indulni, b\u00e1rmikor kipucolhatjuk az adatb\u00e1zist a speci\u00e1lis null\u00e1s migr\u00e1ci\u00f3ra val\u00f3 friss\u00edt\u00e9ssel, majd \u00fajrah\u00fazhatjuk a <code>HasData</code>-nak k\u00f6sz\u00f6nhet\u0151en kezdeti adatokkal \u0151sfelt\u00f6ltve.</p> <pre><code>Update-Database 0\nUpdate-Database\n</code></pre> <p>Ezek ut\u00e1n a <code>SeedDatabase</code> h\u00edv\u00e1sra nincs sz\u00fcks\u00e9g, kommentezz\u00fck ki.</p>"},{"location":"seminar/06-efcore/chapter6/#lekerdezesek","title":"Lek\u00e9rdez\u00e9sek","text":"<p>Minden r\u00e9sz ut\u00e1n az el\u0151z\u0151 szakasz k\u00f3dj\u00e1t kommentezz\u00fck ki, hogy ne keltsen felesleges zajt a kimeneten az el\u0151z\u0151 utas\u00edt\u00e1s, illetve ne legyenek felesleges mell\u00e9khat\u00e1sok.</p> <p>K\u00e9rdezz\u00fck le azoknak a term\u00e9keknek a nev\u00e9t, melyeknek neve egy adott bet\u0171t tartalmaz:</p> <pre><code>//SeedDatabase(ctx);\n//var p = ctx.Products.FirstOrDefault();\n\nvar q = from p in ctx.Products\n        where p.Name.Contains(\"\u00f6\")\n        select p.Name;\n\nforeach (var name in q)\n{\n    Console.WriteLine(name);\n}\n</code></pre> <p>Itt figyelhet\u0151 meg a kor\u00e1bban m\u00e1r t\u00e1rgyalt <code>IEnumerable&lt;&gt;</code> - <code>IQueryable&lt;&gt;</code> k\u00fcl\u00f6nbs\u00e9g. A <code>Products</code> property t\u00edpusa <code>DbSet</code>, ami <code>IQueryable&lt;&gt;</code>. Az <code>IQueryable&lt;&gt;</code>-en t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sok kifejez\u00e9sf\u00e1t (<code>Expression</code>) \u00e9p\u00edtenek \u00e9s szint\u00e9n <code>IQueryable&lt;&gt;</code>-t adnak vissza. A <code>q</code> \u00e9rt\u00e9ke egy olyan <code>IQueryable&lt;&gt;</code>, ami <code>Expression</code>-j\u00e9ben tartalmazza a teljes lek\u00e9rdez\u00e9st. Amikor sz\u00fcks\u00e9g van az adatra, a kifejez\u00e9sfa alapj\u00e1n SQL gener\u00e1l\u00f3dik \u00e9s ez az SQL fut le az adatb\u00e1zison.</p> <p>A debuggerrel l\u00e9ptess\u00fck \u00e1t az egyes utas\u00edt\u00e1sokon a program fut\u00e1s\u00e1t. A k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s miatt csak a <code>foreach</code> v\u00e9grehajt\u00e1sa k\u00f6zben fog az adatb\u00e1zishoz fordulni az EF, hiszen csak ekkor van t\u00e9nylegesen sz\u00fcks\u00e9g az adatra. N\u00e9zz\u00fck meg a lefuttatott SQL-t is. Siker\u00fclt az <code>IQueryable&lt;&gt;</code>-ben tal\u00e1lhat\u00f3 <code>Expression</code>-t SQL utas\u00edt\u00e1ss\u00e1 alak\u00edtania.</p> <p>A fenti p\u00e9ld\u00e1ban az \u00fagynevezett query syntax-t haszn\u00e1ltuk, de ugyanezt megtehetj\u00fck a method vagy fluent syntax-sal is:</p> <pre><code>var q = ctx.Products\n    .Where(p =&gt; p.Name.Contains(\"\u00f6\"))\n    .Select(p =&gt; p.Name);\n</code></pre> <p>A labor sor\u00e1n ez lesz a prefer\u00e1lt a tov\u00e1bbiakban.</p> <p>Az EF el\u00e9g sok C# f\u00fcggv\u00e9nyt SQL-l\u00e9 tud ford\u00edtani. P\u00e9ldak\u00e9pp alak\u00edtsuk a visszaadott nevet nagybet\u0171ss\u00e9.</p> <pre><code>var q = ctx.Products\n    .Where(p =&gt; p.Name.Contains(\"\u00f6\"))\n    .Select(p =&gt; p.Name.ToUpper());\n</code></pre> <p>Figyelj\u00fck meg a konzolon a gener\u00e1lt SQL-t: a projekci\u00f3s r\u00e9szbe beker\u00fclt az <code>UPPER</code> SQL f\u00fcggv\u00e9ny.</p>"},{"location":"seminar/06-efcore/chapter6/#vegyes-kiertekeles","title":"Vegyes ki\u00e9rt\u00e9kel\u00e9s","text":"<p>A f\u00e1k sem n\u0151nek az \u00e9gig, az EF sem tud minden C# f\u00fcggv\u00e9nyt SQL-l\u00e9 ford\u00edtani. Pr\u00f3b\u00e1ljuk ki \u00fagy, hogy a <code>Contains</code>-t karakterrel h\u00edvjuk meg a sz\u0171r\u00e9sben.</p> <pre><code>var q = ctx.Products\n    .Where(p =&gt; p.Name.Contains('\u00f6'))\n    .Select(p =&gt; p.Name.ToUpper());\n</code></pre> <p><code>InvalidOperationException</code>-t kapunk: ezt a lek\u00e9rdez\u00e9st nem tudja a provider SQL-l\u00e9 ford\u00edtani. Egyik lehet\u0151s\u00e9g\u00fcnk, ahogy a hiba\u00fczenet is \u00edrja, hogy kik\u00e9nyszer\u00edtj\u00fck a ki\u00e9rt\u00e9kel\u00e9st a nem lefordul\u00f3 m\u0171velet el\u00e9 helyezett <code>AsEnumerable</code> vagy <code>ToList</code> (illetve ezek aszinkron v\u00e1ltozatai) h\u00edv\u00e1ssal. Pr\u00f3b\u00e1ljuk ki - mivel a sz\u0171r\u00e9st nem siker\u00fclt \u00e1tford\u00edtani, a sz\u0171r\u00e9s el\u00e9 a from v\u00e9g\u00e9re tegy\u00fck az <code>AsEnumerable</code>-t:</p> <pre><code>var q = ctx.Products\n    .AsEnumerable()\n    .Where(p =&gt; p.Name.Contains('\u00f6'))\n    .Select(p =&gt; p.Name.ToUpper());\n</code></pre> <p>Ez m\u0171k\u00f6dik, de a konzolon megjelen\u0151 SQL utas\u00edt\u00e1son l\u00e1tszik, hogy a teljes term\u00e9k t\u00e1bl\u00e1t lek\u00e9rdezt\u00fck \u00e9s felolvastuk a mem\u00f3ri\u00e1ba.</p> <p>Az <code>AsEnumerable</code> jelent\u00e9se: a lek\u00e9rdez\u00e9s innent\u0151l LINQ-to-Objects-k\u00e9nt \u00e9p\u00fcl tov\u00e1bb, a lek\u00e9rdez\u00e9s eddigi r\u00e9sz\u00e9nek mem\u00f3riabeli reprezent\u00e1ci\u00f3ja lesz az adatforr\u00e1s, teh\u00e1t a sz\u0171r\u00e9s \u00e9s a projekci\u00f3 m\u00e1r mem\u00f3ri\u00e1ban fut le. Mivel a teljes lek\u00e9rdez\u00e9s egy r\u00e9sze LINQ-to-Entities (adatb\u00e1zis \u00e9rt\u00e9keli ki), a m\u00e1sik r\u00e9sze LINQ-to-Objects (a .NET runtime \u00e9rt\u00e9keli ki), az ilyen lek\u00e9rdez\u00e9seket \u00fan. vegyes ki\u00e9rt\u00e9kel\u00e9s\u0171nek (mixed evaluation), a LINQ-to-Objects r\u00e9szt kliensoldali ki\u00e9rt\u00e9kel\u00e9s\u0171nek (client evaluation) nevezik. A <code>q</code> t\u00edpusa ebben az esetben m\u00e1r nem <code>IQueryable&lt;&gt;</code>, csak <code>IEnumerable&lt;&gt;</code>.</p> <p>IEnumerable \u00e9s IQueryable k\u00fcl\u00f6nbs\u00e9g\u00e9nek felder\u00edt\u00e9se</p> <p>\u00c9rdemes \u00f6sszevetni a <code>Where</code> f\u00fcggv\u00e9ny defin\u00edci\u00f3j\u00e1t (kurzorral r\u00e1\u00e1llva F12 vagy menu:jobbklikk[Go To Definition]) a k\u00e9t v\u00e1ltozatn\u00e1l. Az els\u0151 esetben <code>IQueryable</code> az adatforr\u00e1s \u00e9s <code>Expression</code> a felt\u00e9tel, a m\u00e1sodikn\u00e1l <code>IEnumerable</code> az adatforr\u00e1s \u00e9s sima delegate a felt\u00e9tel.</p> <p>Vegyes ki\u00e9rt\u00e9kel\u00e9s vesz\u00e9lyei</p> <p>A vegyes ki\u00e9rt\u00e9kel\u00e9s vesz\u00e9lyes lehet, mert a sz\u0171r\u00e9s \u00e9s a projekci\u00f3 m\u00e1r mem\u00f3ri\u00e1ban fut le, azaz az adatb\u00e1zisban l\u00e9v\u0151 adatokat a mem\u00f3ri\u00e1ba kell olvasni, ami nagy adatmennyis\u00e9g eset\u00e9n lass\u00fa \u00e9s er\u0151forr\u00e1sig\u00e9nyes lehet.</p> <p>K\u00fcl\u00f6n\u00f6sen fontos, hogy lehet\u0151leg minden EF lek\u00e9rdez\u00e9s\u00fcnket ellen\u0151rizz\u00fck le, hogy minden r\u00e9sze ott fut-e le (adatb\u00e1zisban vagy mem\u00f3ri\u00e1ban), ahol sz\u00e1m\u00edtunk r\u00e1.</p> <p>M\u00e1sik lehet\u0151s\u00e9g, ha keretrendszer korl\u00e1tba  \u00fctk\u00f6z\u00fcnk, hogy a lek\u00e9rdez\u00e9st megpr\u00f3b\u00e1ljuk \u00fagy \u00e1t\u00edrni, hogy min\u00e9l nagyobb r\u00e9sze lefuttathat\u00f3 legyen adatb\u00e1zisban. Ez a konkr\u00e9t p\u00e9ld\u00e1ban egyszer\u0171, csak vissza kell \u00edrni az els\u0151 v\u00e1ltozatot.</p>"},{"location":"seminar/06-efcore/chapter6/#lekerdezesek-osszefuzese-es-cimkezese","title":"Lek\u00e9rdez\u00e9sek \u00f6sszef\u0171z\u00e9se \u00e9s c\u00edmk\u00e9z\u00e9se","text":"<p>K\u00e9rdezz\u00fck le egy bizonyos \u00e1rn\u00e1l dr\u00e1g\u00e1bb, bizonyos bet\u0171t a nev\u00fckben tartalmaz\u00f3 term\u00e9kek nev\u00e9t - mindezt k\u00e9t k\u00fcl\u00f6n lek\u00e9rdez\u00e9sben:</p> <pre><code>var q1 = ctx.Products\n    .TagWith(\"N\u00e9vsz\u0171r\u00e9s\")\n    .Where(p =&gt; p.Name.Contains(\"r\"));\n\nvar q2 = ctx.Products\n    .Where(p =&gt; p.UnitPrice &gt; 20)\n    .Select(p =&gt; p.Name);\n\nforeach (var name in q2)\n{\n    Console.WriteLine(name);\n}\n</code></pre> <p>A <code>TagWith</code> haszn\u00e1lat\u00e1val k\u00f6nnyebben megtal\u00e1lhatjuk a lek\u00e9rdez\u00e9s \u00e1ltal gener\u00e1lt SQL utas\u00edt\u00e1st a napl\u00f3ban: a f\u00fcggv\u00e9nynek megadott sz\u00f6veg k\u00f6zvetlen\u00fcl a gener\u00e1lt utas\u00edt\u00e1s el\u00e9 ker\u00fcl.</p> <p>Ism\u00e9t figyelj\u00fck meg a napl\u00f3ban, mikor fut le \u00e9s milyen lek\u00e9rdez\u00e9s. Itt is l\u00e1tszik a k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s \u00e9s a lek\u00e9rdez\u00e9sek \u00f6ssze lesznek f\u0171zve, egy lek\u00e9rdez\u00e9s hajt\u00f3dik v\u00e9gre.</p> <p>Lek\u00e9rdez\u00e9sek \u00f6sszef\u0171z\u00e9se</p> <p>Ez r\u00e1mutat az EF egy nagy el\u0151ny\u00e9re: bonyolult lek\u00e9rdez\u00e9seket meg\u00edrhatunk kisebb, egyszer\u0171bb r\u00e9szletekben, az EF pedig \u00f6sszevonja, s\u0151t optimaliz\u00e1lhatja is a teljes lek\u00e9rdez\u00e9st.</p> <p>Pr\u00f3b\u00e1ljuk ki, <code>var q =</code> helyett <code>IEnumerable&lt;Product&gt; q =</code>-val is, ilyenkor nem f\u0171zi \u00f6ssze a lek\u00e9rdez\u00e9st. A <code>q2</code> m\u0171veletei m\u00e1r mem\u00f3ri\u00e1ban fognak lefutni, hiszen a <code>q2</code> adatforr\u00e1sk\u00e9nt csak egy <code>IEnumerable</code>-t l\u00e1t.</p> <p>Pr\u00f3b\u00e1ljuk ki, <code>var q =</code> helyett <code>IQueryable&lt;Product&gt; q =</code> -val is, ilyenkor megint \u00f6sszef\u0171zi a lek\u00e9rdez\u00e9st.</p> <p>Itt is \u00e9rdemes \u00f6sszevetni a <code>where</code> oper\u00e1tor defin\u00edci\u00f3j\u00e1t a k\u00e9t lek\u00e9rdez\u00e9sr\u00e9szben.</p> <p><code>IQueryable</code> \u00e9s <code>IEnumberable</code> k\u00fcl\u00f6nbs\u00e9gei \u00fajra</p> <p>Nem lehet el\u00e9gszer hangs\u00falyozni az <code>IQueryable</code> \u00e9s az <code>IEnumerable</code> k\u00f6zti k\u00fcl\u00f6nbs\u00e9geket. Az <code>IQueryable</code> kifejez\u00e9sek SQL-l\u00e9 fordulnak (amikor le tudnak), m\u00edg az <code>IEnumerable</code>-en v\u00e9gzett m\u0171veletek minden esetben mem\u00f3ri\u00e1ban hajt\u00f3dnak v\u00e9gre.</p> <p>Ha nem akarunk v\u00e9letlen\u00fcl mem\u00f3riabeli ki\u00e9rt\u00e9kel\u00e9sre v\u00e1ltani, az implicit t\u00edpus (<code>var</code>) alkalmaz\u00e1sa j\u00f3 szolg\u00e1latot tehet.</p>"},{"location":"seminar/06-efcore/chapter6/#beszuras-tobb-tobbes-kapcsolatba","title":"Besz\u00far\u00e1s t\u00f6bb-t\u00f6bbes kapcsolatba","text":"<p>Azokat a term\u00e9keket szeretn\u00e9nk megrendelni, amiknek a nev\u00e9ben van egy adott bet\u0171. Haszn\u00e1ljuk fel \u00fajra az el\u0151z\u0151, hasonl\u00f3 lek\u00e9rdez\u00e9s\u00fcnket.</p> <pre><code>var products = ctx.Products\n    .Where(p =&gt; p.Name.Contains(\"r\"))\n    .ToList();\n\nvar order = new Order { OrderDate = DateTime.Now };\n\nforeach (var p in products)\n{\n    order.OrderItems.Add(\n        new OrderItem { Product = p, Order = order, Quantity = 2 }\n    );\n}\n\nctx.Orders.Add(order);\nctx.SaveChanges();\n</code></pre> <p>Ism\u00e9t figyelj\u00fck, hogy milyen SQL gener\u00e1l\u00f3dik. Az <code>Order</code> l\u00e9trehoz\u00e1sa ut\u00e1n nek\u00fcnk m\u00e9g egy \u00faj <code>OrderItem</code> entit\u00e1st is l\u00e9tre kell hoznunk, amit a t\u00f6bb-t\u00f6bb kapcsolatra haszn\u00e1lunk fel.</p> <p>Figyelj\u00fck meg, hogy nem kellett minden <code>OrderItem</code>-et k\u00fcl\u00f6n-k\u00fcl\u00f6n hozz\u00e1adnunk a kontextushoz, az <code>Order</code> hozz\u00e1ad\u00e1s\u00e1val minden <code>OrderItem</code> is beker\u00fclt a kontextusba, majd el is ment\u0151d\u00f6tt az adatb\u00e1zisba.</p>"},{"location":"seminar/06-efcore/chapter6/#kapcsolodo-entitasok-betoltese","title":"Kapcsol\u00f3d\u00f3 entit\u00e1sok bet\u00f6lt\u00e9se","text":"<p>\u00cdrjuk ki minden term\u00e9k neve mell\u00e9 a kateg\u00f3ri\u00e1j\u00e1t is.</p> <pre><code>var products = ctx.Products.ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.Name} ({p.Category.Name})\");\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy a fenti lek\u00e9rdez\u00e9sben a kateg\u00f3ria navig\u00e1ci\u00f3s property <code>null</code> \u00e9rt\u00e9k\u0171 \u00e9s kiv\u00e9tel is keletkezik, pedig biztosan tartozik a term\u00e9khez kateg\u00f3ria az adatb\u00e1zisban.  Ennek oka, hogy az EF alapb\u00f3l nem t\u00f6lti be a navig\u00e1ci\u00f3s property-k \u00e9rt\u00e9keit, ezt egy k\u00fcl\u00f6n <code>Include</code> met\u00f3dush\u00edv\u00e1ssal tudjuk megtenni az <code>IQueryable</code> t\u00edpuson. Ez az \u00fan. eager loading.</p> <pre><code>var products = ctx.Products\n    .Include(p =&gt; p.Category)\n    .ToList();\n</code></pre> <p>Ism\u00e9t figyelj\u00fck, hogy mikor mi fut le az adatb\u00e1zisszerveren: ez egy <code>JOIN</code> seg\u00edts\u00e9g\u00e9vel egy f\u00fcst alatt ber\u00e1nt minden adatot mindk\u00e9t t\u00e1bl\u00e1b\u00f3l.</p> <p>Ha a kapcsol\u00f3d\u00f3 <code>Order</code> list\u00e1t is szeretn\u00e9nk kit\u00f6ltetni, akkor ott egyr\u00e9szt a <code>ProductOrders</code> list\u00e1t is be kell <code>Include</code>-olni, m\u00e1sr\u00e9szt pedig m\u00e9g egy kapcsolattal tov\u00e1bbmenve a <code>OrderItem</code> <code>Order</code> tulajdons\u00e1g\u00e1t is be kell t\u00f6ltetni. Az ilyen t\u00f6bbszintes hivatkoz\u00e1st az <code>Include</code> \u00e9s <code>ThenInclude</code> haszn\u00e1lat\u00e1val lehet el\u00e9rni:</p> <pre><code>var products = ctx.Products\n    .Include(p =&gt; p.Category)\n    .Include(p =&gt; p.ProductOrders)\n        .ThenInclude(po =&gt; po.Order)\n    .ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.Name} ({p.Category.Name})\");\n    foreach (var po in p.ProductOrders)\n    {\n        Console.WriteLine($\"\\tRendel\u00e9s: {po.Order.OrderDate}\");\n    }\n}\n</code></pre> <p>Ha nem akarunk minden oszlopot lek\u00e9rdezni az \u00f6sszes \u00e9rintett t\u00e1bl\u00e1b\u00f3l, akkor a projekci\u00f3s (<code>select</code>) r\u00e9szt \u00fagy is meg\u00edrhatjuk, hogy csak a sz\u00fcks\u00e9ges adatokat k\u00e9rdezze le, ez az \u00fan. query result shaping.</p> <pre><code>var products = ctx.Products\n    .Select(p =&gt; new\n    {\n        ProductName = p.Name,\n        CategoryName = p.Category.Name,\n        OrderDates = p.ProductOrders\n            .Select(po =&gt; po.Order.OrderDate)\n            .ToList(),\n    })\n    .ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.ProductName} ({p.CategoryName})\");\n    foreach (var po in p.OrderDates)\n    {\n        Console.WriteLine($\"\\tRendel\u00e9s: {po}\");\n    }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy a gener\u00e1l\u00f3d\u00f3 <code>SELECT</code> projekci\u00f3s r\u00e9sze \u00edgy j\u00f3val r\u00f6videbb.</p> <p>Lazy Loading</p> <p>Tov\u00e1bbi ritk\u00e1bban alkalmazott / kor\u00e1bbi verzi\u00f3kban elterjedt m\u00f3dszerek: explicit loading, lazy loading.</p>"},{"location":"seminar/06-efcore/chapter6/#tobb-tobbes-kapcsolat-kozvetlen-navigalasa","title":"T\u00f6bb-t\u00f6bbes kapcsolat k\u00f6zvetlen navig\u00e1l\u00e1sa","text":"<p>Lehet\u0151s\u00e9g van t\u00f6bb-t\u00f6bbes kapcsolat navig\u00e1l\u00e1sakor a kapcsol\u00f3t\u00e1bla \u00e1tugr\u00e1s\u00e1ra. Ehhez vegy\u00fcnk fel ennek megfelel\u0151 property-ket a kapcsolat k\u00e9t oldal\u00e1n. Az <code>Order</code>-be:</p> <pre><code>public ICollection&lt;Product&gt; Products { get; } = new List&lt;Product&gt;();\n</code></pre> <p>A <code>Product</code>-ba:</p> <pre><code>public ICollection&lt;Order&gt; Orders { get; } = new List&lt;Order&gt;();\n</code></pre> <p>A kontext <code>OnModelCreating</code>-j\u00e9ben konfigur\u00e1lnunk kell a t\u00f6bb-t\u00f6bbes kapcsolatban r\u00e9szt vev\u0151 minden property-t, hogy az EF tudja, hogy ez az \u00f6sszes property ugyanazon kapcsolathoz tartozik:</p> <pre><code>modelBuilder.Entity&lt;Product&gt;()\n    .HasMany(p =&gt; p.Orders)\n    .WithMany(o =&gt; o.Products)\n    .UsingEntity&lt;OrderItem&gt;(\n        j =&gt; j\n            .HasOne(oi =&gt; oi.Order)\n            .WithMany(o =&gt; o.OrderItems)\n            .HasForeignKey(oi =&gt; oi.OrderId),\n        j =&gt; j\n            .HasOne(oi =&gt; oi.Product)\n            .WithMany(p =&gt; p.ProductOrders)\n            .HasForeignKey(oi =&gt; oi.ProductId),\n        j =&gt;\n        {\n            j.HasKey(oi =&gt; oi.Id);\n        });\n</code></pre> <p>Bonyolultnak t\u0171nik, de ink\u00e1bb csak hossz\u00fa, m\u00edg mind a 9 \u00e9rintett property szerep\u00e9t be\u00e1ll\u00edtjuk.</p> <p>Mindennek nem szabadna adatb\u00e1zis v\u00e1ltoz\u00e1st okoznia, hiszen nem lett t\u00f6bb kapcsolat, csak egy logikai \u00fatr\u00f6vid\u00edt\u00e9st vett\u00fcnk fel. Ellen\u0151rizz\u00fck le:</p> <pre><code>Add-Migration NxN\n</code></pre> <p>Ha mindent j\u00f3l csin\u00e1ltunk, ennek egy \u00fcres migr\u00e1ci\u00f3t kell gener\u00e1lnia. T\u00f6r\u00f6lj\u00fck is.</p> <pre><code>Remove-Migration\n</code></pre> <p>Ezut\u00e1n a kor\u00e1bbi lek\u00e9rdez\u00e9s\u00fcnkn\u00e9l elhagyhatjuk az <code>OrderItem</code> bet\u00f6lt\u00e9s\u00e9t.</p> <pre><code>var products = ctx.Products\n    .Include(p =&gt; p.Category)\n    .Include(p =&gt; p.Orders)\n    .ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.Name} ({p.Category.Name})\");\n    foreach (var po in p.ProductOrders)\n    {\n        Console.WriteLine($\"\\tRendel\u00e9s: {po.Order.OrderDate}\");\n    }\n}\n</code></pre> <p>Warning</p> <p>Ett\u0151l nem felt\u00e9tlen\u00fcl lesz egyszer\u0171bb vagy gyorsabb a gener\u00e1lt lek\u00e9rdez\u00e9s, csak a k\u00f3dunk lesz egyszer\u0171bb.</p>"},{"location":"seminar/06-efcore/chapter6/#modositas-find","title":"M\u00f3dos\u00edt\u00e1s, Find","text":"<p>N\u00e9zz\u00fcnk p\u00e9ld\u00e1t egyszer\u0171 m\u00f3dos\u00edt\u00e1sra.</p> <pre><code>var pFirst = ctx.Products.Find(1);\nif (pFirst != null)\n{\n    Console.WriteLine(ctx.Entry(pFirst).State);\n    pFirst.UnitPrice *= 2;\n    Console.WriteLine(ctx.Entry(pFirst).State);\n    ctx.SaveChanges();\n    Console.WriteLine(ctx.Entry(pFirst).State);\n}\n</code></pre> <p>Debuggerrel sorr\u00f3l sorra l\u00e9pkedve k\u00f6vess\u00fck v\u00e9gig az EF v\u00e1ltoz\u00e1sk\u00f6vet\u0151 m\u0171k\u00f6d\u00e9s\u00e9t. A lek\u00e9rdez\u00e9sek eredm\u00e9nye alap\u00e9rtelmezetten beker\u00fcl a v\u00e1ltoz\u00e1sk\u00f6vet\u0151be (change tracker). Ezut\u00e1n az oszt\u00e1lyon v\u00e9gezhet\u00fcnk adatv\u00e1ltoztat\u00f3 m\u0171veletet, mindig k\u00f6nnyen eld\u00f6nthet\u0151, hogy volt-e v\u00e1ltoz\u00e1s, ha \u00f6sszevetj\u00fck az aktu\u00e1lis \u00e1llapotot (current value) a beker\u00fcl\u00e9skorival (original value). Figyelj\u00fck meg, hogyan kezeli az EF a hozz\u00e1 tartoz\u00f3 objektumok \u00e1llapot\u00e1t.</p> <p>Change tracker Entry adatai</p> <p>Az <code>Entry</code> \u00e1ltal adott oszt\u00e1lyb\u00f3l megtudhatjuk az aktu\u00e1lis \u00e9s a beker\u00fcl\u00e9skori \u00e9rt\u00e9keket az <code>OriginalValues</code> \u00e9s <code>CurrentValues</code> propertyk \u00e1ltal, amit ak\u00e1r mi is felhaszn\u00e1lhatunk saj\u00e1t change tracking logik\u00e1hoz: pl.: audit napl\u00f3.</p> <p>Find</p> <p>A <code>Find</code> az els\u0151dleges kulcs alapj\u00e1n keres ki egy entit\u00e1st. Nem kell ismern\u00fcnk az els\u0151dleges kulcs property nev\u00e9t. Ha a v\u00e1ltoz\u00e1sk\u00f6vet\u0151be m\u00e1r kor\u00e1bban beker\u00fclt a keresett entit\u00e1s, akkor onnan kapjuk vissza, ilyenkor adatb\u00e1zishozz\u00e1f\u00e9r\u00e9s nem t\u00f6rt\u00e9nik.</p> <p>Mikor nem \u00e9l a Change Tracker?</p> <p>Ha <code>Select</code> oper\u00e1tort haszn\u00e1lunk akkor az EF nem tudja k\u00f6vetni a v\u00e1ltoz\u00e1sokat, hiszen nem entit\u00e1sokat kezel\u00fcnk t\u00f6bb\u00e9, hanem egy \u00faj t\u00edpus\u00fa objektumot adunk vissza, \u00edgy a SaveChanges nem fogja tudni, hogy mit kellene menteni.</p> <p>A Change Tracker entit\u00e1sok lek\u00e9rdez\u00e9sekor ki is lehet kapcsolni az <code>AsNoTracking()</code> met\u00f3dussal a Teljes <code>IQueryable</code> lek\u00e9rdez\u00e9sen.</p>"},{"location":"seminar/06-efcore/chapter6/#torles","title":"T\u00f6rl\u00e9s","text":"<p>T\u00f6r\u00f6lj\u00fck ki az adatb\u00e1zisb\u00f3l az egyik megrendel\u00e9st.</p> <pre><code>var orderToRemove = ctx.Orders\n    .OrderBy(o =&gt; o.OrderDate)\n    .First();\n\nctx.Orders.Remove(orderToRemove);\nctx.SaveChanges();\n</code></pre> <p>Figyelj\u00fck meg az adatb\u00e1zis adatai k\u00f6z\u00f6tt, hogy az <code>Order</code> t\u00f6rl\u00e9s\u00e9vel a kapcsol\u00f3d\u00f3 <code>OrderItem</code> bejegyz\u00e9sek is t\u00f6rl\u0151dtek, mivel alap\u00e9rtelmezetten a s\u00e9m\u00e1n be van kapcsolva a kaszk\u00e1d t\u00f6rl\u00e9s.</p> <p>Ez ebben az esetben indokolt is lenne, de sokszor nem szeretn\u00e9nk, ha a kapcsol\u00f3d\u00f3 rekordok is t\u00f6rl\u0151dn\u00e9nek. Ennek megakad\u00e1lyoz\u00e1s\u00e1ra vegy\u00fck fel explicit a konfigur\u00e1ci\u00f3ban az <code>Order-OrderItem</code> kapcsolatot \u00e9s kapcsoljuk ki rajta a kaszk\u00e1d t\u00f6rl\u00e9st az <code>OnModelCreating</code>-ben.</p> <pre><code>j =&gt; j\n    .HasOne(oi =&gt; oi.Order)\n    .WithMany(o =&gt; o.OrderItems)\n    .HasForeignKey(oi =&gt; oi.OrderId) // , t\u00f6r\u00f6lve\n    .OnDelete(DeleteBehavior.Restrict),\n</code></pre> <p>A t\u00f6r\u00f6lt <code>Order</code>-t \u00e9s a sz\u00fcks\u00e9ges kapcsol\u00f3 rekordokat vegy\u00fck fel migr\u00e1ci\u00f3 \u00e1ltal besz\u00fart adatk\u00e9nt. Az <code>OnModelCreating</code> v\u00e9g\u00e9re:</p> <pre><code>modelBuilder.Entity&lt;Order&gt;().HasData(\n     new Order { Id = 1, OrderDate = new DateTime(2019, 02, 01) }\n);\n\nmodelBuilder.Entity&lt;OrderItem&gt;().HasData(\n    new OrderItem { Id = 1, OrderId = 1, ProductId = 1 },\n    new OrderItem { Id = 2, OrderId = 1, ProductId = 2 }\n);\n</code></pre> <p>Ford\u00edt\u00e1s ut\u00e1n ne felejts\u00fck el migr\u00e1ci\u00f3val \u00e1tvezetni az adatb\u00e1zis s\u00e9m\u00e1j\u00e1ba is a v\u00e1ltoz\u00e1sokat, mivel a kaszk\u00e1d t\u00f6rl\u00e9s egy MSSQL funkci\u00f3 nem EF viselked\u00e9s.</p> <pre><code>Add-Migration ProductOrderRestrictDelete\nUpdate-Database 0\nUpdate-Database\n</code></pre> <p>Futtassuk \u00fajra a t\u00f6rl\u0151 k\u00f3dot - kiv\u00e9telt kapunk, mivel az <code>OrderItem</code> rekord nem t\u00f6rl\u0151d\u00f6tt kaszk\u00e1d m\u00f3don, \u00edgy az egy m\u00e1r nem l\u00e9tez\u0151 <code>Order</code>-re hivatkozik, viszont ez a k\u00fcls\u0151 kulcs k\u00e9nyszert megs\u00e9rti. Emiatt az eg\u00e9sz t\u00f6rl\u00e9si m\u0171velet meghi\u00fasul.</p> <p>Soft delete</p> <p>Adatkezel\u0151 alkalmaz\u00e1sokban az adatb\u00e1zisbeli t\u00f6rl\u00e9s (SQL <code>DELETE</code> utas\u00edt\u00e1s) helyett gyakran ink\u00e1bb logikai t\u00f6rl\u00e9st (soft delete) alkalmaznak. A logikai t\u00f6rl\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1val ezen gyakorlat keret\u00e9ben nem foglalkozunk, de egyszer\u0171en megval\u00f3s\u00edthat\u00f3 a SaveChanges fel\u00fcldefini\u00e1l\u00e1s\u00e1val, abban a change tracker figyel\u00e9s\u00e9vel \u00e9s lek\u00e9rdez\u00e9skor Global Query Filter haszn\u00e1lat\u00e1val.</p>"},{"location":"seminar/06-efcore/chapter6/#felsorolt-tipus-ertekkonvertalok","title":"Felsorolt t\u00edpus, \u00e9rt\u00e9kkonvert\u00e1l\u00f3k","text":"<p>Az EF alap\u00e9rtelmezetten k\u00e9pes a felsorolt t\u00edpusokat is lek\u00e9pezni. Hozzunk l\u00e9tre \u00faj felsorolt t\u00edpust a <code>Product</code> oszt\u00e1ly mell\u00e9 <code>ShipmentRegion</code> n\u00e9ven.</p> <pre><code>[Flags]\npublic enum ShipmentRegion\n{\n    EU = 1,\n    NorthAmerica = 2,\n    Asia = 4,\n    Australia = 8\n}\n</code></pre> <p>A <code>Flags</code> attrib\u00fatummal azt jelezz\u00fck, hogy szeretn\u00e9nk a bitm\u0171veleteket is alkalmazni a felsorolt \u00e9rt\u00e9k\u00e9re, \u00edgy egy <code>ShipmentRegion</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3 egyszerre t\u00f6bb \u00e9rt\u00e9ket is felvehet (pl.: 3-as \u00e9rt\u00e9k egyszerre tartalmazza az EU-t \u00e9s \u00c9szak-Amerik\u00e1t is).</p> <p>Vegy\u00fcnk fel a <code>Product</code> oszt\u00e1lyba egy \u00faj property-t az \u00faj felsorolt t\u00edpussal.</p> <pre><code>public ShipmentRegion? ShipmentRegion { get; set; }\n</code></pre> <p>M\u00f3dos\u00edtsuk \u00e9s b\u0151v\u00edts\u00fck a kezdeti <code>Product</code>-ok list\u00e1j\u00e1t sz\u00e1ll\u00edt\u00e1si inform\u00e1ci\u00f3kkal:</p> <pre><code>modelBuilder.Entity&lt;Product&gt;().HasData(\n    new Product()\n    {\n        Id = 1,\n        Name = \"S\u00f6r\",\n        UnitPrice = 50,\n        CategoryId = 1,\n        ShipmentRegion = ShipmentRegion.Asia\n    },\n    new Product() { Id = 2, Name = \"Bor\", UnitPrice = 550, CategoryId = 1 },\n    new Product() { Id = 3, Name = \"Tej\", UnitPrice = 260, CategoryId = 1 },\n    new Product()\n    {\n        Id = 4,\n        Name = \"Whiskey\",\n        UnitPrice = 960,\n        CategoryId = 1,\n        ShipmentRegion = ShipmentRegion.Australia\n    },\n    new Product()\n    {\n        Id = 5,\n        Name = \"Rum\"\n        UnitPrice = 960,\n        CategoryId = 1,\n        ShipmentRegion = ShipmentRegion.EU | ShipmentRegion.NorthAmerica\n    }\n);\n</code></pre> <p>Figyelj\u00fck meg a gener\u00e1lt migr\u00e1ci\u00f3ban, hogy milyen \u00fcgyesen lekezeli az EF a kor\u00e1bbi migr\u00e1ci\u00f3ban besz\u00fart elem (1-es <code>Id</code>) v\u00e1ltoz\u00e1s\u00e1t, m\u00f3dos\u00edt\u00f3 k\u00f3dot gener\u00e1l hozz\u00e1.</p> <p>V\u00e1ltozott a modell, friss\u00edts\u00fck az adatb\u00e1zist.</p> <pre><code>Add-Migration ProductShipmentRegion\nUpdate-Database\n</code></pre> <p>Figyelj\u00fck meg, hogy az \u00faj oszlop eg\u00e9sz sz\u00e1mk\u00e9nt t\u00e1rolja a felsorolt t\u00edpus \u00e9rt\u00e9keit. Ha ez nem tetszik nek\u00fcnk, mert p\u00e9ld\u00e1ul sz\u00f6vegesen szeretn\u00e9nk az adatb\u00e1zisban l\u00e1tni az \u00e9rt\u00e9keket, haszn\u00e1lhatjuk az \u00e9rt\u00e9kkonvert\u00e1l\u00f3kat (value converter), melyek az adatb\u00e1zis- \u00e9s az objektummodell k\u00f6z\u00f6tt k\u00e9pesek oda-vissza konvert\u00e1lni a lek\u00e9pezett elemek \u00e9rt\u00e9keit. Sz\u00e1mos be\u00e9p\u00edtett konvert\u00e1l\u00f3 van az EF-ben, melyek k\u00f6z\u00fcl a leggyakoribbakat automatikusan alkalmaz is az EF, el\u00e9g csak a c\u00e9lt\u00edpust megadnunk. Az felsorolt t\u00edpus - sz\u00f6veg \u00e1talak\u00edt\u00f3 is ilyen. Az <code>OnModelCreating</code>-be:</p> <pre><code>modelBuilder\n    .Entity&lt;Product&gt;()\n    .Property(e =&gt; e.ShipmentRegion)\n    .HasConversion&lt;string&gt;();\n</code></pre> <p>V\u00e1ltozott a modell, friss\u00edts\u00fck az adatb\u00e1zist.</p> <pre><code>Add-Migration ProductShipmentRegionAsString\nUpdate-Database\n</code></pre> <p>Migr\u00e1ci\u00f3k helyess\u00e9g\u00e9nek ellen\u0151rz\u00e9se</p> <p>Ahogy a migr\u00e1ci\u00f3 gener\u00e1l\u00e1sakor a figyelmeztet\u00e9s is \u00edrja, ellen\u0151rizz\u00fck a migr\u00e1ci\u00f3t, mert olyan oszlop t\u00edpus\u00e1t v\u00e1ltoztatjuk, amiben vannak m\u00e1r adatok, ez pedig k\u00fcl\u00f6n\u00f6s k\u00f6r\u00fcltekint\u00e9st ig\u00e9nyel. A gener\u00e1lt migr\u00e1ci\u00f3 nem is t\u00f6k\u00e9letes, a <code>Down</code> r\u00e9szben el\u0151bb \u00e1ll\u00edtja a migr\u00e1ci\u00f3 <code>nvarchar</code>-r\u00f3l <code>int</code>-re az oszlop t\u00edpus\u00e1t, minthogy a sz\u00f6veges \u00e9rt\u00e9ket sz\u00e1mra (pontosabban sz\u00e1mot tartalmaz\u00f3 sz\u00f6vegre) cser\u00e9ln\u00e9 - \u00edgy lefel\u00e9 migr\u00e1l\u00e1skor SQL hib\u00e1t kapunk. Az <code>UpdateData</code> h\u00edv\u00e1s <code>AlterColumn</code> h\u00edv\u00e1s el\u00e9 helyez\u00e9s\u00e9vel ezt jav\u00edthatjuk.</p> <p>Ellen\u0151rizz\u00fck a term\u00e9kek t\u00e1bl\u00e1j\u00e1ban, hogy siker\u00fclt-e az \u00e1talak\u00edt\u00e1s. Kipr\u00f3b\u00e1lhatjuk, hogy m\u0171k\u00f6dik-e a konverzi\u00f3 objektummodell szinten is. A legfels\u0151 szint\u0171 k\u00f3dban k\u00e9rj\u00fck el az \u00f6sszes term\u00e9ket:</p> <pre><code>var prods = ctx.Products.ToList();\n</code></pre> <p>Vizsg\u00e1ljuk meg a list\u00e1ban l\u00e9v\u0151 term\u00e9keket debuggerrel: l\u00e1that\u00f3, hogy a sz\u00e1ll\u00edt\u00e1si ter\u00fcletek megfelel\u0151 \u00e9rt\u00e9k\u0171ek.</p> <p>\u00c9rt\u00e9kkonvert\u00e1l\u00f3k</p> <p>Explicit is megadhatjuk az alkalmazand\u00f3 konvertert, ami leggyakrabban a sz\u00e1mos be\u00e9p\u00edtett konverter k\u00f6z\u00fcl ker\u00fcl ki. Saj\u00e1t konvertereket is \u00edrhatunk, ha a be\u00e9p\u00edtettek k\u00f6z\u00f6tt nem tal\u00e1lunk megfelel\u0151t.</p>"},{"location":"seminar/06-efcore/chapter6/#tranzakciok","title":"Tranzakci\u00f3k","text":"<p>Az EF az egyes <code>SaveChanges</code> h\u00edv\u00e1sokat egy tranzakci\u00f3ban futtatja (ha az adatb\u00e1zis provider t\u00e1mogatja azt). Viszont gyakran megesik az, hogy t\u00f6bb <code>SaveChanges</code> h\u00edv\u00e1st kellene egy tranzakci\u00f3ban kezeln\u00fcnk. Teh\u00e1t ha az egyik sikertelen\u00fcl fut le, akkor a t\u00f6bbit sem szabad \u00e9rv\u00e9nyre juttatni.</p> <p>N\u00e9zz\u00fcnk p\u00e9ld\u00e1t a tranzakci\u00f3kezel\u00e9sre. Sz\u00farjunk be t\u00f6bb term\u00e9ket az adatb\u00e1zisba t\u00f6bb <code>SaveChanges</code> h\u00edv\u00e1ssal.</p> <pre><code>int cid = ctx.Categories.First().Id;\ntry\n{\n    using (var transaction = ctx.Database.BeginTransaction())\n    {\n        ctx.Products.Add(new Product()\n        {\n            CategoryId = cid,\n            Name = \"Coca Cola\",\n        });\n        ctx.SaveChanges();\n\n        ctx.Products.Add(new Product()\n        {\n            CategoryId = cid,\n            Name = \"Pepsi\",\n        });\n        ctx.SaveChanges();\n\n        transaction.Commit();\n    }\n}\ncatch (Exception)\n{\n    // TODO logging\n}\n</code></pre> <p>A tranzakci\u00f3k kezdete-v\u00e9g\u00e9vel kapcsolatos esem\u00e9nyek csak a debug szint\u0171 napl\u00f3ban jelennek meg. \u00c1ll\u00edtsuk \u00e1t a napl\u00f3z\u00e1si szintet a <code>LogTo</code> f\u00fcggv\u00e9nyben:</p> <pre><code>.LogTo(Console.WriteLine, LogLevel.Debug); // LogLevel m\u00f3dos\u00edtva\n</code></pre> <p>A tranzakci\u00f3n <code>Commit</code>-ot h\u00edvunk, ha sikeresen lefutott mindegyik <code>SaveChanges</code>, ha valamelyik hib\u00e1ra futott, akkor a using blokkb\u00f3l val\u00f3 kil\u00e9p\u00e9sig nem fog <code>Commit</code> h\u00edv\u00f3dni. Ha b\u00e1rmilyen ok miatt a <code>Commit</code> nem h\u00edv\u00f3dik meg, legk\u00e9s\u0151bb a using blokk v\u00e9ge <code>Rollback</code>-kel lez\u00e1rja a tranzakci\u00f3t.</p> <p>Pr\u00f3b\u00e1ljuk ki! Ezesetben helyesen fut le a besz\u00far\u00e1sunk. Figyelj\u00fck meg a konzolon a tranzakci\u00f3kezel\u00e9ssel kapcsolatos \u00fczeneteket.</p> <p>Tesztelj\u00fck a hib\u00e1s \u00e1gat is az\u00e1ltal, hogy a m\u00e1sodik term\u00e9ket egy nem l\u00e9tez\u0151 kateg\u00f3ri\u00e1ba pr\u00f3b\u00e1ljuk meg besz\u00farni.</p> <pre><code>using (var transaction = ctx.Database.BeginTransaction())\n{\n    ctx.Products.Add(new Product()\n    {\n        Name = \"Cider\", // \u00faj n\u00e9v\n        CategoryId = cid,\n    });\n    ctx.SaveChanges();\n    ctx.Products.Add(new Product()\n    {\n        Name = \"K\u0151m\u0171ves Actimel\", //\u00faj n\u00e9v\n        CategoryId = 100, //nem l\u00e9tez\u0151 CategoryId\n    });\n    ctx.SaveChanges();\n    transaction.Commit();\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy ilyenkor nem ker\u00fcl besz\u00far\u00e1sra az els\u0151 term\u00e9k sem. \u00dagyszint\u00e9n figyelj\u00fck meg a konzolon a tranzakci\u00f3kezel\u00e9ssel kapcsolatos \u00fczeneteket.</p>"},{"location":"seminar/07-restapi/chapter7/","title":"ASP.NET Core webszolg\u00e1ltat\u00e1sok I.-II.","text":""},{"location":"seminar/07-restapi/chapter7/#kiindulo-projektek-beuzemelese","title":"Kiindul\u00f3 projektek be\u00fczemel\u00e9se","text":"<p>Kl\u00f3nozzuk le a publikus kiindul\u00f3 projektet a GitHub-r\u00f3l az al\u00e1bbi paranccsal:</p> <pre><code>git clone https://github.com/bmeviauav23/WebApiLab-kiindulo.git\n</code></pre> <p>A kiindul\u00f3 solution k\u00e9t .NET 8 oszt\u00e1lyk\u00f6nyvt\u00e1rat foglal mag\u00e1ba, melyek egy N-r\u00e9teg\u0171 architekt\u00fara egy-egy r\u00e9teg\u00e9t val\u00f3s\u00edtj\u00e1k meg:</p> <ul> <li>WebApiLab.Dal: l\u00e9nyeg\u00e9ben az Entity Framework gyakorlatok anyag\u00e1t tartalmazza, ez az adatel\u00e9r\u00e9si r\u00e9teg\u00fcnk.<ul> <li>entit\u00e1sdefin\u00edci\u00f3k</li> <li>kontext, modellkonfigur\u00e1ci\u00f3val, kezdeti adatokkal</li> <li>connection string kezel\u00e9s \u00e9s SQL napl\u00f3z\u00e1s a kor\u00e1bbi gyakorlatok alapj\u00e1n</li> <li>migr\u00e1ci\u00f3 (m\u00e9g) nincs</li> </ul> </li> <li>WebApiLab.Bll: ezt sz\u00e1njuk az \u00fczleti logikai r\u00e9tegnek. F\u0151 feladata, hogy a DAL-ra \u00e9p\u00edtve v\u00e9grehajtsa az <code>Interfaces</code> mapp\u00e1ban defini\u00e1lt m\u0171veleteket.<ul> <li>Interfaces - ez a BLL r\u00e9teg specifik\u00e1ci\u00f3ja</li> <li>Services - ide ker\u00fclnek majd az \u00fczleti logik\u00e1t, ill. az interf\u00e9szeket megval\u00f3s\u00edt\u00f3 oszt\u00e1ly(ok)</li> <li>Dtos - csak k\u00e9s\u0151bb lesz szerep\u00fck, egyel\u0151re nincsenek haszn\u00e1lva</li> <li>Exceptions - saj\u00e1t kiv\u00e9tel oszt\u00e1ly, egyel\u0151re nincs haszn\u00e1lva</li> </ul> </li> </ul> <p>Adjunk hozz\u00e1 a solution-h\u00f6z egy \u00faj C# nyelv\u0171 web API projektet (ASP.NET Core Web API, nem pedig Web App), a neve legyen <code>WebApiLab.Api</code>.</p> <p>A k\u00f6vetkez\u0151 dial\u00f3gusablakban v\u00e1lasszuk ki a .NET 8 opci\u00f3t. Az extr\u00e1k k\u00f6z\u00fcl ne k\u00e9rj\u00fck ezeket: HTTPS, Docker, authentik\u00e1ci\u00f3. Viszont hagyjuk bepip\u00e1lva a Controller \u00e9s az OpenAPI t\u00e1mogat\u00e1st. A gener\u00e1lt projektb\u0151l t\u00f6r\u00f6lhetj\u00fck a minta API f\u00e1jljait, azaz a <code>Weather</code> kezdet\u0171 f\u00e1jlokat a projekt gy\u00f6ker\u00e9b\u0151l \u00e9s a <code>Controllers</code> mapp\u00e1b\u00f3l.</p> <p>Adjuk hozz\u00e1 f\u00fcgg\u0151s\u00e9gk\u00e9nt:</p> <ul> <li>a BLL projektet (menu:projekten jobbklikk[Dependencies &gt; Add Project Reference\u2026])</li> <li>a Microsoft.EntityFrameworkCore.Tools NuGet csomagot. V\u00e1lasszunk olyan verzi\u00f3t, ami egyezik a DAL projekt Entity Framework Core f\u00fcgg\u0151s\u00e9g\u00e9nek verzi\u00f3j\u00e1val.</li> </ul> <p>Warning</p> <p>Olyan csomagokn\u00e1l, ahol a verzi\u00f3sz\u00e1moz\u00e1s k\u00f6veti az alap keretrendszer verzi\u00f3sz\u00e1moz\u00e1s\u00e1t, t\u00f6rekedj\u00fcnk arra, hogy a csomagok verzi\u00f3i konzisztensek legyenek egym\u00e1ssal \u00e9s a keretrendszer verzi\u00f3j\u00e1val is - akkor is, ha egy\u00e9bk\u00e9nt a f\u00fcgg\u0151s\u00e9gi szab\u00e1lyok engedn\u00e9k a verzi\u00f3k kever\u00e9s\u00e9t. Ha a projekt\u00fcnk p\u00e9ld\u00e1ul .NET 8-os keretrendszert haszn\u00e1l, akkor az Entity Framework Core \u00e9s egy\u00e9b extra ASP.NET Core csomagok k\u00f6z\u00fcl is olyan verzi\u00f3t v\u00e1lasszunk, ahol legal\u00e1bb a f\u0151verzi\u00f3 egyezik, teh\u00e1t valamilyen 8.x verzi\u00f3t. Ez nem azt jelenti, hogy az inkonzisztens verzi\u00f3k mindig hib\u00e1t eredm\u00e9nyeznek, ink\u00e1bb a projekt \u00e1ltal\u00e1ban stabilabb, ha a f\u0151verzi\u00f3k k\u00f6z\u00f6tti v\u00e1lt\u00e1st egyszerre, k\u00fcl\u00f6n migr\u00e1ci\u00f3s folyamat (p\u00e9lda) keret\u00e9ben v\u00e9gezz\u00fck.</p>"},{"location":"seminar/07-restapi/chapter7/#az-ef-bekotese-az-aspnet-core-di-naplozo-konfiguralo-rendszereibe","title":"Az EF bek\u00f6t\u00e9se az ASP.NET Core DI, napl\u00f3z\u00f3, konfigur\u00e1l\u00f3 rendszereibe","text":"<p>A kontext konfigur\u00e1l\u00e1sa az EF gyakorlat sor\u00e1n - mivel ott egy sima konzol alkalmaz\u00e1st \u00edrtunk - a kontext <code>OnConfiguring</code> f\u00fcggv\u00e9ny\u00e9ben t\u00f6rt\u00e9nt. Mivel az ASP.NET Core projekt be\u00e9p\u00edtetten DI kont\u00e9nert is ad a sz\u00e1munkra, \u00e9rdemes a kontextet a DI rendszerbe regisztr\u00e1lni, hogy a projekten bel\u00fcl a modulok/oszt\u00e1lyok f\u00fcgg\u0151s\u00e9gk\u00e9nt tudj\u00e1k haszn\u00e1lni. A regisztr\u00e1l\u00e1s a legfels\u0151 szint\u0171 k\u00f3dban t\u00f6rt\u00e9nik (l\u00e1sd ASP.NET Core bevezet\u0151 gyakorlatot).</p> <p>A kontext regisztr\u00e1l\u00e1sa a legfels\u0151 szint\u0171 k\u00f3dban a DI kont\u00e9nerbe:</p> <pre><code>builder.Services.AddDbContext&lt;AppDbContext&gt;(o =&gt;\n    o.UseSqlServer(builder.Configuration.GetConnectionString(\"DefaultConnection\")));\n</code></pre> <p>Az EF napl\u00f3z\u00e1st az ASP.NET Core napl\u00f3z\u00f3 rendszere v\u00e9gzi, amit a kiindul\u00f3 builder m\u00e1r inicializ\u00e1l, \u00edgy ezzel kapcsolatban nincs teend\u0151nk. Viszont egy \u00faj kontext konstruktorra lesz sz\u00fcks\u00e9g\u00fcnk, ami <code>DbContextOptions&lt;AppDbContext&gt;</code>-et v\u00e1r.</p> <p>A kontext <code>OnConfiguring</code>-j\u00e1ra pedig nincs sz\u00fcks\u00e9g, \u00fagyhogy t\u00f6r\u00f6lj\u00fck ki, hely\u00e9re tegy\u00fck az \u00faj konstruktort:</p> <pre><code>public AppDbContext(DbContextOptions&lt;AppDbContext&gt; options)\n    : base(options)\n{\n}\n</code></pre> <p>Az Entity Framework gyakorlat alapj\u00e1n hozzunk l\u00e9tre egy \u00faj LocalDB adatb\u00e1zist egy v\u00e1lasztott n\u00e9vvel, pl. neptun k\u00f3d, northwind, stb. Az SQL Server Object Explorer-b\u0151l a connection string-et lopjuk el. (menu:nyissuk le az adatb\u00e1ziskapcsolatot[jobbklikk az adatb\u00e1zison &gt; Properties &gt; a Properties ablakb\u00f3l a Connection String \u00e9rt\u00e9ke]).</p> <p>Az appsettings.Development.json-ba vegy\u00fck fel a connection string-et \u00e9s a gener\u00e1lt SQL megfigyel\u00e9s\u00e9hez a Microsoft kateg\u00f3ri\u00e1j\u00fa napl\u00f3k minimum szintj\u00e9t cs\u00f6kkents\u00fck Information-re.</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Information\",\n    }\n  }, //vessz\u0151 beker\u00fclt\n  \"ConnectionStrings\": {\n     \"DefaultConnection\": \"&lt;connection string&gt;\"\n  }\n}\n</code></pre> <p>Escapelt karakterek</p> <p>Kukac (<code>@</code>) ilyenkor nem kell a connection string el\u00e9, mert ez JSON.</p> <p>A connection string k\u00fcl\u00f6nleges karaktereit a beilleszt\u00e9s ut\u00e1n a VS alapesetben automatikusan escape-eli. Ha az automatikus escape-el\u00e9s m\u00e9gsem t\u00f6rt\u00e9nik meg, manu\u00e1lisan kell ezt megtenn\u00fcnk, k\u00fcl\u00f6nben A network-related or instance-specific error occurred while establishing a connection to SQL Server hib\u00e1t kaphatunk.</p> <p>Az adatb\u00e1ziskapcsolatot az\u00e9rt kellhet lenyitni, hogy az SQL Server Object Explorer csatlakozzon is az \u00faj adatb\u00e1zishoz, ezut\u00e1n tudjuk megszerezni a connection stringet.</p>"},{"location":"seminar/07-restapi/chapter7/#adatbazis-inicializalasa-code-first-migracioval","title":"Adatb\u00e1zis inicializ\u00e1l\u00e1sa Code-First migr\u00e1ci\u00f3val","text":"<p>Ford\u00edtsuk a teljes solution-t, \u00e1ll\u00edtsuk be ind\u00edtand\u00f3 (startup) projektnek az \u00faj Web API projektet (menu:jobbklikk a projekten[Set as Startup Project]). A Package Manager Console-t nyissuk meg, \u00e9s \u00e1ll\u00edtsuk be Default Project-k\u00e9nt a DAL projektet.</p> <p>.NET 8-ban a migr\u00e1ci\u00f3k csak akkor m\u0171k\u00f6dnek rendesen, ha az API projekten kikapcsoljuk az InvariantGlobalization be\u00e1ll\u00edt\u00e1st. Ezt a WebApiLab.Api.csproj f\u00e1jlban tehetj\u00fck meg:</p> <pre><code>&lt;InvariantGlobalization&gt;false&lt;/InvariantGlobalization&gt;\n</code></pre> <p>K\u00e9sz\u00edttess\u00fck el a migr\u00e1ci\u00f3t \u00e9s futtassuk is le:</p> <pre><code>Add-Migration Init\nUpdate-Database\n</code></pre> <p>Projektek a migr\u00e1ci\u00f3hoz</p> <p>Fontos, hogy a fenti parancs k\u00e9t projektet ismerjen: azt, amelyikben a kontext van, ill. a kontextet haszn\u00e1l\u00f3 futtathat\u00f3 projektet. A VS Package Manager Console-j\u00e1ban futtatva alap\u00e9rtelmez\u00e9sben az el\u0151bbit a Default Project \u00e9rt\u00e9ke adja meg, ut\u00f3bbit az ind\u00edtand\u00f3 projekt. Tov\u00e1bb\u00e1 ezeket a projekteket meg lehet adni param\u00e9terk\u00e9nt is.</p> <p>Migr\u00e1ci\u00f3 sor\u00e1n lefut a Program.cs is?</p> <p>Igen, itt mutatkozik meg, hogy a migr\u00e1ci\u00f3 l\u00e9nyeg\u00e9ben egy teljes alkalmaz\u00e1sind\u00edt\u00e1st jelent a <code>Program</code> oszt\u00e1lyon kereszt\u00fcl: inicializ\u00e1l\u00f3dik a DI kont\u00e9ner, a konfigur\u00e1ci\u00f3s objektum stb.</p> <p>Ellen\u0151rizz\u00fck az SQL Server Object Explorer-ben, hogy rendben lefutott-e a migr\u00e1ci\u00f3, l\u00e9trej\u00f6ttek-e az adatb\u00e1zis objektumok, felt\u00f6lt\u0151dtek-e a t\u00e1bl\u00e1k.</p>"},{"location":"seminar/07-restapi/chapter7/#ef-entitasok-hasznalata-az-api-feluleten","title":"EF entit\u00e1sok haszn\u00e1lata az API fel\u00fcleten","text":"<p>B\u00e1r architekt\u00fara szempontb\u00f3l nem a legszebb, a BLL r\u00e9teget gyakorlatilag mell\u0151zve k\u00f6zvetlen\u00fcl is haszn\u00e1lhatjuk az EF entit\u00e1sokat a kontrollerek megval\u00f3s\u00edt\u00e1s\u00e1n\u00e1l. Ehhez haszn\u00e1lhatjuk a Visual Studio Entity Framework-\u00f6s Controller sablonjait, amit most csak az\u00e9rt haszn\u00e1lunk, hogy gyorsan legyen egy m\u0171k\u00f6d\u0151 API fel\u00fclet\u00fcnk.</p> <p>Adjunk hozz\u00e1 egy \u00faj Controllert a Controllers mapp\u00e1ba (menu:Add[Controller &gt; bal f\u00e1ban Common &gt; API &gt; jobb oldalon API Controller with read/write actions]) <code>EFProductController</code> n\u00e9ven.</p> <p></p> <p>V\u00e1lasszuk ki az <code>AppDbContext</code>-t, \u00e9s a <code>Product</code> entit\u00e1st. Az \u00faj kontrollerben m\u00e1r l\u00e1thatjuk is a scaffoldolt CRUD m\u0171veleteket.</p> <p></p> <p>n\u00e9vterek</p> <p>Figyelj\u00fcnk r\u00e1, hogy ne a <code>Dtos</code> n\u00e9vt\u00e9rb\u0151l adjuk meg a DTO t\u00edpust a t\u00e9nyleges entit\u00e1st\u00edpus helyett.</p> <p>Gener\u00e1l\u00e1s hib\u00e1ra fut</p> <p>A gener\u00e1l\u00e1s sor\u00e1n Unable to create an object of type <code>AppDbContext</code>. hib\u00e1t kaphatunk. A hiba a k\u00f3dgener\u00e1l\u00f3 eszk\u00f6zben keresend\u0151, a kapcsol\u00f3d\u00f3 GitHub issue-ban tal\u00e1lunk egy lehets\u00e9ges megold\u00e1st is a probl\u00e9m\u00e1ra, ami el\u0151 van k\u00e9sz\u00edtve a kiindul\u00f3 projektben is.</p> <p>A legener\u00e1l\u00f3d\u00f3 kontroller m\u00e1r haszn\u00e1lhat\u00f3 is. \u00c1ll\u00edtsuk \u00e1t a z\u00f6ld ny\u00edl mellett az ind\u00edt\u00e1si konfigur\u00e1ci\u00f3t a projektnevesre, hogy ne IIS Express induljon \u00e9s \u00edgy l\u00e1ssuk a konzolon a napl\u00f3t. Ind\u00edtsuk a projektet \u00e9s pr\u00f3b\u00e1ljuk p\u00e9ld\u00e1ul lek\u00e9rni az \u00f6sszes term\u00e9ket az api/efproduct c\u00edmr\u0151l vagy a Swagger fel\u00fcletr\u0151l.</p> <p></p> <p>B\u00f6ng\u00e9sz\u0151 v\u00e1laszt\u00e1sa debugol\u00e1shoz</p> <p>\u00c9rdemes a z\u00f6ld ny\u00edl melletti leny\u00edl\u00f3 men\u00fcben olyan b\u00f6ng\u00e9sz\u0151t megadni (Chrome, Firefox), ami \u00e9rtelmes form\u00e1ban meg tudja jelen\u00edteni a nyers JSON adatokat, ha nem Swagger fel\u00fcletr\u0151l tesztel\u00fcnk.</p> <p>Alap\u00e9rtelmezett URL \u00fatvonal</p> <p>Az alap\u00e9rtelmez\u00e9sben megnyitand\u00f3 URL \u00fatvonalat a projekt tulajdons\u00e1gok k\u00f6z\u00f6tt adhatjuk meg: menu:z\u00f6ld ny\u00edl melletti leg\u00f6rd\u00fcl\u0151 men\u00fc[\\&lt;Projektn\u00e9v&gt; Debug Properties]. Ide egy a gy\u00f6k\u00e9rc\u00edmhez k\u00e9pesti relat\u00edv \u00fatvonalr\u00e9szt kell be\u00edrni. (pl. api/efproduct)</p> <p>Figyelj\u00fck meg, hogy a controller a konstruktorban ig\u00e9nyli meg a DI-t\u00f3l az EF kontextet, amit a szok\u00e1sos m\u00f3don oszt\u00e1lyv\u00e1ltoz\u00f3ban t\u00e1rol el.</p>"},{"location":"seminar/07-restapi/chapter7/#koztes-reteg-alkalmazasa","title":"K\u00f6ztes r\u00e9teg alkalmaz\u00e1sa","text":"<p>A r\u00e9tegezett architekt\u00fara elveit k\u00f6vetve gyakori elj\u00e1r\u00e1s, hogy a kontroller nem \u00e9ri el k\u00f6zvetlen\u00fcl az EF kontextet, hanem csak egy extra r\u00e9tegen kereszt\u00fcl. A kontroller projekt \u00edgy f\u00fcggetlen\u00edthet\u0151 az EF modellt\u0151l.</p> <p>Ehhez a megold\u00e1shoz k\u00e9sz\u00edts\u00fcnk k\u00fcl\u00f6n kontroller v\u00e1ltozatot. A Controllers mapp\u00e1ba hozzunk l\u00e9tre egy kontrollert (menu:Add[Controller &gt; bal f\u00e1ban Common &gt; API &gt; jobb oldalon API Controller with read/write actions]) <code>ProductsController</code> n\u00e9ven.</p> <p>A BLL projekt Services mapp\u00e1j\u00e1ba hozzunk l\u00e9tre egy \u00faj oszt\u00e1lyt <code>ProductService</code> n\u00e9ven. Az \u00faj oszt\u00e1ly kontroller sz\u00e1m\u00e1ra ny\u00fajtand\u00f3 funkci\u00f3it az <code>IProductService</code> adja meg.</p> <p>Implement\u00e1ljuk ezt az interf\u00e9szt, a kiindul\u00f3 implement\u00e1ci\u00f3t gener\u00e1ltassuk a Visual Studio-val. Konstruktorban v\u00e1rja a f\u00fcgg\u0151s\u00e9gk\u00e9nt a kontextet. A kontext seg\u00edts\u00e9g\u00e9vel implement\u00e1ljuk norm\u00e1lisan a <code>GetProducts</code> f\u00fcggv\u00e9nyt. Eager Loading* haszn\u00e1lat\u00e1val az egyes term\u00e9kekhez a kapcsol\u00f3d\u00f3 kateg\u00f3ri\u00e1t \u00e9s megrendel\u00e9seket is adjuk vissza.</p> <pre><code>public class ProductService : IProductService\n{\n    private readonly AppDbContext _context;\n\n    public ProductService(AppDbContext context)\n    {\n        _context = context;\n    }\n\n    public List&lt;Product&gt; GetProducts()\n    {\n        var products = _context.Products\n            .Include(p =&gt; p.Category)\n            .Include(p =&gt; p.ProductOrders)\n                .ThenInclude(po =&gt; po.Order)\n            .ToList();\n\n        return products;\n    }\n    /*T\u00f6bbi f\u00fcggv\u00e9ny gener\u00e1lt implement\u00e1ci\u00f3ja*/\n}\n</code></pre> <p>Injekt\u00e1ljunk <code>IProductService</code>-t a <code>ProductsController</code>-be.</p> <pre><code>private readonly IProductService _productService;\n\npublic ProductsController(IProductService productService)\n{\n    _productService = productService;\n}\n</code></pre> <p>Adjuk meg a DI alrendszernek, hogy hogyan kell egy <code>IProductService</code> t\u00edpus\u00fa f\u00fcgg\u0151s\u00e9get l\u00e9trehozni. A legfels\u0151 szint\u0171 k\u00f3dba:</p> <pre><code>builder.Services.AddTransient&lt;IProductService, ProductService&gt;();\n</code></pre> <p>A f\u00fcgg\u0151s\u00e9ginjekt\u00e1l\u00e1s \u00fagy m\u0171k\u00f6dik, hogy a kontrollereket is a k\u00f6zponti DI komponens p\u00e9ld\u00e1nyos\u00edtja, \u00e9s ilyenkor megvizsg\u00e1lja a konstruktor param\u00e9tereket. Ha a kont\u00e9nerben tal\u00e1l alkalmas beregisztr\u00e1lt oszt\u00e1lyt, akkor azt l\u00e9trehozza \u00e9s \u00e1tadja a konstruktornak. Ezt h\u00edvjuk konstruktor injekt\u00e1l\u00e1snak. Ha a l\u00e9trehozand\u00f3 f\u00fcgg\u0151s\u00e9gnek is vannak konstruktor param\u00e9terei, akkor azokat is megpr\u00f3b\u00e1lja feloldani, \u00edgy rekurz\u00edvan a teljes f\u00fcgg\u0151s\u00e9gi objektum hierarchi\u00e1t le tudja kezelni (ha abban nincs ir\u00e1ny\u00edtott k\u00f6r). Ezt h\u00edvjuk autowiring-nek.</p> <p>A regisztr\u00e1ci\u00f3 sor\u00e1n t\u00f6bb lehet\u0151s\u00e9g\u00fcnk is van. Egyr\u00e9szt nem k\u00f6telez\u0151 interf\u00e9szt megadni egy oszt\u00e1ly beregisztr\u00e1l\u00e1s\u00e1hoz, az oszt\u00e1lyt \u00f6nmag\u00e1ban is be lehet regisztr\u00e1lni, ilyenkor a konstruktorban is oszt\u00e1lyk\u00e9nt kell elk\u00e9rni a f\u00fcgg\u0151s\u00e9geket.</p> <p>H\u00e1romf\u00e9le p\u00e9ld\u00e1nyos\u00edt\u00e1si strat\u00e9gi\u00e1val regisztr\u00e1lhatjuk be az oszt\u00e1lyainkat:</p> <ul> <li>Transient: minden egyes injekt\u00e1l\u00e1s sor\u00e1n \u00faj p\u00e9ld\u00e1ny j\u00f6n l\u00e9tre</li> <li>Scoped: HTTP k\u00e9r\u00e9senk\u00e9nt egy p\u00e9ld\u00e1ny ker\u00fcl l\u00e9trehoz\u00e1sra \u00e9s a k\u00e9r\u00e9sen bel\u00fcl mindenkinek ez lesz injekt\u00e1lva</li> <li>Singleton: mindenkinek ugyanaz az egy p\u00e9ld\u00e1ny ker\u00fcl \u00e1tad\u00e1sra k\u00e9r\u00e9st\u0151l f\u00fcggetlen\u00fcl</li> </ul> <p>\u00cdrjunk \u00faj <code>Get()</code> v\u00e1ltozatot az eredeti helyett a <code>ProductsController</code>-be az <code>IProductService</code> f\u00fcgg\u0151s\u00e9get felhaszn\u00e1lva:</p> <pre><code>[HttpGet]\npublic IEnumerable&lt;Product&gt; Get()\n{\n    return _productService.GetProducts();\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki (<code>api/products</code>).</p> <p>Hib\u00e1t kapunk, mert a <code>ProductService</code> lek\u00e9rdez\u0151 f\u00fcggv\u00e9nye eager loading-gal (<code>Include</code>) navig\u00e1ci\u00f3s property-ket is kit\u00f6lt, \u00edgy k\u00f6nnyen hivatkoz\u00e1si k\u00f6r j\u00f6n l\u00e9tre, amit a JSON soros\u00edt\u00f3 alap\u00e9rtelmez\u00e9sben kiv\u00e9tellel jutalmaz. A soros\u00edt\u00e1st a keretrendszer v\u00e9gzi, a kontrollerf\u00fcggv\u00e9ny visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9t soros\u00edtja a HTTP tartalomegyeztet\u00e9si szab\u00e1lyok szerint. B\u00f6ng\u00e9sz\u0151 kliens eset\u00e9n alapesetben a JSON form\u00e1tum lesz a befut\u00f3. Persze a soros\u00edt\u00e1s enn\u00e9l k\u00f6zvetlenebb\u00fcl is konfigur\u00e1lhat\u00f3, ha sz\u00fcks\u00e9ges.</p> <p>A kontrollerek \u00e1ltal haszn\u00e1lt JSON soros\u00edt\u00f3t konfigur\u00e1lhatjuk a legfels\u0151 szint\u0171 k\u00f3dban, p\u00e9ld\u00e1ul be\u00e1ll\u00edthatjuk, hogy ha egy objektumot m\u00e1r kor\u00e1bban soros\u00edtott, akkor csak hivatkozzon r\u00e1 \u00e9s ne soros\u00edtsa \u00fajra.</p> <pre><code>builder.Services.AddControllers() //; t\u00f6r\u00f6lve\n    .AddJsonOptions(o =&gt; o.JsonSerializerOptions.ReferenceHandler = ReferenceHandler.Preserve);\n</code></pre> <p>\u00cdgy m\u00e1r siker\u00fclni fog a soros\u00edt\u00e1s, egy el\u00e9g furcsa JSON-t l\u00e1thatunk, ahol az els\u0151 elem egy nagyobb objektumgr\u00e1fot le\u00edr\u00f3 r\u00e9sz, a t\u00f6bbi elem pedig csak hivatkoz\u00e1s. Ennek a megold\u00e1snak a h\u00e1tr\u00e1nya, hogy a kliensoldali soros\u00edt\u00f3nak is t\u00e1mogatnia kell ezt a soros\u00edt\u00e1si logik\u00e1t, a JSON-on bel\u00fcli kereszthivatkoz\u00e1sok kezel\u00e9s\u00e9t. Emiatt kommentezz\u00fck is ki ezt a be\u00e1ll\u00edt\u00e1st, keress\u00fcnk m\u00e1s megold\u00e1st.</p>"},{"location":"seminar/07-restapi/chapter7/#dto-osztalyok","title":"DTO oszt\u00e1lyok","text":"<p>L\u00e1thattuk, hogy az entit\u00e1st\u00edpusok k\u00f6zvetlen soros\u00edt\u00e1sa gyakran neh\u00e9zs\u00e9gekbe \u00fctk\u00f6zik. A modell kifejezetten az EF sz\u00e1m\u00e1ra lett megalkotva, illetve hogy a lek\u00e9rdez\u0151 m\u0171veleteket min\u00e9l k\u00e9nyelmesebben v\u00e9gezhess\u00fck. A kliensoldal sz\u00e1m\u00e1ra \u00e9rdemes k\u00fcl\u00f6n modellt megalkotni, egy \u00fan. DTO (Data Transfer Object) modellt, ami a kliensoldal ig\u00e9nyeit veszi figyelembe: pontosan annyi adatot \u00e9s olyan szerkezetben tartalmaz, amire a kliensnek sz\u00fcks\u00e9ge van.</p> <p>A BLL projektben jelenleg egy nagyon egyszer\u0171 DTO modell tal\u00e1lhat\u00f3 a Dtos mapp\u00e1ban:</p> <ul> <li>rekord t\u00edpusok alkotj\u00e1k a modellt</li> <li>nincs benne minden navig\u00e1ci\u00f3s property, pl. <code>Category.Products</code></li> <li>nincs benne a kapcsol\u00f3t\u00e1bl\u00e1t reprezent\u00e1l\u00f3 entit\u00e1s</li> <li>a term\u00e9kb\u0151l k\u00f6zvetlen\u00fcl el\u00e9rhet\u0151k a megrendel\u00e9sek</li> </ul> <p>A k\u00fcl\u00f6nf\u00e9le modellek k\u00f6z\u00f6tti lek\u00e9pez\u00e9sn\u00e9l j\u00f3l j\u00f6nnek az \u00fan. object mapper-ek, melyek seg\u00edtenek elker\u00fclni a lek\u00e9pez\u00e9sn\u00e9l nagyon gyakori repetit\u00edv k\u00f3dokat, mint amilyen az <code>x.Prop = y.Prop</code> jelleg\u0171 property\u00e9rt\u00e9k-m\u00e1solgat\u00e1s.</p> <p>Adjuk hozz\u00e1 az API \u00e9s a BLL projekthez az AutoMapper csomagot.</p> <p>Tranzit\u00edv nuget referenci\u00e1k</p> <p>Alap esetben el\u00e9g lenne csak a BLL projekthez felvenni a nuget csomagot, mivel az API projekt hivatkozik a BLL-re, az az ott behivatkozott csomagokat is l\u00e1thatja (mint ahogy az EF-et is hivatkoztuk fentebbi r\u00e9tegekb\u0151l). Az AutoMapper-t viszont explicit be kell hivatkoznunk az API projektbe is, mert a BLL-ben behivatkozott, class library-val kompatibilis csomag nem tartalmazza az ASP.NET Core-hez sz\u00fcks\u00e9ges konfigur\u00e1ci\u00f3s f\u00fcggv\u00e9nyeket.</p> <p>A lek\u00e9pez\u00e9si konfigur\u00e1ci\u00f3kat profilokba szervezve adhatjuk meg. Adjunk hozz\u00e1 a BLL projekthez egy \u00faj oszt\u00e1lyt <code>WebApiProfile</code> n\u00e9ven a Dtos mapp\u00e1ba. Az AutoMapper konvenci\u00f3 alapon m\u0171k\u00f6dik, teh\u00e1t a DTO-entit\u00e1s p\u00e1rokon k\u00edv\u00fcl nem kell megadni p\u00e9ld\u00e1ul egyes\u00e9vel a property- vagy konstruktorparam\u00e9ter-lek\u00e9pez\u00e9seket, ha a nevek alapj\u00e1n a lek\u00e9pez\u00e9s kik\u00f6vetkeztethet\u0151. K\u00fcl\u00f6n konfigur\u00e1l\u00e1sra csak a nem-trivi\u00e1lis esetekben van sz\u00fcks\u00e9g.</p> <pre><code>using AutoMapper;\n\nnamespace WebApiLab.Bll.Dtos;\n\npublic class WebApiProfile : Profile\n{\n    public WebApiProfile()\n    {\n        CreateMap&lt;Dal.Entities.Product, Product&gt;().ReverseMap();\n        CreateMap&lt;Dal.Entities.Order, Order&gt;().ReverseMap();\n        CreateMap&lt;Dal.Entities.Category, Category&gt;().ReverseMap();\n    }\n}\n</code></pre> <p>A DI kont\u00e9nerhez adjuk hozz\u00e1 \u00e9s konfigur\u00e1ljuk a lek\u00e9pez\u00e9si szolg\u00e1ltat\u00e1st.</p> <pre><code>builder.Services.AddAutoMapper(typeof(WebApiProfile));\n</code></pre> <p>T\u00edpusparam\u00e9ter</p> <p>Az AutoMapper az <code>AddAutoMapper</code> param\u00e9terek\u00e9nt megadott t\u00edpust defini\u00e1l\u00f3 szerelv\u00e9nyben fogja a profilt keresni. A konkr\u00e9t t\u00edpusnak nincs m\u00e1s jelent\u0151s\u00e9ge, nem kell felt\u00e9tlen\u00fcl profilnak lenni.</p> <p>Injekt\u00e1\u00e9juk be a lek\u00e9pz\u0151t reprezent\u00e1l\u00f3 <code>IMapper</code> t\u00edpus\u00fa objektumot a <code>ProductService</code>-be.</p> <pre><code>private readonly AppDbContext _context;\nprivate readonly IMapper _mapper;\n\npublic ProductService(AppDbContext context, IMapper mapper)\n{\n    _context = context;\n    _mapper = mapper;\n}\n</code></pre> <p>A <code>ProductsController</code>-ben, az <code>IProductService</code>-ben \u00e9s a <code>ProductService</code>-ben az entit\u00e1sokra mutat\u00f3 n\u00e9vteret cser\u00e9lj\u00fck ki a DTO-kra mutat\u00f3ra:</p> <pre><code>//using WebApiLab.Dal.Entities;\nusing WebApiLab.Bll.Dtos;\n</code></pre> <p>\u00cdrjuk \u00e1t a lek\u00e9rdez\u00e9st a <code>ProductService</code>-ben a lek\u00e9pz\u0151t alkalmazva:</p> <pre><code>public List&lt;Product&gt; GetProducts()\n{\n    var products = _context.Products\n        .ProjectTo&lt;Product&gt;(_mapper.ConfigurationProvider)\n        .ToList();\n    return products;\n}\n</code></pre> <p>Hogy ne zavarjanak be a Swaggernek az <code>EFProductController</code>-ben haszn\u00e1lt entit\u00e1s oszt\u00e1lyok, t\u00f6r\u00f6lj\u00fck ki a Controllers mapp\u00e1b\u00f3l az <code>EFProductController</code>-t!</p> <p>Pr\u00f3b\u00e1ljuk ism\u00e9t megh\u00edvni b\u00f6ng\u00e9sz\u0151b\u0151l, figyelj\u00fck meg a napl\u00f3ban, hogy milyen SQL lek\u00e9rdez\u00e9s fut le.</p> <p>Modell r\u00e9tegek</p> <p>A t\u00f6bbr\u00e9teg\u0171 architekt\u00far\u00e1n\u00e1l elm\u00e9letben minden r\u00e9tegnek k\u00fcl\u00f6n objektummodellje kellene, hogy legyen DAL: EF entit\u00e1sok, BLL: domain objektumok, Kontroller: DTO-k, viszont ha a domain objektumok nem visznek plusz funkci\u00f3t a rendszerbe, akkor el szoktuk hagyni.</p> <p>A DTO lek\u00e9pez\u00e9st m\u00e1s r\u00e9tegben is v\u00e9gezhetn\u00e9nk. Egyes megk\u00f6zel\u00edt\u00e9sek szerint a kontroller r\u00e9teg feladata lenne, azonban, ha az EF lek\u00e9rdez\u00e9sekkel \u00f6sszevonva v\u00e9gezz\u00fck a lek\u00e9pez\u00e9st, akkor kiakn\u00e1zhatjuk a query result shaping el\u0151nyeit, azaz csak azt k\u00e9rdezz\u00fck le az adatb\u00e1zisb\u00f3l, amire a lek\u00e9pez\u00e9snek sz\u00fcks\u00e9ge van. Az AutoMapper <code>ProjectTo</code> f\u00fcggv\u00e9nye r\u00e1ad\u00e1sul mindezt el is int\u00e9zi helyett\u00fcnk a lek\u00e9pez\u00e9si konfigur\u00e1ci\u00f3 alapj\u00e1n.</p> <p>A <code>ProjectTo</code> met\u00f3dust felfoghatjuk a tov\u00e1bbiakban egy LINQ-s <code>Select()</code> oper\u00e1tornak, annyi k\u00fcl\u00f6nbs\u00e9ggel, hogy az AutoMapper gener\u00e1lja azt az <code>Expression</code>-t, ami alapj\u00e1n el\u0151\u00e1ll majd az eredm\u00e9ny.</p> <p>ProjectTo</p> <p>A <code>ProjectTo</code> speci\u00e1lisan <code>IQueryable</code>-en m\u0171k\u00f6dik. Ha csak sim\u00e1n mem\u00f3riabeli objektumok k\u00f6z\u00f6tt szeretn\u00e9nk lek\u00e9pezni, akkor az <code>IMapper</code> <code>Map&lt;&gt;</code> f\u00fcggv\u00e9ny\u00e9t h\u00edvjuk. A mem\u00f3riabeli lek\u00e9pez\u00e9snek h\u00e1tr\u00e1nya, hogy EF szinten gondoskodnunk kell r\u00f3la, hogy <code>Include</code> h\u00edv\u00e1sokkal a lek\u00e9pez\u00e9shez sz\u00fcks\u00e9ges kapcsol\u00f3d\u00f3 entit\u00e1sokat is lek\u00e9rdezz\u00fck. A <code>ProjectTo</code> ezt is elint\u00e9zi helyett\u00fcnk.</p>"},{"location":"seminar/07-restapi/chapter7/#bll-funkciok-implementacioja","title":"BLL funkci\u00f3k implement\u00e1ci\u00f3ja","text":""},{"location":"seminar/07-restapi/chapter7/#egy-elem-lekerdezese","title":"Egy elem lek\u00e9rdez\u00e9se","text":"<p>Val\u00f3s\u00edtsunk meg tov\u00e1bbi interf\u00e9sz \u00e1ltal el\u0151\u00edrt funkci\u00f3kat a <code>ProductService</code> oszt\u00e1lyban:</p> <pre><code>public Product GetProduct(int productId)\n{\n    return _context.Products\n        .ProjectTo&lt;Product&gt;(_mapper.ConfigurationProvider)\n        .SingleOrDefault(p =&gt; p.Id == productId)\n        ?? throw new EntityNotFoundException(\"Nem tal\u00e1lhat\u00f3 a term\u00e9k\", productId);\n}\n</code></pre> <p>Szint\u00e9n a <code>ProjectTo</code>-t haszn\u00e1lva, de most a <code>SingleOrDefault</code> LINQ oper\u00e1torral k\u00e9rdezz\u00fck le az egyetlen elemet, aminek az <code>Id</code> mez\u0151je egyezik a param\u00e9terben kapott <code>productId</code>-val. Ha nem tal\u00e1ljuk meg az elemet, akkor egy saj\u00e1t kiv\u00e9telt dobunk, ami majd a k\u00e9s\u0151bbiekben lekezel\u00fcnk.</p> <p>SingleOrDefault vagy FirstOrDefault</p> <p>Ha biztosak vagyunk benne, hogy csak egy elemet tal\u00e1lhatunk, akkor a <code>SingleOrDefault</code> haszn\u00e1lata javasolt, mert ha t\u00f6bb elemet tal\u00e1l, akkor kiv\u00e9telt dob. Ha t\u00f6bb elemet is v\u00e1rhat\u00f3 egy lek\u00e9rdez\u00e9s eredm\u00e9nyek\u00e9nt, de biztosak vagyunk benne a k\u00f6vetelm\u00e9nyeink alapj\u00e1n, hogy az els\u0151 elem az, amit keres\u00fcnk, akkor a <code>FirstOrDefault</code> haszn\u00e1lata javasolt.</p>"},{"location":"seminar/07-restapi/chapter7/#beszuras","title":"Besz\u00far\u00e1s","text":"<p>Ez hasonl\u00f3 az EF gyakorlaton l\u00e1tottakhoz, csak itt nem kell legy\u00e1rtanunk az \u00faj <code>Product</code> p\u00e9ld\u00e1nyt, param\u00e9terk\u00e9nt kapjuk \u00e9s mem\u00f3ri\u00e1ban lek\u00e9pezz\u00fck az enitit\u00e1sra. A <code>SaveChanges</code> h\u00edv\u00e1s ut\u00e1n a kulcs \u00e9rt\u00e9ke m\u00e1r ki lesz t\u00f6ltve (adatb\u00e1zis osztja ki a kulcsot).</p> <pre><code>public Product InsertProduct(Product newProduct)\n{\n    var efProduct = _mapper.Map&lt;Dal.Entities.Product&gt;(newProduct);\n    _context.Products.Add(efProduct);\n    _context.SaveChanges();\n    return GetProduct(efProduct.Id);\n}\n</code></pre>"},{"location":"seminar/07-restapi/chapter7/#modositas","title":"M\u00f3dos\u00edt\u00e1s","text":"<p>M\u00f3dos\u00edt\u00e1shoz lek\u00e9rdezz\u00fck az adott elemet, majd a <code>Map</code> f\u00fcggv\u00e9nnyel a DTO-b\u00f3l az entit\u00e1sba mappelj\u00fck az \u00faj adatokat. Ment\u00e9s ut\u00e1n pedig visszaadjuk a m\u00f3dos\u00edtott elemet.</p> <pre><code>public Product UpdateProduct(int productId, Product updatedProduct)\n{\n    var efProduct = _context.Products.SingleOrDefault(p =&gt; p.Id == productId)\n        ?? throw new EntityNotFoundException(\"Nem tal\u00e1lhat\u00f3 a term\u00e9k\", productId);\n    _mapper.Map(updatedProduct, efProduct);\n    _context.SaveChanges();\n    return GetProduct(efProduct.Id);\n}        \n</code></pre> <p>Alternat\u00edv m\u00f3dos\u00edt\u00e1s</p> <p>Alternat\u00edva, hogy a <code>Map</code> helyett a <code>Attach</code> f\u00fcggv\u00e9nyt haszn\u00e1ljuk, amivel az EF kontextusba visszat\u00f6ltj\u00fck az entit\u00e1st, majd a <code>Entry</code> f\u00fcggv\u00e9nnyel jel\u00f6lj\u00fck m\u00f3dos\u00edtottk\u00e9nt. Ilyenkor sp\u00f3rolunk egy lek\u00e9rdez\u00e9st, de a SaveChanges hib\u00e1val t\u00e9rhet vissza ha nem l\u00e9tez\u0151 elemet pr\u00f3b\u00e1lunk m\u00f3dos\u00edtani.</p>"},{"location":"seminar/07-restapi/chapter7/#torles","title":"T\u00f6rl\u00e9s","text":"<p>Hasonl\u00f3an az el\u0151z\u0151ekhez, csak itt a <code>Remove</code> f\u00fcggv\u00e9nyt h\u00edvjuk meg a kontextuson.</p> <pre><code>public void DeleteProduct(int productId)\n{\n    var efProduct = _context.Products.SingleOrDefault(p =&gt; p.Id == productId)\n        ?? throw new EntityNotFoundException(\"Nem tal\u00e1lhat\u00f3 a term\u00e9k\", productId);\n    _context.Products.Remove(efProduct);\n    _context.SaveChanges();\n}\n</code></pre> <p>T\u00f6rl\u00e9s lek\u00e9rdez\u00e9s n\u00e9lk\u00fcl</p> <p>Egy tr\u00fckkel elker\u00fclhetj\u00fck, hogy le kelljen k\u00e9rdezni a t\u00f6rlend\u0151 term\u00e9ket. Az azonos\u00edt\u00f3 alapj\u00e1n el\u0151\u00e1ll\u00edtunk mem\u00f3ri\u00e1ban egy p\u00e9ld\u00e1nyt a megfelel\u0151 kulccsal, majd <code>Remove</code> f\u00fcggv\u00e9nnyel hozz\u00e1adjuk a kontexthez. A <code>Remove</code> t\u00f6rlend\u0151nek jel\u00f6li a p\u00e9ld\u00e1nyt, de itt is hiba\u00e1gakra kell k\u00e9sz\u00fclni, ha nem l\u00e9tez\u0151 elemet pr\u00f3b\u00e1lunk t\u00f6r\u00f6lni.</p> <pre><code>public void DeleteProduct(int productId)\n{\n    _context.Products.Remove(new Dal.Entities.Product(null!) { Id = productId });\n    _context.SaveChanges();\n}\n</code></pre>"},{"location":"seminar/07-restapi/chapter7/#rest-konvenciok-alkalmazasa","title":"REST konvenci\u00f3k alkalmaz\u00e1sa","text":"<p>A REST megk\u00f6zel\u00edt\u00e9s nem csak \u00e1tviteli k\u00f6zegnek tekinti a HTTP-t, hanem a protokoll r\u00e9szeit felhaszn\u00e1lja, hogy kieg\u00e9sz\u00edt\u0151 inform\u00e1ci\u00f3kat vigyen \u00e1t. Emiatt el\u0151ny\u00f6s lenne, ha nagyobb ellen\u0151rz\u00e9s\u00fcnk lenne a HTTP v\u00e1lasz felett - szerencs\u00e9re az ASP.NET Core biztos\u00edtja ehhez a megfelel\u0151 API-kat.</p>"},{"location":"seminar/07-restapi/chapter7/#get-200-ok","title":"GET - 200 OK","text":"<p>Egyik legegyszer\u0171bb ilyen ir\u00e1nyelv, hogy a lek\u00e9rdez\u00e9sek eredm\u00e9nyek\u00e9nt, ha megtal\u00e1ltuk \u00e9s visszaadtuk a k\u00e9rt adatokat, akkor 200 (OK) HTTP v\u00e1laszk\u00f3dot adjunk.</p> <p>HTTP \u00e9s REST ir\u00e1nyelvek</p> <p>A HTTP k\u00e9r\u00e9st \u00e9rint\u0151 ir\u00e1nyelvekr\u0151l egy j\u00f3 \u00f6sszefoglal\u00f3 el\u00e9rhet\u0151 itt.</p> <p>Az eddig meg\u00edrt <code>Get()</code> f\u00fcggv\u00e9ny\u00fcnk most is 200 (OK)-ot ad, ezt le is ellen\u0151rizhetj\u00fck a b\u00f6ng\u00e9sz\u0151nk h\u00e1l\u00f3zati monitoroz\u00f3 eszk\u00f6z\u00e9ben.</p> <p>HTTP monitoroz\u00e1s</p> <p>A HTTP kommunik\u00e1ci\u00f3 megfigyel\u00e9s\u00e9re haszn\u00e1lhatjuk a b\u00f6ng\u00e9sz\u0151k be\u00e9p\u00edtett eszk\u00f6zeit, mint amilyen a Firefox Developer Tools, illetve Chrome DevTools. \u00c1ltal\u00e1ban az F12 billenty\u0171vel aktiv\u00e1lhat\u00f3k. Emellett, ha egy teljes\u00e9rt\u00e9k\u0171 HTTP kliensre van sz\u00fcks\u00e9g\u00fcnk, amivel p\u00e9ld\u00e1ul k\u00f6nnyen tudunk nem csak GET k\u00e9r\u00e9seket k\u00fcldeni, akkor a Postman \u00e9s a Fiddler Classic k\u00fcl\u00f6n telep\u00edtend\u0151 eszk\u00f6z\u00f6k aj\u00e1nlhat\u00f3k. A Fiddler mint proxy megold\u00e1s egy Windows g\u00e9pen foly\u00f3 HTTP kommunik\u00e1ci\u00f3 megfigyel\u00e9s\u00e9re is alkalmas.</p> <p>Els\u0151 k\u00f6rben a k\u00e9t lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt \u00edrjuk \u00e1t \u00fagy, hogy a HTTP v\u00e1laszk\u00f3dokat explicit megadjuk. A jelenlegi aj\u00e1nl\u00e1s ehhez az <code>ActionResult&lt;&gt;</code> haszn\u00e1lata. El\u00e9g <code>T</code>-t visszaadnunk a f\u00fcggv\u00e9nyben, automatikusan <code>ActionResult&lt;T&gt;</code> t\u00edpuss\u00e1 konvert\u00e1l\u00f3dik.</p> <pre><code>[HttpGet]\npublic ActionResult&lt;IEnumerable&lt;Product&gt;&gt; Get()\n{\n    return _productService.GetProducts(); \n}\n</code></pre> <p>\u00cdrjuk meg ugyan\u00edgy a m\u00e1sik <code>Get</code> f\u00fcggv\u00e9nyt is:</p> <pre><code>[HttpGet(\"{id}\")]\npublic ActionResult&lt;Product&gt; Get(int id)\n{\n    return _productService.GetProduct(id);\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki mindk\u00e9t kontroller f\u00fcggv\u00e9nyt (api/products, api/products/1), ellen\u0151rizz\u00fck a st\u00e1tuszk\u00f3dokat is.</p> <p>Ami fura, hogy m\u00e9g mindig nem \u00e1ll\u00edtottunk explicit st\u00e1tuszk\u00f3dokat. A logik\u00e1nk most m\u00e9g nagyon egyszer\u0171, csak a hibamentes \u00e1gat kezelt\u00fck, \u00edgy eddig az <code>ActionResult</code> alap\u00e9rtelmez\u00e9sei megoldott\u00e1k, hogy 200 (OK)-ot kapjunk.</p>"},{"location":"seminar/07-restapi/chapter7/#post-201-created","title":"POST - 201 Created","text":"<p>Most viszont k\u00f6vetkezzen egy l\u00e9trehoz\u00f3 m\u0171velet:</p> <pre><code>[HttpPost]\npublic ActionResult&lt;Product&gt; Post([FromBody] Product product)\n{\n    var created = _productService.InsertProduct(product);\n    return CreatedAtAction(nameof(Get), new { id = created.Id }, created);\n}\n</code></pre> <p>Itt m\u00e1r l\u00e1tszik az <code>ActionResult</code> haszna. A konvenci\u00f3nak megfelel\u0151en 201-es k\u00f3dot akarunk visszaadni. Ehhez a <code>ControllerBase</code> \u0151soszt\u00e1ly biztos\u00edt seg\u00e9df\u00fcggv\u00e9nyt. A seg\u00e9df\u00fcggv\u00e9ny olyan <code>ActionResult</code> lesz\u00e1rmazottat ad vissza, ami 201-es k\u00f3dot szolg\u00e1ltat a kliensnek. M\u00e1sik konvenci\u00f3, hogy a Location HTTP fejl\u00e9cben legyen egy URL az \u00faj term\u00e9k lek\u00e9rdez\u0151 m\u0171velet\u00e9nek megh\u00edv\u00e1s\u00e1hoz. Ezt az URL-t rakjuk \u00f6ssze a <code>CreatedAtAction</code> param\u00e9terei r\u00e9v\u00e9n.</p> <p>Gyakori, hogy a lefele ir\u00e1ny\u00fa kommunik\u00e1ci\u00f3 sor\u00e1n (kliens fel\u00e9) b\u0151vebb adathalmaz ker\u00fcl lek\u00fcld\u00e9sre, mint amit egy l\u00e9trehoz\u00e1skor vagy m\u00f3dos\u00edt\u00e1skor v\u00e1runk. Eset\u00fcnkben is az <code>Orders</code> \u00e9s a <code>Category</code> propertyk l\u00e9trehoz\u00e1skor feleslegesek. Erre a c\u00e9lra jobb egy k\u00fcl\u00f6n DTO-t l\u00e9trehozni, ami csak a megfelel\u0151 adatokat tartalmazza. Most ideiglenesen tegy\u00fck nullozhat\u00f3v\u00e1 ezt a k\u00e9t propertyt.</p> Product.cs<pre><code>public Category? Category { get; init; } //? m\u00f3dos\u00edt\u00f3 beker\u00fclt\npublic List&lt;Order&gt;? Orders { get; init; } //? m\u00f3dos\u00edt\u00f3 beker\u00fclt\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a m\u0171veletet Swagger fel\u00fcletr\u0151l. Egy <code>Product</code>-ot kell felk\u00fclden\u00fcnk. Erre egy p\u00e9lda \u00e9rt\u00e9k:</p> <pre><code>{\n    \"Name\" : \"P\u00e1linka\",\n    \"UnitPrice\" : 4000,\n    \"ShipmentRegion\" : 1,\n    \"CategoryId\" : 1\n}\n</code></pre> <p>Content-Type</p> <p>Ha Fiddlerb\u0151l vagy Postmanb\u0151l tesztel\u00fcnk, ne felejts\u00fck el a Content-Type fejl\u00e9cet application/json-re \u00e1ll\u00edtani!</p> <p>Figyelj\u00fck meg a kapott v\u00e1laszt. A v\u00e1laszb\u00f3l m\u00e1soljuk ki a Location fejl\u00e9cb\u0151l az URL-t \u00e9s h\u00edvjuk meg b\u00f6ng\u00e9sz\u0151b\u0151l.</p> <p>Fiddler Classic p\u00e9lda POST h\u00edv\u00e1sra:</p> <p></p>"},{"location":"seminar/07-restapi/chapter7/#put-200-ok","title":"PUT - 200 OK","text":"<p>A m\u00f3dos\u00edt\u00e1s a konvenci\u00f3 szerint 200 (OK) v\u00e1laszt ad, mert a kliens a m\u00f3dos\u00edtott er\u0151forr\u00e1st kapja vissza.</p> <pre><code>[HttpPut(\"{id}\")]\npublic ActionResult&lt;Product&gt; Put(int id, [FromBody] Product product)\n{\n    return _productService.UpdateProduct(id, product);\n}\n</code></pre> <p>PUT \u00e9s PATCH</p> <p>PUT mellett a m\u00f3dos\u00edt\u00e1shoz haszn\u00e1latos a PATCH is. A PUT konvenci\u00f3 szerint teljes, m\u00edg a PATCH r\u00e9szleges fel\u00fcl\u00edr\u00e1sn\u00e1l haszn\u00e1latos. PATCH eset\u00e9n \u00e1ltal\u00e1ban valamilyen patch form\u00e1tum\u00fa adatot k\u00fcld a kliens, pl. RFC 6902 - JSON Patch. A JSON Patch form\u00e1tumot jelenleg csak a JSON kor\u00e1bbi soros\u00edt\u00f3 (Newtonsoft.Json) t\u00e1mogatja.</p> <p>204 No Content</p> <p>M\u00f3dos\u00edt\u00e1s eset\u00e9ben a konvenci\u00f3 megengedi, hogy \u00fcres t\u00f6rzs\u0171 (body) v\u00e1laszt adjunk, ilyenkor a v\u00e1laszk\u00f3d 204 (No Content).</p>"},{"location":"seminar/07-restapi/chapter7/#delete-204-no-content","title":"DELETE - 204 No Content","text":"<p>A t\u00f6rl\u0151 m\u0171veletekn\u00e9l a konvenci\u00f3 megengedi, hogy \u00fcres t\u00f6rzs\u0171 (body) v\u00e1laszt adjunk, ilyenkor a v\u00e1laszk\u00f3d 204 (No Content). Ilyesfajta v\u00e1lasz el\u0151\u00e1ll\u00edt\u00e1s\u00e1hoz is van seg\u00e9df\u00fcggv\u00e9ny, illetve el\u00e9g csak az <code>ActionResult</code> t\u00edpust megadni visszat\u00e9r\u00e9si t\u00edpusnak:</p> <pre><code>[HttpDelete(\"{id}\")]\npublic ActionResult Delete(int id)\n{\n    _productService.DeleteProduct(id);\n    return NoContent();\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk kit\u00f6r\u00f6lni az \u00fajonnan felvett term\u00e9ket Swaggerb\u0151l/Fiddler-b\u0151l/Postman-b\u0151l (DELETE ig\u00e9s k\u00e9r\u00e9s az <code>api/products/&lt;\u00faj id&gt;</code> c\u00edmre, \u00fcres t\u00f6rzzsel). Siker\u00fclnie kell, mert m\u00e9g nincs r\u00e1 idegen kulcs hivatkoz\u00e1s.</p>"},{"location":"seminar/07-restapi/chapter7/#hibakezeles","title":"Hibakezel\u00e9s","text":"<p>Eddig f\u0151leg csak a hibamentes \u00e1gakat (happy path) n\u00e9zt\u00fck. A REST konvenci\u00f3k rendelkeznek arr\u00f3l is, hogy bizonyos hibahelyezetekben milyen HTTP v\u00e1laszt illik adni, p\u00e9ld\u00e1ul ha a k\u00e9r\u00e9sben hivatkozott azonos\u00edt\u00f3 nem l\u00e9tezik - 404-es hiba a bevett elj\u00e1r\u00e1s. St\u00e1tuszk\u00f3dok szempontj\u00e1b\u00f3l a kor\u00e1bban id\u00e9zett oldal ad seg\u00edts\u00e9get, a v\u00e1lasz t\u00f6rzs\u00e9ben a hiba\u00fczenet szerkezete tekintet\u00e9ben az RFC 7807 ad ir\u00e1nymutat\u00e1st az \u00fan. Problem Details t\u00edpus\u00fa v\u00e1laszok bevezet\u00e9s\u00e9vel. Az ASP.NET Core t\u00e1mogatja a Problem Details v\u00e1laszokat, \u00e9s \u00e1ltal\u00e1ban automatikusan ilyen v\u00e1laszokat k\u00fcld.</p>"},{"location":"seminar/07-restapi/chapter7/#400-bad-request","title":"400 Bad Request","text":"<p>Kezdj\u00fck a kliens \u00e1ltal k\u00fcld\u00f6tt nem helyes adatokkal. Ez a hibak\u00f3d nem \u00f6sszekeverend\u0151 a 415-tel, ahol az adat form\u00e1tuma nem megfelel\u0151 (XML vagy JSON): ezt \u00e1ltal\u00e1ban nem kell k\u00e9zzel lekezelj\u00fck, mivel ezt az ASP.NET Core megteszi helyett\u00fcnk. 400-zal olyan hib\u00e1kat szoktunk lekezelni, ahol a k\u00fcld\u00f6tt adat form\u00e1tuma megfelel\u0151, de valamilyen saj\u00e1t valid\u00e1ci\u00f3s logik\u00e1nak nem felel meg a kapott objektum, pl.: egys\u00e9g\u00e1r nem lehet negat\u00edv stb.</p> <p>Itt haszn\u00e1ljuk fel a .NET \u00fan. Data Annotation attrib\u00fatumait, amiket a DTO-kon \u00e9rv\u00e9nyes\u00edthet\u00fcnk, \u00e9s az ASP.NET Core figyelembe vesz a m\u0171velet v\u00e9grehajt\u00e1sa sor\u00e1n. Vegy\u00fcnk fel a <code>Product</code> DTO oszt\u00e1lyban n\u00e9h\u00e1ny megk\u00f6t\u00e9st attrib\u00fatumok form\u00e1j\u00e1ban.</p> <pre><code>[Required(ErrorMessage = \"Product name is required.\", AllowEmptyStrings = false)]\npublic string Name { get; init; } = null!;\n\n[Range(1, int.MaxValue, ErrorMessage = \"Unit price must be higher than 0.\")]\npublic int UnitPrice { get; init; }\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki egy POST /api/Products m\u0171velet megh\u00edv\u00e1s\u00e1val. Param\u00e9terk\u00e9nt kiindulhatunk a fel\u00fclet \u00e1ltal adott minta JSON-b\u00f3l, csak t\u00f6r\u00f6lj\u00fck ki a navig\u00e1ci\u00f3s property-ket \u00e9s s\u00e9rts\u00fck meg valamelyik (vagy mindk\u00e9t) fenti szab\u00e1lyt. Egy p\u00e9lda t\u00f6rzs:</p> <pre><code>{\n    \"Name\" : \"\",\n    \"UnitPrice\" : 0,\n    \"ShipmentRegion\" : 1,\n    \"CategoryId\" : 1\n}\n</code></pre> <p>A v\u00e1lasz 400-as k\u00f3d \u00e9s valami hasonl\u00f3, RFC 7807-nek megfelel\u0151 t\u00f6rzs lesz:</p> <pre><code>{\n    \"type\": \"https://tools.ietf.org/html/rfc7231#section-6.5.1\",\n    \"title\": \"One or more validation errors occurred.\",\n    \"status\": 400,\n    \"traceId\": \"|2f35d378-4420cbafb80aec04.\",\n    \"errors\": {\n        \"Name\": [\n            \"Product name is required.\"\n        ],\n        \"UnitPrice\": [\n            \"Unit price must be higher than 0.\"\n        ]\n    }\n}\n</code></pre> <p>\u00d6sszetettebb valid\u00e1ci\u00f3</p> <p>Az egyszer\u0171bb esetekn\u00e9l a Data Annotation attrib\u00fatumok elegend\u0151ek, de ha \u00f6sszetettebb valid\u00e1ci\u00f3ra van sz\u00fcks\u00e9g, akkor \u00e9rdemes a FluentValidation csomagot haszn\u00e1lni.</p>"},{"location":"seminar/07-restapi/chapter7/#404-not-found-kontroller-szinten","title":"404 Not Found - kontroller szinten","text":"<p>Konvenci\u00f3 szerint 404-es hib\u00e1t kellene adnunk, ha a keresett azonos\u00edt\u00f3val nem tal\u00e1lhat\u00f3 er\u0151forr\u00e1s - eset\u00fcnkben term\u00e9k. Jelenleg a <code>ProductService</code> <code>EntityNotFoundException</code>-t dob, \u00e9s amennyiben Development m\u00f3dban futtatjuk az alkalmaz\u00e1st, a cifra hibaoldal jelenik meg, amit a DeveloperExceptionPage middleware gener\u00e1l. Ha kivessz\u00fck a middleware-t (vagy nem Development m\u00f3dban ind\u00edtjuk, de ekkor gondoskodnunk kell connection string-r\u0151l, ami eddig csak a Development konfigur\u00e1ci\u00f3ban volt be\u00e1ll\u00edtva), akkor 500-as hib\u00e1t kapunk vissza.</p> <p>Exception Shielding</p> <p>A kezeletlen kiv\u00e9telek \u00e1ltal\u00e1ban 500-as hibak\u00f3d form\u00e1j\u00e1ban ker\u00fclnek vissza a kliensre, mindenfajta egy\u00e9b inform\u00e1ci\u00f3 n\u00e9lk\u00fcl (\u00fcres oldalk\u00e9nt jelenik meg). Ez a jobbik eset, ahhoz k\u00e9pest, ha a teljes kiv\u00e9telsz\u00f6veg \u00e9s stack trace is visszaker\u00fclne. Az \u00e1tlagos felhaszn\u00e1l\u00f3k nem tudj\u00e1k \u00e9rtelmezni, viszont a t\u00e1mad\u00f3 sz\u00e1nd\u00e9k\u00faaknak \u00e9rt\u00e9kes inform\u00e1ci\u00f3t jelenthet, \u00edgy aj\u00e1nlott elker\u00fclni, hogy a kiv\u00e9tel ilyen m\u00f3don kijusson. Ez az elker\u00fcl\u00e9s az \u00fagynevezett exception shielding technika, \u00e9s az ASP.NET Core alap\u00e9rtelmezetten alkalmazza.</p> <p>Legegyszer\u0171bb m\u00f3dszer a kontroller m\u0171veletben \u00e9rv\u00e9nyes\u00edteni a konvenci\u00f3t egy try-catch blokkal:</p> <pre><code>[HttpGet(\"{id}\")]\npublic ActionResult&lt;Product&gt; Get(int id)\n{\n    try\n    {\n        return _productService.GetProduct(id);\n    }\n    catch (EntityNotFoundException)\n    {\n        return NotFound();\n    }\n}\n</code></pre> <p>null \u00e9rt\u00e9k</p> <p>Alternat\u00edv megold\u00e1s, hogy a <code>ProductService</code> egy <code>null</code> \u00e9rt\u00e9kkel jelezn\u00e9, hogy nincs tal\u00e1lat. Ezesetben a fenti k\u00f3dban a <code>null</code> \u00e9rt\u00e9kre kellene vizsg\u00e1lni, pl. <code>if</code> szerkezettel. A k\u00e9s\u0151bbiekben l\u00e1tjuk majd, hogy a kiv\u00e9teleket egyszer\u0171bb k\u00f6zponti helyen kezelni.</p> <p>Pr\u00f3b\u00e1ljuk ki, hogy 404-es st\u00e1tuszk\u00f3dot \u00e9s annak megfelel\u0151 problem details-t kapunk-e, ha egy nem l\u00e9tez\u0151 term\u00e9kazonos\u00edt\u00f3val h\u00edvjuk a fenti m\u0171veletet.</p> <p>Ha saj\u00e1t problem details-t szeretn\u00e9nk a 404-es k\u00f3d mell\u00e9, akkor k\u00e9zzel \u00f6sszerakhatjuk \u00e9s visszak\u00fcldhetj\u00fck.</p> <pre><code>catch (EntityNotFoundException)\n{\n    ProblemDetails details= new ProblemDetails\n    {\n        Title = \"Invalid ID\",\n        Status = StatusCodes.Status404NotFound,\n        Detail = $\"No product with ID {id}\"\n    };\n    return NotFound(details);\n}\n</code></pre> <p>\u00cdgy is pr\u00f3b\u00e1ljuk ki. Az \u00e1ltalunk megadott \u00fczenetet kell visszakapjuk.</p>"},{"location":"seminar/07-restapi/chapter7/#404-not-found-kozponti-hibakezelessel","title":"404 Not Found - k\u00f6zponti hibakezel\u00e9ssel","text":"<p>A rendhagy\u00f3 v\u00e1laszok el\u0151\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l el\u0151ny\u00f6s lehet, ha az alacsonyabb r\u00e9tegekb\u0151l specifikus kiv\u00e9teleket dobunk, mert ezeket egy k\u00f6zponti helyen szisztematikusan \u00e1talak\u00edthatjuk konvenci\u00f3nak megfelel\u0151 HTTP v\u00e1laszokk\u00e1. Ezt az ASP.NET Core 8 \u00f3ta be\u00e9p\u00edtetten meg tudjuk tenni. Erre a c\u00e9lra t\u00f6bb kiterjeszt\u00e9si pontja is van a keretrendszernek 1 2, de nek\u00fcnk most el\u00e9g a legmagasabb szinten a <code>ProblemDetails</code> v\u00e1laszt testreszabni.</p> <p>Az <code>AddProblemDetails</code> konfigur\u00e1ci\u00f3j\u00e1ban a saj\u00e1t kiv\u00e9telt\u00edpusunkat k\u00e9pezz\u00fck le 404-es hibak\u00f3dra \u00e9s a v\u00e1lasz tartalm\u00e1t m\u00f3dos\u00edtsuk.</p> <pre><code>builder.Services.AddProblemDetails(options =&gt;\n        options.CustomizeProblemDetails = context =&gt;\n        {\n            if (context.HttpContext.Features.Get&lt;IExceptionHandlerFeature&gt;()?.Error is EntityNotFoundException ex)\n            {\n                context.HttpContext.Response.StatusCode = StatusCodes.Status404NotFound;\n                context.ProblemDetails.Title = \"Invalid ID\";\n                context.ProblemDetails.Status = StatusCodes.Status404NotFound;\n                context.ProblemDetails.Detail = $\"No product with ID {ex.Id}\";\n            }\n        }\n    );\n</code></pre> <p>A middleware pipeline-ba az al\u00e1bbi be\u00e9p\u00edtett middleware-eket kell felvenni a cs\u0151vezet\u00e9k elej\u00e9re:</p> <pre><code>var app = builder.Build();\n\napp.UseExceptionHandler();\napp.UseStatusCodePages();\n</code></pre> <p>T\u00e9rj\u00fcnk vissza a kor\u00e1bbi, nem kiv\u00e9tel-elkap\u00f3s v\u00e1ltozatra:</p> <pre><code>[HttpGet(\"{id}\")]\npublic ActionResult&lt;Product&gt; Get(int id)\n{\n    return _productService.GetProduct(id);\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki: hasonl\u00f3an kell m\u0171k\u00f6dj\u00f6n, mint a kontroller szint\u0171 v\u00e1ltozat, de ez \u00e1ltal\u00e1nosabb, b\u00e1rmely m\u0171veletb\u0151l <code>EntityNotFoundException</code> \u00e9rkezik, azt kezeli, nem kell minden m\u0171veletben meg\u00edrni a kezel\u0151 logik\u00e1t.</p> <p>500 Internal Server Error</p> <p>Be\u00e9p\u00edtetten a fenti megold\u00e1s minden egy\u00e9b kezeletlen hib\u00e1ra 500-as hibak\u00f3dot ad vissza, \u00e9s egy \u00e1ltal\u00e1nos ProblemDetails tartalommal t\u00e9r vissza, ami nem tartalmazza a kiv\u00e9tel sz\u00f6veg\u00e9t \u00e9s stack trace-j\u00e9t.</p> <p>Az exception shielding elv miatt csak olyan kiv\u00e9telekn\u00e9l alkalmazzuk, ahol a felhaszn\u00e1l\u00f3k sz\u00e1m\u00e1ra hasznos, de nem technikai jelleg\u0171 inform\u00e1ci\u00f3t tartalmaz a kiv\u00e9tel sz\u00f6vege.</p> <p>Delete idempotens m\u0171k\u00f6d\u00e9se</p> <p>Jelenleg a delete m\u0171velet\u00fcnk hib\u00e1val t\u00e9r vissza m\u00e1sodj\u00e1ra, ha 2x egym\u00e1s ut\u00e1n megh\u00edvn\u00e1nk azonos azonos\u00edt\u00f3val.</p> <p>Egy m\u00e1sik megk\u00f6zel\u00edt\u00e9s szerint a DELETE m\u0171veletnek idempotensnek kellene lennie, teh\u00e1t egym\u00e1s ut\u00e1n t\u00f6bbsz\u00f6r v\u00e9grehajtva is sikeres eredm\u00e9nyt kell kapjunk. Ez azt is jelenti, hogy 404-es hiba helyet 204 No Content st\u00e1tuszk\u00f3dot kell k\u00fclden\u00fcnk akkor is, ha nem tal\u00e1lhat\u00f3 adott ID-val entit\u00e1s. Ezt a jelenlegi k\u00f3dban egyszer\u0171en implement\u00e1lhatjuk, hogy nem dobunk kiv\u00e9telt a megfelel\u0151 \u00e1gban.</p> <p>Pr\u00f3b\u00e1ljuk ki, hogy az egy term\u00e9k lek\u00e9rdez\u00e9s\u00e9n\u00e9l, a m\u00f3dos\u00edt\u00e1sn\u00e1l \u00e9s a t\u00f6rl\u00e9sn\u00e9l is a rossz azonos\u00edt\u00f3 egys\u00e9gesen m\u0171k\u00f6dik-e: 404-es hib\u00e1t ad vissza, a Problem Details-ben a kiv\u00e9tel sz\u00f6veg\u00e9vel.</p>"},{"location":"seminar/07-restapi/chapter7/#aszinkron-muveletek","title":"Aszinkron m\u0171veletek","text":"<p>Aszinkron m\u0171veletek alkalmaz\u00e1s\u00e1val hat\u00e9konys\u00e1gjavul\u00e1st \u00e9rhet\u00fcnk el: nem felt\u00e9tlen\u00fcl az egyes m\u0171veleteink lesznek gyorsabbak, hanem id\u0151egys\u00e9g alatt t\u00f6bb m\u0171veletet tudunk kiszolg\u00e1lni. Ennek oka, hogy az <code>await</code>-n\u00e9l (p\u00e9ld\u00e1ul egy adatb\u00e1zis m\u0171velet elk\u00fcld\u00e9sekor) a v\u00e1rakoz\u00e1si idej\u00e9re t\u00f6rt\u00e9n\u0151 kiugr\u00e1sn\u00e1l, ha vissza tudunk ugr\u00e1lni eg\u00e9szen az ASP.NET engine szintj\u00e9ig, akkor a v\u00e9grehajt\u00f3 k\u00f6rnyezet a kiszolg\u00e1l\u00f3 sz\u00e1lat a v\u00e1rakoz\u00e1s idej\u00e9re m\u00e1s k\u00e9r\u00e9s kiszolg\u00e1l\u00e1s\u00e1ra felhaszn\u00e1lhatja.</p> <p>Aszinkronit\u00e1s v\u00e9gigvezet\u00e9se a k\u00f3dban</p> <p>\u00d6k\u00f6lszab\u00e1ly, hogy ha elk\u00f6telezt\u00fck magunkat az aszinkronit\u00e1s mellett, akkor ha megoldhat\u00f3, az aszinkronit\u00e1st vezess\u00fck v\u00e9gig a kontrollert\u0151l az adatb\u00e1zis m\u0171velet v\u00e9grehajt\u00e1s\u00e1ig minden r\u00e9tegben. Ha egy API-nak van TAP jelleg\u0171 v\u00e1ltozata, akkor azt r\u00e9szes\u00edts\u00fck el\u0151nyben (pl. <code>SaveChanges</code> helyett <code>SaveChangesAsync</code>). Ha aszinkronb\u00f3l szinkronba v\u00e1ltunk, cs\u00f6kkentj\u00fck a hat\u00e9konys\u00e1got, rosszabb esetben deadlock-ot is el\u0151id\u00e9zhet\u00fcnk.</p> <p>Vezess\u00fck v\u00e9gig az aszinkronit\u00e1st egy m\u0171velet teljes v\u00e9grehajt\u00e1s\u00e1n:</p> IProductService.cs<pre><code>public Task&lt;Product&gt; UpdateProductAsync(int productId, Product updatedProduct);\n</code></pre> ProductService.cs<pre><code>public async Task&lt;Product&gt; UpdateProductAsync(int productId, Product updatedProduct)\n{\n    var efProduct = await _context.Products.SingleOrDefaultAsync(p =&gt; p.Id == productId)\n        ?? throw new EntityNotFoundException(\"Nem tal\u00e1lhat\u00f3 a term\u00e9k\", productId);\n    _mapper.Map(updatedProduct, efProduct);\n    await _context.SaveChangesAsync();\n    return await GetProductAsync(efProduct.Id);\n}\n</code></pre> ProductController.cs<pre><code>[HttpPut(\"{id}\")]\npublic async Task&lt;ActionResult&lt;Product&gt;&gt; Put(int id, [FromBody] Product product)\n{\n    return await _productService.UpdateProductAsync(id, product);\n}\n</code></pre> <p>Async v\u00e9gz\u0151d\u00e9s \u00e9s kontroller m\u0171veletek</p> <p>Az Async v\u00e9gz\u0151d\u00e9s alkalmaz\u00e1sa kontroller m\u0171veletek nev\u00e9ben jelenleg nem aj\u00e1nlott, mert k\u00f6nnyen hib\u00e1kba futhatunk.</p> <p>Pr\u00f3b\u00e1ljuk ki, hogy tov\u00e1bbra is m\u0171k\u00f6dik a m\u00f3dos\u00edtott m\u0171velet.</p>"},{"location":"seminar/07-restapi/chapter7/#vegallapot","title":"V\u00e9g\u00e1llapot","text":"<p>A v\u00e9g\u00e1llapot el\u00e9rhet\u0151 a kapcsol\u00f3d\u00f3 GitHub repo megoldas \u00e1g\u00e1n is.</p>"},{"location":"seminar/08-client/chapter8/","title":"ASP.NET Core webszolg\u00e1ltat\u00e1sok III.","text":""},{"location":"seminar/08-client/chapter8/#kiegeszito-anyagok-segedeszkozok","title":"Kieg\u00e9sz\u00edt\u0151 anyagok, seg\u00e9deszk\u00f6z\u00f6k","text":"<ul> <li>kapcsol\u00f3d\u00f3 repo: https://github.com/bmeviauav23/WebApiLab-kiindulo</li> <li>NSwag Studio - itt is el\u00e9g csak a legfrissebb zip verzi\u00f3t az Assets r\u00e9szr\u0151l let\u00f6lteni</li> <li>Postman HTTP k\u00e9r\u00e9sek k\u00fcld\u00e9s\u00e9hez</li> </ul>"},{"location":"seminar/08-client/chapter8/#kiindulo-projektek-beuzemelese","title":"Kiindul\u00f3 projektek be\u00fczemel\u00e9se","text":"<p>Kl\u00f3nozzuk le a kiindul\u00f3 projekt <code>lab-kiindulo-240502</code> \u00e1g\u00e1t, ez az el\u0151z\u0151 gyakorlat folytat\u00e1sa - a k\u00f3dot ismerj\u00fck. Ha nincs m\u00e1r meg az adatb\u00e1zisunk, akkor az el\u0151z\u0151 gyakorlat alapj\u00e1n hozzuk l\u00e9tre az adatb\u00e1zist Code-First migr\u00e1ci\u00f3val (<code>Update-Database</code>).</p> <pre><code>git clone https://github.com/bmeviauav23/WebApiLab-kiindulo -b lab-kiindulo-240502\n</code></pre>"},{"location":"seminar/08-client/chapter8/#egyszeru-kliens","title":"Egyszer\u0171 kliens","text":"<p>A t\u00e1rgy tematik\u00e1j\u00e1nak ugyan nem r\u00e9sze a kliensoldal, de demonstr\u00e1ci\u00f3s c\u00e9llal egy egyszer\u0171 kliensoldalr\u00f3l ind\u00edtott h\u00edv\u00e1st implement\u00e1lunk. A webes API-khoz nagyon sokf\u00e9le technik\u00e1val \u00edrhatunk klienst, mivel gyakorlatilag csak k\u00e9t k\u00e9pess\u00e9ggel kell rendelkezni:</p> <ul> <li>HTTP alap\u00fa kommunik\u00e1ci\u00f3, HTTP k\u00e9r\u00e9sek k\u00fcld\u00e9se, a v\u00e1lasz feldolgoz\u00e1sa</li> <li>JSON soros\u00edt\u00e1s</li> </ul> <p>A fentiekhez szinte minden manaps\u00e1g haszn\u00e1lt kliensoldali technol\u00f3gia ad t\u00e1mogat\u00e1st. Mi most egy sima, .NET alap\u00fa konzol alkalmaz\u00e1st \u00edrunk kliens gyan\u00e1nt.</p> <p>A k\u00e9t k\u00e9pess\u00e9get k\u00f6nnyen lefedhetj\u00fck a System.Net.Http (HTTP kommunik\u00e1ci\u00f3) \u00e9s a System.Text.Json (JSON soros\u00edt\u00e1s) csomagokkal. Mindkett\u0151 a Microsoft.NetCore.App shared framework r\u00e9sze, \u00edgy \u00e1ltal\u00e1ban nem kell k\u00fcl\u00f6n beszerezn\u00fcnk \u0151ket.</p> <p>Adjunk a solution-h\u00f6z egy konzolos projektet (Console App (.NET 8), nem .NET Framework!) WebApiLab.Client n\u00e9ven. A Program.cs-ben \u00edrjuk meg az egy term\u00e9ket lek\u00e9rdez\u0151 f\u00fcggv\u00e9nyt (<code>GetProductAsync</code>) \u00e9s h\u00edvjuk meg.</p> <pre><code>Console.Write(\"ProductId: \");\nvar id = Console.ReadLine();\nif(id != null)\n{\n    await GetProductAsync(int.Parse(id));\n}\n\nConsole.ReadKey();\n\nstatic async Task GetProductAsync(int id)\n{\n    using var client = new HttpClient();\n\n    // Ha elt\u00e9r, a portot \u00edrjuk \u00e1t a szervernek megfelel\u0151en\n    var response = await client.GetAsync(new Uri($\"http://localhost:5184/api/Products/{id}\"));\n    response.EnsureSuccessStatusCode();\n    var jsonStream = await response.Content.ReadAsStreamAsync();\n    var json = await JsonDocument.ParseAsync(jsonStream);\n    Console.WriteLine(\n        $\"{json.RootElement.GetProperty(\"name\")}:\" +\n        $\"{json.RootElement.GetProperty(\"unitPrice\")}\");\n}\n</code></pre> <p>Ez most jelenleg csak egy egyszer\u0171 p\u00e9lda DTO oszt\u00e1lyok n\u00e9lk\u00fcl, a k\u00e9s\u0151bbiekben egyszer\u0171s\u00edteni fogjuk a JSON feldolgoz\u00e1st.</p> <p>!!! tip .NET 8 kliensen is     Az elterjedtebb .NET alap\u00fa kliensek, a WinForms, WPF alkalmaz\u00e1sok a legut\u00f3bbi id\u0151kig .NET Framework alap\u00faak voltak, viszont m\u00e1r egy ideje a .NET 6-os verzi\u00f3t\u00f3l felfel\u00e9 is t\u00e1mogatja a WinForms, WPF, WinUI, MAUI (r\u00e9gi Xamarin) alkalmaz\u00e1sokat. C\u00e9lszer\u0171 ezeket v\u00e1lasztani a r\u00e9gi .NET Framework alap\u00fa v\u00e1ltozatok helyett.</p> <p>\u00c1ll\u00edtsuk be, hogy a szerver \u00e9s a kliensoldal is elinduljon (menu:solution\u00f6n jobbklikk[Set startup projects\u2026]), majd pr\u00f3b\u00e1ljuk ki, hogy a megadott azonos\u00edt\u00f3j\u00fa term\u00e9k neve \u00e9s \u00e1ra megjelenik-e a konzolon.</p> <p>Jelenleg csak alapszint\u0171 (nem t\u00edpusos) JSON soros\u00edt\u00e1st alkalmazunk. A k\u00f6vetkez\u0151 l\u00e9p\u00e9s az lenne, hogy a JSON alapj\u00e1n visszasoros\u00edtan\u00e1nk egy konkr\u00e9tabb objektumba. Ehhez kliensoldalon is kellene lennie egy <code>Product</code> DTO-nak megfelel\u0151 oszt\u00e1lynak. Hogyan j\u00f6hetnek l\u00e9tre a kliensoldali modelloszt\u00e1lyok?</p> <ul> <li>k\u00e9zzel l\u00e9trehozzuk \u0151ket a JSON alapj\u00e1n - macer\u00e1s, b\u00e1r vannak r\u00e1 eszk\u00f6z\u00f6k, amik seg\u00edtenek</li> <li>a DTO-kat oszt\u00e1lyk\u00f6nyvt\u00e1rba szervezz\u00fck \u00e9s mindk\u00e9t alkalmaz\u00e1s hivatkozza <ul> <li>csak akkor m\u0171k\u00f6dik, ha mindk\u00e9t oldal .NET-es, r\u00e1ad\u00e1sul k\u00f6nnyen kaphat az oszt\u00e1lyk\u00f6nyvt\u00e1r olyan f\u00fcgg\u0151s\u00e9get, ami igaz\u00e1b\u00f3l az egyik oldalnak kell csak, \u00edgy meg mindk\u00e9t oldal meg fogja kapni</li> </ul> </li> <li>gener\u00e1ltatjuk valamilyen eszk\u00f6zzel a szerveroldal alapj\u00e1n - ezt pr\u00f3b\u00e1ljuk most ki</li> </ul> <p>\u00c1ll\u00edtsuk be, hogy csak a szerveroldal (Api projekt) induljon.</p>"},{"location":"seminar/08-client/chapter8/#openapiswagger-szerver-oldal","title":"OpenAPI/Swagger Szerver oldal","text":"<p>Az OpenAPI (eredeti nev\u00e9n: Swagger) eszk\u00f6zk\u00e9szlet seg\u00edts\u00e9g\u00e9vel egy JSON alap\u00fa le\u00edr\u00e1s\u00e1t tudjuk el\u0151\u00e1ll\u00edtani a szerveroldali API-nknak. A le\u00edr\u00e1s alapj\u00e1n gener\u00e1lhatunk dokument\u00e1ci\u00f3t, s\u0151t kliensoldali k\u00f3dot is a kliensoldali fejleszt\u0151k sz\u00e1m\u00e1ra. Jelenleg a legfrissebb specifik\u00e1ci\u00f3 az OpenAPI v3-as (OAS v3). Az egyes verzi\u00f3k dokument\u00e1ci\u00f3ja el\u00e9rhet\u0151 itt.</p> <p>Az OpenAPI nem .NET specifikus, k\u00fcl\u00f6nf\u00e9le nyelven \u00edrt szervert \u00e9s klienst is t\u00e1mogat. Ugyanakkor k\u00e9sz\u00fcltek kifejezetten a .NET-hez is OpenAPI eszk\u00f6z\u00f6k, ezek k\u00f6z\u00fcl haszn\u00e1lunk p\u00e1rat most. .NET k\u00f6rnyezetben a legelterjedtebb eszk\u00f6zk\u00e9szletek:</p> <ul> <li>NSwag - le\u00edr\u00f3-, szerver-, \u00e9s kliensoldali gener\u00e1l\u00e1s is. R\u00e9szleges OAS v3 t\u00e1mogat\u00e1s.</li> <li>Swashbuckle - csak le\u00edr\u00f3 gener\u00e1l\u00e1s. OAS v3 t\u00e1mogatott.</li> <li>AutoRest - npm csomag .NET f\u00fcgg\u0151s\u00e9ggel, csak kliensoldali k\u00f3dgener\u00e1l\u00e1shoz. R\u00e9szleges OAS v3 t\u00e1mogat\u00e1s.</li> <li>Swagger codegen - java alap\u00fa kliensoldali gener\u00e1tor. C# t\u00e1mogat\u00e1s csak OpenAPI v2-h\u00f6z</li> <li>Kiota - \u00faj, Microsoft fejleszt\u00e9s\u0171 C# alap\u00fa kliensoldali gener\u00e1tor. OAS v3 t\u00e1mogatott.</li> </ul>"},{"location":"seminar/08-client/chapter8/#leiro-generalas","title":"Le\u00edr\u00f3 gener\u00e1l\u00e1s","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt a szerveroldali k\u00f3dunk alapj\u00e1n Swagger le\u00edr\u00e1st gener\u00e1lunk NSwag seg\u00edts\u00e9g\u00e9vel.</p> <p>Adjuk hozz\u00e1 a projekthez az NSwag.AspNetCore csomagot a <code>Package Manager Console</code>-b\u00f3l vagy az API projekt Manage NuGet packages UI-on, \u00e9s t\u00f6r\u00f6lj\u00fck ki a Swashbuckle.AspNetCore csomagot.</p> <p>Konfigur\u00e1ljuk a sz\u00fcks\u00e9ges szolg\u00e1ltat\u00e1sokat a DI rendszerbe.</p> <pre><code>//builder.Services.AddEndpointsApiExplorer();\n//builder.Services.AddSwaggerGen();\nbuilder.Services.AddOpenApiDocument();\n</code></pre> <p>Az OpenAPI le\u00edr\u00f3, illetve a dokument\u00e1ci\u00f3s fel\u00fclet kiszolg\u00e1l\u00e1s\u00e1ra regisztr\u00e1ljunk egy-egy NSwag middleware-t az Endpoint MW el\u00e9. Az eddigi Swagger t\u00e1mogat\u00e1ssal kapcsolatos k\u00f3dok t\u00f6r\u00f6lhet\u0151k.</p> <pre><code>if (app.Environment.IsDevelopment())\n{\n    //app.UseSwagger();\n    //app.UseSwaggerUI();\n    app.UseOpenApi();\n    app.UseSwaggerUi();\n}\n</code></pre> <p>A Swagger UI a <code>/swagger</code> \u00fatvonalon lesz el\u00e9rhet\u0151. Pr\u00f3b\u00e1ljuk ki, hogy m\u0171k\u00f6dik-e a dokument\u00e1ci\u00f3s fel\u00fclet a /swagger \u00fatvonalon, illetve a le\u00edr\u00f3 el\u00e9rhet\u0151-e a /swagger/v1/swagger.json \u00fatvonalon.</p> <p>Tip</p> <p>A Swagger le\u00edr\u00f3 linkje megtal\u00e1lhat\u00f3 a dokument\u00e1ci\u00f3s fel\u00fclet c\u00edmsora alatt.</p>"},{"location":"seminar/08-client/chapter8/#testreszabas-xml-kommentek","title":"Testreszab\u00e1s - XML kommentek","text":"<p>Az NSwag k\u00e9pes a k\u00f3dunk XML kommentjeit hasznos\u00edtani a dokument\u00e1ci\u00f3s fel\u00fcleten. \u00cdrjuk meg egy m\u0171velet XML kommentj\u00e9t.</p> <pre><code>/// &lt;summary&gt;\n/// Get a specific product with the given identifier\n/// &lt;/summary&gt;\n/// &lt;param name=\"id\"&gt;Product's identifier&lt;/param&gt;\n/// &lt;returns&gt;Returns a specific product with the given identifier&lt;/returns&gt;\n/// &lt;response code=\"200\"&gt;Listing successful&lt;/response&gt;\n[HttpGet(\"{id}\")]\npublic async Task&lt;ActionResult&lt;Product&gt;&gt; Get(int id){/*...*/}\n</code></pre> <p>A Swagger komponens\u00fcnk az XML kommenteket nem a forr\u00e1sk\u00f3db\u00f3l, hanem egy gener\u00e1lt \u00e1llom\u00e1nyb\u00f3l k\u00e9pes kiolvasni. \u00c1ll\u00edtsuk be ennek a gener\u00e1l\u00e1s\u00e1t a projekt build be\u00e1ll\u00edt\u00e1sai k\u00f6z\u00f6tt ( menu:Build[XML documentation file]). Az alatta l\u00e9v\u0151 textbox-ot \u00fcresen hagyhatjuk.</p> <p></p> Projektbe\u00e1ll\u00edt\u00e1sok (Build lap) - XML dokument\u00e1ci\u00f3s f\u00e1jl gener\u00e1l\u00e1sa"},{"location":"seminar/08-client/chapter8/#testreszabas-felsorolt-tipusok-sorositasa-szovegkent","title":"Testreszab\u00e1s - Felsorolt t\u00edpusok soros\u00edt\u00e1sa sz\u00f6vegk\u00e9nt","text":"<p>K\u00f6vetkez\u0151 kis testreszab\u00e1si lehet\u0151s\u00e9g, amit kipr\u00f3b\u00e1lunk, a felsorolt t\u00edpusok sz\u00f6vegk\u00e9nt val\u00f3 gener\u00e1l\u00e1sa (az eg\u00e9sz sz\u00e1mos k\u00f3dol\u00e1s helyett). Ez \u00e1ltal\u00e1ban a bev\u00e1lt m\u00f3dszer, mivel a kliensek sz\u00e1m\u00e1ra kifejez\u0151bb. A DI-ban a JSON soros\u00edt\u00e1st konfigur\u00e1ljuk:</p> <pre><code>builder.Services.AddControllers() //; t\u00f6r\u00f6lve\n    .AddJsonOptions(o =&gt;\n    {\n        o.JsonSerializerOptions.Converters.Add(new JsonStringEnumConverter());\n    });\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki, hogy az XML komment\u00fcnk megjelenik-e a megfelel\u0151 m\u0171veletn\u00e9l, illetve a v\u00e1laszban a <code>Product.ShipmentRegion</code> sz\u00f6veges \u00e9rt\u00e9keket vesz-e fel.</p>"},{"location":"seminar/08-client/chapter8/#testreszabas-http-statuszkodok-dokumentalasa","title":"Testreszab\u00e1s - HTTP st\u00e1tuszk\u00f3dok dokument\u00e1l\u00e1sa","text":"<p>Gyakori testreszab\u00e1si feladat, hogy az egyes m\u0171veletek eset\u00e9n a v\u00e1lasz pontos HTTP st\u00e1tuszk\u00f3dj\u00e1t is dokument\u00e1lni szeretn\u00e9nk, illetve ha t\u00f6bb k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f3d\u00fa v\u00e1lasz is lehets\u00e9ges, akkor mindegyiket.</p> <p>Ehhez el\u00e9g egy (vagy t\u00f6bb) <code>ProducesResponseType</code> attrib\u00fatumot felrakni a m\u0171veletre.</p> <pre><code>/// &lt;summary&gt;\n/// Creates a new product\n/// &lt;/summary&gt;\n/// &lt;param name=\"product\"&gt;The product to create&lt;/param&gt;\n/// &lt;returns&gt;Returns the product inserted&lt;/returns&gt;\n/// &lt;response code=\"201\"&gt;Insert successful&lt;/response&gt;\n[HttpPost]\n[ProducesResponseType(StatusCodes.Status201Created)]\npublic async Task&lt;ActionResult&lt;Product&gt;&gt; Post([FromBody] Product product)\n{/*...*/}\n\n[HttpDelete(\"{id}\")]\n[ProducesResponseType(StatusCodes.Status204NoContent)]\npublic async Task&lt;ActionResult&gt; Delete(int id)\n{/*...*/}\n</code></pre> <p>Ellen\u0151rizz\u00fck, hogy a dokument\u00e1ci\u00f3s fel\u00fcleten a fentieknek megfelel\u0151 st\u00e1tuszk\u00f3dok jelennek-e meg.</p> <p>A hiba\u00e1gakra is felvehetj\u00fck a megfelel\u0151 <code>ProducesResponseType</code> attrib\u00fatumot, ahol annak generikus param\u00e9tere a hiba t\u00edpusa.</p> <pre><code>[HttpGet]\n[ProducesResponseType(StatusCodes.Status200OK)]\npublic async Task&lt;ActionResult&lt;IEnumerable&lt;Product&gt;&gt;&gt; Get()\n{\n    return await _productService.GetProductsAsync();\n}\n\n[HttpGet(\"{id}\")]\n[ProducesResponseType(StatusCodes.Status200OK)]\n[ProducesResponseType&lt;ProblemDetails&gt;(StatusCodes.Status404NotFound)]\npublic async Task&lt;ActionResult&lt;Product&gt;&gt; Get(int id)\n{\n    return await _productService.GetProductAsync(id);\n}\n\n[HttpPost]\n[ProducesResponseType(StatusCodes.Status201Created)]\n[ProducesResponseType&lt;ProblemDetails&gt;(StatusCodes.Status404NotFound)]\n[ProducesResponseType&lt;ValidationProblemDetails&gt;(StatusCodes.Status400BadRequest)]\npublic async Task&lt;ActionResult&lt;Product&gt;&gt; Post([FromBody] Product product)\n{\n    var created = await _productService.InsertProductAsync(product);\n    return CreatedAtAction(nameof(Get), new { id = created.Id }, created);\n}\n\n[HttpPut(\"{id}\")]\n[ProducesResponseType(StatusCodes.Status200OK)]\n[ProducesResponseType&lt;ProblemDetails&gt;(StatusCodes.Status404NotFound)]\n[ProducesResponseType&lt;ValidationProblemDetails&gt;(StatusCodes.Status400BadRequest)]\npublic async Task&lt;ActionResult&lt;Product&gt;&gt; Put(int id, [FromBody] Product product)\n{\n    return await _productService.UpdateProductAsync(id, product);\n}\n\n[HttpDelete(\"{id}\")]\n[ProducesResponseType(StatusCodes.Status204NoContent)]\n[ProducesResponseType&lt;ProblemDetails&gt;(StatusCodes.Status404NotFound)]\npublic async Task&lt;ActionResult&gt; Delete(int id)\n{\n    await _productService.DeleteProductAsync(id);\n    return NoContent();\n}\n</code></pre> <p>Vegy\u00fck \u00e9szre az al\u00e1bbiakat:</p> <ul> <li>Ha nem adunk meg a <code>ProducesResponseType</code> attrib\u00fatumnak t\u00edpus param\u00e9tert, akkor a met\u00f3dus visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u00e9b\u0151l pr\u00f3b\u00e1lja kital\u00e1lni a modellt.</li> <li>Am\u00edg nem adtunk meg semmilyen <code>ProducesResponseType</code> attrib\u00fatumot, addig a Swagger UI az egyenes \u00e1gra mindig 200-as st\u00e1tuszk\u00f3dot fog felt\u00e9telezni</li> <li>Ezt a felt\u00e9telez\u00e9st elvesz\u00edtj\u00fck, ha b\u00e1rmilyen <code>ProducesResponseType</code> attrib\u00fatumot felvessz\u00fck pl.: <code>ProducesResponseType(StatusCodes.Status404NotFound)</code> eset\u00e9ben sz\u00fcks\u00e9ges m\u00e1r ki\u00edrni a 200-as st\u00e1tuszk\u00f3dot is, ha az is lehets\u00e9ges v\u00e1lasz.</li> <li>A hibaeseteket ak\u00e1r k\u00f6z\u00f6ss\u00e9 is tehetn\u00e9nk, ha a <code>ProducesResponseType</code> attrib\u00fatumokat nem a met\u00f3dusra, hanem a kontrollerre rakn\u00e1nk. Ilyenkor viszont hib\u00e1san a list\u00e1s v\u00e9gpontra is azt nyilatkozn\u00e1nk, hogy j\u00f6het 404-es st\u00e1tuszk\u00f3d, pedig ez nem igaz.</li> </ul>"},{"location":"seminar/08-client/chapter8/#openapiswagger-kliensoldal","title":"OpenAPI/Swagger kliensoldal","text":"<p>A kliensoldalt az NSwag Studio eszk\u00f6zzel gener\u00e1ltatjuk. Ez a gener\u00e1tor egy egyszer\u0171en haszn\u00e1lhat\u00f3, de m\u00e9gis sok be\u00e1ll\u00edt\u00e1st t\u00e1mogat\u00f3 eszk\u00f6z, azonban van p\u00e1r hi\u00e1nyoss\u00e1ga:</p> <ul> <li>egyetlen f\u00e1jlt gener\u00e1l</li> <li>csak r\u00e9szlegesen t\u00e1mogatja az \u00faj JSON soros\u00edt\u00f3t, csak a r\u00e9gebbit</li> </ul> <p>El\u0151k\u00e9sz\u00edt\u00e9sk\u00e9nt adjuk a Client projekthez az al\u00e1bbiakat:</p> <ul> <li>Newtonsoft.Json NuGet csomagot</li> <li>egy oszt\u00e1lyt <code>ApiClients</code> n\u00e9ven</li> </ul> <p>Ind\u00edtsuk el a projekt\u00fcnket (a szerveroldalra lesz most sz\u00fcks\u00e9g) \u00e9s az NSwag Studio-t, \u00e9s adjuk meg az al\u00e1bbi be\u00e1ll\u00edt\u00e1sokat:</p> <ul> <li>Input r\u00e9sz (bal oldal): v\u00e1lasszuk az OpenAPI/Swagger Specification f\u00fclet \u00e9s adjuk meg a OpenAPI le\u00edr\u00f3nk c\u00edm\u00e9t (pl.: http://localhost:5000/swagger/v1/swagger.json). Nyomjuk meg a Create local Copy gombot.</li> <li>Input r\u00e9sz (bal oldal) - Runtime: Net80</li> <li>Output r\u00e9sz (jobb oldal) - jel\u00f6lj\u00fck be a CSharp Client jel\u00f6l\u0151t</li> <li>Output r\u00e9sz (jobb oldal) - CSharp Client f\u00fcl - Settings alf\u00fcl: f\u00f6l\u00fcl a Namespace mez\u0151ben adjunk meg egy n\u00e9vteret, pl. WebApiLab.Client.Api, lentebb a Use the base URL for the request ne legyen bepip\u00e1lva</li> </ul> <p></p> NSwag Studio be\u00e1ll\u00edt\u00e1sok <p>Jobb oldalt alul a Generate Outputs gombbal gener\u00e1ltathatjuk a kliensoldali k\u00f3dot.</p> <p>A gener\u00e1lt k\u00f3ddal \u00edrjuk fel\u00fcl az ApiClients.cs tartalm\u00e1t (ehhez le kell \u00e1ll\u00edtani a futtat\u00e1st). Ezut\u00e1n a projektnek fordulnia kell. \u00cdrjuk meg a Program.cs-ben a <code>GetProduct</code> \u00faj v\u00e1ltozat\u00e1t:</p> <pre><code>static async Task&lt;Product&gt; GetProduct2Async(int id)\n{\n    using var httpClient = new HttpClient()\n        { BaseAddress = new Uri(\"http://localhost:5184/\") };\n    var client = new ProductsClient(httpClient);\n    return await client.GetAsync(id);\n}\n</code></pre> <p>Haszn\u00e1ljuk az \u00faj v\u00e1ltozatot.</p> <pre><code>if (id != null)\n{\n    //await GetProductAsync(int.Parse(id));\n    var p = await GetProduct2Async(int.Parse(id));\n    Console.WriteLine($\"{p.Name}: {p.UnitPrice}.-\");\n}\n</code></pre> <p>\u00c1ll\u00edtsuk be, hogy a szerver \u00e9s a kliensoldal is elinduljon, majd pr\u00f3b\u00e1ljuk ki, hogy megjelenik-e a k\u00e9rt term\u00e9k neve \u00e9s \u00e1ra.</p> <p>NSwag be\u00e1ll\u00edt\u00e1sai</p> <p>Ez csak egy minim\u00e1lp\u00e9lda volt, az NSwag nagyon sok be\u00e1ll\u00edt\u00e1ssal rendelkezik.</p> <p>A kliensre innent\u0151l nem lesz sz\u00fcks\u00e9g, be\u00e1ll\u00edthatjuk, hogy csak a szerver induljon.</p> <p>Helyes st\u00e1tuszk\u00f3dok</p> <p>A gener\u00e1lt kliens helyes m\u0171k\u00f6d\u00e9s\u00e9hez a m\u0171veletek minden nem hib\u00e1t jelz\u0151 st\u00e1tuszk\u00f3djait (2xx) dokument\u00e1lnunk kellene Swagger-ben a <code>ProducesResponseType</code> attrib\u00fatummal, k\u00fcl\u00f6nben helyes szerver oldali lefut\u00e1s ut\u00e1n is kliensoldalon nem v\u00e1rt st\u00e1tuszk\u00f3d hib\u00e1t kaphatunk.</p>"},{"location":"seminar/08-client/chapter8/#hibakezeles-ii","title":"Hibakezel\u00e9s II.","text":""},{"location":"seminar/08-client/chapter8/#409-conflict-konkurenciakezeles","title":"409 Conflict - konkurenciakezel\u00e9s","text":"<p>Konfigur\u00e1ljuk fel a <code>Product</code> entit\u00e1st \u00fagy, hogy az esetleges konkurenciahelyzeteket is felismerje a friss\u00edt\u00e9s sor\u00e1n. Jel\u00f6lj\u00fcnk ki egy kit\u00fcntetett mez\u0151t (<code>RowVersion</code>), amit minden update m\u0171veletkor friss\u00edt\u00fcnk, \u00edgy ez az eg\u00e9sz rekordra vonatkoz\u00f3 konkurenciatokenk\u00e9nt is felfoghat\u00f3.</p> <p>Ehhez vegy\u00fcnk fel egy <code>byte[]</code>-t a <code>Product</code> entit\u00e1s oszt\u00e1lyba <code>RowVersion</code> n\u00e9ven.</p> <pre><code>public class Product\n{\n    //...\n    public byte[] RowVersion { get; set; } = null!;\n}\n</code></pre> <p>\u00c1ll\u00edtsuk be az EF kontextben (<code>OnModelCreating</code>), hogy minden m\u00f3dos\u00edt\u00e1sn\u00e1l friss\u00edtse ezt a mez\u0151t \u00e9s ez legyen a konkurenciatoken, az <code>IsRowVersion</code> f\u00fcggv\u00e9ny ezt egyben el is int\u00e9zi:</p> <pre><code>modelBuilder.Entity&lt;Product&gt;()\n    .Property(p =&gt; p.RowVersion)\n    .IsRowVersion();\n</code></pre> <p>Mi t\u00f6rt\u00e9nik a h\u00e1tt\u00e9rben?</p> <p>A h\u00e1tt\u00e9rben az EF a m\u00f3dos\u00edt\u00e1s sor\u00e1n egy plusz felt\u00e9telt csemp\u00e9sz az UPDATE SQL utas\u00edt\u00e1sba, m\u00e9gpedig, hogy az adatb\u00e1zisban l\u00e9v\u0151 <code>RowVersion</code> mez\u0151 adatb\u00e1zisbeli \u00e9rt\u00e9ke az ugyanaz-e mint, amit \u0151 ismert (a kliens \u00e1ltal l\u00e1tott) \u00e9rt\u00e9ke. Ha ez a felt\u00e9tel s\u00e9r\u00fcl, akkor konkurenciahelyzet \u00e1ll fent, mivel valaki m\u00e1r megv\u00e1ltoztatta az adatb\u00e1zisban l\u00e9v\u0151 \u00e9rt\u00e9ket.</p> <p>Migr\u00e1lnunk kell, mert megjelent egy \u00faj mez\u0151 a <code>Products</code> t\u00e1bl\u00e1nkban. Ne felejts\u00fck el a szok\u00e1sos m\u00f3don be\u00e1ll\u00edtani a Default Project-et a DAL-ra a Package Manager Console-ban!</p> <pre><code>Add-Migration ProductRowVersion\nUpdate-Database\n</code></pre> <p>M\u00e9g a <code>Product</code> DTO oszt\u00e1lyba is fel kell vegy\u00fck a <code>RowVersion</code> tulajdons\u00e1got \u00e9s legyen ez is k\u00f6telez\u0151.</p> <pre><code>public record Product\n{\n    //...\n    [Required(ErrorMessage = \"RowVersion is required\")]\n    public byte[] RowVersion { get; init; } = null!;\n}\n</code></pre> <p>Konkurenciahelyzet eset\u00e9n a 409-es hibak\u00f3ddal szok\u00e1s visszat\u00e9rni, illetve PUT m\u0171velet sor\u00e1n a v\u00e1lasz azt is tartalmazhatja, hogy melyek voltak az \u00fctk\u00f6z\u0151 mez\u0151k. Az \u00fctk\u00f6z\u00e9s felold\u00e1sa tipikusan nem feladatunk ilyenkor.</p> <p>K\u00e9sz\u00edts\u00fcnk egy saj\u00e1t <code>ProblemDetails</code> lesz\u00e1rmazottat. Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t ErrorHandling n\u00e9ven az Api projektben \u00e9s bele egy \u00faj oszt\u00e1lyt <code>ConcurrencyProblemDetails</code> n\u00e9ven, az al\u00e1bbi implement\u00e1ci\u00f3val:</p> <pre><code>public record Conflict(object? CurrentValue, object? SentValue);\n\npublic class ConcurrencyProblemDetails : ProblemDetails\n{\n    public Dictionary&lt;string, Conflict&gt; Conflicts { get; }\n\n    public ConcurrencyProblemDetails(DbUpdateConcurrencyException ex)\n    {\n        Status = 409;\n\n        Conflicts = new Dictionary&lt;string, Conflict&gt;();\n        var entry = ex.Entries[0];\n        var props = entry.Properties\n            .Where(p =&gt; !p.Metadata.IsConcurrencyToken).ToArray();\n        var currentValues = props.ToDictionary(\n            p =&gt; p.Metadata.Name, p =&gt; p.CurrentValue);\n\n        entry.Reload();\n\n        foreach (var property in props)\n        {\n            if (!Equals(currentValues[property.Metadata.Name], property.CurrentValue))\n            {\n                Conflicts[property.Metadata.Name] = new Conflict\n                (\n                    property.CurrentValue,\n                    currentValues[property.Metadata.Name]\n                );\n            }\n        }\n    }\n}\n</code></pre> <p>A fenti megval\u00f3s\u00edt\u00e1s \u00f6sszeszedi az egyes property-khez (a <code>Dictionary</code> kulcsa) a jelenlegi (<code>CurrentValue</code>) \u00e9s a kliens \u00e1ltal k\u00fcld\u00f6tt (<code>SentValue</code>) \u00e9rt\u00e9ket. Adjunk egy \u00fajabb lek\u00e9pez\u00e9st a hibakezel\u0151 MW-hez a legfels\u0151 szint\u0171 k\u00f3dban:</p> <pre><code>builder.Services.AddProblemDetails(options =&gt;\n    options.CustomizeProblemDetails = context =&gt;\n    {\n        if (context.HttpContext.Features.Get&lt;IExceptionHandlerFeature&gt;()?.Error is EntityNotFoundException ex)\n        {\n            // ...\n        }\n        else if (context.HttpContext.Features.Get&lt;IExceptionHandlerFeature&gt;()?.Error is DbUpdateConcurrencyException ex)\n        {\n            context.HttpContext.Response.StatusCode = StatusCodes.Status409Conflict;\n            context.ProblemDetails = new ConcurrencyProblemDetails(ex);\n        }\n    }\n);\n</code></pre> <p>Ezzel k\u00e9sz is az implement\u00e1ci\u00f3nk, amit Postman-b\u0151l fogjuk kipr\u00f3b\u00e1lni. A k\u00e9sz k\u00f3d el\u00e9rhet\u0151 a net8-client-megoldas \u00e1gon.</p> <p>Konkurencia mez\u0151 besz\u00far\u00e1s eset\u00e9ben</p> <p>A k\u00f6telez\u0151en kit\u00f6ltend\u0151 konkurencia mez\u0151 besz\u00far\u00e1sn\u00e1l kellemetlen, hiszen kliensoldalon m\u00e9g nem tudhat\u00f3 a token kezdeti \u00e9rt\u00e9ke. Ilyenkor haszn\u00e1lhatunk b\u00e1rmilyen \u00e9rt\u00e9ket, az adatb\u00e1zis fogja a kezdeti token \u00e9rt\u00e9ket be\u00e1ll\u00edtani.</p> <p>Ezt feloldhatn\u00e1nk \u00fagy, hogy a k\u00fcl\u00f6nb\u00f6z\u0151 CRUD m\u0171veletekhez k\u00fcl\u00f6n DTO-kat haszn\u00e1lunk, ahol a <code>RowVersion</code> mez\u0151 csak a friss\u00edt\u00e9sn\u00e9l k\u00f6telez\u0151. Ezt a megold\u00e1st azonban nem fogjuk most bemutatni.</p>"},{"location":"seminar/08-client/chapter8/#postman-hasznalata","title":"Postman haszn\u00e1lata","text":"<p>Postman seg\u00edts\u00e9g\u00e9vel \u00f6ssze\u00e1ll\u00edtunk egy olyan h\u00edv\u00e1si sorozatot, ami k\u00e9t felhaszn\u00e1l\u00f3 \u00e1tlapol\u00f3d\u00f3 m\u00f3dos\u00edt\u00f3 m\u0171velet\u00e9t szimul\u00e1lja. A k\u00e9t felhaszn\u00e1l\u00f3 ugyanazt a term\u00e9ket (tej) fogja m\u00f3dos\u00edtani, ezzel konkurenciahelyzetet el\u0151id\u00e9zve.</p>"},{"location":"seminar/08-client/chapter8/#kollekcio-generalas-openapi-leiro-alapjan","title":"Kollekci\u00f3 gener\u00e1l\u00e1s OpenAPI le\u00edr\u00f3 alapj\u00e1n","text":"<p>A Postman k\u00e9pes az OpenAPI le\u00edr\u00f3 alapj\u00e1n p\u00e9ldah\u00edv\u00e1sokat gener\u00e1lni. Ehhez ind\u00edtsuk el a szerveralkalmaz\u00e1sunkat \u00e9s a Postman-t is. A Postman-ben f\u00f6l\u00fcl az Import gombot v\u00e1lasztva adjuk meg az OpenAPI le\u00edr\u00f3 swagger.json URL-j\u00e9t (amit az elind\u00edtott BE /swagger oldal\u00e1n a c\u00edmsor alatt tal\u00e1lunk). A felugr\u00f3 ablakban csak a Generate collection from imported APIs opci\u00f3t v\u00e1lasszuk. Ezut\u00e1n megjelenik egy \u00faj Postman API \u00e9s egy \u00faj kollekci\u00f3 is My Title n\u00e9ven - ezeket nevezz\u00fck \u00e1t WebApiLab-ra (menu:jobbklikk a n\u00e9ven[Rename]).</p> <p>Import\u00e1l\u00e1s</p> <p>Tov\u00e1bbi seg\u00edts\u00e9g a dokument\u00e1ci\u00f3ban.</p> <p>A kollekci\u00f3ban mind az \u00f6t m\u0171veletre tal\u00e1lhat\u00f3 p\u00e9ldah\u00edv\u00e1s.</p>"},{"location":"seminar/08-client/chapter8/#valtozok","title":"V\u00e1ltoz\u00f3k","text":"<p>A v\u00e1ltoz\u00f3kat a k\u00e9r\u00e9seken bel\u00fcli \u00e9s a k\u00e9r\u00e9sek k\u00f6z\u00f6tti adat\u00e1tad\u00e1sra haszn\u00e1lhatjuk. T\u00f6bb hat\u00f3k\u00f6r (scope) k\u00f6z\u00fcl v\u00e1laszthatunk, amikor defini\u00e1lunk egy v\u00e1ltoz\u00f3t: glob\u00e1lis, kollekci\u00f3n bel\u00fcli, k\u00f6rnyezeten bel\u00fcli, k\u00e9r\u00e9sen bel\u00fcli lok\u00e1lis. S\u0151t, egy adott nev\u0171 v\u00e1ltoz\u00f3t is defini\u00e1lhatunk t\u00f6bb szinten is - ilyenkor a specifikusabb fel\u00fcl\u00edrja az \u00e1ltal\u00e1nosabbat. Ebben a p\u00e9ld\u00e1ban mi most csak a kollekci\u00f3 szintet fogjuk haszn\u00e1lni.</p> <p>A kollekci\u00f3t kiv\u00e1lasztva egy \u00faj f\u00fcl jelenik meg, itt a Variables f\u00fcl\u00f6n \u00e1ll\u00edthatjuk a v\u00e1ltoz\u00f3kat, illetve megn\u00e9zhetj\u00fck az aktu\u00e1lis \u00e9rt\u00e9k\u00fcket.</p> <p>V\u00e1ltoz\u00f3k</p> <p>Tov\u00e1bbi seg\u00edts\u00e9g a kollekci\u00f3 v\u00e1ltoz\u00f3k felv\u00e9tel\u00e9hez a dokument\u00e1ci\u00f3ban.</p> <p>Vegy\u00fck fel az al\u00e1bbi v\u00e1ltoz\u00f3kat:</p> <ul> <li><code>u1_allprods</code> - az els\u0151 felhaszn\u00e1l\u00f3 \u00e1ltal lek\u00e9rdezett \u00f6sszes term\u00e9k adata</li> <li><code>u1_tejid</code> - az el\u0151z\u0151 list\u00e1b\u00f3l az els\u0151 felhaszn\u00e1l\u00f3 \u00e1ltal kiv\u00e1lasztott term\u00e9k (tej) azonos\u00edt\u00f3ja</li> <li><code>u1_tej</code> - az el\u0151bbi azonos\u00edt\u00f3 alapj\u00e1n lek\u00e9rdezett term\u00e9k adata</li> <li><code>u1_tej_deluxe</code> - az el\u0151bbi term\u00e9k m\u00f3dos\u00edtott term\u00e9kadata, amit a felhaszn\u00e1l\u00f3 menteni k\u00edv\u00e1n</li> </ul> <p>Ne felejts\u00fck el elmenteni a kollekci\u00f3 v\u00e1ltoztat\u00e1sait a Save (Ctrl+S) gombbal.</p> <p>Ment\u00e9s</p> <p>A Postman nem ment automatikusan, ez\u00e9rt lehet\u0151leg mindig ments\u00fcnk (Ctrl+S), amikor egy m\u00e1sik h\u00edv\u00e1s, kollekci\u00f3 szerkeszt\u00e9s\u00e9re t\u00e9r\u00fcnk \u00e1t.</p>"},{"location":"seminar/08-client/chapter8/#mappak","title":"Mapp\u00e1k","text":"<p>A k\u00e9r\u00e9seinket k\u00fcl\u00f6n mapp\u00e1kba szervezve elk\u00fcl\u00f6n\u00edthetj\u00fck a kollekci\u00f3n bel\u00fcl az egyes (r\u00e9sz)folyamatokat. Mapp\u00e1kat a kollekci\u00f3 extra men\u00fcj\u00e9n (a kollekci\u00f3 neve mellett a \u2026 ikont megnyomva) bel\u00fcl az Add Folder men\u00fcpont seg\u00edts\u00e9g\u00e9vel vehet\u00fcnk fel.</p> <p>Vegy\u00fcnk fel a kollekci\u00f3nkba egy \u00faj mapp\u00e1t Update Tej n\u00e9ven.</p> <p>Mapp\u00e1k</p> <p>Tov\u00e1bbi seg\u00edts\u00e9g \u00faj mappa felv\u00e9tel\u00e9hez a dokument\u00e1ci\u00f3ban.</p>"},{"location":"seminar/08-client/chapter8/#egy-felhasznalo-folyamata","title":"Egy felhaszn\u00e1l\u00f3 folyamata","text":"<p>Egy tipikus m\u00f3dos\u00edt\u00f3 folyamat felhaszn\u00e1l\u00f3i szempontb\u00f3l az al\u00e1bbi l\u00e9p\u00e9sekb\u0151l \u00e1ll - az egyes l\u00e9p\u00e9sekhez szerveroldali API m\u0171veletek kapcsol\u00f3dnak, ezeket a listaelemekhez hozz\u00e1 is rendelhetj\u00fck:</p> <ul> <li>\u00f6sszes term\u00e9k megjelen\u00edt\u00e9se - API: \u00f6sszes term\u00e9k lek\u00e9rdez\u00e9se</li> <li>m\u00f3dos\u00edtani k\u00edv\u00e1nt term\u00e9k kiv\u00e1laszt\u00e1sa - API: nincs teend\u0151, tiszt\u00e1n kliensoldali m\u0171velet</li> <li>a m\u00f3dos\u00edtani k\u00edv\u00e1nt term\u00e9k r\u00e9szletes adatainak megjelen\u00edt\u00e9se - API: egy term\u00e9k adatainak lek\u00e9rdez\u00e9se</li> <li>a k\u00edv\u00e1nt m\u00f3dos\u00edt\u00e1s(ok) bevitele - API: nincs, tiszt\u00e1n kliensoldali m\u0171velet</li> <li>ment\u00e9s - API: adott term\u00e9k m\u00f3dos\u00edt\u00e1sa</li> <li>(vissza) navig\u00e1ci\u00f3 + aktu\u00e1lis (friss\u00edtett) \u00e1llapot megjelen\u00edt\u00e9se - API: \u00f6sszes term\u00e9k lek\u00e9rdez\u00e9se</li> </ul> <p>A n\u00e9gy API h\u00edv\u00e1st kl\u00f3nozzuk (Ctrl+D) a gener\u00e1lt p\u00e9ldah\u00edv\u00e1sokb\u00f3l. Egy adott h\u00edv\u00e1sra csin\u00e1ljunk egy kl\u00f3nt (jobbklikk \u2192 Duplicate), drag-and-drop-pal h\u00fazzuk r\u00e1 az \u00faj mapp\u00e1nkra, v\u00e9g\u00fcl nevezz\u00fck \u00e1t (Ctrl+E). Ezekre a h\u00edv\u00e1sokra csin\u00e1ljuk meg:</p> <ul> <li>\u00f6sszes term\u00e9k lek\u00e9rdez\u00e9se (m\u00f3dos\u00edt\u00e1s el\u0151tt), azaz Products Get All p\u00e9ldah\u00edv\u00e1s, nevezz\u00fck \u00e1t erre: [U1]GetAllProductsBefore</li> <li>egy term\u00e9k adatainak lek\u00e9rdez\u00e9se, azaz az <code>{id}</code> mapp\u00e1n bel\u00fcli Get a specific product with the given identifier p\u00e9ldah\u00edv\u00e1s, nevezz\u00fck \u00e1t erre [U1]GetTejDetails</li> <li>adott term\u00e9k m\u00f3dos\u00edt\u00e1sa, azaz az <code>{id}</code> mapp\u00e1n bel\u00fcli Products Put p\u00e9ldah\u00edv\u00e1s, nevezz\u00fck \u00e1t erre [U1]UpdateTej</li> <li>\u00f6sszes term\u00e9k lek\u00e9rdez\u00e9se (m\u00f3dos\u00edt\u00e1s ut\u00e1n), azaz Products Get All p\u00e9ldah\u00edv\u00e1s, nevezz\u00fck \u00e1t erre: [U1]GetAllProductsAfter</li> </ul> <p></p> Postman h\u00edv\u00e1sok - egy felhaszn\u00e1l\u00f3 folyamata <p>Warning</p> <p>Vegy\u00fck \u00e9szre, hogy az elnevez\u00e9sek az OpenAPI le\u00edr\u00f3 alapj\u00e1n gener\u00e1l\u00f3dnak, teh\u00e1t ha m\u00e1shogy dokument\u00e1ltuk az API-nkat, akkor m\u00e1s lesz a p\u00e9ldah\u00edv\u00e1sok neve is.</p>"},{"location":"seminar/08-client/chapter8/#osszes-termek-lekerdezese-sajat-vizualizacio-es-adattarolas-valtozoba","title":"\u00d6sszes term\u00e9k lek\u00e9rdez\u00e9se, saj\u00e1t vizualiz\u00e1ci\u00f3 \u00e9s adatt\u00e1rol\u00e1s v\u00e1ltoz\u00f3ba","text":"<p>Az [U1]GetAllProductsBefore h\u00edv\u00e1s m\u00e1r most is kipr\u00f3b\u00e1lhat\u00f3 k\u00fcl\u00f6n a Send gombbal \u00e9s az als\u00f3 Body r\u00e9szen l\u00e1that\u00f3 az eredm\u00e9ny form\u00e1zott (Pretty) \u00e9s nyers (Raw) n\u00e9zetben.</p> <p>Saj\u00e1t vizualiz\u00e1ci\u00f3t is \u00edrhatunk, ehhez a k\u00e9r\u00e9s Tests f\u00fcl\u00e9t haszn\u00e1lhatjuk. Az ide \u00edrt JavaScript nyelv\u0171 k\u00f3d a k\u00e9r\u00e9s ut\u00e1n fog lefutni. \u00c1ltal\u00e1ban a v\u00e1laszra vonatkoz\u00f3 teszteket szoktuk ide \u00edrni.</p> <p>\u00cdrjuk be a k\u00e9r\u00e9s Tests f\u00fcl\u00e9n l\u00e9v\u0151 sz\u00f6vegdobozba az al\u00e1bbi k\u00f3dot, ami egy t\u00e1bl\u00e1zatos form\u00e1ba form\u00e1zza a v\u00e1lasz JSON fontosabb adatait:</p> <pre><code>const template = `\n    &lt;table bgcolor=\"#FFFFFF\"&gt;\n        &lt;tr&gt;\n            &lt;th&gt;Name&lt;/th&gt;\n            &lt;th&gt;Unit price&lt;/th&gt;\n            &lt;th&gt;[Hidden]Concurrency token&lt;/th&gt;\n        &lt;/tr&gt;\n\n        {{#each response}}\n            &lt;tr&gt;\n                &lt;td&gt;{{name}}&lt;/td&gt;\n                &lt;td&gt;{{unitPrice}}&lt;/td&gt;\n                &lt;td&gt;{{rowVersion}}&lt;/td&gt;\n            &lt;/tr&gt;\n        {{/each}}\n    &lt;/table&gt;\n`;\nconst respJson = pm.response.json();\npm.visualizer.set(template, {\n    response: respJson\n});\n</code></pre> <p>Vizualiz\u00e1ci\u00f3</p> <p>Tov\u00e1bbi seg\u00edts\u00e9g a vizualiz\u00e1ci\u00f3khoz a dokument\u00e1ci\u00f3ban.</p> <p>A visszakapott adatokra a k\u00e9s\u0151bbi l\u00e9p\u00e9seknek is sz\u00fcks\u00e9g\u00fck lesz, ez\u00e9rt ments\u00fck el az <code>u1_allprods</code> v\u00e1ltoz\u00f3ba.</p> <pre><code>pm.visualizer.set(template, {\n    response: respJson\n});\n\npm.collectionVariables.set(\"u1_allprods\", JSON.stringify(respJson));\n</code></pre> <p>Soros\u00edt\u00e1s v\u00e1ltoz\u00f3kba</p> <p>V\u00e1ltoz\u00f3ba mindig soros\u00edtott (pl. egyszer\u0171 sz\u00f6veg t\u00edpus\u00fa) adatot ments\u00fcnk, ne k\u00f6zvetlen\u00fcl a JavaScript v\u00e1ltoz\u00f3kat. Ezzel elker\u00fclhetj\u00fck a JavaScript t\u00edpusok \u00e9s a Postman v\u00e1ltoz\u00f3k k\u00f6z\u00f6tti konverzi\u00f3s probl\u00e9m\u00e1kat.</p> <p>Pr\u00f3b\u00e1ljuk ki \u00edgy a k\u00e9r\u00e9st, alul a Body f\u00fcl Visualize alf\u00fcl\u00e9n t\u00e1bl\u00e1zatos megjelen\u00edt\u00e9snek kell megjelennie, illetve a kollekci\u00f3 v\u00e1ltoz\u00f3kezel\u0151 fel\u00fclet\u00e9n az <code>u1_allprods</code> \u00e9rt\u00e9kbe be kellett \u00edr\u00f3dnia a teljes v\u00e1lasz t\u00f6rzsnek.</p> <p>V\u00e1ltoz\u00f3k</p> <p>Nem k\u00f6telez\u0151 el\u0151zetesen felvenni a v\u00e1ltoz\u00f3kat, a <code>set</code> h\u00edv\u00e1s hat\u00e1s\u00e1ra l\u00e9trej\u00f6n, ha m\u00e9g nem l\u00e9tezik.</p> <p>Scriptek</p> <p>Tov\u00e1bbi seg\u00edts\u00e9g szkriptek \u00edr\u00e1s\u00e1hoz a dokument\u00e1ci\u00f3ban.</p>"},{"location":"seminar/08-client/chapter8/#egy-termek-reszletes-adatainak-lekerdezese-valtozok-felhasznalasa","title":"Egy term\u00e9k r\u00e9szletes adatainak lek\u00e9rdez\u00e9se, v\u00e1ltoz\u00f3k felhaszn\u00e1l\u00e1sa","text":"<p>A forgat\u00f3k\u00f6nyv\u00fcnk szerint a felhaszn\u00e1l\u00f3 a term\u00e9kek list\u00e1j\u00e1b\u00f3l kiv\u00e1laszt egy term\u00e9ket (a Tej nev\u0171t). Ezt a l\u00e9p\u00e9st szkriptb\u0151l szimul\u00e1ljuk, mint az [U1]GetTejDetails h\u00edv\u00e1s el\u0151tt lefut\u00f3 szkript. A h\u00edv\u00e1s el\u0151tt fut\u00f3 szkripteket a h\u00edv\u00e1s Pre-request Script f\u00fcl\u00e9n l\u00e9v\u0151 sz\u00f6vegdobozba \u00edrhatjuk:</p> <pre><code>const allProds = JSON.parse(pm.collectionVariables.get(\"u1_allprods\"));\nconst tejid = allProds.find(({ name }) =&gt; name.startsWith('Tej')).id;\npm.collectionVariables.set(\"u1_tejid\", tejid);\n</code></pre> <p>Teh\u00e1t kiolvassuk az elmentett term\u00e9klist\u00e1t, kikeress\u00fck a Tej nev\u0171 elemet, vessz\u00fck annak azonos\u00edt\u00f3j\u00e1t, amit elment\u00fcnk az <code>u1_tejid</code> v\u00e1ltoz\u00f3ba. Ezt a v\u00e1ltoz\u00f3t m\u00e1r fel is haszn\u00e1ljuk a k\u00e9r\u00e9s param\u00e9terek\u00e9nt: a Params f\u00fcl\u00f6n az <code>id</code> nev\u0171 URL param\u00e9ter (Path Variable) \u00e9rt\u00e9ke legyen <code>{{u1_tejid}}</code></p> <p>A k\u00e9r\u00e9s lefut\u00e1sa ut\u00e1n ments\u00fck el a v\u00e1lasz t\u00f6rzs\u00e9t az <code>u1_tej</code> v\u00e1ltoz\u00f3ba. A Tests f\u00fcl\u00f6n l\u00e9v\u0151 sz\u00f6vegdobozba:</p> <pre><code>pm.collectionVariables.set(\"u1_tej\", pm.response.text());\n</code></pre> <p>R\u00e9szletes adatok</p> <p>Ezt a f\u00e1zist ki is lehetne hagyni, mert a list\u00e1ban m\u00e1r minden sz\u00fcks\u00e9ges adat benne volt a m\u00f3dos\u00edt\u00e1shoz, de \u00e1ltal\u00e1noss\u00e1gban gyakori, hogy egy r\u00e9szletes n\u00e9zeten lehet a m\u00f3dos\u00edt\u00e1st elv\u00e9gezni, ami a r\u00e9szletes adatok lek\u00e9rdez\u00e9s\u00e9vel j\u00e1r.</p>"},{"location":"seminar/08-client/chapter8/#modositott-termek-mentese","title":"M\u00f3dos\u00edtott term\u00e9k ment\u00e9se","text":"<p>Miel\u0151tt a m\u00f3dos\u00edtott term\u00e9ket elk\u00fclden\u00e9nk a szervernek, szimul\u00e1ljuk mag\u00e1t a felhaszn\u00e1l\u00f3i m\u00f3dos\u00edt\u00e1st. Az [U1]UpdateTej h\u00edv\u00e1s Pre-request Script-je legyen ez:</p> <pre><code>const tej = JSON.parse(pm.collectionVariables.get(\"u1_tej\"));\ntej.unitPrice++;\npm.collectionVariables.set(\"u1_tej_deluxe\", JSON.stringify(tej));\n</code></pre> <p>L\u00e1that\u00f3, hogy a m\u00f3dos\u00edtott term\u00e9kadatot egy \u00faj v\u00e1ltoz\u00f3ba (<code>u1_tej_deluxe</code>) mentj\u00fck. Enn\u00e9l a h\u00edv\u00e1sn\u00e1l is a Params f\u00fcl\u00f6n az <code>id</code> nev\u0171 URL param\u00e9ter (Path Variable) \u00e9rt\u00e9ke legyen <code>{{u1_tejid}}</code>. Viszont itt m\u00e1r a k\u00e9r\u00e9s t\u00f6rzs\u00e9t is ki kell t\u00f6lteni a m\u00f3dos\u00edtott term\u00e9kadattal. Mivel ez meg is van v\u00e1ltoz\u00f3ban, \u00edgy el\u00e9g a Body f\u00fcl sz\u00f6vegdoboz\u00e1ba (Raw n\u00e9zetben) csak ennyit be\u00edrni: <code>{{u1_tej_deluxe}}</code>.</p>"},{"location":"seminar/08-client/chapter8/#frissitett-termeklista-lekerdezese-folyamat-futtatasa","title":"Friss\u00edtett term\u00e9klista lek\u00e9rdez\u00e9se, folyamat futtat\u00e1sa","text":"<p>Az utols\u00f3 folyamatl\u00e9p\u00e9sn\u00e9l m\u00e1r nincs sok teend\u0151, ha akarunk vizualiz\u00e1ci\u00f3t, akkor a Tests f\u00fcl sz\u00f6vegdoboz\u00e1ba m\u00e1soljuk \u00e1t a fentebbi vizualiz\u00e1ci\u00f3s szkriptet.</p> <p>Egy k\u00e9r\u00e9ssorozat futtat\u00e1s\u00e1hoz haszn\u00e1lhat\u00f3 a Collection Runner funkci\u00f3, ami a kollekci\u00f3 vagy egy almapp\u00e1j\u00e1nak oldal\u00e1r\u00f3l (ami a kollekci\u00f3/almappa kiv\u00e1laszt\u00e1sakor jelenik meg) a jobb sz\u00e9len a Save melletti Run gombra nyomva hozhat\u00f3 el\u0151. A megjelen\u0151 ablak bal oldal\u00e1n megjelennek a v\u00e1lasztott kollekci\u00f3/mappa alatti h\u00edv\u00e1sok, amiket sz\u0171rhet\u00fcnk (a h\u00edv\u00e1sok el\u0151tti jel\u00f6l\u0151dobozzal), illetve sorrendezhet\u00fcnk (a sor legelej\u00e9n l\u00e9v\u0151 foganty\u00faval).</p> <p>Futtat\u00e1s</p> <p>Tov\u00e1bbi seg\u00edts\u00e9g kollekci\u00f3k futtat\u00e1s\u00e1hoz a dokument\u00e1ci\u00f3ban.</p> <p>Az eddig elk\u00e9sz\u00fclt folyamatunk futtat\u00e1s\u00e1hoz v\u00e1lasszuk ki az Update Tej mapp\u00e1t. \u00c9rdemes be\u00e1ll\u00edtani a jobb r\u00e9szen a Save responses jel\u00f6l\u0151t, \u00edgy a lefut\u00e1s ut\u00e1n megvizsg\u00e1lhatjuk az egyes k\u00e9r\u00e9sekre j\u00f6tt v\u00e1laszokat.</p> <p></p> Postman Runner konfigur\u00e1l\u00e1sa egy felhaszn\u00e1l\u00f3 folyamat\u00e1nak futtat\u00e1s\u00e1hoz <p>Pr\u00f3b\u00e1ljuk lefuttatni a folyamatot, a lefut\u00e1s ut\u00e1n a v\u00e1laszokban ellen\u0151rizz\u00fck a term\u00e9kadatokat (kattintsuk meg a h\u00edv\u00e1st, majd a felugr\u00f3 ablakocsk\u00e1ban v\u00e1lasszuk a Response Body r\u00e9szt), k\u00fcl\u00f6n\u00f6sen az utols\u00f3 h\u00edv\u00e1s ut\u00e1nit - a tej \u00e1r\u00e1nak meg kellett v\u00e1ltoznia az els\u0151 h\u00edv\u00e1shoz k\u00e9pest.</p> <p></p> Postman Runner - egy felhaszn\u00e1l\u00f3 folyamat\u00e1nak lefut\u00e1sa"},{"location":"seminar/08-client/chapter8/#a-masodik-felhasznalo-folyamata","title":"A m\u00e1sodik felhaszn\u00e1l\u00f3 folyamata","text":"<p>Az al\u00e1bbi l\u00e9p\u00e9sekkel \u00e1ll\u00edtsuk el\u0151 a m\u00e1sodik felhaszn\u00e1l\u00f3 folyamat\u00e1t:</p> <ul> <li>vegy\u00fcnk fel minden <code>u1</code> v\u00e1ltoz\u00f3 alapj\u00e1n \u00faj v\u00e1ltoz\u00f3t <code>u2</code> n\u00e9vkezdettel</li> <li>duplik\u00e1ljunk minden [U1] h\u00edv\u00e1st, a kl\u00f3nok neve legyen ugyanaz, mint az eredeti\u00e9, de kezd\u0151dj\u00f6n [U2]-vel</li> <li>a kl\u00f3nok minden szkriptj\u00e9ben, illetve param\u00e9ter\u00e9ben \u00edrjunk \u00e1t minden <code>u1</code>-es v\u00e1ltoz\u00f3nevet <code>u2</code>-esre<ul> <li>az [U2]GetAllProductsBefore h\u00edv\u00e1sban a Tests f\u00fcl\u00f6n egy helyen</li> <li>az [U2]GetTejDetails h\u00edv\u00e1sban a Pre-request Script f\u00fcl\u00f6n k\u00e9t helyen, a Tests f\u00fcl\u00f6n egy helyen, illetve a Params f\u00fcl\u00f6n egy helyen</li> <li>az [U2]UpdateTej h\u00edv\u00e1sban a Pre-request Script f\u00fcl\u00f6n k\u00e9t helyen, a Body f\u00fcl\u00f6n egy helyen, illetve a Params f\u00fcl\u00f6n egy helyen</li> </ul> </li> <li>az [U2]UpdateTej h\u00edv\u00e1s Pre-request Script m\u00f3dos\u00edt\u00f3 utas\u00edt\u00e1s\u00e1t \u00edrjuk \u00e1t a lenti k\u00f3dra. A term\u00e9k nev\u00e9t m\u00f3dos\u00edtjuk, nem az \u00e1r\u00e1t, a konkurenciahelyzetet ugyanis akkor is \u00e9rz\u00e9kelni kell, ha a k\u00e9t felhaszn\u00e1l\u00f3 nem ugyanazt az adatmez\u0151t m\u00f3dos\u00edtja (ugyanazon term\u00e9ken bel\u00fcl).</li> </ul> <pre><code>tej.name = \"Tej \" + new Date().getTime();\n</code></pre> <p></p> Postman h\u00edv\u00e1sok - mindk\u00e9t felhaszn\u00e1l\u00f3 folyamata <p>Ezzel elk\u00e9sz\u00fclt a m\u00e1sodik felhaszn\u00e1l\u00f3 folyamata. Att\u00f3l f\u00fcgg\u0151en, hogy hogyan lapoltatjuk \u00e1t a n\u00e9gy-n\u00e9gy h\u00edv\u00e1st, kapunk vagy nem kapunk 409-es v\u00e1laszk\u00f3dot futtat\u00e1skor. Az al\u00e1bbi sorrend nem ad hib\u00e1t, hiszen a m\u00e1sodik felhaszn\u00e1l\u00f3 azut\u00e1n k\u00e9ri le a term\u00e9ket, hogy az els\u0151 felhaszn\u00e1l\u00f3 m\u00e1r m\u00f3dos\u00edtott:</p> <ol> <li>[U1]GetAllProductsBefore</li> <li>[U2]GetAllProductsBefore</li> <li>[U1]GetTejDetails</li> <li>[U1]UpdateTej</li> <li>[U1]GetAllProductsAfter</li> <li>[U2]GetTejDetails</li> <li>[U2]UpdateTej</li> <li>[U2]GetAllProductsAfter</li> </ol> <p>Az utols\u00f3 h\u00edv\u00e1s ut\u00e1n a tej \u00e1ra \u00e9s neve is megv\u00e1ltozott.</p> <p>Az al\u00e1bbi sorrend viszont hib\u00e1t ad, hiszen a m\u00e1sodik felhaszn\u00e1l\u00f3 m\u00e1r elavult <code>RowVersion</code>-t fog ment\u00e9skor elk\u00fcldeni:</p> <ol> <li>[U1]GetAllProductsBefore</li> <li>[U2]GetAllProductsBefore</li> <li>[U1]GetTejDetails</li> <li>[U2]GetTejDetails</li> <li>[U1]UpdateTej</li> <li>[U1]GetAllProductsAfter</li> <li>[U2]UpdateTej</li> <li>[U2]GetAllProductsAfter</li> </ol> <p></p> Postman Runner lefut\u00e1s konkurenciahelyzettel <p>Konkurenciakezel\u00e9s sor\u00e1n felhaszn\u00e1lhat\u00f3 adatok</p> <p>\u00c9rdemes megvizsg\u00e1lni a 409-es hibak\u00f3d\u00fa v\u00e1lasz t\u00f6rzs\u00e9t \u00e9s benne a v\u00e1ltozott mez\u0151k eredeti \u00e9s megv\u00e1ltozott \u00e9rt\u00e9k\u00e9t.</p> <p>Konkurenciakezel\u00e9s szab\u00e1lyai</p> <p>Ha igazi klienst \u00edrunk, figyelj\u00fcnk arra, hogy a konkurenciatokent mindig k\u00fcldj\u00fck le a kliensnek, a kliens v\u00e1ltozatlanul k\u00fcldje vissza a szerverre, \u00e9s a szerver pedig a m\u00f3dos\u00edt\u00e1s sor\u00e1n a klienst\u0151l kapott tokent szerepeltesse a m\u00f3dos\u00edtand\u00f3 entit\u00e1sban. A legt\u00f6bb hib\u00e1s implement\u00e1ci\u00f3 arra vezethet\u0151 vissza, hogy nem k\u00f6vetj\u00fck ezeket az elveket. Szerencs\u00e9re az adatel\u00e9r\u00e9si k\u00f3dunkban ezeknek a probl\u00e9m\u00e1knak a nagy r\u00e9sz\u00e9t megoldja az EF.</p> <p>Postman Runner</p> <p>H\u00edv\u00e1sokb\u00f3l \u00e1ll\u00f3 folyamatokat nem csak Runnerben \u00e1ll\u00edthatunk \u00f6ssze, hanem szkriptb\u0151l is. Ha \u00e9pp ellenkez\u0151leg, kevesebb szkriptel\u00e9st szeretn\u00e9nk, akkor a Postman Flows aj\u00e1nlott.</p> <p>Az elk\u00e9sz\u00fclt teljes Postman kollekci\u00f3 import\u00e1lhat\u00f3 err\u0151l a linkr\u0151l az OpenAPI import\u00e1l\u00e1shoz hasonl\u00f3 m\u00f3don. A kollekci\u00f3 szinten ne felejts\u00fck el be\u00e1ll\u00edtani a <code>baseUrl</code> v\u00e1ltoz\u00f3t a szerveralkalmaz\u00e1sunk alap URL-j\u00e9re.</p>"},{"location":"seminar/10-test/chapter10/","title":"Automatiz\u00e1lt tesztel\u00e9s","text":""},{"location":"seminar/10-test/chapter10/#segedeszkozok","title":"Seg\u00e9deszk\u00f6z\u00f6k","text":"<ul> <li>kapcsol\u00f3d\u00f3 GitHub repo: https://github.com/bmeviauav23/WebApiLab-kiindulo</li> </ul>"},{"location":"seminar/10-test/chapter10/#bevezetes","title":"Bevezet\u00e9s","text":"<p>Az automatiz\u00e1lt tesztel\u00e9s az alkalmaz\u00e1sfejleszt\u00e9s egyik fontos l\u00e9p\u00e9se, mivel ezzel tudunk meggy\u0151z\u0151dni arr\u00f3l, hogy egy-egy funkci\u00f3 akkor is helyesen m\u0171k\u00f6dik, ha az alkalmaz\u00e1s egy m\u00e1sik r\u00e9sz\u00e9n valamit m\u00f3dos\u00edtunk. Hogy ezt az ellen\u0151rz\u00e9st ne kelljen minden egyes alkalommal manu\u00e1lisan v\u00e9grehajtani az alkalmaz\u00e1son, programozott teszteket szoktunk \u00edrni, amelyek futtat\u00e1s\u00e1t CI/CD folyamatokban automatiz\u00e1lhatjuk.</p> <p>A tesztek t\u00f6bb t\u00edpus\u00e1t ismerhetj\u00fck:</p> <ul> <li>Unit test (egys\u00e9gteszt) c\u00e9lja, hogy egy adott oszt\u00e1ly egy met\u00f3dus\u00e1nak a viselked\u00e9s\u00e9t \u00f6nmag\u00e1ba vizsg\u00e1ljuk \u00fagy, hogy a f\u00fcgg\u0151s\u00e9geit mock/fake objektumokkal helyettes\u00edtj\u00fck, hogy azok a tesztesetnek megfelel\u0151en viselkedjenek vagy megfigyelhet\u0151ek legyenek.</li> <li>Integr\u00e1ci\u00f3s teszt / End-2-end teszt / funkcion\u00e1lis teszt eset\u00e9ben a c\u00e9lunk, hogy a teljes rendszert meghajtsuk \u00fagy, hogy az integr\u00e1ci\u00f3k (SQL kapcsolat, egy\u00e9b szolg\u00e1ltat\u00e1sok) is tesztel\u00e9sre ker\u00fclnek, illetve a BE szempontj\u00e1b\u00f3l vizsg\u00e1ljuk azt is, hogy a rendszer interf\u00e9sze helyesen v\u00e1laszol-e a k\u00fcl\u00f6nb\u00f6z\u0151 k\u00e9r\u00e9sekre.</li> <li>UI teszt eset\u00e9ben azt vizsg\u00e1ljuk, hogy a felhaszn\u00e1l\u00f3i fel\u00fclet a k\u00fcl\u00f6nb\u00f6z\u0151 felhaszn\u00e1l\u00f3i interakci\u00f3kra, esem\u00e9nyekre helyesen rajzolja-e ki az elv\u00e1rt fel\u00fcleteket.</li> </ul> <p>A fenti tesztel\u00e9si m\u00f3dok mindegyike fontos, de \u00e9rdemes egy olyan eg\u00e9szs\u00e9ges egyens\u00falyt megtal\u00e1lni, ahol a lehet\u0151 legjobban lefedhet\u0151ek a legfontosabb funkcionalit\u00e1sok k\u00fcl\u00f6nb\u00f6z\u0151 tesztesetekkel.</p>"},{"location":"seminar/10-test/chapter10/#automatizalt-teszteles-net-kornyezetben","title":"Automatiz\u00e1lt tesztel\u00e9s .NET k\u00f6rnyezetben","text":"<p>Automatiz\u00e1lt tesztel\u00e9sre t\u00f6bb keretrendszer is haszn\u00e1lhat\u00f3 .NET k\u00f6rnyezetben, de ASP.NET Core alkalmaz\u00e1sok eset\u00e9ben a legelterjedtebb ilyen k\u00f6nyvt\u00e1r az xUnit. Ebben a keretrendszerben lehet\u0151s\u00e9g\u00fcnk van tesztesetek defini\u00e1l\u00e1s\u00e1ra, ak\u00e1r a bemenetek vari\u00e1l\u00e1s\u00e1val is, illetve kell\u0151en rugalmas, ahhoz, hogy a tesztek feldolgoz\u00e1si mechanizmusa kiterjeszthet\u0151 legyen.</p> <p>Unit tesztek eset\u00e9ben az oszt\u00e1lyok f\u00fcgg\u0151s\u00e9geit le kell cser\u00e9lj\u00fck, amire t\u00f6bb library is lehet\u0151s\u00e9get ny\u00fajt. A legelterjedtebbek a Moq \u00e9s az NSubstitute.</p> <p>Gyakran sz\u00fcks\u00e9ges funkci\u00f3, hogy a bemen\u0151 adatok el\u0151\u00e1ll\u00edt\u00e1sa sor\u00e1n szeretn\u00e9nk a val\u00f3s\u00e1gra hasonl\u00edt\u00f3 v\u00e9letlenszer\u0171/gener\u00e1lt p\u00e9ldaadatokat megadni. Ehhez egy bev\u00e1lt oszt\u00e1lyk\u00f6nyvt\u00e1r a Bogus.</p> <p>A tesztesetek elv\u00e1rt eredm\u00e9ny\u00e9nek a vizsg\u00e1lat\u00e1t asszert\u00e1l\u00e1snak nevezz\u00fck (assert), aminek az \u00edr\u00e1s\u00e1hoz nagy seg\u00edts\u00e9get tud ny\u00fajtani a Fluent Assertions k\u00f6nyvt\u00e1r. Ez nem csak a szintaktik\u00e1t teszi olvashat\u00f3bb\u00e1 fluent szintakszissal, hanem t\u00f6bb olyan be\u00e9p\u00edtett seg\u00e9dlogik\u00e1t tartalmaz, amivel t\u00f6m\u00f6rebb\u00e9 tehet\u0151 az assert logika (pl.: objektumok m\u00e9lys\u00e9gi \u00f6sszehasonl\u00edt\u00e1sa \u00e9rt\u00e9k szerint).</p>"},{"location":"seminar/10-test/chapter10/#integracios-teszteles","title":"Integr\u00e1ci\u00f3s tesztel\u00e9s","text":"<p>Ezen gyakorlat keret\u00e9ben csak integr\u00e1ci\u00f3s teszteket fogunk k\u00e9sz\u00edteni.</p>"},{"location":"seminar/10-test/chapter10/#teszt-projekt","title":"Teszt projekt","text":"<p>Vegy\u00fcnk fel a solutionbe egy \u00faj xUnit (.NET 8) t\u00edpus\u00fa projektet <code>WebApiLab.Tests</code> n\u00e9ven. A l\u00e9trej\u00f6v\u0151 tesztoszt\u00e1lyt \u00e9s f\u00e1jlj\u00e1t nevezz\u00fck \u00e1t <code>ProductControllerTests</code> n\u00e9vre. Ide fogjuk a <code>ProductController</code>-hez kapcsol\u00f3d\u00f3 m\u0171veletekre vonatkoz\u00f3 integr\u00e1ci\u00f3s teszteket k\u00e9sz\u00edteni.</p> <p>Vegy\u00fck fel az al\u00e1bbi NuGet csomagokat a teszt projektbe. A Bogus*r\u00f3l \u00e9s a *Fluent Assertions*r\u0151l m\u00e1r volt sz\u00f3. A *Microsoft.AspNetCore.Mvc.Testing csomag olyan seg\u00e9dszolg\u00e1ltat\u00e1sokat ny\u00fajt, amivel integr\u00e1ci\u00f3s tesztekhez egy in-process teszt szervert tudunk futtatni, \u00e9s ennek a megh\u00edv\u00e1s\u00e1ban is seg\u00edts\u00e9get ny\u00fajt. A projektf\u00e1jlban a t\u00f6bbi <code>PackageReference</code> mell\u00e9 (menu:a projekten jobbklikk[Edit Project File]):</p> <pre><code>&lt;PackageReference Include=\"Bogus\" Version=\"35.5.1\" /&gt;\n&lt;PackageReference Include=\"FluentAssertions\" Version=\"6.12.0\" /&gt;\n&lt;PackageReference Include=\"Microsoft.AspNetCore.Mvc.Testing\" Version=\"8.0.4\" /&gt;\n</code></pre> <p>Vegy\u00fck fel az Api projektet projekt referenciak\u00e9nt a teszt projektbe. A projektf\u00e1jlban egy m\u00e1sik <code>ItemGroup</code> mell\u00e9:</p> <pre><code>&lt;ItemGroup&gt;\n  &lt;ProjectReference Include=\"..\\WebApiLab.Api\\WebApiLab.Api.csproj\" /&gt;\n&lt;/ItemGroup&gt;\n</code></pre>"},{"location":"seminar/10-test/chapter10/#teszt-szerver","title":"Teszt szerver","text":"<p>A tesztszervernek meg kell tudnunk mondani, hogy melyik oszt\u00e1ly adja az alkalmaz\u00e1sunk bel\u00e9p\u00e9si pontj\u00e1t. Viszont mivel top level statement szintaktik\u00e1j\u00fa a <code>Program</code> oszt\u00e1lyunk, annak l\u00e1that\u00f3s\u00e1ga internal, ami a tesztel\u00e9s szempontj\u00e1b\u00f3l nem szerencs\u00e9s (a hasonl\u00f3 esetekben alkalmazott <code>InternalsVisibleTo</code> sem lenne ebben az esetben megold\u00e1s). Helyette tegy\u00fck a <code>Program</code> oszt\u00e1lyt publikuss\u00e1 egy <code>partial</code> deklar\u00e1ci\u00f3val. Vegy\u00fck fel az al\u00e1bbi partial kieg\u00e9sz\u00edt\u00e9st az API projektben a legfels\u0151 szint\u0171 k\u00f3d v\u00e9g\u00e9re:</p> <pre><code>public partial class Program { }\n</code></pre> <p>Az integr\u00e1ci\u00f3s teszt\u00fcnkh\u00f6z az in-process teszt szervert egy <code>WebApplicationFactory&lt;TEntryPoint&gt;</code> lesz\u00e1rmazott oszt\u00e1ly fogja l\u00e9trehozni. Ez a seg\u00e9d \u0151soszt\u00e1ly a fenti Microsoft.AspNetCore.Mvc.Testing csomagb\u00f3l j\u00f6n. Itt lehet\u0151s\u00e9g\u00fcnk van a teszt szerver\u00fcnket konfigur\u00e1lni, \u00edgy ak\u00e1r a DI konfigur\u00e1ci\u00f3t is.</p> <p>Hozzunk l\u00e9tre egy oszt\u00e1lyt a teszt projektbe <code>CustomWebApplicationFactory</code> n\u00e9ven, ami sz\u00e1rmazzon a <code>WebApplicationFactory&lt;Program&gt;</code> oszt\u00e1lyb\u00f3l \u00e9s defini\u00e1ljuk fel\u00fcl a <code>CreateHost</code> met\u00f3dus\u00e1t.</p> <pre><code>public class CustomWebApplicationFactory : WebApplicationFactory&lt;Program&gt;\n{\n    protected override IHost CreateHost(IHostBuilder builder)\n    {\n        builder.UseEnvironment(\"Development\");\n        builder.ConfigureServices(services =&gt;\n        {\n            services.AddScoped(sp =&gt; new DbContextOptionsBuilder&lt;AppDbContext&gt;()\n                .UseSqlServer(@\"connection string\")\n                .UseApplicationServiceProvider(sp)\n                .Options);\n        });\n\n        var host = base.CreateHost(builder);\n\n        using var scope = host.Services.CreateScope();\n        scope.ServiceProvider.GetRequiredService&lt;AppDbContext&gt;()\n            .Database.EnsureCreated();\n\n        return host;\n    }\n}\n</code></pre> <p>Megfigyelhetj\u00fck, hogy itt is LocalDB-t haszn\u00e1lunk (mivel integr\u00e1ci\u00f3s teszt), de a connection stringet lecser\u00e9j\u00fck a DI konfigur\u00e1ci\u00f3ban. A connection string alapvet\u0151en egyezhet a tesztelend\u0151 projektben haszn\u00e1lttal, csak az adatb\u00e1zisnevet v\u00e1ltoztassuk meg. Az adatb\u00e1zis automatikusan l\u00e9trej\u00f6n \u00e9s a migr\u00e1ci\u00f3k is lefutnak az <code>EnsureCreated</code> megh\u00edv\u00e1s\u00e1val - az els\u0151 lefut\u00e1skor.</p> <p>DI Scope l\u00e9trehoz\u00e1sa</p> <p>Mivel az <code>AppDbContext</code> Scoped \u00e9letciklussal van regisztr\u00e1lva a DI-ba, sz\u00fcks\u00e9ges l\u00e9trehozni egy scope-ot, hogy el tudjuk k\u00e9rni a DI kont\u00e9nert\u0151l. Ezt term\u00e9szetesen ha HTTP k\u00e9r\u00e9s k\u00f6zben lenn\u00e9nk az ASP.NET Core automatikusan megtenn\u00e9.</p>"},{"location":"seminar/10-test/chapter10/#kontrollertesztek-elokeszitese","title":"Kontrollertesztek el\u0151k\u00e9sz\u00edt\u00e9se","text":"<p>Alak\u00edtsuk \u00e1t a <code>ProductControllerTests</code> oszt\u00e1lyt. Az oszt\u00e1ly val\u00f3s\u00edtsa meg az <code>IClassFixture&lt;CustomWebApplicationFactory&gt;</code> interf\u00e9szt, amivel azt tudjuk jelezni az xUnit-nak, hogy kezelje a <code>CustomWebApplicationFactory</code> \u00e9letciklus\u00e1t (tesztek k\u00f6z\u00f6tt megosztott objektum lesz), illetve pluszban lehet\u0151s\u00e9g\u00fcnk van ezt a tesztoszt\u00e1lyokban konstruktoron kereszt\u00fcl elk\u00e9rni.</p> <pre><code>public partial class ProductControllerTests : IClassFixture&lt;CustomWebApplicationFactory&gt;\n{\n    private readonly WebApplicationFactory&lt;Program&gt; _appFactory;\n\n    public ProductControllerTests(CustomWebApplicationFactory appFactory)\n    {\n        _appFactory = appFactory;\n    }\n}\n</code></pre> <p>xUnit Fixture</p> <p>Az xUnit nem tartalmaz DI kont\u00e9nert. Csak azok a konstruktorparam\u00e9terek t\u00f6lt\u0151dnek ki, amelyek a dokument\u00e1ci\u00f3ban megtal\u00e1lhat\u00f3k. A <code>CustomWebApplicationFactory</code> t\u00edpus\u00fa param\u00e9ter az\u00e9rt t\u00f6lt\u0151dik ki, mert az oszt\u00e1ly az interf\u00e9sz\u00e9ben jelzi, hogy megosztott kontextusk\u00e9nt <code>CustomWebApplicationFactory</code>-t v\u00e1r.</p> <p>Hozzunk l\u00e9tre a Bogus k\u00f6nyvt\u00e1rral egy olyan <code>Faker&lt;Product&gt;</code> objektumot, amivel az API-nak k\u00fcldend\u0151 DTO objektum gener\u00e1l\u00e1s\u00e1t v\u00e9gezz\u00fck el. Azonos\u00edt\u00f3k\u00e9nt k\u00fcldj\u00fcnk 0 \u00e9rt\u00e9ket, mivel a l\u00e9trehoz\u00e1s m\u0171veletet fogjuk tesztelni, kateg\u00f3ria eset\u00e9ben pedig az 1-et, mivel a migr\u00e1ci\u00f3 \u00e1ltal l\u00e9trehozott 1-es kateg\u00f3ri\u00e1t fogjuk tudni csak haszn\u00e1lni. A t\u00f6bbi esetben haszn\u00e1ljuk a Bogus be\u00e9p\u00edtett lehet\u0151s\u00e9geit a n\u00e9v \u00e9s a sz\u00e1m \u00e9rt\u00e9kek random gener\u00e1l\u00e1s\u00e1hoz.</p> <pre><code>// ...\nprivate readonly Faker&lt;Product&gt; _dtoFaker;\n\npublic ProductControllerTests(CustomWebApplicationFactory appFactory)\n{\n    // ...\n    _dtoFaker = new Faker&lt;Product&gt;()\n        .RuleFor(p =&gt; p.Id, 0)\n        .RuleFor(p =&gt; p.Name, f =&gt; f.Commerce.Product())\n        .RuleFor(p =&gt; p.UnitPrice, f =&gt; f.Random.Int(200, 20000))\n        .RuleFor(p =&gt; p.ShipmentRegion,\n                 f =&gt; f.PickRandom&lt;Dal.Entities.ShipmentRegion&gt;())\n        .RuleFor(p =&gt; p.CategoryId, 1)\n        .RuleFor(p =&gt; p.RowVersion, f =&gt; f.Random.Bytes(5));\n}\n</code></pre> <p>A kliensoldali JSON soros\u00edt\u00e1st a szerveroldallal kompatibilisen kell megtegy\u00fck. Ehhez k\u00e9sz\u00edts\u00fcnk egy <code>JsonSerializerOptions</code> objektumot, amibe be\u00e1ll\u00edtjuk, hogy a felsorolt t\u00edpusokat sz\u00f6veges \u00e9rt\u00e9kk\u00e9nt kezelje. Mivel ugyanazt a p\u00e9ld\u00e1nyt akarjuk haszn\u00e1lni a tesztekben, ez\u00e9rt a p\u00e9ld\u00e1nyt a <code>CustomWebApplicationFactory</code> (mint tesztek k\u00f6z\u00f6tti megosztott objektum) k\u00e9sz\u00edtse el \u00e9s aj\u00e1nlja ki.</p> <pre><code>public JsonSerializerOptions SerializerOptions { get; }\n\npublic CustomWebApplicationFactory()\n{\n    JsonSerializerOptions jso = new(JsonSerializerDefaults.Web);\n    jso.Converters.Add(new JsonStringEnumConverter());\n    SerializerOptions = jso;\n}\n</code></pre> <p>A <code>ProductControllerTests</code> a kiaj\u00e1nlott <code>JsonSerializerOptions</code>-t vegye \u00e1t.</p> <pre><code>// ...\nprivate readonly JsonSerializerOptions _serializerOptions;\n\npublic ProductControllerTests(CustomWebApplicationFactory appFactory)\n{\n    // ...\n    _serializerOptions = appFactory.SerializerOptions;\n}\n</code></pre> <p>Soros\u00edt\u00e1s be\u00e1ll\u00edt\u00e1sai</p> <p>Sajnos ezt a <code>JsonSerializerOptions</code> p\u00e9ld\u00e1nyt minden soros\u00edt\u00e1st ig\u00e9nyl\u0151 m\u0171veletn\u00e9l majd \u00e1t kell adnunk, mivel az alap\u00e9rtelmezett JSON soros\u00edt\u00f3nak nincs publikusan el\u00e9rhet\u0151 API-ja alap\u00e9rtelmezett soros\u00edt\u00e1si be\u00e1ll\u00edt\u00e1sok megad\u00e1s\u00e1hoz. Ugyanakkor fontos, hogy ker\u00fclj\u00fck a <code>JsonSerializerOptions</code> felesleges p\u00e9ld\u00e1nyos\u00edt\u00e1s\u00e1t. Ugyanolyan be\u00e1ll\u00edt\u00e1sokat ig\u00e9nyl\u0151 m\u0171veletek lehet\u0151leg ugyanazt a p\u00e9ld\u00e1nyt haszn\u00e1lj\u00e1k. Ezt most az XUnit megosztott kontextus\u00e1val oldottuk meg.</p>"},{"location":"seminar/10-test/chapter10/#post-muvelet-alapmukodes-tesztelese","title":"POST m\u0171velet alapm\u0171k\u00f6d\u00e9s tesztel\u00e9se","text":"<p>K\u00e9sz\u00edts\u00fck el az els\u0151 teszt\u00fcnket a <code>ProductController</code> <code>Post</code> m\u0171velet\u00e9hez. \u00c9rdemes azt az oszt\u00e1lystrukt\u00far\u00e1t k\u00f6vetni, hogy minden m\u0171velethez / f\u00fcggv\u00e9nyhez k\u00fcl\u00f6n teszt oszt\u00e1lyokat hozunk l\u00e9tre, ami ak\u00e1r t\u00f6bb tesztesetet is tartalmazhat. Ez a teszt oszt\u00e1lyt be\u00e1gyazott oszt\u00e1lyk\u00e9nt (<code>Post</code>) hozzuk l\u00e9tre egy k\u00fcl\u00f6n partial f\u00e1jlban (ProductIntegrationTests.Post.cs) a nagyobb egys\u00e9ghez tartoz\u00f3 tesztoszt\u00e1lyon bel\u00fcl. Ezzel sz\u00e9pen struktur\u00e1ltan tudjuk tartani a Test Explorerben (l\u00e1sd k\u00e9s\u0151bb) is a teszteseteinket. Pluszban m\u00e9g sz\u00e1rmaztassuk le a tartalmaz\u00f3 oszt\u00e1lyb\u00f3l, hogy a tesztesetek el\u00e9rhess\u00e9k a fentebb l\u00e9trehozott oszt\u00e1lyv\u00e1ltoz\u00f3kat.</p> <p>L\u00e1that\u00f3s\u00e1g be\u00e1gyazott oszt\u00e1lyokn\u00e1l</p> <p>\u00c9rdekess\u00e9g, hogy nem kell <code>protected</code> l\u00e1that\u00f3s\u00e1g\u00faaknak lenni\u00fck a fenti oszt\u00e1lyv\u00e1ltoz\u00f3knak, ha be\u00e1gyazott oszt\u00e1ly akarja el\u00e9rni azokat.</p> <pre><code>public partial class ProductControllerTests\n{\n    //...\n    public class Post : ProductControllerTests\n    {\n        public Post(CustomWebApplicationFactory appFactory)\n            : base(appFactory)\n        {\n        }\n    }\n}\n</code></pre> <p>A tesztesetek a teszt oszt\u00e1lyban met\u00f3dusok fogj\u00e1k reprezent\u00e1lni, amelyek <code>[Fact]</code> vagy <code>[Theory]</code> attrib\u00fatummal rendelkeznek. A f\u0151 k\u00fcl\u00f6nb\u00e9g az, hogy a <code>Fact</code> egy statikus tesztesetet reprezent\u00e1l, m\u00edg a <code>Theory</code> bemen\u0151 param\u00e9terekkel rendelkezhet.</p> <p>Els\u0151k\u00e9nt az egyenes \u00e1gat tesztelj\u00fck le, hogy a besz\u00far\u00e1s helyesen lefut-e, \u00e9s a megfelel\u0151 HTTP v\u00e1laszk\u00f3dot, a location HTTP fejl\u00e9cet, \u00e9s v\u00e1lasz DTO-t adja-e vissza.  Hozzunk l\u00e9tre egy f\u00fcggv\u00e9nyt <code>Fact</code> attrib\u00fatummal <code>Should_Succeded_With_Created</code> n\u00e9ven.</p> <p>A teszteset az AAA (Arrange, Act, Assert) mint\u00e1t k\u00f6veti, ahol 3 r\u00e9szre tagoljuk mag\u00e1t a tesztesetet.</p> <ol> <li>Az Arrange f\u00e1zisban el\u0151k\u00e9sz\u00edtj\u00fck a teszteset k\u00f6r\u00fclm\u00e9nyeit.</li> <li>Az Act f\u00e1zisban elv\u00e9gezz\u00fck a tesztelend\u0151 m\u0171veletet.</li> <li>Az Assert f\u00e1zisban pedig megvizsg\u00e1ljuk a v\u00e9grehajtott m\u0171velet eredm\u00e9nyeit, mell\u00e9khat\u00e1sait.</li> </ol> <pre><code>[Fact]\npublic async Task Should_Succeded_With_Created()\n{\n    // Arrange\n\n    // Act\n\n    // Assert\n}\n</code></pre> <p>Az Arrage-ben k\u00e9rj\u00fcnk el egy a teszt szerverhez kapcsol\u00f3d\u00f3 <code>HttpClient</code> objektumot, illetve hozzunk l\u00e9tre egy felk\u00fcldend\u0151 DTO-t.</p> <pre><code>// Arrange\nvar client = _appFactory.CreateClient();\nvar dto = _dtoFaker.Generate();\n</code></pre> <p>Az Act f\u00e1zisban k\u00fcldj\u00fcnk el egy POST k\u00e9r\u00e9st a megfelel\u0151 v\u00e9gpontra a megfelel\u0151 soros\u00edt\u00e1si be\u00e1ll\u00edt\u00e1sokkal \u00e9s olvassuk ki a v\u00e1laszt.</p> <pre><code>// Act\nvar response = await client.PostAsJsonAsync(\"/api/products\", dto, _serializerOptions);\nvar p = await response.Content.ReadFromJsonAsync&lt;Product&gt;(_serializerOptions);\n</code></pre> <p>Az Assert f\u00e1zisban pedig fogalmazzuk meg a FluentValidation k\u00f6nyvt\u00e1r seg\u00edts\u00e9g\u00e9vel az elv\u00e1rt eredm\u00e9ny szab\u00e1lyait. Gondoljunk arra is, hogy a <code>Category</code>, <code>Order</code>, <code>Id</code> \u00e9s <code>RowVersion</code> property-k eset\u00e9ben nem az az elv\u00e1rt v\u00e1lasz, amit felk\u00fcld\u00fcnk a szerverre, ez\u00e9rt ezeket sz\u0171rj\u00fck le az \u00f6sszehasonl\u00edt\u00e1sb\u00f3l \u00e9s vizsg\u00e1ljuk \u0151ket k\u00fcl\u00f6n szab\u00e1llyal.</p> <pre><code>// Assert\nresponse.StatusCode.Should().Be(HttpStatusCode.Created);\nresponse.Headers.Location\n    .Should().Be(\n        new Uri(_appFactory.Server.BaseAddress, $\"/api/Products/{p.Id}\")\n    );\n\np.Should().BeEquivalentTo(\n    dto,\n    opt =&gt; opt.Excluding(x =&gt; x.Category)\n        .Excluding(x =&gt; x.Orders)\n        .Excluding(x =&gt; x.Id)\n        .Excluding(x =&gt; x.RowVersion));\np.Category.Should().NotBeNull();\np.Category.Id.Should().Be(dto.CategoryId);\np.Orders.Should().BeEmpty();\np.Id.Should().BeGreaterThan(0);\np.RowVersion.Should().NotBeEmpty();\n</code></pre> <p>Fluent Assertions \u00e9s Nullable Reference Types</p> <p>A Fluent Assertions (nem preview verzi\u00f3ja) jelenleg m\u00e9g nem m\u0171k\u00f6dik egy\u00fctt a nem nullozhat\u00f3 referencia t\u00edpusokkal kapcsolatos ellen\u0151rz\u00e9si logik\u00e1kkal, \u00edgy az Assert r\u00e9szen kaphatunk ennek kapcs\u00e1n figyelmeztet\u00e9seket <code>Should().NotBeNull()</code> h\u00edv\u00e1sok ut\u00e1n is.</p> <p>A POST m\u0171velet megv\u00e1ltoztatn\u00e1 az adatb\u00e1zis \u00e1llapot\u00e1t, amit c\u00e9lszer\u0171 lenne elker\u00fclni. Ezt legegyszer\u0171bben \u00fagy \u00e9rhetj\u00fck el, hogy nyitunk egy tranzakci\u00f3t a tesztben, amit nem commitolunk a teszt lefut\u00e1sa sor\u00e1n. Ehhez vegy\u00fck fel az al\u00e1bbi utas\u00edt\u00e1sokat az Arrange f\u00e1zisban.</p> <pre><code>// Arrange\n_appFactory.Server.PreserveExecutionContext = true;\nusing var tran = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);\n\nvar client = _appFactory.CreateClient();\nvar dto = _dtoFaker.Generate();\n</code></pre> <p>Tranzakci\u00f3t a .NET <code>TransactionScope</code> oszt\u00e1llyal fogunk most nyitni, amin enged\u00e9lyezz\u00fck az aszinkron t\u00e1mogat\u00e1st is. Ahhoz pedig, hogy a tesztben l\u00e9trehozott tranzakci\u00f3 \u00e9rv\u00e9nyre jusson a teszt szerveren is, a <code>PreserveExecutionContext</code> tulajdons\u00e1got be kell kapcsoljuk.</p> <p>Pr\u00f3b\u00e1ljuk ki a menu:Test[Run All Test] men\u00fcpont seg\u00edts\u00e9g\u00e9vel. A Test Explorerben figyelj\u00fck meg az eredm\u00e9nyt.</p>"},{"location":"seminar/10-test/chapter10/#post-muvelet-hibaag-tesztelese","title":"POST m\u0171velet hiba\u00e1g tesztel\u00e9se","text":"<p>K\u00e9sz\u00edts\u00fcnk egy tesztesetet, ami a hib\u00e1s term\u00e9kn\u00e9v \u00e1gat teszteli le. Mivel ez k\u00e9t esetet is mag\u00e1ban foglal (null, \u00fcres string), haszn\u00e1ljunk param\u00e9terezhet\u0151 tesztesetet, teh\u00e1t <code>Theory</code>-t. A teszteset bemen\u0151 param\u00e9tereit t\u00f6bbf\u00e9lek\u00e9ppen is meg lehet adni. Mi most v\u00e1lasszuk az <code>InlineData</code> megk\u00f6zel\u00edt\u00e9st, ahol attrib\u00fatumokkal a teszteset f\u00f6l\u00f6tt k\u00f6zvetlen\u00fcl megadhat\u00f3ak a bemen\u0151 param\u00e9ter \u00e9rt\u00e9kei. Ilyen esetben az attrib\u00fatumban megadott \u00e9rt\u00e9keket a teszt met\u00f3dus param\u00e9terlist\u00e1j\u00e1n kell elk\u00e9rj\u00fck. Eset\u00fcnkben a n\u00e9v hib\u00e1s \u00e9rt\u00e9keit v\u00e1rjuk els\u0151 param\u00e9terk\u00e9nt, m\u00e1sodik param\u00e9terk\u00e9nt pedig az elv\u00e1rt hiba\u00fczenetet.</p> <pre><code>[Theory]\n[InlineData(\"\", \"Product name is required.\")]\n[InlineData(null, \"Product name is required.\")]\npublic async Task Should_Fail_When_Name_Is_Invalid(string name, string expectedError)\n{\n    // Arrange\n\n    // Act\n\n    // Assert\n}\n</code></pre> <p>Az el\u0151z\u0151 tesztesethez hasonl\u00f3an hozzunk l\u00e9tre a teszt szervert \u00e9s a DTO-t, de most a nevet a param\u00e9ter alapj\u00e1n t\u00f6lts\u00fck fel. B\u00e1r elvileg nem lenne sz\u00fcks\u00e9ges tranzakci\u00f3kezel\u00e9s, hiszen nem szabadna adatb\u00e1zis m\u00f3dos\u00edt\u00e1snak t\u00f6rt\u00e9nnie, a biztons\u00e1g kedv\u00e9\u00e9rt implement\u00e1ljuk itt is a tranzakci\u00f3kezel\u00e9st.</p> <pre><code>// Arrange\n _appFactory.Server.PreserveExecutionContext = true;\nusing var tran = new TransactionScope(TransactionScopeAsyncFlowOption.Enabled);\nvar client = _appFactory.CreateClient();\nvar dto = _dtoFaker.RuleFor(x =&gt; x.Name, name).Generate();\n</code></pre> <p>Az Act f\u00e1zisban annyi a k\u00fcl\u00f6nbs\u00e9g, hogy most <code>ValidationProblemDetails</code> objektumot v\u00e1runk a v\u00e1laszban.</p> <pre><code>// Act\nvar response = await client.PostAsJsonAsync(\"/api/products\", dto, _serializerOptions);\nvar p = await response.Content\n    .ReadFromJsonAsync&lt;ValidationProblemDetails&gt;(_serializerOptions);\n</code></pre> <p>Az Assert f\u00e1zisban pedig a HTTP st\u00e1tuszk\u00f3dot \u00e9s a <code>ProblemDetails</code> tartalm\u00e1ra vizsg\u00e1ljunk.</p> <pre><code>// Assert\nresponse.StatusCode.Should().Be(HttpStatusCode.BadRequest);\n\np.Status.Should().Be(400);\np.Errors.Should().HaveCount(1);\np.Errors.Should().ContainKey(nameof(Product.Name));\np.Errors[nameof(Product.Name)].Should().ContainSingle(expectedError);\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a menu:Test[Run All Test] men\u00fcpont seg\u00edts\u00e9g\u00e9vel. Figyelj\u00fck meg a tesztek hierarchi\u00e1j\u00e1t is, a POST m\u0171velethez kapcsol\u00f3d\u00f3 tesztek egy csoportba lettek \u00f6sszefogva a be\u00e1gyazott oszt\u00e1ly ment\u00e9n.</p> <p>Transzakci\u00f3kezel\u00e9s k\u00f3dduplik\u00e1ci\u00f3</p> <p>\u00c9szrevehetj\u00fck, hogy a tranzakci\u00f3kezel\u00e9ssel kapcsolatos k\u00f3dot duplik\u00e1ltuk, ennek elker\u00fcl\u00e9s\u00e9re p\u00e9ld\u00e1ul p\u00e9ld\u00e1ul tesztf\u00fcggv\u00e9nyre tehet\u0151 attrib\u00fatumot vezethet\u00fcnk be.</p>"},{"location":"seminar/10-test/chapter10/#naplozas","title":"Napl\u00f3z\u00e1s","text":"<p>A tesztek \u00fczeneteket napl\u00f3zhatnak egy speci\u00e1lis tesztkimenetre. Ehhez minden tesztoszt\u00e1ly p\u00e9ld\u00e1ny kap(hat) egy saj\u00e1t <code>ITestOutputHelper</code> p\u00e9ld\u00e1nyt a konstruktoron kereszt\u00fcl. Vezess\u00fck be az \u00faj konstruktorparam\u00e9tert a tesztoszt\u00e1lyban \u00e9s az \u0151soszt\u00e1ly\u00e1ban is.</p> <pre><code>private readonly ITestOutputHelper _testOutput;\n\npublic ProductControllerTests(\n    CustomWebApplicationFactory appFactory,\n    ITestOutputHelper output)\n{\n    //...\n    _testOutput = output;\n}\n</code></pre> Post be\u00e1gyazott t\u00edpus konstruktora<pre><code>public Post(CustomWebApplicationFactory appFactory, ITestOutputHelper output)\n    : base(appFactory, output)\n{ }\n</code></pre> <p>Pr\u00f3bak\u00e9pp \u00edrjunk ki egy \u00fczenetet a <code>ProductControllerTests</code> konstruktor\u00e1ban.</p> <pre><code>output.WriteLine(\"ProductControllerTests ctor\");\n</code></pre> <p>Ellen\u0151rizz\u00fck, hogy a tesztek lefuttat\u00e1sa ut\u00e1n Test Explorer-ben megjelennek-e az \u00fczenetek a Test Detail Summary ablakr\u00e9sz Standard output szekci\u00f3j\u00e1ban. Ebb\u0151l l\u00e1thatjuk, hogy minden tesztf\u00fcggv\u00e9ny, s\u0151t minden tesztf\u00fcggv\u00e9ny v\u00e1ltozat (a Theory minden bemeneti adatsora egy k\u00fcl\u00f6n v\u00e1ltozat) megh\u00edv\u00e1sakor lefut a konstruktor.</p> <p>Ugyanerre a kimenetre k\u00f6ss\u00fck r\u00e1 a szerveroldali napl\u00f3z\u00e1st, hogy a tesztek lefut\u00e1sa mellett ezek a napl\u00f3\u00fczenetek is megjelenjenek. Ehhez telep\u00edts\u00fcnk egy seg\u00e9dcsomagot a tesztprojektbe.</p> <pre><code>&lt;PackageReference Include=\"MartinCostello.Logging.XUnit\" Version=\"0.3.0\" /&gt;\n</code></pre> <p>A <code>ProductControllerTests</code> konstruktor\u00e1ban k\u00f6ss\u00fck \u00f6ssze a k\u00e9t param\u00e9tert, a <code>CustomWebApplicationFactory</code> \u00e9s az <code>ITestOutputHelper</code> p\u00e9ld\u00e1nyt a fenti seg\u00e9dcsomag (<code>AddXUnit</code> met\u00f3dus) seg\u00edts\u00e9g\u00e9vel. A tesztszerver napl\u00f3z\u00f3 alrendszer\u00e9nek adjuk meg kimenetk\u00e9nt az xUnit tesztkimenet\u00e9t.</p> <pre><code>_appFactory = appFactory\n    .WithWebHostBuilder(builder =&gt;\n    {\n        builder.ConfigureLogging(logging =&gt;\n        {\n            logging.ClearProviders();\n            logging.AddXUnit(output);\n        });\n    });\n</code></pre> <p>Ellen\u0151rizz\u00fck, hogy a tesztek lefuttat\u00e1sa ut\u00e1n Test Explorer-ben megjelennek-e a szerveroldali \u00fczenetek is.</p> <p>A v\u00e9g\u00e1llapot el\u00e9rhet\u0151 a kapcsol\u00f3d\u00f3 GitHub rep\u00f3ban.</p>"}]}