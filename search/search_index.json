{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftverfejleszt\u00e9s .NET platformra","text":"<p>Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a Szoftverfejleszt\u00e9s .NET platformra c. t\u00e1rgyhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p> <p>A felhaszn\u00e1l\u00e1si felt\u00e9telekr\u0151l b\u0151vebben a repository LICENSE.md f\u00e1jlj\u00e1ban olvashatsz.</p>"},{"location":"homework/","title":"H\u00e1zi feladat tudnival\u00f3k","text":"<p>TBD</p>"},{"location":"information/contributing/","title":"Hozz\u00e1j\u00e1rul\u00e1s az anyaghoz","text":"<p>Az anyag terjedelm\u00e9b\u0151l adand\u00f3an apr\u00f3bb hib\u00e1k esetenk\u00e9nt hi\u00e1nyoss\u00e1gok jelentkezhetnek a laborokban. Ha egy ilyennel tal\u00e1lkozol \u00e9s \u00fagy d\u00f6ntesz szeretn\u00e9l seg\u00edteni hallgat\u00f3t\u00e1rsaidnak, azt a k\u00f6vetkez\u0151kben le\u00edrtak alapj\u00e1n tudod megtenni.</p> <p>Plusz pont jegyzet jav\u00edt\u00e1s\u00e9rt</p> <p>M\u00e1s tant\u00e1rgyak mint\u00e1j\u00e1ra itt is szeretn\u00e9nk plusz pontot adni a jegyzet open-source hozz\u00e1j\u00e1rul\u00e1sai\u00e9rt. Akik a t\u00e1rgyat jelenleg hallgatj\u00e1k, pontokat kaphatnak hozz\u00e1j\u00e1rul\u00e1saik\u00e9rrt.</p> <p>A f\u00e9l\u00e9v sor\u00e1n max 3 db plusz pontot lehet szerezni fejenk\u00e9nt olyan jav\u00edt\u00e1sok\u00e9rt, amik a trivi\u00e1lis 1-2 bet\u0171 elg\u00e9pel\u00e9sen t\u00fal \u00e9rdemben jav\u00edtanak a githubon tal\u00e1lhat\u00f3 labor jegyzetek min\u0151s\u00e9g\u00e9n. Pl.: jelent\u0151s mennyis\u00e9g\u0171 elg\u00e9pel\u00e9s jav\u00edt\u00e1sa, egy\u00e9rtelm\u0171s\u00edt\u00e9sek, illusztr\u00e1ci\u00f3k kieg\u00e9sz\u00edt\u00e9sek k\u00e9sz\u00edt\u00e9se vagy ak\u00e1r egy teljes kieg\u00e9sz\u00edt\u0151 jegyzet \u00edr\u00e1sa  (term\u00e9szetesen nem azonos pont\u00e9rt\u00e9kkel).</p> <p>Persze a pont n\u00e9lk\u00fcl az 1-1 bet\u0171s elg\u00e9pel\u00e9seket is sz\u00edvesen fogadjuk, ami bemeleg\u00edt\u00e9snek is t\u00f6k\u00e9letes.</p>"},{"location":"information/contributing/#hibak-jelzese","title":"Hib\u00e1k jelz\u00e9se","text":"<p>Amennyiben hib\u00e1t tal\u00e1lsz az anyagban, vagy szeretn\u00e9d b\u0151v\u00edteni, de nem \u00e1ll m\u00f3dodban jav\u00edtani, nyithatsz egy issue-t amiben le\u00edrod a hib\u00e1t.</p> <ol> <li>N\u00e9zd meg, hogy valaki nem jelezte-e, amit szeretn\u00e9l.     Gyakran m\u00e1r l\u00e9tez\u0151 probl\u00e9m\u00e1kat tal\u00e1lnak, amire m\u00e1r van pull request,     \u00edgy miel\u0151tt b\u00e1rmit tenn\u00e9l n\u00e9zd meg valaki nem el\u0151z\u00f6tt-e meg</li> <li>Az issues tabon a new issue gombbal hozz l\u00e9tre egy \u00faj issue-t.     </li> <li>L\u00e1sd el a megfelel\u0151 c\u00edmk\u00e9kkel<ol> <li>A labor t\u00edpusa (<code>android</code> az androidos laborokn\u00e1l \u00e9s <code>web</code> a webes laborokn\u00e1l)</li> <li>A hiba t\u00edpusa (<code>clarification</code>, <code>typo</code>, <code>illustration</code> vagy <code>notes</code>)</li> </ol> </li> <li>\u00cdrd le, hogy mit k\u00e9ne tartalmaznia a jav\u00edt\u00e1snak</li> </ol> <p>Tip</p> <p>Az c\u00edme legyen r\u00f6vid \u00e9s l\u00e9nyegret\u00f6r\u0151, pl.: <code>Megfogalmaz\u00e1s pontos\u00edt\u00e1sa a 4. laborban</code> vagy <code>A 6. laborban a le\u00edrt k\u00f3d hib\u00e1san m\u0171k\u00f6dik Android 12-n</code></p> <p>A issue descriptionj\u00e9ben pedig fejtsd ki, hol tal\u00e1lhat\u00f3 a hi\u00e1nyoss\u00e1g, illetve ha van r\u00e1 \u00f6tleted, hogy lehetne orvosolni ezt. Ha ezeken t\u00fal m\u00e9g screenshotot is tudsz mell\u00e9kelni, az nagyban megseg\u00edti a probl\u00e9ma mihamarabbi jav\u00edt\u00e1s\u00e1t.</p> <p>Warning</p> <p>A github issues nem a laborfeladatok megold\u00e1s\u00e1val kapcsolatos probl\u00e9m\u00e1k helye, \u00edgy a \"Nem tudom megoldani hogy az \u00e9rtes\u00edt\u00e9s meg\u00e9rkezzen\" jelleg\u0171 probl\u00e9m\u00e1kat ne itt jelezz\u00e9tek, erre vannak a laboralkalmak.</p>"},{"location":"information/contributing/#valtoztatasok-javaslasa","title":"V\u00e1ltoztat\u00e1sok javasl\u00e1sa","text":"<p>Amennyiben a hozz\u00e1j\u00e1rul\u00e1sod meg tudod val\u00f3s\u00edtani ind\u00edts pull requestet</p> <ol> <li> <p>Forkold a repository-t a Githubon jobb fels\u0151 sarokban tal\u00e1lhat\u00f3 gombbal     </p> </li> <li> <p>V\u00e9gezd el a v\u00e1ltoztat\u00e1sokat.</p> <ol> <li> <p>Hozz l\u00e9tre egy branchet a saj\u00e1t forkodon, amin a v\u00e1ltoztat\u00e1sokat el fogod v\u00e9gezni.</p> </li> <li> <p>Ezen a branchen k\u00e9sz\u00edtsd el a jav\u00edt\u00e1sokat</p> </li> <li> <p>Ellen\u0151rizd, hogy ne ker\u00fclj\u00f6n bele a commitba olyan file, amit az editor gener\u00e1lt (pl.: <code>.idea</code> mappa) illetve olyan file aminek nem k\u00e9ne kiker\u00fclnie, pl.: Github Private Access Token</p> </li> <li> <p>Ha k\u00e9sz vagy ind\u00edts egy pull requestet a jegyzeteket tartalmaz\u00f3 rep\u00f3 f\u0151 \u00e1g\u00e1ra.</p> </li> <li> <p>A le\u00edr\u00e1sban r\u00e9szletezd v\u00e1ltoztat\u00e1sok ok\u00e1t.     Ne felejtsd el bele\u00edrni a NEPTUN k\u00f3dod a le\u00edr\u00e1sba, mert \u00edgy fogjuk tudni megadni a pontokat.</p> </li> </ol> </li> <li> <p>Valaki, akinek hozz\u00e1f\u00e9r\u00e9se van a repositoryhoz, ellen\u0151rzi a v\u00e1ltoztat\u00e1sok sz\u00fcks\u00e9gess\u00e9g\u00e9t, \u00e9s elb\u00edr\u00e1lja, hogy val\u00f3ban beker\u00fclhet az anyagba.</p> </li> <li>A v\u00e1ltoztat\u00e1sokra review-t ind\u00edtunk \u00e9s ha kell m\u00f3dos\u00edt\u00e1sokat fogunk k\u00e9rni.</li> <li>Ha minden k\u00e9rt v\u00e1ltoztat\u00e1s megt\u00f6rt\u00e9nt, a hozz\u00e1j\u00e1rul\u00e1sod beleker\u00fcl az anyagba.</li> </ol>"},{"location":"information/contributing/#code-style","title":"Code style","text":"<ul> <li>Markdown: Mivel az alap spec nem mindig a legtiszt\u00e1bban \u00e9rthet\u0151, a markdownlint szab\u00e1lyai alapj\u00e1n, az n\u00e9h\u00e1ny kiv\u00e9tel\u00e9vel. Ezeket a <code>.markdownlint.yaml</code>-ben tal\u00e1lod, ha VSCode-ot haszn\u00e1lsz automatikusan alkalmazza \u0151ket az editor \u00e9s jelzi ha nem megfelel\u0151 amit \u00edrsz.</li> </ul> <p>Ezek a st\u00edlusok a t\u00e1rgyban aj\u00e1nlott editorokban k\u00f6nnyen be\u00e1ll\u00edthat\u00f3ak.</p>"},{"location":"information/contributing/#vscode","title":"VSCode","text":"<p>Aj\u00e1nlott extension\u00f6k:</p> <ul> <li><code>yzhang.markdown-all-in-one</code>: MD szinkroniz\u00e1lt live preview</li> <li><code>DavidAnson.vscode-markdownlint</code>: MD form\u00e1z\u00e1s, szab\u00e1lyok stb.</li> <li>Prettier: HTML+CSS form\u00e1z\u00f3</li> <li>Error Lens: Kiemeli a hib\u00e1kat hogy gyorsabben megtal\u00e1ljuk \u0151ket</li> <li>Paste Image: egyszer\u0171s\u00edti a k\u00e9pek beilleszt\u00e9s\u00e9t markdownba</li> </ul> <p>Az editor be\u00e1ll\u00edt\u00e1s\u00e1hoz nyisd meg a repo-t a gy\u00f6ker\u00e9ben VSCode-al. A VSCode fel fogja aj\u00e1nlani a k\u00e9t markdown extension-t.</p> <p></p> <p>Ha ez megt\u00f6rt\u00e9nt, nyiss meg egy markdown dokumentumot, \u00e9s haszn\u00e1ld a Ctrl+Shift+P shortcutot, a command palette megnyit\u00e1s\u00e1hoz.</p> <p>Tip</p> <p>A command palette a VSCode parancsaihoz ny\u00fajt hozz\u00e1f\u00e9r\u00e9st, autocompleteeli a parancsokat \u00e9s egy minim\u00e1lis GUI-t is biztos\u00edt.</p> <p>A command palette-be keress\u00fck meg a <code>Format Document With...</code> men\u00fcpontot \u00e9s v\u00e1lasszuk ki. Ekkor egy almen\u00fcbe dob az editor \u00e9s kiv\u00e1laszthatjuk hogy melyik form\u00e1z\u00f3val form\u00e1zzuk a MD dokumentumokat. Legalul lesz egy <code>Configure Default Formatter</code>, v\u00e1lasszuk ezt. Ezut\u00e1n v\u00e1lasszuk a <code>markdownlint</code> extensiont, \u00e9s k\u00e9szen vagyunk.</p> <p>Megfelel\u0151 formatter kiv\u00e1laszt\u00e1sa</p> <p>Ne v\u00e1laszd ki a prettiert formatterk\u00e9nt, mert elt\u00f6ri a sz\u00f6vegbubor\u00e9kokat.</p> <p>Ezen fel\u00fcl \u00e9rdemes lehet bekapcsolni a ment\u00e9s el\u0151tti form\u00e1z\u00e1st.</p> <p>A Ctrl+, shortcuttal megnyitjuk a be\u00e1ll\u00edt\u00e1sokat, \u00e9s r\u00e1keres\u00fcnk arra, hogy format on save. Itt kipip\u00e1ljuk a checkboxot \u00e9s k\u00e9szen vagyunk.</p> <p>Ha ehhez nem lenne t\u00fcrelmed, itt a json amit a <code>settings.json</code>-ba illesztve be\u00e1ll\u00edt\u00f3dik minden.</p> <pre><code>{\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"DavidAnson.vscode-markdownlint\",\n    \"editor.formatOnSave\": true\n  }\n}\n</code></pre>"},{"location":"information/preface/","title":"Tudnival\u00f3k","text":""},{"location":"information/preface/#a-jegyzet-celja-es-celkozonsege","title":"A jegyzet c\u00e9lja \u00e9s c\u00e9lk\u00f6z\u00f6ns\u00e9ge","text":"<p>Ezen jegyzet els\u0151dlegesen a BME Villamosm\u00e9rn\u00f6ki \u00e9s Informatikai Kar\u00e1n oktatott Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgyhoz k\u00e9sz\u00fclt, c\u00e9lja, hogy seg\u00edts\u00e9get ny\u00fajtson egyr\u00e9szt a gyakorlatvezet\u0151nek a gyakorlat megtart\u00e1s\u00e1ban, m\u00e1sr\u00e9szt a kurzus hallgat\u00f3inak a gyakorlat otthoni ut\u00f3lagos megism\u00e9tl\u00e9s\u00e9hez, a tanult ismeretek \u00e1tism\u00e9tl\u00e9s\u00e9hez.</p> <p>Ebb\u0151l kifoly\u00f3lag nem tekinthet\u0151 egy teljesen kezd\u0151 szint\u0171 bevezet\u0151 C# tank\u00f6nyvnek, hiszen er\u0151teljesen \u00e9p\u00edt m\u00e1s kari t\u00e1rgyak (pl. Szoftvertechnik\u00e1k, Adatb\u00e1zisok) \u00e1ltal lefedett ismeretekre, de m\u00e9g ink\u00e1bb a Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgy el\u0151ad\u00e1saira.</p> <p>A felt\u00e9telezett el\u0151ismeretek:</p> <ul> <li>C# \u00e9s objektumorient\u00e1lt nyelvi alapok<ul> <li>oper\u00e1torok, v\u00e1ltoz\u00f3k, t\u00f6mb\u00f6k, strukt\u00far\u00e1k, f\u00fcggv\u00e9nyek fogalma</li> <li>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s \u00e9s f\u00fcggv\u00e9nyv\u00e1ltozatok</li> <li>alapvet\u0151 mem\u00f3riakezel\u00e9s (heap, stack), mutat\u00f3k fogalma, \u00e9rt\u00e9k \u00e9s referencia t\u00edpusok</li> <li>alapvet\u0151 vez\u00e9rl\u00e9si szerkezetek (ciklus, el\u00e1gaz\u00e1s, stb.), \u00e9rt\u00e9k- \u00e9s referencia szerinti param\u00e9ter\u00e1tad\u00e1s, rekurzi\u00f3</li> <li>oszt\u00e1ly, oszt\u00e1lyp\u00e9ld\u00e1ny fogalma, static, <code>new</code> oper\u00e1tor, oszt\u00e1ly szint\u0171 v\u00e1ltoz\u00f3k, generikus t\u00edpusok</li> <li>lesz\u00e1rmaz\u00e1s, virtu\u00e1lis tagf\u00fcggv\u00e9nyek</li> <li>C# esem\u00e9ny, delegate t\u00edpusok \u00e9s delegate p\u00e9ld\u00e1nyok</li> <li>Visual Studio haszn\u00e1lat\u00e1nak alapjai</li> <li>oper\u00e1ci\u00f3s rendszer kapcsolatok, folyamatok, sz\u00e1lak, parancssor, parancssori argumentumok, k\u00f6rnyezeti v\u00e1ltoz\u00f3k</li> </ul> </li> <li>SQL nyelvi alapok (SELECT, UPDATE, INSERT, DELETE utas\u00edt\u00e1sok), valamint alapvet\u0151 rel\u00e1ci\u00f3s adatmodell ismeretek (t\u00e1bl\u00e1k, els\u0151dleges- \u00e9s idegen kulcsok)</li> </ul> <p>A fentiek elsaj\u00e1t\u00edt\u00e1s\u00e1hoz seg\u00edts\u00e9get ny\u00fajthatnak Reiter Istv\u00e1n ingyenesen let\u00f6lthet\u0151 k\u00f6nyvei.</p> <p>A sz\u00f6vegben megtal\u00e1lhat\u00f3k a gyakorlatvezet\u0151knek sz\u00f3l\u00f3 kit\u00e9telek (\u201eR\u00f6viden mondjuk el\u2026\", \u201eMutassuk meg\u2026\", stb.). Ezeket mezei olvas\u00f3k\u00e9nt \u00e9rdemes figyelmen k\u00edv\u00fcl hagyni, illetve sz\u00fcks\u00e9g eset\u00e9n a kapcsol\u00f3d\u00f3 elm\u00e9leti ismereteket az el\u0151ad\u00e1sanyagb\u00f3l \u00e1tism\u00e9telni.</p>"},{"location":"information/preface/#a-jegyzet-naprakeszsege","title":"A jegyzet naprak\u00e9szs\u00e9ge","text":"<p>Az anyag gerinc\u00e9t ad\u00f3 .NET Core / .NET 5,6 platform jelenleg igen gyors \u00fctemben fejl\u0151dik. A .NET Core 1.0-s verzi\u00f3 \u00f3ta a k\u00e9sz\u00edt\u0151k t\u00f6rekednek a visszafel\u00e9 kompatibilit\u00e1sra, azonban az eszk\u00f6zk\u00e9szlet \u00e9s a korszer\u0171nek \u00e9s aj\u00e1nlottnak tekinthet\u0151 m\u00f3dszerek folyamatosan v\u00e1ltoznak, finomodnak.</p> <p>A jegyzet els\u0151dlegesen az al\u00e1bbi technol\u00f3giai verzi\u00f3khoz k\u00e9sz\u00fclt:</p> <ul> <li>C# 12</li> <li>.NET 8</li> <li>ASP.NET Core 8</li> <li>Visual Studio 2022</li> </ul> <p>Ahogyan a fenti verzi\u00f3k v\u00e1ltoznak, \u00fagy avulhatnak el a jegyzetben mutatott elj\u00e1r\u00e1sok.</p>"},{"location":"information/preface/#szoftverkornyezet","title":"Szoftverk\u00f6rnyezet","text":"<p>A gyakorlatok az al\u00e1bbi szoftverekb\u0151l \u00e1ll\u00f3 k\u00f6rnyezethez k\u00e9sz\u00fcltek:</p> <ul> <li>Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>Visual Studio 2022 (az ingyenes Community verzi\u00f3 el\u00e9g) az al\u00e1bbi workloadokkal:<ul> <li>.NET desktop development</li> <li>Data storage and processing</li> <li>ASP.NET and web development</li> <li>Azure Development</li> </ul> </li> <li>Telerik Fiddler Classic</li> <li>Postman</li> </ul> <p>A .NET (kor\u00e1bban .NET Core) sz\u00e9lesk\u00f6r\u0171 platformt\u00e1mogat\u00e1sa miatt bizonyos nem Windows platformokon is elv\u00e9gezhet\u0151k a gyakorlatok Visual Studio helyett Visual Studio Code haszn\u00e1lat\u00e1val - azonban a gyakorlatok sz\u00f6vege a Visual Studio haszn\u00e1lat\u00e1t felt\u00e9telezi.</p>"},{"location":"information/preface/#kodreszletek-valtozaskovetese","title":"K\u00f3dr\u00e9szletek v\u00e1ltoz\u00e1sk\u00f6vet\u00e9se","text":"<p>Az egyes gyakorlatok sor\u00e1n gyakori eset, hogy a C# k\u00f3d egy r\u00e9sz\u00e9t tov\u00e1bbfejlesztj\u00fck, megv\u00e1ltoztatjuk. Ilyen esetben a v\u00e1ltoz\u00f3 sorokat a jegyzetben kiemelt h\u00e1tt\u00e9rrel rendelkeznek. A t\u00f6r\u00f6lt k\u00f3dr\u00e9szleteket (amennyiben van seg\u00edti a meg\u00e9rt\u00e9st) kommentez\u00e9ssel jelezz\u00fck. Jel\u00f6lj\u00fck m\u00e9g a megl\u00e9v\u0151, de a jegyzetben nem megjelen\u00edtett k\u00f3dr\u00e9szleteket komment \u00e9s ... (<code>//...</code>) jellel.</p> <pre><code>using System; //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\nusing static System.Console; //ez \u00faj k\u00f3dsor\n\n//... megl\u00e9v\u0151 k\u00f3dr\u00e9szlet az el\u0151z\u0151 feladatokb\u00f3l\n\nforeach (var dog in dogs)    //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\n  /* Console.*/WriteLine(dog); //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n\n/* Console.*/ReadLine();     //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n</code></pre> <p>JSON kommentek</p> <p>A JSON form\u00e1tum alap\u00e9rtelmez\u00e9sben (RFC szerint) nem t\u00e1mogatja a kommenteket, \u00edgy ha JSON k\u00f3dr\u00e9szletet m\u00e1solunk, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy nem maradt-e a beillesztett k\u00f3dban komment, mert probl\u00e9m\u00e1t okozhat.</p>"},{"location":"seminar/01-csharp1/chapter1/","title":"C# alapok, szintaxis","text":"<p>C\u00e9lunk, hogy a hallgat\u00f3k legal\u00e1bb r\u00e9szben meg\u00e9rts\u00e9k \u00e9s r\u00e1\u00e9rezzenek a C# szintaktik\u00e1j\u00e1ra, megismerkedjenek alapvet\u0151 nyelvi elemekkel \u00e9s konstrukci\u00f3kkal.</p>"},{"location":"seminar/01-csharp1/chapter1/#hello-c","title":"Hello C#!","text":"<p>A Visual Studio ind\u00edt\u00f3ablak\u00e1ban v\u00e1lasszuk a <code>Create a new project</code> opci\u00f3t. Magyar\u00e1zzuk el, hogy van lehet\u0151s\u00e9g\u00fcnk el\u0151re gy\u00e1rtott sablonokb\u00f3l l\u00e9trehozni projekteket, illetve hogy</p> <ul> <li>egy C# projekt egy szerelv\u00e9nny\u00e9 fordul (.dll, .exe).</li> <li>a Solution dolga, hogy logikailag \u00f6sszefogja a Project-eket (t\u00f6bb-t\u00f6bbes kapcsolatban vannak).</li> <li>a projektek k\u00f6z\u00f6tt referenci\u00e1kat adhatunk m\u00e1sik projektekre \u00fagy, hogy a ford\u00edt\u00e1si mechanizmus figyelembe veszi a referenci\u00e1kat \u00e9s sz\u00fcks\u00e9g eset\u00e9n \u00fajraford\u00edtja a szerelv\u00e9nyeket.</li> <li>a projektek hivatkozhatnak k\u00fcls\u0151 forr\u00e1sb\u00f3l sz\u00e1rmaz\u00f3 szerelv\u00e9nyekre is NuGet csomagok form\u00e1j\u00e1ban. A NuGet egy egys\u00e9ges m\u00f3dszer szerelv\u00e9nyeink terjeszt\u00e9s\u00e9re.</li> </ul> <p>Hozzunk l\u00e9tre egy \u00faj C# Console Application-t! Ehhez keress\u00fck ki a sablonok k\u00f6z\u00fcl a Console App nev\u0171t (ne a .NET Framework-\u00f6set). A neve legyen HelloCSharp.</p> <p>New Project dialogusablak keres\u0151</p> <p>A kikeres\u00e9shez haszn\u00e1lhatjuk fel\u00fcl a sz\u00f6vegdobozos sz\u0171r\u0151t, illetve a leg\u00f6rd\u00fcl\u0151 list\u00e1s sz\u0171r\u0151ket is (Nyelv: C#, Platform: Windows, Projektt\u00edpus: Console)</p> <p>A sablon konfigur\u00e1ci\u00f3j\u00e1n\u00e1l adjunk meg egy olyan helyet, ahov\u00e1 van \u00edr\u00e1si jogunk. A Place solution and project in the same directory opci\u00f3t kapcsoljuk be, \u00edgy nem fog l\u00e9trej\u00f6nni egy felesleges mappa a k\u00f6nyvt\u00e1rszerkezetben. A .NET verzi\u00f3t \u00e1ll\u00edtsuk .NET 8-ra.</p> <p>\u00c9szrevehetj\u00fck, hogy az alkalmaz\u00e1s sablonok k\u00f6z\u00f6tt sima \u00e9s (.NET Framework) jel\u00f6l\u00e9s\u0171ek is vannak. A sim\u00e1k alapvet\u0151en a modernebb .NET Core/.NET 5-8 platformot c\u00e9lozz\u00e1k, a .NET Framework ezekhez k\u00e9pest egy r\u00e9gebbi platform.</p> <ul> <li>.NET Core: a .NET Framework modulariz\u00e1lt, moderniz\u00e1lt, cross-platform \u00e9s ny\u00edlt forr\u00e1sk\u00f3d\u00fa megval\u00f3s\u00edt\u00e1sa. Kisebb NuGet csomagokban \u00e9rhet\u0151 el a teljes .NET Framework funkcionalit\u00e1sa (Collections, Reflection, XML feldolgoz\u00e1s, stb.).</li> <li>.NET Framework: a \u201eklasszikus\u201d, teljes\u00e9rt\u00e9k\u0171 .NET keretrendszer, out-of-the-box t\u00e1mogatja a legelterjedtebb alkalmaz\u00e1sfejleszt\u00e9si lehet\u0151s\u00e9geket. A .NET Core megjelen\u00e9s\u00e9t k\u00f6vet\u0151en is t\u00e1mogatott, enterprise k\u00f6rnyezetekben haszn\u00e1latos, ugyanis n\u00e9h\u00e1ny enterprise technol\u00f3gia els\u0151dlegesen csak ebben t\u00e1mogatott (pl. szerver oldali WCF). Csak Windows-ra telep\u00edthet\u0151.</li> <li>.NET 5 \u00e9s f\u00f6l\u00f6tte: A .NET Core 3.1 ut\u00e1ni f\u0151 verzi\u00f3i. M\u00e1r elnevez\u00e9s\u00e9ben is jelzi, hogy ez egyben a kor\u00e1bbi .NET Core \u00e9s .NET Framework verzi\u00f3knak is ut\u00f3dja.</li> </ul> <p>Az al\u00e1bbi elemeket ismertethetj\u00fck, miel\u0151tt a k\u00f3d\u00edr\u00e1sba belekezd\u00fcnk:</p> <ul> <li>R\u00f6vid \u00e1ttekint\u00e9s az IDE-r\u0151l: men\u00fcs\u00e1v, Solution Explorer, Properties, Output, Error List ablakok, ablakoz\u00f3rendszer. Mutassuk meg, hogy drag-n-drop m\u0171veletekkel testreszabhat\u00f3 a fel\u00fclet, pl. helyezz\u00fck a Solution Explorert a k\u00e9perny\u0151 bal oldal\u00e1ra. Ha valaki v\u00e9letlen\u00fcl \u00e1trendezi az alap\u00e9rtelmezett elrendez\u00e9st, a menu:Window[Reset Window Layout] lehet\u0151s\u00e9ggel vissza\u00e1ll\u00edthatja.</li> <li>A projekt tulajdons\u00e1gok (menu:jobb klikk[Properties]) oldal\u00e1n az Application f\u00fcl\u00f6n megn\u00e9zhetj\u00fck, hogy az Output type \u00e9rt\u00e9ke hat\u00e1rozza meg, hogy milyen jelleg\u0171 (konzolos, Windows, oszt\u00e1lyk\u00f6nyvt\u00e1r) alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk.</li> <li>Mutassuk meg, hogy milyen alapvet\u0151 szerelv\u00e9nyekre adunk referenci\u00e1t a projektben!</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> f\u00e1jl tartalm\u00e1t \u00e9s fussuk \u00e1t a l\u00e1that\u00f3 elemeket!</li> <li>Magyar\u00e1zzuk el a <code>using</code> \u00e9s <code>namespace</code> kulcsszavak jelent\u00e9s\u00e9t, egym\u00e1shoz k\u00e9pesti viszonyukat! A n\u00e9vt\u00e9r \u00e9rt\u00e9ke egy \u00fajonnan l\u00e9trehozott f\u00e1jln\u00e1l alap\u00e9rtelmezetten Projektn\u00e9v.Mappaszerkezet alak\u00fa, \u00e9rdemes konvencion\u00e1lisan ezt k\u00f6vetni. Sok hallgat\u00f3n\u00e1l nem tiszta, hogy hogyan viszonyul egym\u00e1shoz a n\u00e9vt\u00e9r \u00e9s a szerelv\u00e9ny fogalma, ez\u00e9rt pr\u00f3b\u00e1ljuk meg ezt tiszt\u00e1zni!</li> <li>Utaljunk arra, hogy alapvet\u0151en kiz\u00e1r\u00f3lag objektumorient\u00e1ltan tudunk k\u00f3dot \u00edrni, \u00edgy a <code>Program</code> egy oszt\u00e1ly, a <code>Main</code> bel\u00e9p\u00e9si pont pedig egy statikus met\u00f3dus.</li> <li>Besz\u00e9lj\u00fcnk r\u00f6viden a C# elnevez\u00e9si konvenci\u00f3kr\u00f3l! A publikus elemeket (pl. Java-val \u00e9s JavaScripttel ellent\u00e9tben) \u00e9s minden met\u00f3dust \u00f6k\u00f6lszab\u00e1lyk\u00e9nt PascalCasing elnevez\u00e9si konvenci\u00f3 k\u00f6vet, a nem publikus elemekn\u00e9l camelCasing (ezek k\u00f6z\u00fcl vannak kiv\u00e9telek \u00e9s m\u00e1s konvenci\u00f3k, de ez egy gyakori megk\u00f6zel\u00edt\u00e9s).</li> </ul> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> met\u00f3dust az al\u00e1bbi k\u00f3dr\u00e9szlettel, k\u00f6zben h\u00edvjuk fel a figyelmet az IntelliSense haszn\u00e1lat\u00e1ra:</p> <pre><code>int a = 5;\nint b = 7;\nConsole.WriteLine(a + b);\nConsole.ReadLine();\n</code></pre> <p>Az IntelliSense-t demonstr\u00e1lhatjuk az al\u00e1bbi m\u00f3don:</p> <ul> <li>A k\u00f3dban b\u00e1rmely logikus helyen haszn\u00e1lhat\u00f3 az IntelliSense a Ctrl+Space billenty\u0171kombin\u00e1ci\u00f3val, ezen k\u00edv\u00fcl alap\u00e9rtelmezetten felugrik k\u00f3d\u00edr\u00e1s k\u00f6zben is.</li> <li>\u00cdrjuk be a <code>Console</code> \u00e9s a <code>.WriteLine()</code> elemeket \u00fagy, hogy g\u00e9pel\u00e9s k\u00f6zben az IntelliSense leg\u00f6rd\u00fcl\u0151b\u0151l v\u00e1lasszuk ki az elemet, majd Tab billenty\u0171vel v\u00e9gleges\u00edts\u00fck a v\u00e1laszt\u00e1st.</li> <li>Haszn\u00e1ljuk a <code>cw</code> code snippetet, amit az IntelliSense is jelez, azaz \u00edrjuk be: <code>cw</code> majd nyomjunk k\u00e9tszer Tab-ot.</li> <li>Ha a <code>Console.ReadLine()</code> helyett <code>Console.Readline()</code>-t \u00edrunk, els\u0151k\u00e9nt az IDE azonnal jav\u00edtja a hib\u00e1t. Ha ezt a jav\u00edt\u00e1st visszavonjuk Ctrl+Z), lehet\u0151s\u00e9g\u00fcnk van a jav\u00edt\u00e1sra a Ctrl+. haszn\u00e1lat\u00e1val: a fejleszt\u0151eszk\u00f6z \u00e9szreveszi, hogy hib\u00e1t v\u00e9tett\u00fcnk, \u00e9s felk\u00edn\u00e1lja a gyakori megold\u00e1sokat.</li> <li>Overload-ok: jel\u00f6lj\u00fck ki a <code>WriteLine</code> h\u00edv\u00e1s nyit\u00f3 z\u00e1r\u00f3jel\u00e9t, \u00e9s \u00edrjuk be ism\u00e9t a nyit\u00f3 z\u00e1r\u00f3jelet. \u00cdgy el\u0151j\u00f6n az overload-ok list\u00e1ja, amik k\u00f6z\u00fcl a megfelel\u0151t a f\u00f6l/le ir\u00e1nybillenty\u0171kkel v\u00e1laszthatjuk ki. Az overload list\u00e1t megnyithatjuk \u00fagy is, hogy a z\u00e1r\u00f3jelben b\u00e1rhova \u00edrunk egy vessz\u0151 karaktert. Az overload azt jelenti, hogy ugyanazzal a f\u00fcggv\u00e9nyn\u00e9vvel t\u00f6bb, k\u00fcl\u00f6nb\u00f6z\u0151 szignat\u00far\u00e1j\u00fa met\u00f3dust is felvehet\u00fcnk, a megfelel\u0151 f\u00fcggv\u00e9ny kiv\u00e1laszt\u00e1sa a megadott param\u00e9terek sz\u00e1ma \u00e9s t\u00edpusa alapj\u00e1n t\u00f6rt\u00e9nik.</li> </ul> <p>Ind\u00edtsuk el az alkalmaz\u00e1st! Ehhez a fent tal\u00e1lhat\u00f3 Start lehet\u0151s\u00e9get haszn\u00e1lhatjuk, de mondjuk el, hogy ez a men\u00fc menu:Debug[Start Debugging] (F5) lehet\u0151s\u00e9ggel ekvivalens.</p> <p>Mutassuk be a <code>for</code> \u00e9s <code>foreach</code> vez\u00e9rl\u00e9si szerkezeteket! A projekt Properties oldal\u00e1n (kbd:[Alt+Enter] a projekt kijel\u00f6l\u00e9se ut\u00e1n) adjunk meg a Debug f\u00fcl\u00f6n a Start Options blokkn\u00e1l legal\u00e1bb \u00f6t tetsz\u0151leges parancssori argumentumot (sz\u00f3k\u00f6zzel elv\u00e1lasztva), pl. kutya alma b\u00e9ka ban\u00e1n l\u00f3.</p> <p> .NET projektbe\u00e1ll\u00edt\u00e1sok</p> <pre><code>for (int i = 0; i &lt; args.Length; i++)\n    Console.WriteLine(args[i]);\n\nforeach (string arg in args)\n    Console.WriteLine(arg);\n\nConsole.ReadLine();\n</code></pre> <p>Ind\u00edtsuk el, \u00e9s gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk.</p>"},{"location":"seminar/01-csharp1/chapter1/#debug","title":"Debug","text":"<p>Rakjunk egy breakpointot (F9), vagy klikkelj\u00fcnk baloldalon a f\u00fcgg\u0151leges s\u00e1von a k\u00f3d sorsz\u00e1ma mellett) a <code>Console.WriteLine(args[i]);</code> sorra, majd ind\u00edtsuk \u00fajra az alkalmaz\u00e1st! Amikor a breakpointon meg\u00e1ll az alkalmaz\u00e1s fut\u00e1sa, a sor s\u00e1rga sz\u00edn\u0171 lesz. Ekkor vigy\u00fck az egeret az <code>i</code>, az <code>args</code> \u00e9s az <code>args.Length</code> elemek fel\u00e9, \u00e9s mutassuk meg, hogy l\u00e1thatjuk az aktu\u00e1lis \u00e9rt\u00e9keiket, komplexebb objektumok eset\u00e9n be tudjuk j\u00e1rni az objektumgr\u00e1fot. A Watch ablakba is \u00edrhatunk kifejez\u00e9seket, \u00e9s megmutathatjuk a Locals ablakot is. F10-zel (vagy a men\u00fcsoron a Step Over elemmel) l\u00e9pj\u00fcnk tov\u00e1bb, n\u00e9zz\u00fck meg, milyen sorrendben \u00e9rt\u00e9kel\u0151dik ki a <code>for</code> ciklus. Az F5-tel tov\u00e1bbengedhetj\u00fck az alkalmaz\u00e1s fut\u00e1s\u00e1t, majd z\u00e1rjuk is be.</p> <p>Mutassuk meg a Conditional Breakpoint haszn\u00e1lat\u00e1t is. Tegy\u00fcnk m\u00e9g egy breakpointot a m\u00e1sik <code>Console.WriteLine</code>-ra is. menu:Jobb eg\u00e9r gomb az els\u0151 breakpointon[Conditions\u2026], majd adjuk meg az al\u00e1bbiakat: Conditional Expression Is true <code>(i == 3)</code>. A m\u00e1sik breakpointon is adjunk meg felt\u00e9telt: Hit Count = 4. Mindk\u00e9t alkalommal a 4. elemen (ban\u00e1n) \u00e1llunk meg. Megjegyezhetj\u00fck, hogy a Conditional Breakpoint haszn\u00e1lat\u00e1val nem \u00e9rdemes mell\u00e9khat\u00e1st okoz\u00f3 m\u0171veleteket megadni, illetve hogy jelent\u0151sen le tudja cs\u00f6kkenteni a debuggol\u00e1s sebess\u00e9g\u00e9t.</p>"},{"location":"seminar/01-csharp1/chapter1/#tulajdonsagok-property-k","title":"Tulajdons\u00e1gok (Property-k)","text":"<p>Hozzuk l\u00e9tre a <code>Person</code> adatoszt\u00e1lyt! Ehhez menu: jobb katt a projekten[Add &gt; Class], a f\u00e1jl neve legyen <code>Person</code> (a kiterjeszt\u00e9st automatikusan hozz\u00e1biggyeszti a Visual Studio, ha nem adjuk meg). .NET-ben nincs megk\u00f6t\u00e9s arra, hogy a k\u00f3dokat tartalmaz\u00f3 f\u00e1jlok \u00e9s az egyes t\u00edpusok sz\u00e1moss\u00e1ga hogyan viszonyul egym\u00e1shoz: lehets\u00e9ges egy k\u00f3df\u00e1jlba is \u00edrnunk a teljes alkalmaz\u00e1s-k\u00f3dot, illetve egy oszt\u00e1lyt is sz\u00e9tdarabolhatunk t\u00f6bb f\u00e1jlra (ehhez a <code>partial</code> kulcssz\u00f3t haszn\u00e1ljuk).</p> <p>A C# tulajdons\u00e1g (property) egy szintaktikai \u00e9des\u00edt\u0151szer, amely egy objektump\u00e9ld\u00e1ny (vagy oszt\u00e1ly) egy explicit (mem\u00f3riabeli) vagy implicit (sz\u00e1rmaztatott vagy indirekt) jellemz\u0151j\u00e9t \u00edrja le. Egy tulajdons\u00e1ggal k\u00e9t m\u0171velet v\u00e9gezhet\u0151: lek\u00e9rdez\u00e9s (get) \u00e9s \u00e9rt\u00e9kad\u00e1s (set); ezeknek megadhat\u00f3 k\u00fcl\u00f6n a l\u00e1that\u00f3s\u00e1ga, \u00e9s a kett\u0151 k\u00f6z\u00fcl elegend\u0151 egy implement\u00e1l\u00e1sa. A legt\u00f6bb C# szintaktikai \u00e9des\u00edt\u0151szer a boilerplate k\u00f3dok \u00edr\u00e1s\u00e1nak elker\u00fcl\u00e9se v\u00e9gett k\u00e9sz\u00fclt, \u00edgy kevesebb k\u00f3dol\u00e1ssal \u00e9rj\u00fck el ugyanazt az eredm\u00e9nyt (sokszor az IL k\u00f3d nem is v\u00e1ltozik, gyakorlatilag hasonl\u00f3 a k\u00f3dgener\u00e1l\u00e1shoz).</p> <p>A <code>Person</code> oszt\u00e1lyban hozzuk l\u00e9tre a <code>string Name</code> property-t, <code>name</code> oszt\u00e1lyv\u00e1ltoz\u00f3val (field). Ehhez haszn\u00e1ljuk a <code>propfull</code> code snippetet (<code>propf</code>, majd Tab+Tab, ezut\u00e1n Tab-bal lehet l\u00e9pkedni a m\u00f3dos\u00edtand\u00f3 elemek k\u00f6z\u00f6tt):</p> <pre><code>public class Person\n{\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        private set { name = value; }\n    }\n\n    public Person(string name)\n    {\n        this.name = name;\n    }\n}\n</code></pre> <p>L\u00e1that\u00f3s\u00e1g</p> <p>Figyelj\u00fcnk az oszt\u00e1ly l\u00e1that\u00f3s\u00e1g\u00e1ra is, alapb\u00f3l nem publikusk\u00e9nt gener\u00e1l\u00f3dik!</p> <p>Igaz\u00e1b\u00f3l csak k\u00e9t tov\u00e1bbi (k\u00f3dban nem l\u00e1that\u00f3) met\u00f3dust hozunk l\u00e9tre, mintha egy-egy <code>GetName</code> \u00e9s <code>SetName</code> met\u00f3dust k\u00e9sz\u00edten\u00e9nk, viszont haszn\u00e1lat szempontj\u00e1b\u00f3l ugyanolyannak t\u0171nik, mintha egy sima mez\u0151 lenne. A settert priv\u00e1t l\u00e1that\u00f3s\u00e1g\u00fara tessz\u00fck, ez\u00e9rt csak egy <code>Person</code> p\u00e9ld\u00e1nyon bel\u00fclr\u0151l tudjuk \u00e1ll\u00edtani a <code>Name</code> property \u00e9rt\u00e9k\u00e9t. Jegyezz\u00fck meg, hogy a getterben \u00e9s setterben teljesen m\u00e1s jelleg\u0171 m\u0171veleteket is v\u00e9gezhet\u00fcnk (pl. els\u00fcthet\u00fcnk egy esem\u00e9nyt, hogy megv\u00e1ltozott a felhaszn\u00e1l\u00f3 neve, napl\u00f3zhatjuk, h\u00e1nyszor k\u00e9rt\u00e9k le a nev\u00e9t, stb.). A property egyik nagy er\u00e9nye, hogy oszt\u00e1lyon k\u00edv\u00fclr\u0151l az oszt\u00e1lyv\u00e1ltoz\u00f3kn\u00e1l megszokott szintaxissal haszn\u00e1lhatjuk.</p> <p>A <code>Main</code> f\u00fcggv\u00e9nybe \u00edrhatjuk p\u00e9ld\u00e1ul:</p> Program.cs<pre><code>Person p = new Person(\"Eric Lippert\");\np.Name = \"Mads Torgersen\";\nConsole.WriteLine(p.Name);\n</code></pre> <p>Debuggerrel figyelj\u00fck meg, hogy az els\u0151 sor a konstruktort, m\u00edg a m\u00e1sodik a property setter\u00e9t, v\u00e9g\u00fcl a harmadik sor ugyanazon property getter\u00e9t h\u00edvja.</p> <p>Mivel a backing field \u00e1ll\u00edt\u00e1s\u00e1n k\u00edv\u00fcl nem csin\u00e1lunk semmit a property k\u00f3dban, ez\u00e9rt haszn\u00e1lhatjuk a <code>propg</code> code snippetet is:</p> Person.cs<pre><code>public string Name { get; private set; }\n</code></pre> <p>Ez az \u00fan. auto-implement\u00e1lt property szintaxis. A property \u00e1ltal lek\u00e9rdezhet\u0151-be\u00e1ll\u00edthat\u00f3 field gener\u00e1l\u00f3dik, arra a k\u00f3dban nem is tudunk hivatkozni - ez az egys\u00e9gbe z\u00e1r\u00e1s miatt el\u0151ny\u00f6s.</p> <p>A l\u00e1that\u00f3s\u00e1g miatt a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben a setter h\u00edv\u00e1s m\u00e1r nem fordul, kommentezz\u00fck ki.</p> Person.cs<pre><code>//p.Name = \"Mads Torgersen\";\n</code></pre> <p>L\u00e9tezik m\u00e9g a <code>prop</code> code snippet is, ami mindk\u00e9t m\u00f3dos\u00edt\u00f3sz\u00f3t publikusan hagyja. L\u00e1that\u00f3s\u00e1gi m\u00f3dos\u00edt\u00f3sz\u00f3t a <code>get</code> \u00e9s <code>set</code> k\u00f6z\u00fcl csak az egyik el\u00e9 tehet\u00fcnk ki, \u00e9s az is csak szigor\u00edthat a k\u00fcls\u0151 l\u00e1that\u00f3s\u00e1gon (ekkor a m\u00e1sik a k\u00fcls\u0151t kapja meg).</p> <p>Ez a megold\u00e1s az el\u0151z\u0151vel teljes m\u00e9rt\u00e9kben ekvivalens (csak nem l\u00e1tjuk a gener\u00e1lt backing fieldet, de val\u00f3j\u00e1ban ott van). Ha van id\u0151nk, akkor vizsg\u00e1ljuk meg decompilerben (pl. Telerik JustDecompile), hogy val\u00f3ban \u00edgy van.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3an vegy\u00fck fel a sz\u00fclet\u00e9si d\u00e1tumot is. A sz\u00fclet\u00e9si d\u00e1tum nem v\u00e1ltozhat, gyakorlatilag <code>readonly</code> mez\u0151r\u0151l van sz\u00f3. Ha egy tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t az objektum is csak a konstruktorban tudja megadni, akkor a setter teljes m\u00e9rt\u00e9kben elhagyhat\u00f3:</p> Person.cs<pre><code>public DateTime DateOfBirth { get; }\n\npublic Person(string name, DateTime dateOfBirth)\n{\n    Name = name;\n    DateOfBirth = dateOfBirth;\n}\n</code></pre> <p>Ez a szintaktika megegyezik azzal, mintha egy <code>readonly</code> mez\u0151t haszn\u00e1ln\u00e1nk, azaz a mez\u0151 \u00e9rt\u00e9ke legk\u00e9s\u0151bb a konstruktorban inicializ\u00e1land\u00f3.</p> <p>Vegy\u00fcnk fel neki egy azonos\u00edt\u00f3t, ami egy <code>Guid</code> strukt\u00fara t\u00edpus\u00fa legyen:</p> Person.cs<pre><code>public Guid Id { get; } = Guid.NewGuid();\n</code></pre> <p>Ez egy csak lek\u00e9rdezhet\u0151 tulajdons\u00e1g, ami konstru\u00e1l\u00e1skor inicializ\u00e1l\u00f3dik egy \u00faj v\u00e9letlenszer\u0171 azonos\u00edt\u00f3 \u00e9rt\u00e9kre.</p> <p>Megadhatjuk a kort, mint implicit/sz\u00e1m\u00edtott tulajdons\u00e1got:</p> Person.cs<pre><code>public int Age { get { return DateTime.Now.Subtract(DateOfBirth).Days / 365; } }\n</code></pre> <p>Mivel a f\u00fcggv\u00e9ny\u00fcnk t\u00f6rzse egyetlen kifejez\u00e9ssel megadhat\u00f3, ez\u00e9rt elhagyva a sallangot (<code>return</code>, kapcsos z\u00e1r\u00f3jelek, stb.) expression bodied property szintaxissal is \u00edrhatjuk:</p> Person.cs<pre><code>public int Age =&gt; DateTime.Now.Subtract(DateOfBirth).Days / 365;\n</code></pre> <p>Tip</p> <p>Alkalmaz\u00e1sok fejleszt\u00e9sekor a legfontosabb els\u0151 l\u00e9p\u00e9sek egyike, hogy az objektummodell\u00fcnk \u00e1tl\u00e1that\u00f3, karbantarthat\u00f3 \u00e9s egy\u00e9rtelm\u0171 legyen. A C# v\u00e1ltozatos szintaxisa nagyon sokat seg\u00edt ezen c\u00e9lok el\u00e9r\u00e9s\u00e9ben.</p>"},{"location":"seminar/01-csharp1/chapter1/#generikus-kollekcio","title":"Generikus kollekci\u00f3","text":"<p>A <code>Main</code> met\u00f3dusban vegy\u00fcnk fel n\u00e9h\u00e1ny <code>Person</code> objektumot, \u00e9s list\u00e1zzuk ki a relev\u00e1ns tulajdons\u00e1gaikat! Ehhez egy <code>Person</code> list\u00e1ban t\u00e1roljuk a szem\u00e9lyeket. A <code>List</code> generikus kollekci\u00f3, azaz t\u00edpusparam\u00e9tert v\u00e1r, t\u00edpusokkal param\u00e9terezhet\u0151. A <code>List</code> t\u00edpusparam\u00e9tere jelzi, hogy milyen t\u00edpus\u00fa objektumokat t\u00e1rol. Met\u00f3dusok, tulajdons\u00e1gok, t\u00edpusok lehetnek generikusak. A genericit\u00e1s fontos a k\u00f3dunk \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1ga \u00e9s karbantarthat\u00f3s\u00e1ga \u00e9rdek\u00e9ben.</p> <pre><code>static void Main(string[] args)\n{\n    List&lt;Person&gt; people = new List&lt;Person&gt;();\n    people.Add(new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)));\n    people.Add(new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)));\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n\n    foreach (Person person in people)\n        Console.WriteLine(person);\n\n    Console.ReadLine();\n}\n</code></pre> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, mi t\u00f6rt\u00e9nik! Annyiszor \u00edr\u00f3dik ki a <code>Person</code> oszt\u00e1lyunk teljes neve (fully qualified type name), ah\u00e1ny elem van a list\u00e1ban.</p>"},{"location":"seminar/01-csharp1/chapter1/#leszarmazas-string-interpolacio","title":"Lesz\u00e1rmaz\u00e1s, string interpol\u00e1ci\u00f3","text":"<p>Ha a <code>WriteLine</code> f\u00f6l\u00e9 vissz\u00fck az egeret, l\u00e1that\u00f3, hogy az overload-ok k\u00f6z\u00fcl az h\u00edv\u00f3dik meg, amelyik objektumot v\u00e1r param\u00e9ter\u00fcl. Ebben az esetben a param\u00e9ter <code>ToString</code> met\u00f3dus\u00e1t h\u00edvja meg a <code>WriteLine</code>, ami alap\u00e9rtelmez\u00e9s szerint az objektum t\u00edpus\u00e1nak teljes nev\u00e9t adj\u00e1k vissza. Tegy\u00fck szebb\u00e9 a ki\u00edr\u00e1st, defini\u00e1ljuk fel\u00fcl az alap\u00e9rtelmezett <code>ToString</code> implement\u00e1ci\u00f3t a <code>Person</code> oszt\u00e1lyban:</p> Person.cs<pre><code>public override string ToString()\n{\n    return string.Format(\"{0} ({1}) [ID: {2}]\", Name, Age, Id);\n}\n</code></pre> <p>A <code>Person</code> oszt\u00e1lynak nincs explicit megadva \u0151soszt\u00e1lya, m\u00e9gis van fel\u00fcldefini\u00e1lhat\u00f3 f\u00fcggv\u00e9nye. Ezeket az <code>Object</code> oszt\u00e1ly defini\u00e1lja. Ha egy referencia t\u00edpusnak nincs megadva \u0151soszt\u00e1lya, akkor az <code>Object</code> lesz az.</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1ra m\u00e1s szintaktikai \u00e9des\u00edt\u0151szereket is haszn\u00e1lhatunk:</p> Person.cs<pre><code>public override string ToString() =&gt; $\"{Name} ({Age}) [ID: {Id}]\";\n</code></pre> <p>A k\u00e9t implement\u00e1ci\u00f3 ekvivalens, a m\u00e1sodik implement\u00e1ci\u00f3 az \u00fan. expression bodied method \u00e9s a string interpol\u00e1ci\u00f3 kombin\u00e1l\u00e1s\u00e1b\u00f3l ad\u00f3dik.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st!</p> <p>Hozzuk l\u00e9tre a <code>Student</code> oszt\u00e1lyt, ami sz\u00e1rmazik a <code>Person</code> oszt\u00e1lyb\u00f3l!</p> <pre><code>public class Student : Person\n{\n    public string Neptun { get; set; }\n\n    public string Major { get; set; }\n\n    public Student(string name, DateTime dateOfBirth)\n        : base(name, dateOfBirth)\n    {\n    }\n\n    public override string ToString() =&gt; $\"{base.ToString()} Neptun: {Neptun} Major: {Major}\";\n}\n</code></pre> <p>Ez az oszt\u00e1ly m\u00e1s megk\u00f6zel\u00edt\u00e9ssel k\u00e9sz\u00fclt, mint a sz\u00fcl\u0151je, az \u00e1llapota nem a konstruktor megh\u00edv\u00e1sakor t\u00f6lt\u0151dik fel, ut\u00f3lag lehet megadni setter h\u00edv\u00e1sokkal. Ez egyr\u00e9szt k\u00e9nyelmes, mert nem kell sokparam\u00e9teres konstruktorokkal k\u00fczdeni, m\u00e1sr\u00e9szt fel kell k\u00e9sz\u00fcln\u00fcnk arra, hogy bizonyos adatokat nem t\u00f6ltenek ki.</p> <p>\u0150s konstruktora</p> <p>Ha az \u0151soszt\u00e1lynak nincs param\u00e9ter n\u00e9lk\u00fcli konstruktora (a <code>Person</code> oszt\u00e1lynak nincs), akkor k\u00f6telesek vagyunk a gyerek konstruktorban az \u0151soszt\u00e1ly valamelyik konstruktor\u00e1t megh\u00edvni a <code>base</code> kulcssz\u00f3val.</p>"},{"location":"seminar/01-csharp1/chapter1/#objektum-inicializalok","title":"Objektum inicializ\u00e1l\u00f3k","text":"<p>Az object initializer seg\u00edts\u00e9g\u00e9vel az objektum l\u00e9trehoz\u00e1s\u00e1t (konstruktor h\u00edv\u00e1s) \u00e9s a property setterek megh\u00edv\u00e1s\u00e1val t\u00f6rt\u00e9n\u0151 inicializ\u00e1l\u00e1s\u00e1t int\u00e9zhetj\u00fck egy f\u00fcst alatt.  Az objektum inicializ\u00e1l\u00f3 csak konstruktorh\u00edv\u00e1s eset\u00e9n haszn\u00e1lhat\u00f3, \u00edgy pl. factory met\u00f3dus \u00e1ltal gy\u00e1rtott objektump\u00e9ld\u00e1ny eset\u00e9n nem.</p> <p>A <code>Main</code> met\u00f3dusban \u00edrhatjuk az al\u00e1bbi p\u00e9ld\u00e1t:</p> <pre><code>static void Main(string[] args)\n{\n    /*...*/\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n    Student elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major = \"Info BSc\"\n    };\n    /*...*/\n}\n</code></pre> <p>Konstruktor szintaktik\u00e1k</p> <p>Objektum inicializ\u00e1l\u00e1s sor\u00e1n, param\u00e9ter n\u00e9lk\u00fcli konstruktor eset\u00e9n a <code>()</code> is elhagyhat\u00f3.</p> <p>T\u00f6bb sorba t\u00f6rdel\u00e9s</p> <p>\u00c1ltal\u00e1ban 1-2 tulajdons\u00e1g eset\u00e9n lehet egy sorba is \u00edrni az inicializ\u00e1ci\u00f3t, t\u00f6bb eset\u00e9n viszont \u00e1ltal\u00e1ban t\u00f6bb sorba \u00e9rdemes t\u00f6rdelni az olvashat\u00f3s\u00e1g \u00e9rdek\u00e9ben.</p> <p>L\u00e1thatjuk, hogy csak az aktu\u00e1lis kontextusban egy\u00e9bk\u00e9nt is l\u00e1that\u00f3 \u00e9s be\u00e1ll\u00edthat\u00f3 tulajdons\u00e1gokat \u00e1ll\u00edthatjuk be, egyik \u00edgy be\u00e1ll\u00edtott tulajdons\u00e1g sem k\u00f6telez\u0151 jelleg\u0171.</p> <p>Az object initializer val\u00f3ban csak az egyes tulajdons\u00e1gokat \u00e1ll\u00edtja be, teh\u00e1t csak szintaktikailag k\u00fcl\u00f6nb\u00f6zik az els\u0151 defin\u00edci\u00f3 az al\u00e1bbit\u00f3l:</p> <p>Note</p> <p>Nem kell be\u00edrni, csak szeml\u00e9ltet\u00e9s.</p> <pre><code>Student _elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10));\n_elek.Neptun = \"ABC123\";\n_elek.Major = \"Info BSc\";\nStudent elek = _elek;\n</code></pre> <p>A h\u00e1tt\u00e9rben t\u00e9nyleg egy (sz\u00e1munkra nem l\u00e1that\u00f3) tempor\u00e1lis v\u00e1ltoz\u00f3ban fog t\u00f6rt\u00e9nni az inicializ\u00e1ci\u00f3, ugyanis, ha az object initializer kiv\u00e9telt dob (az egyik setter \u00e1ltal), az objektumunk nem veszi fel a k\u00edv\u00e1nt \u00e9rt\u00e9ket.</p> <p>Objektum inicializ\u00e1l\u00f3 haszna</p> <p>Ebb\u0151l l\u00e1tszik az objektum inicializ\u00e1l\u00f3 els\u0151dleges haszna, m\u00e9gpedig, hogy nem kell \u00e1lland\u00f3an ki\u00edrogatni, hogy melyik p\u00e9ld\u00e1nyra gondolunk (\u00edgy elrontani sem tudjuk).</p>"},{"location":"seminar/01-csharp1/chapter1/#kollekcio-inicializacio","title":"Kollekci\u00f3 inicializ\u00e1ci\u00f3","text":"<p>Az egyszer\u0171s\u00edtett kollekci\u00f3 inicializ\u00e1ci\u00f3 szintaxissal a lista teljes felt\u00f6lt\u00e9se j\u00f3val kevesebb k\u00f3ddal \u00e9s j\u00f3val olvashat\u00f3bban megadhat\u00f3. R\u00e1ad\u00e1sul a kollekci\u00f3 elemeit l\u00e9trehozhatjuk az objektum inicializ\u00e1ci\u00f3s szintaxissal is. A teljes lista l\u00e9trehoz\u00e1st \u00e9s -felt\u00f6lt\u00e9s r\u00e9szt cser\u00e9lj\u00fck le az al\u00e1bbira.</p> <pre><code>List&lt;Person&gt; people = new List&lt;Person&gt;\n{\n    new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)),\n    new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)),\n    new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)),\n    new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major=\"Info BSc\"\n    },\n    new Student(\"Hi\u00e1ny \u00c1ron\", new DateTime(2000, 02, 13))\n};\n</code></pre> <p>Nem kell az <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1st \u00e9s a lista referenci\u00e1t ki\u00edrni, egy\u00e9rtelm\u0171, hogy melyik list\u00e1hoz adunk hozz\u00e1.</p> <p>Add</p> <p>Ez a forma is ugyanolyan <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokra fordul, mint az eredeti v\u00e1ltozatban.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! L\u00e1thatjuk, hogy a konstruktoron kereszt\u00fcl teljesen inicializ\u00e1lhat\u00f3 <code>Person</code> p\u00e9ld\u00e1nyok eset\u00e9ben a ki\u00edr\u00e1s teljes, viszont vannak olyan <code>Student</code> p\u00e9ld\u00e1nyok, ahol a ki\u00edr\u00e1s \u00fcres \u00e9rt\u00e9keket tal\u00e1l. Ezzel a jelens\u00e9ggel a k\u00f6vetkez\u0151 gyakorlatokon tov\u00e1bb foglalkozunk.</p>"},{"location":"seminar/02-csharp2/chapter2/","title":"C# alapok II.","text":""},{"location":"seminar/02-csharp2/chapter2/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt hozzunk l\u00e9tre egy .NET C# konzolalkalmaz\u00e1st: a projektsablon sz\u0171r\u0151ben v\u00e1lasszuk a C# nyelv - Windows platform - Console projektt\u00edpust. A sz\u0171rt list\u00e1ban v\u00e1lasszuk a Console App sablont (ne a .NET Framework-\u00f6s legyen). A neve legyen HelloCSharp2. A solutiont ne tegy\u00fck k\u00fcl\u00f6n mapp\u00e1ba (Place solution and project in the same directory legyen bekapcsolva). A megc\u00e9lzott framework verzi\u00f3 legyen .NET 8.</p>"},{"location":"seminar/02-csharp2/chapter2/#legfelso-szintu-utasitasok-implicit-globalis-nevter-hivatkozasok","title":"Legfels\u0151 szint\u0171 utas\u00edt\u00e1sok, implicit glob\u00e1lis n\u00e9vt\u00e9r-hivatkoz\u00e1sok","text":"<p>Csod\u00e1lkozzunk r\u00e1, hogy a gener\u00e1lt projekt mind\u00f6ssze egyetlen \u00e9rdemi sort tartalmaz.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\n</code></pre> <p>C# 10 \u00f3ta a program bel\u00e9p\u00e9si pontj\u00e1t ad\u00f3 forr\u00e1sf\u00e1jlt jelent\u0151sen ler\u00f6vid\u00edthetj\u00fck:</p> <ul> <li>a f\u00e1jl tetej\u00e9n l\u00e9v\u0151 using-okat elhagyhatjuk, ha azok implicit hivatkozva vannak. Az implicit hivatkozott using-ok projektt\u00edpust\u00f3l f\u00fcggenek \u00e9s a dokument\u00e1ci\u00f3b\u00f3l olvashatjuk ki</li> <li>a <code>Main</code> f\u00fcggv\u00e9nyt tartalmaz\u00f3 oszt\u00e1ly deklar\u00e1ci\u00f3j\u00e1t (<code>namespace</code> blokk, <code>class</code> blokk) elhagyhatjuk, ezt a ford\u00edt\u00f3 gener\u00e1lja nek\u00fcnk</li> <li>a <code>Main</code> f\u00fcggv\u00e9ny deklar\u00e1ci\u00f3j\u00e1t szint\u00e9n gener\u00e1lja a ford\u00edt\u00f3. A met\u00f3dus neve nem defini\u00e1lt, nem (biztos, hogy) <code>Main</code>. A met\u00f3dus szignat\u00far\u00e1ja att\u00f3l f\u00fcgg, milyen utas\u00edt\u00e1sokat adunk meg a forr\u00e1sf\u00e1jlban. P\u00e9ld\u00e1ul, ha nincs return, akkor <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. A param\u00e9tere viszont mindig <code>string[] args</code>.</li> <li>a f\u00fcggv\u00e9ny blokkba nem foglalt k\u00f3d a gener\u00e1lt bel\u00e9p\u00e9si pont f\u00fcggv\u00e9ny belsej\u00e9be ker\u00fcl. F\u00fcggv\u00e9nyt is \u00edrhatunk, az a bel\u00e9p\u00e9si pontot tartalmaz\u00f3 gener\u00e1lt oszt\u00e1ly tagf\u00fcggv\u00e9nye lesz.</li> <li>t\u00edpusokat, oszt\u00e1lyokat is defini\u00e1lhatunk, de csak a legfels\u0151 szint\u0171 k\u00f3dot k\u00f6vet\u0151en</li> </ul> <p>Warning</p> <p>Fontos \u00e9szrev\u00e9tel a fentiekb\u0151l: ezen k\u00e9pess\u00e9g nem v\u00e1ltoztatja meg a C# semmilyen alapvet\u0151 jellemz\u0151j\u00e9t, p\u00e9ld\u00e1ul ugyan\u00fagy minden f\u00fcggv\u00e9nynek oszt\u00e1lyon bel\u00fcl kell lennie. A ford\u00edt\u00e1s sor\u00e1n a legfels\u0151 szint\u0171 utas\u00edt\u00e1sok k\u00f3dja \u00fagy eg\u00e9sz\u00fcl ki, ami m\u00e1r minden szab\u00e1lynak megfelel.</p> <p>L\u00e1that\u00f3s\u00e1g</p> <p>A legfels\u0151 szint\u0171 k\u00f3d olyan, amit a program m\u00e1s r\u00e9sz\u00e9r\u0151l nem tudunk h\u00edvni, hiszen nem is ismerj\u00fck a burkol\u00f3 oszt\u00e1ly nev\u00e9t. Emiatt nincs \u00e9rtelme legfels\u0151 szint\u0171 k\u00f3dban l\u00e1that\u00f3s\u00e1gi be\u00e1ll\u00edt\u00e1snak (<code>private</code>, <code>protected</code> stb.) vagy propertynek.</p> <p>Akad\u00e1lyozzuk meg a program azonnali lefut\u00e1s\u00e1t egy blokkol\u00f3 h\u00edv\u00e1ssal.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\nConsole.ReadLine();\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a gener\u00e1lt projektet mindenf\u00e9le egy\u00e9b v\u00e1ltoztat\u00e1s n\u00e9lk\u00fcl, ford\u00edt\u00e1s (menu:projekten jobbklikk[Build]) ut\u00e1n. N\u00e9zz\u00fcnk bele a kimeneti k\u00f6nyvt\u00e1rba (menu:projekten jobbklikk[Open Folder in File Explorer], majd menu:bin[Debug &gt; net8.0]): l\u00e1that\u00f3, hogy az alkalmaz\u00e1sunkb\u00f3l a ford\u00edt\u00e1s sor\u00e1n egy cross-platform bin\u00e1ris (\\&lt;projektn\u00e9v&gt;.dll) \u00e9s .NET Core v3 \u00f3ta egy platform specifikus futtathat\u00f3 \u00e1llom\u00e1ny (Windows eset\u00e9n \\&lt;projektn\u00e9v&gt;.exe) is gener\u00e1l\u00f3dik. Kipr\u00f3b\u00e1lhatjuk, hogy az exe a szokott m\u00f3don ind\u00edthat\u00f3 (pl. duplaklikkel), m\u00edg a dll a <code>dotnet</code> paranccsal.</p> <pre><code>dotnet &lt;projektn\u00e9v.dll&gt;\n</code></pre> <p>Parancssor aktu\u00e1lis mapp\u00e1ja</p> <p>A dotnet parancshoz a dll k\u00f6nyvt\u00e1r\u00e1ban kell lenn\u00fcnk. Ehhez a legegyszer\u0171bb, ha a Windows f\u00e1jlkezel\u0151ben a megfelel\u0151 k\u00f6nyvt\u00e1rban \u00e1llva az el\u00e9r\u00e9si \u00fatvonal mez\u0151t \u00e1t\u00edrjuk a <code>cmd</code> sz\u00f6vegre, majd kbd:[ENTER]-t nyomunk.</p> <p>Adjunk a l\u00e9trej\u00f6v\u0151 projekthez egy <code>Dog</code> oszt\u00e1lyt Dog.cs n\u00e9ven, ez lesz az adatmodell\u00fcnk:</p> <pre><code>public class Dog\n{\n    public string Name { get; set; }\n    public Guid Id { get; } = Guid.NewGuid();\n    public DateTime DateOfBirth { get; set; }\n    private int AgeInDays =&gt; DateTime.Now.Subtract(DateOfBirth).Days;\n    public int Age =&gt; AgeInDays / 365;\n    public int AgeInDogYears =&gt; AgeInDays * 7 / 365;\n    public override string ToString() =&gt;\n            $\"{Name} ({Age} | {AgeInDogYears}) [ID: {Id}]\";\n}\n</code></pre> <p>Az adatmodell az el\u0151z\u0151 \u00f3r\u00e1n l\u00e9trehozotthoz nagyon hasonl\u00edt, ennek viszont nincsen explicit konstruktora \u00e9s a <code>Name</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gok publikusan is \u00e1ll\u00edthat\u00f3k.</p> <p>Hozzunk l\u00e9tre egy <code>Dog</code> p\u00e9ld\u00e1nyt objektum inicializ\u00e1ci\u00f3s szintaxissal, majd \u00edrjuk ki ezt a p\u00e9ld\u00e1nyt a kezdeti k\u00f6sz\u00f6nt\u0151 sz\u00f6veg helyett:</p> <pre><code>Dog banan = new Dog\n{\n    Name = \"Ban\u00e1n\",\n    DateOfBirth = new DateTime(2014, 06, 10)\n};\nConsole.WriteLine(banan);\n</code></pre> <p>Ezzel k\u00e9sz a kiindul\u00f3 projekt\u00fcnk.</p>"},{"location":"seminar/02-csharp2/chapter2/#implicit-tipusdeklaracio","title":"Implicit t\u00edpusdeklar\u00e1ci\u00f3","text":"<p>A <code>var</code> kulcssz\u00f3 jelent\u0151s\u00e9ge: ha a ford\u00edt\u00f3 ki tudja tal\u00e1lni a kontextusb\u00f3l az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n \u00e1ll\u00f3 \u00e9rt\u00e9k t\u00edpus\u00e1t, nem sz\u00fcks\u00e9ges a t\u00edpus nev\u00e9t explicit megadnunk, az implicit k\u00f6vetkezik a k\u00f3db\u00f3l. Ebben az esetben a t\u00edpus egy\u00e9rtelm\u0171en <code>Dog</code>. Ha csak deklar\u00e1lni szeretn\u00e9nk egy v\u00e1ltoz\u00f3t (nem adunk \u00e9rt\u00e9k\u00fcl a v\u00e1ltoz\u00f3nak semmit), akkor nem haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t, ugyanis nem k\u00f6vetkezik a k\u00f3db\u00f3l a v\u00e1ltoz\u00f3 t\u00edpusa. Ekkor explicit meg kell adnunk a t\u00edpust.</p> <pre><code>Dog banan = new Dog\n{\n   Name = \"Ban\u00e1n\",\n   DateOfBirth = new DateTime(2014, 06, 10)\n};\nvar watson = new Dog { Name = \"Watson\" };\n\nvar unnamed = new Dog { DateOfBirth = new DateTime(2017, 02, 10) };\nvar unknown = new Dog { };\n//watson = 3; // \n//var error;  // \n\nConsole.WriteLine(banan);\nConsole.ReadLine();\n</code></pre> <ul> <li>Ford\u00edt\u00e1si hiba: a <code>watson</code> deklar\u00e1ci\u00f3jakor eld\u0151lt, hogy \u0151 <code>Dog</code> t\u00edpus, ut\u00f3lag nem lehet megv\u00e1ltoztatni \u00e9s p\u00e9ld\u00e1ul sz\u00e1m\u00e9rt\u00e9ket \u00e9rt\u00e9k\u00fcl adni. Ez nem JavaScript.</li> <li>Ford\u00edt\u00e1si hiba: implicit t\u00edpust csak \u00fagy lehet deklar\u00e1lni, ha egy\u00fattal inicializ\u00e1ljuk is. Az inicializ\u00e1ci\u00f3s kifejez\u00e9s alapj\u00e1n d\u0151l el (implicit) a p\u00e9ld\u00e1ny t\u00edpusa.</li> </ul> <p>Pr\u00f3b\u00e1ljuk ki a nem fordul\u00f3 sorokat, n\u00e9zz\u00fck meg a ford\u00edt\u00f3 hiba\u00fczeneteit!</p> <p>Er\u0151ss t\u00edpusos\u00e1g</p> <p>A <code>var</code> nem a gyenge t\u00edpusoss\u00e1g jele a C#-ban, nem \u00fagy, mint pl. JavaScript-ben. Az inicializ\u00e1ci\u00f3s sor ut\u00e1n a t\u00edpus egy\u00e9rtelm\u0171en eld\u0151l, ut\u00e1na m\u00e1r csak ennek a t\u00edpusnak megfelel\u0151 m\u0171veletek v\u00e9gezhet\u0151k, p\u00e9ld\u00e1ul egy \u00e9rt\u00e9kad\u00e1ssal nem v\u00e1ltoztathatjuk meg a t\u00edpust.</p> <p>A <code>var</code>-t tipikusan akkor alkalmazzuk, ha:</p> <ul> <li>hossz\u00fa t\u00edpusneveket nem akarunk ki\u00edrni</li> <li>feleslegesnek tartjuk az inicializ\u00e1ci\u00f3 mindk\u00e9t oldal\u00e1n ki\u00edrni ugyanazt a t\u00edpust</li> <li>anonim t\u00edpusokat haszn\u00e1lunk (k\u00e9s\u0151bb)</li> </ul>"},{"location":"seminar/02-csharp2/chapter2/#init-only-setter","title":"Init-only setter","text":"<p>Az objektum inicializ\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9hez sz\u00fcks\u00e9ges a megfelel\u0151 l\u00e1that\u00f3s\u00e1g\u00fa setter. Viszont egy ilyen settert nem csak objektum inicializ\u00e1ci\u00f3kor lehet haszn\u00e1lni, hanem b\u00e1rmikor \u00e1t\u00e1ll\u00edthatjuk egy p\u00e9ld\u00e1ny adat\u00e1t (mut\u00e1ci\u00f3).</p> <p>Az al\u00e1bbi p\u00e9lda egy ilyen ut\u00f3lagos m\u00f3dos\u00edt\u00e1sra / mut\u00e1ci\u00f3ra.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nwatson.Name = \"Sherlock\";\n</code></pre> <p>Ez \u00edgy hiba n\u00e9lk\u00fcl lefordul.</p> <p>Kiz\u00e1r\u00f3lag az inicializ\u00e1ci\u00f3ra korl\u00e1tozhatjuk a setter megh\u00edv\u00e1s\u00e1t az init-only setterrel (<code>init</code> kulcssz\u00f3).</p> <pre><code>public class Dog\n{\n    public string Name { get; init; }\n    //...\n}\n</code></pre> <p>Ezut\u00e1n az inicializ\u00e1ci\u00f3s sor tov\u00e1bbra is lefordul, de a n\u00e9v\u00e1t\u00edr\u00e1sos m\u00e1r nem. Ez ut\u00f3bbi sort kommentezz\u00fck ki.</p> <p>Init-only setter konstruktorb\u00f3l</p> <p>Init-only settert az oszt\u00e1ly konstruktor\u00e1b\u00f3l is meg lehet h\u00edvni - hiszen az is inicializ\u00e1ci\u00f3.</p> <p>Haszn\u00e1lata</p> <p>Init-only settert t\u00f6bb okb\u00f3l kifoly\u00f3lag is haszn\u00e1lhatunk, p\u00e9ld\u00e1ul a t\u00edpus p\u00e9ld\u00e1nyainak immut\u00e1bilis kezel\u00e9s\u00e9t akarjuk kik\u00e9nyszer\u00edteni, vagy csak inicializ\u00e1ci\u00f3ra akarjuk korl\u00e1tozni a propertyk be\u00e1ll\u00edt\u00e1s\u00e1t, de nem akarunk ehhez konstruktort \u00edrni.</p> <p>Jelen form\u00e1j\u00e1ban az init-only setter nem tudja helyettes\u00edteni a k\u00f6telez\u0151 konstruktor param\u00e9tert, mert nem k\u00f6telez\u0151 kit\u00f6lteni ezt a propertyt. Erre a megold\u00e1s a C# 11-ben bevezetett <code>required</code> kulcssz\u00f3 a property el\u0151tt.</p> <pre><code>public class Dog\n{\n    public required string Name { get; init;  }\n    //...\n}\n</code></pre> <p>Ezzel k\u00f6telez\u0151v\u00e9 v\u00e1lik a <code>Name</code> kit\u00f6lt\u00e9se, ha a <code>Dog</code> p\u00e9ld\u00e1nyt inicializ\u00e1ljuk.</p>"},{"location":"seminar/02-csharp2/chapter2/#indexer-operator-nameof-operator-index-inicializalo","title":"Indexer oper\u00e1tor, nameof oper\u00e1tor, index inicializ\u00e1l\u00f3","text":"<p>A collection initializer anal\u00f3gi\u00e1j\u00e1ra j\u00f6tt l\u00e9tre az index initializer nyelvi elem, ami a kor\u00e1bbihoz hasonl\u00f3an sorban h\u00edv meg egy oper\u00e1tort, hogy m\u00e1r inicializ\u00e1lt objektumot kapjunk vissza. A k\u00fcl\u00f6nbs\u00e9g egyr\u00e9szt a szintaxis, m\u00e1sr\u00e9szt az ilyenkor megh\u00edvott met\u00f3dus, ami az index oper\u00e1tor.</p> <p>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s</p> <p>Saj\u00e1t t\u00edpusainkban lehet\u0151s\u00e9g\u00fcnk van defini\u00e1lni \u00e9s fel\u00fcldefini\u00e1lni oper\u00e1torokat, mint pl. +, -, indexel\u00e9s, implicit cast, explicit cast, stb.</p> <p>Tegy\u00fck fel, hogy egy kuty\u00e1hoz b\u00e1rmilyen, \u00fczleti logik\u00e1ban nem felhaszn\u00e1lt inform\u00e1ci\u00f3 ker\u00fclhet, amire \u00e1ltal\u00e1nos strukt\u00far\u00e1t szeretn\u00e9nk. Vegy\u00fcnk fel a <code>Dog</code> oszt\u00e1lyba egy <code>string-object</code> sz\u00f3t\u00e1rat, amiben b\u00e1rmilyen tov\u00e1bbi inform\u00e1ci\u00f3t t\u00e1rolhatunk! Ezen fel\u00fcl \u00e1ll\u00edtsuk be a <code>Dog</code> indexer\u00e9t, hogy az a <code>Metadata</code> indexel\u00e9s\u00e9t v\u00e9gezze:</p> <pre><code>public class Dog\n{\n    //...\n    public Dictionary&lt;string, object&gt;  Metadata { get; } = new();\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>Konstruktor t\u00edpus n\u00e9lk\u00fcl</p> <p>A <code>new</code> oper\u00e1tor ut\u00e1ni konstruktorh\u00edv\u00e1s sok esetben elhagyhat\u00f3, ha a bal oldal alapj\u00e1n am\u00fagy is tudhat\u00f3 a t\u00edpus.</p> <p>n\u00e9vt\u00e9r hivatkoz\u00e1sok</p> <p>Az \u00fajabb projektsablonok sokkal kevesebb n\u00e9vt\u00e9rdeklar\u00e1ci\u00f3t (<code>using</code>) gener\u00e1lnak alapb\u00f3l. Ha kell, vegy\u00fck fel a sz\u00fcks\u00e9geseket a fel nem oldott n\u00e9ven \u00e1llva a gyorsm\u0171velet (villanyk\u00f6rte) eszk\u00f6zzel (Ctrl+.)</p> <p>Az objektum inicializ\u00e1l\u00f3 \u00e9s az index inicializ\u00e1l\u00f3 vegy\u00edthet\u0151, \u00edgy az al\u00e1bbi m\u00f3don tudunk felvenni tov\u00e1bbi tulajdons\u00e1gokat a kuty\u00e1khoz a legfels\u0151 szint\u0171 k\u00f3dba:</p> <pre><code>var pimpedli = new Dog\n{\n    Name = \"Pimpedli\",\n    DateOfBirth = new DateTime(2006, 06, 10),\n    [\"Chip azonos\u00edt\u00f3\"] = \"123125AJ\"\n};\n</code></pre> <p>Mivel indexelni \u00e1ltal\u00e1ban kollekci\u00f3kat szok\u00e1s (t\u00f6mb, lista, sz\u00f3t\u00e1r), ez\u00e9rt ezekben az esetekben igen j\u00f3 eszk\u00f6z lehet az index inicializ\u00e1l\u00f3. Vegy\u00fcnk fel egy \u00faj kutyasz\u00f3t\u00e1rt a kuty\u00e1k kiteny\u00e9szt\u00e9se ut\u00e1n:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [\"banan\"] = banan,\n    [\"watson\"] = watson,\n    [\"unnamed\"] = unnamed,\n    [\"unknown\"] = unknown,\n    [\"pimpedli\"] = pimpedli\n};\n\nforeach (var dog in dogs)\n    Console.WriteLine($\"{dog.Key} - {dog.Value}\");\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki - minden n\u00e9v-kutya p\u00e1rt ki kell \u00edrnia a sz\u00f3t\u00e1rb\u00f3l.</p> <p>Els\u0151re j\u00f3 \u00f6tletnek t\u0171nhet kiv\u00e1ltani a sz\u00f6vegliter\u00e1lokat a <code>Name</code> property haszn\u00e1lat\u00e1val.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [banan.Name] = banan,\n    [watson.Name] = watson,\n    [unnamed.Name] = unnamed,\n    [unknown.Name] = unknown,\n    [pimpedli.Name] = pimpedli\n};\n//ArgumentNullException!\n</code></pre> <p>Ez azonban kiv\u00e9telt okoz, amikor a kutya neve nincs kit\u00f6ltve, azaz <code>null</code> \u00e9rt\u00e9k\u0171. Eset\u00fcnkben el\u00e9g lenne az adott v\u00e1ltoz\u00f3 neve sz\u00f6vegk\u00e9nt. Erre j\u00f3 a <code>nameof</code> oper\u00e1tor.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [nameof(banan)] = banan,\n    [nameof(watson)] = watson,\n    [nameof(unnamed)] = unnamed,\n    [nameof(unknown)] = unknown,\n    [nameof(pimpedli)] = pimpedli\n};\n</code></pre> <p>Ez a v\u00e1ltozat m\u00e1r nem fog kiv\u00e9telt okozni.</p> <p>A <code>nameof</code> oper\u00e1tor sokfajta nyelvi elemet t\u00e1mogat, vissza tudja adni egy v\u00e1ltoz\u00f3, egy t\u00edpus, egy property vagy egy f\u00fcggv\u00e9ny nev\u00e9t is.</p> <p>A sz\u00f3t\u00e1r felt\u00f6lt\u00e9s\u00e9t meg\u00edrhatjuk kollekci\u00f3 inicializ\u00e1ci\u00f3val is. Ehhez kihaszn\u00e1ljuk, hogy a sz\u00f3t\u00e1r t\u00edpus rendelkezik egy <code>Add</code> met\u00f3dussal, amelyik egyszer\u0171en egy kulcsot \u00e9s egy hozz\u00e1tartoz\u00f3 \u00e9rt\u00e9ket v\u00e1r:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    { nameof(banan), banan },\n    { nameof(watson), watson },\n    { nameof(unnamed), unnamed },\n    { nameof(unknown), unknown },\n    { nameof(pimpedli), pimpedli }\n};\n</code></pre>"},{"location":"seminar/02-csharp2/chapter2/#using-static","title":"Using static","text":"<p>Ha egy oszt\u00e1ly statikus tagjait vagy egy statikus oszt\u00e1lyt szeretn\u00e9nk haszn\u00e1lni, lehet\u0151s\u00e9g\u00fcnk van a <code>using static</code> kulcsszavakkal az oszt\u00e1lyt bevonni a n\u00e9vfelold\u00e1si logik\u00e1ba. Ha a <code>Console</code> oszt\u00e1lyt refer\u00e1ljuk ilyen m\u00f3don, lehet\u0151s\u00e9g\u00fcnk van a rajta lev\u0151 met\u00f3dusok megh\u00edv\u00e1s\u00e1ra az aktu\u00e1lis kontextusunkban an\u00e9lk\u00fcl, hogy az oszt\u00e1ly nev\u00e9t ki\u00edrn\u00e1nk:</p> <pre><code>using System;\nusing static System.Console;\n//..\nforeach (var dog in dogs)\n    /*Console.*/WriteLine($\"{dog.Key} - {dog.Value}\");\n/*Console.*/WriteLine(banan);\n/*Console.*/ReadLine();\n</code></pre> <p>n\u00e9vfelold\u00e1s</p> <p>Az \u00e1ltal\u00e1nos n\u00e9vfelold\u00e1si szab\u00e1ly tov\u00e1bbra is \u00e9l: ha egy\u00e9rtelm\u0171en feloldhat\u00f3 a hivatkoz\u00e1s, akkor nem sz\u00fcks\u00e9ges kitenni a megk\u00fcl\u00f6nb\u00f6ztet\u0151 el\u0151tagot (itt: oszt\u00e1ly), k\u00fcl\u00f6nben igen.</p>"},{"location":"seminar/02-csharp2/chapter2/#nullozhato-tipusok","title":"Nullozhat\u00f3 t\u00edpusok","text":"<p>Term\u00e9szetesen a referenciat\u00edpusok mind olyan t\u00edpusok, melyek vehetnek fel <code>null</code> \u00e9rt\u00e9ket, viszont esetenk\u00e9nt j\u00f3 volna, ha a <code>null</code> \u00e9rt\u00e9ket egy\u00e9bk\u00e9nt felvenni nem k\u00e9pes t\u00edpusok is lehet\u00e9nek ilyen \u00e9rt\u00e9k\u0171ek, ezzel pl. jelezv\u00e9n, hogy egy \u00e9rt\u00e9k be van-e \u00e1ll\u00edtva vagy sem. Pl. egy sz\u00e1m eset\u00e9n a 0 egy konkr\u00e9t, helyes \u00e9rt\u00e9k lehet a domain modell\u00fcnkben, a <code>null</code> viszont azt jelenthetn\u00e9, hogy nem vett fel \u00e9rt\u00e9ket.</p> <p>Vizsg\u00e1ljuk meg, hogy a konzolra t\u00f6rt\u00e9n\u0151 ki\u00edr\u00e1skor mi\u00e9rt lesz az aktu\u00e1lis \u00e9v Watson kutya \u00e9letkora! Valamelyik <code>Console.WriteLine</code> sorhoz vegy\u00fcnk fel egy t\u00f6r\u00e9spontot (F9), majd debuggol\u00e1s k\u00f6zben a Locals ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Locals]) figyelj\u00fck meg az egyes p\u00e9ld\u00e1nyok adatait. Watsont kinyitva l\u00e1thatjuk, hogy a turpiss\u00e1g abb\u00f3l fakad, hogy a <code>DateOfBirth</code> adat t\u00edpusa, a <code>DateTime</code> nem referenciat\u00edpus, \u00e9s alap\u00e9rtelmez\u00e9s szerinti \u00e9rt\u00e9ket veszi fel, ami 0001. 01. 01. 00:00:00 - hiszen nem \u00e1ll\u00edtottunk be m\u00e1st.</p> <p>Ismeretlen sz\u00fclet\u00e9si d\u00e1tum\u00fa, kor\u00fa egyedek helyes t\u00e1rol\u00e1s\u00e1hoz az <code>Age</code> tulajdons\u00e1g t\u00edpus\u00e1t v\u00e1ltoztassuk <code>int?</code>-re! Az <code>int?</code> szintaktikai \u00e9des\u00edt\u0151szere a <code>Nullable&lt;int&gt;</code>-nek, egy olyan strukt\u00far\u00e1nak, ami egy <code>int</code> \u00e9rt\u00e9ket t\u00e1rol, \u00e9s t\u00e1rolja, hogy az be van-e \u00e1ll\u00edtva vagy sem. A <code>Nullable&lt;int&gt;</code> szignat\u00far\u00e1it megmutathatjuk, hogyha a kurzort a t\u00edpusra helyezve F12-t nyomunk.</p> <p>M\u00f3dos\u00edtsuk a <code>Dog</code> <code>Age</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gait is, hogy tudjuk, be vannak-e \u00e1ll\u00edtva az \u00e9rt\u00e9keik:</p> <pre><code>public class Dog\n{\n    //...\n\n    public DateTime? DateOfBirth { get; set; }\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    //...\n}\n</code></pre> <p>Aritmentikai oper\u00e1torok</p> <p>\u00d6rvendezz\u00fcnk, hogy az alap aritmetikai oper\u00e1torok pont \u00fagy m\u0171k\u00f6dnek, ahogy szeretn\u00e9nk (<code>null</code> bemenetre <code>null</code> eredm\u00e9ny), nem kellett semmilyen tr\u00fckk.</p> <p>Az <code>AgeInDays</code> akkor ad vissza <code>null</code> \u00e9rt\u00e9ket, ha a <code>DateOfBirth</code> maga is <code>null</code> volt. Teh\u00e1t ha nincs megadva sz\u00fclet\u00e9si d\u00e1tumunk, nem tudunk \u00e9letkort sem sz\u00e1m\u00edtani. Ennek kifejez\u00e9s\u00e9re haszn\u00e1lhatjuk a <code>?.</code> (Elvis, magyarban Kozs\u00f3 - <code>null</code> conditional operator) oper\u00e1tort: a ki\u00e9rt\u00e9kelend\u0151 \u00e9rt\u00e9k jobb oldal\u00e1t adja vissza, ha a bal oldal nem <code>null</code>, k\u00fcl\u00f6nben <code>null</code>-t. A kifejez\u00e9st meg kellett v\u00e1ltoztatnunk, hogy a <code>DateOfBirth</code>-b\u0151l vonjuk ki a jelenlegi d\u00e1tumot \u00e9s ezt neg\u00e1ljuk, ugyanis a <code>null</code> vizsg\u00e1land\u00f3 \u00e9rt\u00e9k a bin\u00e1ris oper\u00e1tor bal oldal\u00e1n kell, hogy elhelyezkedjen.</p> Elvis oper\u00e1tor <p>Az Elvis oper\u00e1tor nev\u00e9nek eredet\u00e9re t\u00f6bb magyar\u00e1zatot is lehet tal\u00e1lni, a forr\u00e1sok annyiban nagyr\u00e9szt megegyeznek, hogy a k\u00e9rd\u0151jel tekered\u0151 r\u00e9sze az \u00e9nekes jellegzetes bodorod\u00f3 hajviselet\u00e9re eml\u00e9keztet, a pontok pedig a szemeket jel\u00f6lik, \u00edgy v\u00e9g\u00fclis a ?. egy Elvis emotikonk\u00e9nt foghat\u00f3 fel. Ezen logika ment\u00e9n ad\u00f3dik a magyar megfelel\u0151, a Kozs\u00f3 oper\u00e1tor, hiszen a szem k\u00f6r\u00fcl tekerg\u0151z\u0151 legikonikusabb hajtincs a magyar zenei kult\u00far\u00e1ban Kozs\u00f3 nev\u00e9hez k\u00f6thet\u0151.</p> <p>Ha \u00edgy futtatjuk az alkalmaz\u00e1st, az <code>AgeInDays</code> \u00e9s a sz\u00e1rmaztatott tulajdons\u00e1gok \u00e9rt\u00e9ke <code>null</code> (vagy ki\u00edrva \u00fcres) lesz, ha a sz\u00fclet\u00e9si d\u00e1tum nincs megadva.</p>"},{"location":"seminar/02-csharp2/chapter2/#rekord-tipus","title":"Rekord t\u00edpus","text":"<p>A rekord t\u00edpusok speci\u00e1lis t\u00edpusok, melyek:</p> <ul> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n \u00e9rt\u00e9k t\u00edpusokra jellemz\u0151 logik\u00e1t k\u00f6vetnek, azaz k\u00e9t p\u00e9ld\u00e1ny akkor egyenl\u0151, ha adataik egyenl\u0151ek</li> <li>k\u00f6nnyen immut\u00e1biliss\u00e1 tehet\u0151k, k\u00f6nnyen kezelhet\u0151k immut\u00e1bilis t\u00edpusk\u00e9nt</li> </ul> <p>A <code>Dog</code> t\u00edpus ezzel szemben jelenleg:</p> <ul> <li>nem immut\u00e1bilis, hiszen a sz\u00fclet\u00e9si d\u00e1tum b\u00e1rmikor m\u00f3dos\u00edthat\u00f3 (sima setter)</li> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n a norm\u00e1l referencia szerinti \u00f6sszehasonl\u00edt\u00e1st k\u00f6vet</li> </ul> <p>Az automatikusan gener\u00e1l\u00f3d\u00f3 egyedi azonos\u00edt\u00f3t iktassuk ki a <code>Dog</code> oszt\u00e1lyb\u00f3l, hogy az adat alap\u00fa \u00f6sszehasonl\u00edt\u00e1st k\u00f6nnyebben tesztelhess\u00fck.</p> <pre><code>public Guid Id { get; } = Guid.Empty;\n</code></pre> <p>Vegy\u00fcnk fel egy logikailag megegyez\u0151 p\u00e9ld\u00e1nyt.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nvar watson2 = new Dog { Name = watson.Name };\n</code></pre> <p>Ism\u00e9t \u00e1lljunk meg debug sor\u00e1n valamelyik <code>WriteLine</code> soron. A Locals ablakban n\u00e9zz\u00fck meg, hogy a k\u00e9t p\u00e9ld\u00e1ny minden adata megegyezik. A Watch ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Watch &gt; Watch 1]) \u00e9rt\u00e9kelj\u00fck ki a <code>watson == watson2</code> kifejez\u00e9st. L\u00e1thatjuk, hogy ez az egyenl\u0151s\u00e9gvizsg\u00e1lat hamist ad, ami technikailag helyes, mert k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 mem\u00f3riater\u00fcletr\u0151l van sz\u00f3, a referenci\u00e1k nem ugyanoda mutatnak a mem\u00f3ri\u00e1ban. Sok esetben azonban nem ezt szeretn\u00e9nk, hanem p\u00e9ld\u00e1ul a dupla r\u00f6gz\u00edt\u00e9s elker\u00fcl\u00e9s\u00e9re az adatok alapj\u00e1n t\u00f6rt\u00e9n\u0151 \u00f6sszehasonl\u00edt\u00e1st, ami \u00e9rt\u00e9k t\u00edpusokn\u00e1l van. Referencia t\u00edpusokn\u00e1l klasszikusan ezt a <code>GetHashCode</code>, <code>Equals</code> f\u00fcggv\u00e9nyek fel\u00fcldefini\u00e1l\u00e1s\u00e1val \u00e9rt\u00fck el (vagy az <code>IComparable&lt;T&gt;</code>, <code>IComparer&lt;T&gt;</code> interf\u00e9szre \u00e9p\u00fcl\u0151 logik\u00e1kkal). Egy \u00fajabb lehet\u0151s\u00e9g a rekord t\u00edpus haszn\u00e1lata.</p>"},{"location":"seminar/02-csharp2/chapter2/#pozicio-alapu-megadas","title":"Poz\u00edci\u00f3 alap\u00fa megad\u00e1s","text":"<p>Vegy\u00fcnk fel a <code>Dog</code> t\u00edpus adatainak megfelel\u0151 rekord t\u00edpust, mind\u00f6ssze egy kifejez\u00e9sk\u00e9nt. A <code>Dog</code> t\u00edpus al\u00e1:</p> <pre><code>public record class DogRec(\n    Guid Id,\n    string Name,\n    DateTime? DateOfBirth=null,\n    Dictionary&lt;string, object&gt; Metadata=null\n);\n</code></pre> <p>Note</p> <p>A <code>record class</code> jel\u00f6l\u0151b\u0151l a <code>class</code> elhagyhat\u00f3.</p> <p>Ez az \u00fan. poz\u00edci\u00f3 alap\u00fa megad\u00e1si forma, ami a legink\u00e1bb r\u00f6vid\u00edtett megad\u00e1si form\u00e1ja a rekord t\u00edpusnak. Ebb\u0151l a r\u00f6vid form\u00e1b\u00f3l, mindenfajta extra k\u00f3d \u00edr\u00e1sa n\u00e9lk\u00fcl a ford\u00edt\u00f3 sz\u00e1mos dolgot gener\u00e1l:</p> <ul> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1sb\u00f3l konstruktort \u00e9s dekonstruktort</li> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1s alapj\u00e1n propertyket <code>get</code> \u00e9s <code>init</code> tagf\u00fcggv\u00e9nyekkel</li> <li>alap\u00e9rtelmezett logik\u00e1t az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1shoz</li> <li>kl\u00f3noz\u00f3 \u00e9s m\u00e1sol\u00f3 konstruktor logik\u00e1kat</li> <li>alap\u00e9rtelmezett form\u00e1zott ki\u00edr\u00e1st, sz\u00f6veges reprezent\u00e1ci\u00f3t (<code>ToString</code> implement\u00e1ci\u00f3t)</li> </ul> <p>\u00cdgy egy k\u00f6nnyen kezelhet\u0151, immut\u00e1bilis, az \u00f6sszehasonl\u00edt\u00e1sokban \u00e9rt\u00e9k t\u00edpusk\u00e9nt viselked\u0151 adatoszt\u00e1lyunk lesz.</p> <p>Warning</p> <p>Az <code>Id</code>-nek nem tudjuk be\u00e1ll\u00edtani ebben a form\u00e1ban az alap\u00e9rtelmezett <code>Guid.Empty</code> \u00e9rt\u00e9ket vagy a <code>Metadata</code>-nak az \u00faj p\u00e9ld\u00e1nyt, mert az egyenl\u0151s\u00e9gjeles kifejez\u00e9sekb\u0151l alap\u00e9rtelmezett konstruktorparam\u00e9ter-\u00e9rt\u00e9kek lesznek, amik csak statikus, ford\u00edt\u00e1si id\u0151ben ki\u00e9rt\u00e9kelhet\u0151 kifejez\u00e9sek lehetnek.</p> <p>Vegy\u00fcnk fel a t\u00f6bbi Watson p\u00e9ld\u00e1ny mell\u00e9 k\u00e9t \u00fajabbat, de itt m\u00e1r az \u00faj rekord t\u00edpusunkat haszn\u00e1ljuk.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\");\n</code></pre> <p>A fentebbi Watch ablakos m\u00f3dszerrel ellen\u0151rizz\u00fck a <code>watson3 == watson4</code> kifejez\u00e9s \u00e9rt\u00e9k\u00e9t. Ez m\u00e1r igaz \u00e9rt\u00e9k lesz az adatmez\u0151 alap\u00fa \u00f6sszehasonl\u00edt\u00e1si logika miatt.</p> <p>Pr\u00f3b\u00e1ljuk ki ugyanezt a ki\u00e9rt\u00e9kel\u00e9st az al\u00e1bbi v\u00e1ltozattal:</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\n</code></pre> <p>Ez hamis \u00e9rt\u00e9ket ad, az egyenl\u0151s\u00e9gnek minden mez\u0151re teljes\u00fclnie kell, nem csak a mindkett\u0151ben kit\u00f6lt\u00f6ttekre.</p> <p>A <code>DogRec</code> t\u00edpus alapvet\u0151en immut\u00e1bilis, a p\u00e9ld\u00e1nyainak alapadatai inicializ\u00e1l\u00e1s ut\u00e1n nem m\u00f3dos\u00edthat\u00f3k. Pr\u00f3b\u00e1ljuk fel\u00fcl\u00edrni a nevet.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nwatson4.Name = watson3.Name + \"_2\"; //&lt;= nem fordul\n</code></pre> <p>Nem fog lefordulni, mert minden property init-only t\u00edpus\u00fa. A sor jobboldala egy\u00e9bk\u00e9nt lefordulna, teh\u00e1t a lek\u00e9rdez\u00e9s (getter h\u00edv\u00e1s) m\u0171k\u00f6dne.</p> <p>Ha immut\u00e1bilis t\u00edpusokkal dolgozunk, akkor mut\u00e1ci\u00f3 helyett \u00faj p\u00e9ld\u00e1nyt hozunk l\u00e9tre megv\u00e1ltoztatott adatokkal. Alapvet\u0151en ezt az OO nyelvekben m\u00e1sol\u00f3 konstruktorral oldjuk meg. A rekord t\u00edpusn\u00e1l enn\u00e9l is tov\u00e1bbmenve m\u00e1sol\u00f3 kifejez\u00e9st haszn\u00e1lhatunk.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\n</code></pre> <p>Futtat\u00e1skor a konzolban gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk a rekord t\u00edpusok alap\u00e9rtelmezetten is olvashat\u00f3 sz\u00f6veges ki\u00edr\u00e1s\u00e1ban.</p> <p>A m\u00e1sol\u00f3 kifejez\u00e9sben a <code>with</code> oper\u00e1tor el\u0151tt megadjuk, melyik p\u00e9ld\u00e1nyt kl\u00f3nozn\u00e1nk, majd az inicializ\u00e1ci\u00f3 r\u00e9szek\u00e9nt milyen \u00e9rt\u00e9keket \u00e1ll\u00edtan\u00e1nk \u00e1t, ehhez az objektum inicializ\u00e1ci\u00f3s szintaxist haszn\u00e1lhatjuk. Fontos esz\u00fcnkbe v\u00e9sni, hogy a m\u00e1sol\u00e1s eredm\u00e9nyek\u00e9nt \u00faj p\u00e9ld\u00e1ny j\u00f6n l\u00e9tre, \u00faj mem\u00f3riater\u00fclet foglal\u00f3dik le. Gondoljunk erre akkor, amikor egy ciklusban haszn\u00e1ljuk ezt a m\u00f3dszert sok egym\u00e1st k\u00f6vet\u0151 m\u00f3dos\u00edt\u00e1sra.</p> <p>Mire is j\u00f3 a rekord t\u00edpus</p> <p>Mire j\u00f3 a rekord t\u00edpus, az immutabilit\u00e1s? Az immut\u00e1bilis t\u00edpussokkal val\u00f3 hat\u00e9kony \u00e9s eredm\u00e9nyes munka m\u00e1sfajta, az imperat\u00edv nyelvekhez szokott fejleszt\u0151k sz\u00e1m\u00e1ra szokatlan m\u00f3dszereket k\u00edv\u00e1n. Vannak ter\u00fcletek, ahol ez a befektet\u00e9s megt\u00e9r\u00fcl, ilyen p\u00e9ld\u00e1ul a t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezet. A legt\u00f6bb sz\u00e1lkezel\u00e9ssel kapcsolatos probl\u00e9ma ugyanis a sz\u00e1lak \u00e1ltal k\u00f6z\u00f6sen haszn\u00e1lt adatstrukt\u00far\u00e1k mut\u00e1ci\u00f3j\u00e1ra vezethet\u0151 vissza (\u00fan. race condition, versenyhelyzet). Nincs mut\u00e1ci\u00f3 - nincs probl\u00e9ma. (No mutation - no cry)</p>"},{"location":"seminar/02-csharp2/chapter2/#kitero-a-szotar-visszavag","title":"Kit\u00e9r\u0151: a sz\u00f3t\u00e1r visszav\u00e1g","text":"<p>A rekord t\u00edpus \u00e1ltal biztos\u00edtott kellemes tulajdons\u00e1gok csak akkor \u00e9rv\u00e9nyesek, ha nem keverj\u00fck hagyom\u00e1nyos referencia t\u00edpusokkal.</p> <p>A szok\u00e1sos m\u00f3dszerrel ellen\u0151rizz\u00fck le, hogy a <code>watson5 == watson6</code> kifejez\u00e9s igaz-e. Igen, hiszen minden kit\u00f6lt\u00f6tt adatuk egyezik.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nvar watson6 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Vigy\u00fcnk be egy \u00e1rtatlan inicializ\u00e1ci\u00f3t a <code>Metadata</code> propertyre.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson6 = watson4 with { Name = \"Sherlock\", Metadata= new Dictionary&lt;string, object&gt;() };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Ezzel el\u00e9gg\u00e9 illogikus m\u00f3don hamisra v\u00e1ltozik a <code>watson5 == watson6</code> kifejez\u00e9s. Az oka az, hogy a <code>Metadata</code> sz\u00f3t\u00e1r egy klasszikus referencia t\u00edpus, az \u00f6sszehasonl\u00edt\u00e1sn\u00e1l a klasszikus mem\u00f3riac\u00edm-\u00f6sszehasonl\u00edt\u00e1s t\u00f6rt\u00e9nik, viszont az a k\u00e9t \u00faj sz\u00f3t\u00e1r p\u00e9ld\u00e1ny eset\u00e9ben elt\u00e9r\u0151 lesz. A form\u00e1zott sz\u00f6veges ki\u00edr\u00e1sba is belerond\u00edt a sz\u00f3t\u00e1r, mert ott is a sz\u00f3t\u00e1r t\u00edpus alap\u00e9rtelmezett sz\u00f6veges reprezent\u00e1ci\u00f3ja jut \u00e9rv\u00e9nyre, ami a t\u00edpus neve.</p> <p>Kl\u00f3nozzunk tov\u00e1bb, azt\u00e1n pr\u00f3b\u00e1ljunk mut\u00e1ci\u00f3t v\u00e9grehajtani a <code>Metadata</code> sz\u00f3t\u00e1ron.</p> <pre><code>var watson6 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson7 = watson6 with { Name = \"Watson\" };\nwatson7.Metadata.Add(\"Chip azonos\u00edt\u00f3\", \"12345QQ\");\nWriteLine(watson4);\n</code></pre> <p>Ez lefordul, pedig ez mut\u00e1ci\u00f3. A Locals ablakban figyelj\u00fck meg a <code>watson6</code> \u00e9s <code>watson7</code> sz\u00f3t\u00e1rait: mindkett\u0151be beker\u00fclt a chip azonos\u00edt\u00f3. Ez az \u00fan. shallow copy jelens\u00e9g, amikor nem a sz\u00f3t\u00e1r mem\u00f3riater\u00fclete kl\u00f3noz\u00f3dik, csak a r\u00e1 mutat\u00f3 referencia, ami azt eredm\u00e9nyezi, hogy a k\u00e9t p\u00e9ld\u00e1nynak k\u00f6z\u00f6s sz\u00f3t\u00e1ra lesz.</p> <p>\u00d6sszess\u00e9g\u00e9ben az adatstrukt\u00far\u00e1nkban megjelen\u0151 klasszikus referencia t\u00edpus elrontja:</p> <ul> <li>az immutabilit\u00e1st</li> <li>az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1st</li> <li>a form\u00e1zott sz\u00f6veges megjelen\u00e9st</li> <li>a kl\u00f3noz\u00e1st</li> </ul> <p>Immutabilit\u00e1s</p> <p>Immut\u00e1bilis k\u00f6rnyezetben t\u00f6rekedj\u00fcnk arra, hogy a teljes adatstrukt\u00far\u00e1nk t\u00e1mogassa az immut\u00e1bilis kezel\u00e9st.</p>"},{"location":"seminar/02-csharp2/chapter2/#normal-megadas","title":"Norm\u00e1l megad\u00e1s","text":"<p>Ha nincs sz\u00fcks\u00e9g\u00fcnk a kik\u00e9nyszer\u00edtett immutabilit\u00e1sra, akkor haszn\u00e1lhatjuk a rekord norm\u00e1l megad\u00e1s\u00e1t. Fogjuk a <code>Dog</code> oszt\u00e1lyt, m\u00e1soljuk le a k\u00f3dj\u00e1t, adjunk neki m\u00e1s nevet \u00e9s <code>class</code> helyett <code>record</code> jel\u00f6l\u0151t.</p> <p>A <code>Dog</code> oszt\u00e1ly f\u00f6l\u00e9:</p> <pre><code>public record DogRecExt\n{\n    public string Name { get; init; }\n    public Guid Id { get; } = Guid.Empty;\n    public DateTime? DateOfBirth { get; set; }\n    public Dictionary&lt;string, object&gt; Metadata { get; } = new();\n\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>ToString</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1t elhagytuk az el\u0151z\u0151 szakaszban eml\u00edtettek miatt.</p> <p>A <code>Program.cs</code>-be:</p> <pre><code>var watson8 = new DogRecExt { Name = \"Watson\" };\nwatson8.DateOfBirth = DateTime.Now.AddYears(-15);\nvar watson9 = watson8 with { };\nWriteLine(watson8);\nWriteLine(watson9);\n</code></pre> <p>Ellen\u0151rizz\u00fck le a rekord tulajdons\u00e1gokat:</p> <ul> <li>A konzol kimeneten a form\u00e1z\u00e1st, tov\u00e1bb\u00e1 a mut\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9t, azaz a <code>watson8</code> sz\u00fclet\u00e9si d\u00e1tuma a be\u00e1ll\u00edtott lesz.</li> <li>Ez nem csoda, hiszen a property deklar\u00e1ci\u00f3ban engedt\u00fck a mut\u00e1ci\u00f3t.</li> <li>A konzol kimeneten megfigyelt p\u00e9ld\u00e1nyadatokon a kl\u00f3noz\u00f3 kifejez\u00e9s m\u0171k\u00f6d\u00e9s\u00e9t. Semmi k\u00fcl\u00f6n\u00f6s, ugyan\u00fagy m\u0171k\u00f6dik, mint a t\u00f6m\u00f6r form\u00e1n\u00e1l.</li> <li>A Watch ablakban <code>watson8 == watson9</code> egyenl\u0151s\u00e9get. Ez igaz, mert minden adattagjuk egyezik.</li> </ul> <p>record struct</p> <p>A rekordoknak tov\u00e1bbi v\u00e1lfajai vannak, ugyanis strukt\u00fara is lehet rekord, ilyenkor a <code>record struct</code> kulcssz\u00f3 p\u00e1rt haszn\u00e1ljuk a t\u00edpus deklar\u00e1ci\u00f3j\u00e1n\u00e1l. S\u0151t, a <code>readonly record struct</code> egy immut\u00e1bilis <code>record struct</code>. Ezen v\u00e1lfajok nyilv\u00e1n k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek, mely viselked\u00e9seket itt most nem r\u00e9szletezz\u00fck, de a dokument\u00e1ci\u00f3ban megtal\u00e1lhat\u00f3k.</p>"},{"location":"seminar/03-linq/chapter3/","title":"LINQ","text":""},{"location":"seminar/03-linq/chapter3/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>A gyakorlat kezdet\u00e9n kl\u00f3nozzuk le a kiindul\u00f3 projektet az al\u00e1bbi paranccsal:</p> <pre><code>git clone https://github.com/bmeviauav23/Linq-lab.git\n</code></pre> <p>Nyissuk meg Visual Studio-ban a HelloLinq.sln solution f\u00e1jlt.</p> <p>Megnyit\u00e1s ut\u00e1n tekints\u00fck \u00e1t a kiindul\u00f3 projektben lev\u0151 f\u00e1jlokat:</p> <ul> <li>Program.cs: a legfels\u0151 szint\u0171 k\u00f3dot tartalmaz\u00f3 oszt\u00e1ly. Tal\u00e1lhat\u00f3 benne egy <code>Dogs</code> v\u00e1ltoz\u00f3, ami a <code>Dog</code> oszt\u00e1ly statikus <code>Repository</code> tulajdons\u00e1g\u00e1ba h\u00edv \u00e1t.</li> <li>Dog.cs: a kor\u00e1bbi gyakorlatokon haszn\u00e1lt adatmodell (apr\u00f3bb m\u00f3dos\u00edt\u00e1sokkal).<ul> <li>Beker\u00fclt egy <code>Siblings</code> tulajdons\u00e1g, a <code>ToString</code> pedig ki\u00edrja a kuty\u00e1hoz tartoz\u00f3 testv\u00e9rek sz\u00e1m\u00e1t is (ehhez a <code>TrimPad</code> b\u0151v\u00edt\u0151 met\u00f3dust haszn\u00e1lja).</li> <li>A statikus <code>Repository</code> tulajdons\u00e1g m\u00f6g\u00f6tt egy lust\u00e1n inicializ\u00e1lt <code>Lazy&lt;T&gt; RepositoryHolder</code> tal\u00e1lhat\u00f3, ami egy megfelel\u0151en form\u00e1zott bemeneti CSV f\u00e1jlb\u00f3l elk\u00e9sz\u00edti sz\u00e1munkra az adatmodellt, amivel a k\u00e9s\u0151bbiekben dolgozunk. Ennek implement\u00e1ci\u00f3j\u00e1t el\u00e9g a gyakorlat v\u00e9g\u00e9n megn\u00e9zni. Az <code>Import</code> \u00e9s <code>Export</code> f\u00fcggv\u00e9nyek a kuty\u00e1k soros\u00edt\u00e1s\u00e1t v\u00e9gzik el mindk\u00e9t ir\u00e1nyban.</li> </ul> </li> <li>Extensions/StringExtensions.cs: ez az oszt\u00e1ly tartalmaz egy seg\u00e9dmet\u00f3dust a form\u00e1zott ki\u00edr\u00e1shoz. A <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel. A b\u0151v\u00edt\u0151 met\u00f3dusos r\u00e9szben lesz jelent\u0151s\u00e9ge.</li> <li>dogs.csv: egy pontosvessz\u0151vel tagolt adathalmaz, amelyben 100 darab el\u0151re felvett kutya adata tal\u00e1lhat\u00f3. Innen pusk\u00e1zhatunk, ha ellen\u0151rizni akarjuk, hogy helyesek-e a programunk eredm\u00e9nyei.</li> </ul> <p>A kiindul\u00f3 projektben a glob\u00e1lis implicit n\u00e9vt\u00e9rhivatkoz\u00e1sok ki vannak kapcsolva. A csproj f\u00e1jlban megn\u00e9zhetj\u00fck (menu:jobb klikk a projekten[Edit Project File]):</p> <pre><code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;\n</code></pre>"},{"location":"seminar/03-linq/chapter3/#lambda-kifejezesek-delegatok","title":"Lambda kifejez\u00e9sek, deleg\u00e1tok","text":"<p>Gyakori feladat, hogy objektumok kollekci\u00f3j\u00e1val kell dolgoznunk. K\u00e9pesek vagyunk olyan jelleg\u0171 seg\u00e9df\u00fcggv\u00e9nyeket k\u00e9sz\u00edteni, amik p\u00e9ld\u00e1ul egy kollekci\u00f3ban kikeresik az \u00f6sszes olyan elemet, amely egy megadott felt\u00e9telnek eleget tesz.</p> <p>A <code>Program.cs</code> f\u00e1jlban l\u00e1that\u00f3 ennek a kezdeti naiv v\u00e1ltozata, szemrev\u00e9telezz\u00fck:</p> <pre><code>static List&lt;Dog&gt; ListDogsByNamePrefix(IEnumerable&lt;Dog&gt; dogs, string prefix)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (dog.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>A k\u00f3d m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3.  Ha b\u00e1rmi m\u00e1s alapj\u00e1n szeretn\u00e9nk keresni a kuty\u00e1k k\u00f6z\u00f6tt (pl. a neve tartalmaz-e egy adott sz\u00f6vegr\u00e9szt), mindig egy \u00faj seg\u00e9df\u00fcggv\u00e9nyt kell k\u00e9sz\u00edten\u00fcnk, ami rontja a k\u00f3d \u00fajrahasznos\u00edthat\u00f3s\u00e1g\u00e1t.</p> <p>Oldjuk meg \u00fagy, hogy az \u00e1ltal\u00e1nos probl\u00e9m\u00e1t is megoldjuk! Ehhez az sz\u00fcks\u00e9ges, hogy a kollekci\u00f3nk egyes elemein ki\u00e9rt\u00e9kelhess\u00fcnk egy, a h\u00edv\u00f3 \u00e1ltal megadott predik\u00e1tumot. K\u00e9sz\u00edts\u00fck el az \u00e1ltal\u00e1nosabb v\u00e1ltozatot, ehhez felhaszn\u00e1lhatjuk a <code>ListDogsByNamePrefix</code> k\u00f3dj\u00e1t.</p> <pre><code>static List&lt;Dog&gt; ListDogsByPredicate(\n    IEnumerable&lt;Dog&gt; dogs, Predicate&lt;Dog&gt; predicate)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (predicate(dog))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>A legfels\u0151 szint\u0171 k\u00f3dban \u00edgy h\u00edvhatjuk meg (felhaszn\u00e1lhatjuk az eredeti ciklust):</p> <pre><code>foreach(var dog in ListDogsByPredicate(Dogs, delegate (Dog d) \n    {\n        return d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n    })\n)\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Egy egy bemen\u0151 param\u00e9ter\u0171 \u00e9s egy logikai (<code>bool</code>) \u00e9rt\u00e9ket visszad\u00f3 f\u00fcggv\u00e9nyt defini\u00e1lunk helyben (inline) \u00e9s ezt (illetve a referenci\u00e1j\u00e1t) adjuk \u00e1t. Haszn\u00e1ljunk ink\u00e1bb lambda kifejez\u00e9st, az j\u00f3val r\u00f6videbben le\u00edrhat\u00f3 - egyel\u0151re csak n\u00e9zz\u00fck meg, de ne integr\u00e1ljuk a k\u00f3dba:</p> <pre><code>d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Lambda kifejez\u00e9sek szintaktik\u00e1ja</p> <p>Lambda kifejez\u00e9ssel az egyetlen kifejez\u00e9sb\u0151l \u00e1ll\u00f3 f\u00fcggv\u00e9nyeket adhatjuk meg nagyon kompakt m\u00f3don. A <code>=&gt;</code>-t\u00f3l balra elnevezz\u00fck a bemen\u0151 param\u00e9tereket, jobbra pedig felhaszn\u00e1l(hat)juk. A <code>return</code>, <code>{}</code> \u00e9s egy\u00e9b sallangokat elhagyhatjuk.</p> <p>Vess\u00fck \u00f6ssze, hogy az els\u0151 esetben explicit megadtuk, hogy a bemen\u0151 param\u00e9ter\u00fcnk <code>Dog</code>, most viszont nem. Ezt a ford\u00edt\u00f3 statikus k\u00f3danal\u00edzis alapj\u00e1n el tudja d\u00f6nteni: a <code>d</code> v\u00e1ltoz\u00f3nk nem lehet m\u00e1s, csak <code>Dog</code> (statikus) t\u00edpus\u00fa, ez\u00e9rt csak \u00edgy haszn\u00e1lhatjuk, viszont nem kell ki\u00edrnunk a t\u00edpust.</p> <p>A lambda kifejez\u00e9sek egy lehets\u00e9ges m\u00f3dja a deleg\u00e1tok le\u00edr\u00e1s\u00e1nak. A deleg\u00e1t k\u00f3dot reprezent\u00e1l, viszont a k\u00f3dot kezelhetj\u00fck adatk\u00e9nt is.</p> <p>Pr\u00f3b\u00e1ljuk meg a deleg\u00e1tunkat kivenni egy implicit t\u00edpus\u00fa v\u00e1ltoz\u00f3ba a ciklus el\u0151tt:</p> <pre><code>// ford\u00edt\u00e1si hiba!\nvar predicate = \n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\nforeach (var dog in ListDogsByPredicate(Dogs, predicate))\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Ford\u00edt\u00e1si hib\u00e1t kapunk, lambda kifejez\u00e9s t\u00edpusa nem lehet implicit eld\u00f6nthet\u0151 az inicializ\u00e1ci\u00f3s sorban: sem a bemen\u0151 param\u00e9ter pontos t\u00edpus\u00e1t nem tudjuk (<code>Dog</code>? <code>Puppy</code>?), sem a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket (<code>bool</code>? <code>object</code>? <code>void</code>?). Teh\u00e1t explicit meg kell adnunk a t\u00edpust:</p> <pre><code>Predicate&lt;Dog&gt; predicate =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Ezut\u00e1n fordul \u00e9s fut is az alkalmaz\u00e1sunk.</p> <p>Predicate be\u00e9p\u00edtett deleagate t\u00edpus</p> <p>Ehhez tudnunk kellett, hogy a <code>Predicate&lt;T&gt;</code> megfelel\u0151 szignat\u00far\u00e1j\u00fa. Mutassuk meg ezen t\u00edpus dokument\u00e1ci\u00f3j\u00e1t vagy tegy\u00fck a kurzort a t\u00edpusra \u00e9s nyomjunk F12-t.</p>"},{"location":"seminar/03-linq/chapter3/#func-action","title":"<code>Func&lt;&gt;</code>, <code>Action&lt;&gt;</code>","text":"<p>Ismerkedj\u00fcnk meg a <code>Func</code> \u00e9s <code>Action</code> \u00e1ltal\u00e1nos deleg\u00e1tt\u00edpusokkal. Ezzel a k\u00e9t generikus t\u00edpussal (pontosabban a v\u00e1ltozataikkal) gyakorlatilag az \u00f6sszes gyakorlatban el\u0151fordul\u00f3 f\u00fcggv\u00e9nyszignat\u00far\u00e1t le lehet fedni. P\u00e9ld\u00e1ul a fenti sz\u0171r\u0151logik\u00e1t is \u00e1t\u00edrhatn\u00e1nk erre:</p> <pre><code>Func&lt;Dog, bool&gt; dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A <code>dogFunc</code> \u00e9s a <code>predicate</code> kompatibilisnek t\u0171nhetnek (elv\u00e9gre a jobboldaluk ugyanaz), \u00e1m ha lecser\u00e9ln\u00e9nk pl. a <code>ListDogsByPredicate(Dogs, predicate)</code> h\u00edv\u00e1sban a <code>predicate</code>-et <code>dogFunc</code>-ra, a k\u00f3d nem fordulna, ugyanis a k\u00e9t deleg\u00e1tt\u00edpus nem kompatibilis.</p> <p>Az <code>Action&lt;&gt;</code> hasonl\u00f3 elven m\u0171k\u00f6dik, visszat\u00e9r\u00e9si \u00e9rt\u00e9k n\u00e9lk\u00fcli f\u00fcggv\u00e9nyekre.</p> <p>Egy\u00e9b delegate t\u00edpusok</p> <p>Ha minden esetre j\u00f3k, mi\u00e9rt vannak haszn\u00e1latban <code>Action&lt;&gt;</code> \u00e9s <code>Func&lt;&gt;</code>-on k\u00edv\u00fcl m\u00e1s deleg\u00e1tt\u00edpusok? Egyr\u00e9szt t\u00f6rt\u00e9nelmi okok miatt. K\u00e9s\u0151bb jelentek meg, mint a specifikusak, p\u00e9ld\u00e1ul a <code>Predicate&lt;T&gt;</code>. M\u00e1sr\u00e9szt a specifikusabbak a nev\u00fckkel kifejez\u0151bbek lehetnek.</p> <p>Tiszta f\u00fcggv\u00e9nyek</p> <p>A fenti predik\u00e1tumv\u00e1ltozataink mind nem tiszta f\u00fcggv\u00e9nyek (pure function), ugyanis olyan adatt\u00f3l is f\u00fcgg a visszat\u00e9r\u00e9si \u00e9rt\u00e9ke, ami nem szerepel a param\u00e9terlist\u00e1j\u00e1n - ez eset\u00fcnkben a <code>searchText</code> v\u00e1ltoz\u00f3. A k\u00f3dunk az\u00e9rt m\u0171k\u00f6dik, mert a deleg\u00e1t megad\u00e1sakor a <code>searchText</code> aktu\u00e1lis \u00e9rt\u00e9k\u00e9t elkapjuk (capture), belerakjuk a f\u00fcggv\u00e9nylogik\u00e1ba.</p> <p>Pr\u00f3b\u00e1ljuk a <code>dogFunc</code>-ot <code>var</code>-k\u00e9nt deklar\u00e1lni.</p> <pre><code>//Ford\u00edt\u00e1si hiba!\nvar dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A ford\u00edt\u00f3 nem tudja meghat\u00e1rozni a <code>d</code> param\u00e9ter t\u00edpus\u00e1t, ez\u00e9rt kapjuk a ford\u00edt\u00e1si hib\u00e1t. Adjuk meg explicit a param\u00e9ter t\u00edpus\u00e1t.</p> <pre><code>var dogFunc =\n    (Dog d) =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Debugger-rel ellen\u0151rizhetj\u00fck, hogy a <code>dogFunc</code> val\u00f3di t\u00edpusa <code>Func&lt;Dog, bool&gt;</code> lesz.</p>"},{"location":"seminar/03-linq/chapter3/#ienumerablet-bovito-metodusok","title":"IEnumerable\\&lt;T&gt; b\u0151v\u00edt\u0151 met\u00f3dusok","text":"<p>Vigy\u00fck tov\u00e1bb az \u00e1ltal\u00e1nos\u00edt\u00e1st. \u00cdrjunk olyan logik\u00e1kat, mely nem csak kuty\u00e1k list\u00e1j\u00e1ra, hanem b\u00e1rmilyen felsorolhat\u00f3 (enumer\u00e1lhat\u00f3) kollekci\u00f3ra m\u0171k\u00f6dik. \u00cdrjunk <code>IEnumerable&lt;T&gt;</code> t\u00edpuson m\u0171k\u00f6d\u0151 seg\u00e9df\u00fcggv\u00e9nyeket.</p> <p>Hozzunk l\u00e9tre egy <code>EnumerableExtensions</code> (I bet\u0171 n\u00e9lk\u00fcl, az ugyanis interf\u00e9szre utal) nev\u0171 f\u00e1jlt az <code>Extensions</code> mapp\u00e1ban! Els\u0151k\u00e9nt val\u00f3s\u00edtsuk meg az \u00f6sszegz\u0151 logik\u00e1t.</p> <pre><code>namespace HelloLinq.Extensions.Enumerable;\n\npublic static class EnumerableExtensions\n{\n    public static int Sum&lt;T&gt; (IEnumerable&lt;T&gt;  source, Func&lt;T, int&gt;  sumSelector)\n    {\n        var result = 0;\n        foreach (var elem in source)\n        {\n            result += sumSelector(elem);\n        }\n        return result;\n    }\n}\n</code></pre> <p>H\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3db\u00f3l.</p> <pre><code>using HelloLinq.Extensions.Enumerable;\n\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\nforeach (var dog in Dogs)\n{\n    Console.WriteLine(dog);\n}\n\nConsole.WriteLine(\n    \"\u00c9letkorok \u00f6sszege: \" \n    + $\"{EnumerableExtensions.Sum(Dogs, d =&gt; d.Age ?? 0)}\");\n\nstring searchText;\n</code></pre> <p>A seg\u00e9df\u00fcggv\u00e9nyek h\u00e1tr\u00e1nya, hogy ismern\u00fcnk kell a seg\u00e9doszt\u00e1ly nev\u00e9t. Tov\u00e1bb\u00e1 jobb lenne, ha a kollekci\u00f3n k\u00f6zvetlen\u00fcl h\u00edvhatn\u00e1nk az \u00f6sszegz\u0151 f\u00fcggv\u00e9nyt. Erre megold\u00e1s a b\u0151v\u00edt\u0151 met\u00f3dus.</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok:</p> <ul> <li>statikus oszt\u00e1lyban defini\u00e1lhat\u00f3k</li> <li>statikus f\u00fcggv\u00e9nyek</li> <li>els\u0151 param\u00e9tere el\u0151tt <code>this</code> jel\u00f6li, hogy melyik t\u00edpust b\u0151v\u00edtik</li> </ul> <p>Az els\u0151 param\u00e9ter el\u00e9 tegy\u00fck be a <code>this</code> jel\u00f6l\u0151t.</p> <pre><code>public static int Sum&lt;T&gt; (\n    this IEnumerable&lt;T&gt;  source,\n    Func&lt;T, int&gt;  sumSelector)\n    {\n        // ...\n    }\n</code></pre> <p>Most m\u00e1r haszn\u00e1lhatjuk azt a szintaxist, mintha a kollekci\u00f3nak eleve lenne \u00f6sszegz\u0151 f\u00fcggv\u00e9nye:</p> <pre><code>Console.WriteLine($\"\u00c9letkorok \u00f6sszege: {Dogs.Sum(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>OO egys\u00e9gbez\u00e1r\u00e1si elv</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok semmilyen m\u00f3don nem bontj\u00e1k meg a t\u00edpusok egys\u00e9gbez\u00e1r\u00e1si k\u00e9pess\u00e9geit. A f\u00fcggv\u00e9nyek implement\u00e1ci\u00f3i a b\u0151v\u00edtend\u0151 t\u00edpusok k\u00edv\u00fclr\u0151l is el\u00e9rhet\u0151 f\u00fcggv\u00e9nyeit, propertyjeit haszn\u00e1lhatj\u00e1k, priv\u00e1t adattagokhoz, f\u00fcggv\u00e9nyekhez nem f\u00e9rnek hozz\u00e1.</p> <p>Oszt\u00e1ly nev\u00e9nek felold\u00e1sa</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok alkalmaz\u00e1sakor nagyon fontos, hogy b\u00e1r a b\u0151v\u00edt\u0151 met\u00f3dus oszt\u00e1ly\u00e1nak nev\u00e9t nem \u00edrjuk ki, az oszt\u00e1ly nev\u00e9nek feloldhat\u00f3nak kell lennie, azaz az oszt\u00e1ly n\u00e9vter\u00e9t <code>using</code> direkt\u00edv\u00e1val be kell hivatkoznunk. Egy pr\u00f3ba erej\u00e9ig kommentezz\u00fck ki a <code>using HelloLinq.Extensions.Enumerable;</code> sort \u00e9s ellen\u0151rizz\u00fck, hogy nem fordul a k\u00f3dunk, a b\u0151v\u00edt\u0151 met\u00f3dus nev\u00e9t a ford\u00edt\u00f3 nem tudja feloldani.</p> <p>Gyakorl\u00e1sk\u00e9ppen \u00edrhatunk tov\u00e1bbi gyakori adatfeldolgoz\u00e1si m\u0171veletekre f\u00fcggv\u00e9nyeket, mint amilyen az \u00e1tlagsz\u00e1m\u00edt\u00e1s, min-max keres\u00e9s.</p> Megold\u00e1s <pre><code>public static class EnumerableExtensions\n{\n    //...\n\n    public static double Average&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; sumSelector)\n    {\n        var result = 0.0; // Az oszt\u00e1s m\u0171velet miatt double\n        var elements = 0;\n        foreach (var elem in source)\n        {\n            elements++;\n            result += sumSelector(elem);\n        }\n        return result / elements;\n    }\n\n    public static int Min&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n    {\n        int value = int.MaxValue;\n        foreach (var elem in source)\n        {\n            var currentValue = valueSelector(elem);\n            if (currentValue &lt; value)\n            {\n                value = currentValue;\n            }\n        }\n        return value;\n    }\n\n    public static int Max&lt;T&gt; (this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n        =&gt; -source.Min(e =&gt; -valueSelector(e));\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az \u00faj f\u00fcggv\u00e9nyeket. Mivel a <code>Dogs</code> t\u00edpusa <code>IEnumerable&lt;Dog&gt;</code>, \u00edgy a b\u0151v\u00edt\u0151 met\u00f3dusok b\u0151v\u00edtend\u0151 t\u00edpusa illeszkedik r\u00e1.</p> <pre><code>Console.WriteLine($\"\u00c1tlagos \u00e9letkor: {Dogs.Average(d =&gt; d.Age ?? 0)}\");\nConsole.WriteLine(\n    $\"Minimum-maximum \u00e9letkor: \" +\n    $\"{Dogs.Min(d =&gt; d.Age ?? 0)} | {Dogs.Max(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>StringExtensions.cs</p> <p>A <code>StringExtensions</code> oszt\u00e1lyban egy lambdak\u00e9nt megval\u00f3s\u00edtott b\u0151v\u00edt\u0151 met\u00f3dust l\u00e1thatunk, ami egy sz\u00f6veget adott hosszra (sz\u00e9less\u00e9gre) eg\u00e9sz\u00edt ki sz\u00f3k\u00f6z\u00f6kkel. A f\u00fcggv\u00e9nyt a <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel.</p>"},{"location":"seminar/03-linq/chapter3/#gyakori-lekerdezo-muveletek-yield-return","title":"Gyakori lek\u00e9rdez\u0151 m\u0171veletek, yield return","text":"<p>Gyakran el\u0151fordul, hogy egy list\u00e1t sz\u0171rni vagy projekt\u00e1lni szeretn\u00e9nk. \u00cdrjunk saj\u00e1t gener\u00e1tort ezekhez a m\u0171veletekhez is az <code>EnumerableExtensions</code>-be:</p> <pre><code>public static IEnumerable&lt;T&gt; Where&lt;T&gt;(\n    this IEnumerable&lt;T&gt;  source, Predicate&lt;T&gt;  predicate)\n{\n    foreach (var elem in source)\n    {\n        if (predicate(elem))\n        {\n            yield return elem;\n        }\n    }\n}\n\npublic static IEnumerable&lt;TValue&gt; Select&lt;T, TValue&gt;(\n    this IEnumerable&lt;T&gt;  source, Func&lt;T, TValue&gt; selector)\n{\n    foreach (var elem in source)\n    {\n        yield return selector(elem);\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n, v\u00e1lasszuk ki a 2010 el\u0151tt sz\u00fcletett kuty\u00e1k nev\u00e9t \u00e9s kor\u00e1t egy stringbe:</p> <pre><code>foreach (var text in Dogs\n    .Where(d =&gt; d.DateOfBirth?.Year &lt; 2010)\n    .Select(d =&gt; $\"{d.Name} ({d.Age})\"))\n{\n    Console.WriteLine(text);\n}\n</code></pre> <p>A yield return haszna</p> <p>A <code>yield return</code> egy hasznos eszk\u00f6z, ha IEnumerable-t kell produk\u00e1lnunk visszat\u00e9r\u00e9si \u00e9rt\u00e9kk\u00e9nt. Seg\u00edts\u00e9g\u00e9vel mindig csak akkor \u00e1ll\u00edtjuk el\u0151 a k\u00f6vetkez\u0151 elemet, amikor a h\u00edv\u00f3 k\u00e9ri. A m\u0171k\u00f6d\u00e9s\u00e9t debuggerrel is figyelj\u00fck meg: tegy\u00fcnk breakpointot a k\u00e9t <code>yield return</code> sorra, majd F10-zel k\u00f6vess\u00fck v\u00e9gig, ahogy a <code>foreach</code> elk\u00e9ri a <code>Select</code>-t\u0151l a k\u00f6vetkez\u0151 elemet, ami emiatt elk\u00e9ri a <code>Where</code>-t\u0151l, majd \u00fajraindul a ciklus. A h\u00edv\u00e1sok \u00e1llapotg\u00e9pk\u00e9nt m\u0171k\u00f6dnek, a k\u00f6vetkez\u0151 megh\u00edv\u00e1skor onnan folytat\u00f3dnak, ahonnan az el\u0151z\u0151 <code>yield return</code>-n\u00e9l kil\u00e9pt\u00fcnk.</p> <p>Nem nagy meglepet\u00e9s, hogy az \u00e1ltalunk meg\u00edrt <code>Sum</code>, <code>Average</code> (melyek egyedi visszat\u00e9r\u00e9s\u0171ek), <code>Select</code> \u00e9s <code>Where</code> (amik szekvenci\u00e1lis visszat\u00e9r\u00e9s\u0171ek, gener\u00e1torok) met\u00f3dusok mind a .NET keretrendszer r\u00e9sz\u00e9t k\u00e9pezik (a <code>System.Linq.Enumerable</code> statikus oszt\u00e1lyban defini\u00e1lt b\u0151v\u00edt\u0151 met\u00f3dusok). A LINQ\u2009\u2014\u2009**L**anguage **IN**tegrated **Q**uery\u2009\u2014\u2009ezeket a m\u0171veleteket teszi lehet\u0151v\u00e9 <code>IEnumerable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 objektumokon. A LINQ f\u00fcggv\u00e9nyek b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt lettek hozz\u00e1adva meglev\u0151 funkcionalit\u00e1shoz (kollekci\u00f3khoz, lek\u00e9rdez\u00e9sekhez), s\u0151t, k\u00fcls\u0151 library-k is adnak saj\u00e1t LINQ b\u0151v\u00edt\u0151 met\u00f3dusokat.</p> <p>Cser\u00e9lj\u00fck le a <code>Program.cs</code>-ben a <code>using HelloLinq.Extensions.Enumerable</code> hivatkoz\u00e1st <code>using System.Linq</code>-re: az \u00e1ltalunk meg\u00edrt k\u00f3d tov\u00e1bbra is ugyanazt az eredm\u00e9nyt produk\u00e1lja! N\u00e9zz\u00fck meg, hogy hol vannak defini\u00e1lva ezek a f\u00fcggv\u00e9nyek a keretrendszeren bel\u00fcl: a kurzort tegy\u00fck a k\u00f3dban oda, ahol valamelyik kor\u00e1bban meg\u00edrt f\u00fcggv\u00e9ny\u00fcnket h\u00edvn\u00e1nk, majd nyomjunk F12-t. Pr\u00f3b\u00e1ljuk ki, hogy tov\u00e1bbra is az elv\u00e1rt m\u00f3don m\u0171k\u00f6dik-e a programunk.</p> <p>Implicit usings</p> <p>A n\u00e9vt\u00e9rcsere helyett bekapcsolhatjuk a glob\u00e1lis implicit n\u00e9vt\u00e9r funkci\u00f3t, mert a <code>System.Linq</code> n\u00e9vt\u00e9r is egy implicit hivatkozott n\u00e9vt\u00e9r. Ehhez a projektf\u00e1jlban az <code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;</code> be\u00e1ll\u00edt\u00e1st \u00edrjuk \u00e1t <code>enable</code>-re, majd a <code>using HelloLinq</code> -en k\u00edv\u00fcl minden n\u00e9vt\u00e9rhivatkoz\u00e1st t\u00f6r\u00f6lj\u00fcnk a <code>Program.cs</code>-b\u0151l.</p>"},{"location":"seminar/03-linq/chapter3/#anonim-tipusok","title":"Anonim t\u00edpusok","text":"<p>Lek\u00e9rdez\u00e9sekn\u00e9l gyakran haszn\u00e1latosak az anonim t\u00edpusok, amelyeket jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9nek ideiglenes, t\u00edpusos t\u00e1rol\u00e1s\u00e1ra haszn\u00e1lunk. Az anonim t\u00edpusokkal lehet\u0151s\u00e9g\u00fcnk van inline defini\u00e1lni olyan oszt\u00e1lyokat, amelyek jellemz\u0151en csak dobozol\u00e1sra \u00e9s adattov\u00e1bb\u00edt\u00e1sra haszn\u00e1ltak. Vegy\u00fck az al\u00e1bbi p\u00e9ld\u00e1kat a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n:</p> <pre><code>var dolog1 = new { Name = \"Alma\", Weight = 100, Size = 10 };\nvar dolog2 = new { Name = \"K\u00f6rte\", Weight = 90 };\n</code></pre> <p>Kor\u00e1bban m\u00e1r eml\u00edtett\u00fck a <code>var</code> kulcssz\u00f3t, amellyel implicit t\u00edpus\u00fa, lok\u00e1lis v\u00e1ltoz\u00f3k defini\u00e1lhat\u00f3k. Az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n defini\u00e1lunk egy-egy anonim t\u00edpust, amelynek felvesz\u00fcnk n\u00e9h\u00e1ny tulajdons\u00e1got. A tulajdons\u00e1gok mind t\u00edpusosak maradnak, a t\u00edpusrendszer\u00fcnk tov\u00e1bbra is s\u00e9rtetlen. Az implicit statikus t\u00edpusoss\u00e1g nem csak a <code>var</code> kulcssz\u00f3ban jelenik meg teh\u00e1t, hanem az egyes tulajdons\u00e1gok t\u00edpus\u00e1ban is.</p> <p>Az anonim t\u00edpusok:</p> <ul> <li>csak referencia t\u00edpus\u00faak lehetnek (objektumok, nem pedig strukt\u00far\u00e1k),</li> <li>csak publikusan l\u00e1that\u00f3, csak olvashat\u00f3 tulajdons\u00e1gokat tartalmazhatnak,</li> <li>esem\u00e9nyeket \u00e9s met\u00f3dusokat nem tartalmazhatnak (delegate p\u00e9ld\u00e1nyokat tulajdons\u00e1gban viszont igen),</li> <li>szerelv\u00e9nyen bel\u00fcl l\u00e1that\u00f3k (<code>internal</code>) \u00e9s nem sz\u00e1rmazhat bel\u0151l\u00fck m\u00e1sik t\u00edpus (<code>sealed</code>)</li> <li>t\u00edpusnev\u00e9t nem ismerj\u00fck, \u00edgy hivatkozni sem tudunk r\u00e1, csak a <code>var</code>-t tudjuk haszn\u00e1lni</li> <li>nem haszn\u00e1lhat\u00f3k ott, ahol a <code>var</code> t\u00edpus se haszn\u00e1lhat\u00f3, t\u00f6bbek k\u00f6z\u00f6tt nem adhatjuk \u00e1t f\u00fcggv\u00e9nynek \u00e9s nem lehet visszat\u00e9r\u00e9si \u00e9rt\u00e9k sem</li> </ul> <p>Ha az egeret a <code>var</code> kulcsszavak vagy egyes tulajdons\u00e1gnevek f\u00f6l\u00e9 vissz\u00fck, l\u00e1thatjuk, hogy val\u00f3ban ford\u00edt\u00e1si idej\u0171 t\u00edpusokr\u00f3l van sz\u00f3.</p> <p>IntelliSense</p> <p>Figyelj\u00fck meg, hogy az IntelliSense is m\u0171k\u00f6dik ezekre a t\u00edpusokra, felk\u00edn\u00e1lja a t\u00edpus property-jeit.</p> <p>A ford\u00edt\u00f3 \u00fajra is hasznos\u00edtja az egyes t\u00edpusokat:</p> <pre><code>var dolgok = new { Name = \"Gy\u00fcm\u00f6lcs\u00f6k\", Contents = new[] { dolog1, dolog2 } };\n</code></pre> <p>A <code>Contents</code> tulajdons\u00e1g t\u00edpusa a fenti anonim objektumaink t\u00f6mbje, ez\u00e9rt nem is adhatn\u00e1nk meg m\u00e1sk\u00e9ppen (nem tudjuk a nev\u00e9t, amivel hivatkozhatunk r\u00e1). A ford\u00edt\u00f3 most panaszkodik, ugyanis a k\u00e9t dolog t\u00edpusa nem implicit k\u00f6vetkeztethet\u0151. Ha felvessz\u00fck a <code>Size</code> tulajdons\u00e1got a <code>dolog2</code> defin\u00edci\u00f3j\u00e1ba, m\u00e1ris fordul.</p> <pre><code>var dolog2 = new { Name = \"K\u00f6rte\", Weight = 90, Size = 12 };\n</code></pre> <p>Ha v\u00e9gezt\u00fcnk az anonim t\u00edpusokkal val\u00f3 ismerked\u00e9ssel, az ezekkel kapcsolatos k\u00f3dsorokat kikommentezhetj\u00fck.</p>"},{"location":"seminar/03-linq/chapter3/#linq-szintaxisok","title":"LINQ szintaxisok","text":"<p>Az el\u0151z\u0151 r\u00e9szben ismertetett jelleg\u0171 lek\u00e9rdez\u00e9sek nagyban hasonl\u00edtanak azokhoz, amiket adatb\u00e1zis-lek\u00e9rdez\u00e9sekben alkalmazunk. A k\u00fcl\u00f6nbs\u00e9g itt az, hogy imperat\u00edv szintaxist haszn\u00e1lunk, szemben pl. az SQL-lel, ami deklarat\u00edvat. Ez\u00e9rt is van jelen a C# nyelvben az \u00fan. query syntax, amely j\u00f3val hasonlatosabb az SQL szintaxis\u00e1hoz, \u00edgy az adatb\u00e1zisokban j\u00e1rtas fejleszt\u0151k is k\u00f6nnyebben \u00edrhatnak lek\u00e9rdez\u00e9seket. Ugyanakkor nem minden lek\u00e9rdez\u00e9st tudunk query syntax-szal le\u00edrni.</p> <p>Mi\u00e9rt nem lehet mindent meg\u00edrni query syntaxban?</p> <p>Ennek oka, hogy az oper\u00e1torok bevezet\u00e9se egy nyelvben el\u00e9g dr\u00e1ga - le kell p\u00e9l\u00e1dul foglalni az oper\u00e1tor nev\u00e9t, amit ut\u00e1na korl\u00e1tozottan lehet csak haszn\u00e1lni m\u00e1sra. Ez\u00e9rt sem csin\u00e1lt\u00e1k meg minden LINQ f\u00fcggv\u00e9nynek az oper\u00e1tor p\u00e1rj\u00e1t, csak az SQL-ben gyakrabban haszn\u00e1latosabbaknak.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3 lek\u00e9rdez\u00e9st meg\u00edrhatunk az al\u00e1bbi m\u00f3don query syntax haszn\u00e1lat\u00e1val:</p> <pre><code>using HelloLinq.Extensions;\n\n//...\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\n\nvar query = from d in Dogs\n            where d.DateOfBirth?.Year &lt; 2010\n            select new\n            {\n                Dog = d,\n                AverageSiblingAge = d.Siblings.Average(s =&gt; s.Age ?? 0)\n            };\nforeach (var meta in query)\n{\n    Console.WriteLine(\n        $\"{meta.Dog.Name} - {meta.AverageSiblingAge}\");\n}\n</code></pre> <p>A query szintaxis v\u00e9g\u00fcl a kor\u00e1bban is haszn\u00e1lt, \u00fan. *fluent szintaxis*s\u00e1 fordul. Ennek igazol\u00e1s\u00e1ra n\u00e9zz\u00fck meg F12-vel, hogy hol vannak defini\u00e1lva az \u00fajonnan megismert oper\u00e1torok (<code>select</code>, <code>where</code>). A k\u00e9t szintaxist szok\u00e1s \u00f6tv\u00f6zni is, jellemz\u0151en akkor, ha query szintaxisban \u00edrjuk a lek\u00e9rdez\u00e9st, \u00e9s a hi\u00e1nyz\u00f3 funkcionalit\u00e1st fluent szintaxissal p\u00f3toljuk.</p> <p>Fluent szintaxis</p> <p>A fluent szintaxist olyan kialak\u00edt\u00e1s\u00fa API-kn\u00e1l alkalmazhatjuk, ahol a f\u00fcggv\u00e9nyek a tartalmaz\u00f3 t\u00edpust v\u00e1rj\u00e1k (egyik) bemenetk\u00e9nt \u00e9s azonos (vagy lesz\u00e1rmazott) t\u00edpust adnak vissza. A LINQ-n\u00e9l ez a t\u00edpus az <code>IEnumerable&lt;&gt;</code>.</p> <p>Ezen az \u00f3r\u00e1n mem\u00f3riabeli adatforr\u00e1sokkal dolgoztunk (konkr\u00e9tan a <code>Dogs</code> nev\u0171 <code>Dictionary&lt;,&gt;</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3val), a LINQ oper\u00e1torok k\u00f6z\u00fcl a mem\u00f3riabeli list\u00e1kon dolgoz\u00f3kat haszn\u00e1ltuk, melyeket az <code>IEnumerable&lt;&gt;</code> interf\u00e9szre biggyesztettek r\u00e1 b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt. Ezt a LINQ API-t teljes nev\u00e9n *LINQ-to-Objects*nek h\u00edvj\u00e1k, de gyakran csak LINQ-k\u00e9nt hivatkozz\u00e1k.</p>"},{"location":"seminar/03-linq/chapter3/#kitekinto-expression-linq-providerek","title":"Kitekint\u0151: Expression\\&lt;&gt;, LINQ providerek","text":"<p>Vegy\u00fck az al\u00e1bbi nagyon egyszer\u0171 delegate-et \u00e9s ennek <code>Expression&lt;&gt;</code>-\u00f6s p\u00e1rj\u00e1t.</p> <pre><code>Func&lt;int, int&gt;  f = x =&gt; x + 1;\nExpression&lt;Func&lt;int, int&gt;&gt; e = x =&gt; x + 1;\n</code></pre> <p>N\u00e9zz\u00fck meg debuggol\u00e1s k\u00f6zben a Watch ablakban a fenti k\u00e9t v\u00e1ltoz\u00f3t. Az <code>f</code> egy delegate, leford\u00edtott k\u00f3d*ra mutat\u00f3 referencia, az <code>Expression</code> a jobb oldali kifejez\u00e9sb\u0151l \u00e9p\u00edtett (fa strukt\u00far\u00e1j\u00fa) *adat.</p> <p>A f\u00e1t k\u00f3dd\u00e1 ford\u00edthatjuk a <code>Compile</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel, mely a leford\u00edtott f\u00fcggv\u00e9ny referenci\u00e1j\u00e1t (deleg\u00e1t p\u00e9ld\u00e1ny) adja vissza, amit a f\u00fcggv\u00e9nyh\u00edv\u00e1s szintaxissal h\u00edvhatunk meg. Ebb\u0151l \u00e1ll \u00f6ssze az al\u00e1bbi fura kin\u00e9zet\u0171 kifejez\u00e9s:</p> <pre><code>Console.WriteLine(e.Compile()(5));\n</code></pre> <p>B\u00e1r az <code>Expression&lt;&gt;</code> emiatt okosabb v\u00e1laszt\u00e1snak t\u0171nik, \u00e1m a LINQ-to-Objects alapinterf\u00e9sz\u00e9nek (ami a lek\u00e9rdez\u0151f\u00fcggv\u00e9nyeket biztos\u00edtja) f\u00fcggv\u00e9nyei <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code> deleg\u00e1tokat v\u00e1rnak. Ami nem csoda, hiszen mem\u00f3riabeli list\u00e1kat \u00e1ltal\u00e1ban sima programk\u00f3ddal dolgozunk fel, nincs \u00e9rtelme fel\u00e9p\u00edteni kifejez\u00e9sf\u00e1t csak az\u00e9rt, hogy ut\u00e1na egyb\u0151l k\u00f3dd\u00e1 ford\u00edtsuk. Emellett m\u00e1s, mem\u00f3riabeli adatokon dolgoz\u00f3 LINQ technol\u00f3gia is l\u00e9tezik, pl. LINQ-to-XML saj\u00e1t API-val (nem <code>IEnumerable&lt;&gt;</code> alapt\u00edpussal).</p> <p>A nem mem\u00f3riabeli adatokon, hanem p\u00e9ld\u00e1ul k\u00fcls\u0151 adatb\u00e1zisb\u00f3l dolgoz\u00f3 LINQ provider-ek viszont <code>IQueryable&lt;&gt;</code>-t val\u00f3s\u00edtanak meg. Az <code>IQueryable&lt;&gt;</code> az <code>IEnumerable&lt;&gt;</code>-b\u00f3l sz\u00e1rmazik, \u00edgy neki is vannak <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code>-\u00f6s f\u00fcggv\u00e9nyei, de emellett <code>Expression&lt;&gt;</code>-\u00f6sek is. Ez ut\u00f3bbiak teszik lehet\u0151v\u00e9, hogy ne csak .NET k\u00f3dot gener\u00e1ljanak a lambda kifejez\u00e9sekb\u0151l, hanem helyette pl. SQL kifejez\u00e9st - hiszen egy rel\u00e1ci\u00f3s adatb\u00e1zis adatfeldolgoz\u00f3 nyelve nem .NET, hanem valamilyen SQL dialektus.</p>"},{"location":"seminar/03-linq/chapter3/#a-linq-providerek-altalanos-mukodese","title":"A LINQ providerek \u00e1ltal\u00e1nos m\u0171k\u00f6d\u00e9se","text":"<p>Bemenet\u00fck: query f\u00fcggv\u00e9nyeknek (<code>IQueryable&lt;&gt;</code> vagy <code>IEnumerable&lt;&gt;</code> f\u00fcggv\u00e9nyei vagy pl. <code>XDocument</code>) param\u00e9ter\u00fcl adott lambd\u00e1k (<code>Func&lt;&gt;</code> vagy <code>Expression&lt;&gt;</code>)</p> <p>Kimenet\u00fck: az adatforr\u00e1snak megfelel\u0151 nyelv\u0171, a query-t v\u00e9grehajt\u00f3 k\u00f3d (.NET k\u00f3d vagy SQL).</p> <p>LINQ-to-Objects eset\u00e9n nincs val\u00f3di LINQ provider (a provider az <code>IQueryable.Provider</code>-en kereszt\u00fcl \u00e9rhet\u0151 el, de a <code>List&lt;&gt;</code> nem <code>IQueryable</code>!), hiszen nincs feladata: k\u00f3dot kap bemenet\u00fcl, ugyanazt kellene kimenet\u00fcl adnia. A LINQ-to-XML is hasonl\u00f3 elven m\u0171k\u00f6dik.</p> <p>Val\u00f3di LINQ providert val\u00f3s\u00edt meg p\u00e9ld\u00e1ul az Entity Framework, de ezt a technol\u00f3gi\u00e1t k\u00e9s\u0151bb t\u00e1rgyaljuk.</p>"}]}