{"config":{"lang":["hu"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Szoftverfejleszt\u00e9s .NET platformra","text":"<p>Jegyzetek, gyakorlati anyagok \u00e9s h\u00e1zi feladatok a Szoftverfejleszt\u00e9s .NET platformra c. t\u00e1rgyhoz.</p> <p>Jav\u00edt\u00e1s az anyagban</p> <p>A t\u00e1rgy hallgat\u00f3inak a jegyzet anyag\u00e1ban t\u00f6rt\u00e9n\u0151 jav\u00edt\u00e1s\u00e9rt, kieg\u00e9sz\u00edt\u00e9s\u00e9rt plusz pontot adunk! Ha hib\u00e1t tal\u00e1lsz a jegyzet b\u00e1rmely r\u00e9sz\u00e9ben, vagy kieg\u00e9sz\u00edten\u00e9d azt, nyiss egy pull request-et! A repository linkj\u00e9t a jobb fels\u0151 sarokban tal\u00e1lod.</p> <p>Felhaszn\u00e1l\u00e1si felt\u00e9telek</p> <p>Az itt tal\u00e1lhat\u00f3 oktat\u00e1si seg\u00e9danyagok a BMEVIAUAC01 t\u00e1rgy hallgat\u00f3inak k\u00e9sz\u00fcltek. Az anyagok oly m\u00f3d\u00fa felhaszn\u00e1l\u00e1sa, amely a t\u00e1rgy oktat\u00e1s\u00e1hoz nem szorosan kapcsol\u00f3dik, csak a szerz\u0151(k) \u00e9s a forr\u00e1s megjel\u00f6l\u00e9s\u00e9vel t\u00f6rt\u00e9nhet.</p> <p>Az anyagok a t\u00e1rgy keret\u00e9ben oktatott kontextusban \u00e9rtelmezhet\u0151ek. Az anyagok\u00e9rt egy\u00e9b felhaszn\u00e1l\u00e1s eset\u00e9n a szerz\u0151(k) felel\u0151ss\u00e9get nem v\u00e1llalnak.</p> <p>A felhaszn\u00e1l\u00e1si felt\u00e9telekr\u0151l b\u0151vebben a repository LICENSE.md f\u00e1jlj\u00e1ban olvashatsz.</p>"},{"location":"homework/","title":"H\u00e1zi feladat tudnival\u00f3k","text":"<p>Az itteni szerkezetet k\u00f6vess\u00e9tek: p\u00e9lda specifik\u00e1ci\u00f3</p>"},{"location":"homework/#kovetelmenyek","title":"K\u00f6vetelm\u00e9nyek","text":"<p>Az al\u00e1bbiak k\u00f6z\u00fcl mindegyiknek teljes\u00fclnie kell az al\u00e1\u00edr\u00e1shoz:</p> <ul> <li>K\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll<ul> <li>szerver oldali HTTP alap\u00fa szolg\u00e1ltat\u00e1s</li> <li>egy vastag vagy v\u00e9kony kliens (szerveroldali renderel\u00e9s n\u00e9lk\u00fcl) alkalmaz\u00e1s, ami a szolg\u00e1ltat\u00e1st h\u00edvja<ul> <li>elfogadhat\u00f3 (p\u00e9ld\u00e1k): WPF, WinForms, MAUI, Swing, JavaFX, Blazor WebAssembly, Angular, React, Vue, Android (kotlin, java), iOS (swift, obj-c), stb.</li> <li>nem elfogadhat\u00f3: ASP.NET Core MVC Razor gener\u00e1lt weboldalakb\u00f3l \u00e1ll\u00f3 webalkalmaz\u00e1s, JSP, PHP, Blazor Server, vagy Blazor Static Render, sima HTML+JS+CSS</li> <li>kiv\u00e9tel: a felhaszn\u00e1l\u00f3kezel\u00e9shez szorosan kapcsol\u00f3d\u00f3 fel\u00fcletek (bel\u00e9p\u00e9s, regisztr\u00e1ci\u00f3, stb.) b\u00e1rmilyen fel\u00fcleti technol\u00f3gi\u00e1val k\u00e9sz\u00fclhetnek</li> </ul> </li> <li>a vastag/v\u00e9kony kliens kiv\u00e1lthat\u00f3 Postman klienssel</li> </ul> </li> <li>A kliens nem \u00e9ri el k\u00f6zvetlen\u00fcl az adatb\u00e1zist</li> <li>A kliens nem csak egym\u00e1st\u00f3l f\u00fcggetlen h\u00edv\u00e1sokat csin\u00e1l, hanem t\u00e9nylegesen v\u00e9gre is lehet hajtani a felhaszn\u00e1l\u00f3i folyamatokat. Pl. Postman kliens eset\u00e9ben, nem csak k\u00fcl\u00f6n\u00e1ll\u00f3 teszth\u00edv\u00e1sok vannak, hanem kollekci\u00f3kba rendezve h\u00edv\u00e1si sorozatok, ahol ez egyes h\u00edv\u00e1sok k\u00f6z\u00f6tt v\u00e1ltoz\u00f3kban \u00e1llapotot is t\u00e1rolunk.</li> <li>Adatel\u00e9r\u00e9s: Entity Framework Core v8.x</li> <li>Kommunik\u00e1ci\u00f3: ASP.NET Core v8.x<ul> <li>Az el\u0151bb megadott verzi\u00f3khoz k\u00e9pest k\u00e9s\u0151bbi verzi\u00f3k haszn\u00e1lhat\u00f3k - saj\u00e1t felel\u0151ss\u00e9gre</li> </ul> </li> <li>Minimum 3 \u00f6sszef\u00fcgg\u0151 t\u00e1bla haszn\u00e1lata, nem sz\u00e1molva a felhaszn\u00e1l\u00f3kezel\u00e9ssel kapcsolatos t\u00e1bl\u00e1kat</li> <li>A leadott specifik\u00e1ci\u00f3nak megfelel\u0151 funkcionalit\u00e1s</li> </ul>"},{"location":"homework/example-spec/","title":"Kisdoktori gener\u00e1tor","text":""},{"location":"homework/example-spec/#feladat-1","title":"Feladat <sup>1</sup>","text":"<p>Egy olyan alkalmaz\u00e1s k\u00e9sz\u00edt\u00e9se, mely t\u00f6rzsanyagokb\u00f3l disszert\u00e1ci\u00f3t \u00e1ll\u00edt el\u0151. T\u00f6rzsanyagokat lehet felvinni a rendszerbe, egy szerkeszt\u0151fel\u00fcleten megadni a gener\u00e1l\u00e1s param\u00e9tereit, majd a gener\u00e1lt dokumentumot k\u00fcl\u00f6nb\u00f6z\u0151 form\u00e1tumokba menteni.</p>"},{"location":"homework/example-spec/#a-kishaziban-elerheto-funkciok-2","title":"A kish\u00e1ziban el\u00e9rhet\u0151 funkci\u00f3k <sup>2</sup>","text":"<ul> <li>t\u00f6rzsanyagok felt\u00f6lt\u00e9se (csak .txt form\u00e1tumban), t\u00f6rl\u00e9se - a t\u00f6rzsanyag t\u00e9m\u00e1ja megadhat\u00f3.</li> <li>egyszer\u0171 szerkeszt\u0151fel\u00fclet - t\u00e9ma megad\u00e1sa, elv\u00e1rt sz\u00f3sz\u00e1m</li> <li>egyszer\u0171 gener\u00e1l\u00e1s - a t\u00e9ma alapj\u00e1n sz\u00f6vegek \u00f6sszev\u00e1logat\u00e1sa v\u00e9letlenszer\u0171en</li> <li>ment\u00e9s XML form\u00e1tumban, az egyes sz\u00f6vegr\u00e9szekhez megadva, hogy melyik forr\u00e1sm\u0171b\u0151l sz\u00e1rmaznak</li> <li>az el\u0151bbi XML bet\u00f6lt\u00e9se \u00e9s tartalm\u00e1nak megjelen\u00edt\u00e9se (az egyes sz\u00f6vegr\u00e9szekhez jelenjen meg, hogy melyik forr\u00e1sm\u0171b\u0151l val\u00f3)</li> </ul>"},{"location":"homework/example-spec/#adatbazis-entitasok-3","title":"Adatb\u00e1zis entit\u00e1sok <sup>3</sup>","text":"<ul> <li>t\u00f6rzsanyag</li> <li>dolgozat</li> <li>forr\u00e1shivatkoz\u00e1s</li> </ul>"},{"location":"homework/example-spec/#alkalmazott-alaptechnologiak-4","title":"Alkalmazott alaptechnol\u00f3gi\u00e1k <sup>4</sup>","text":"<ul> <li>adatel\u00e9r\u00e9s: Entity Framework Core v8</li> <li>kommunik\u00e1ci\u00f3, szerveroldal: ASP.NET Core v8</li> <li>kliensoldal: Blazor WebAssembly</li> </ul>"},{"location":"homework/example-spec/#tovabbfejlesztesi-tervek-5","title":"Tov\u00e1bbfejleszt\u00e9si tervek <sup>5</sup>","text":"<ul> <li>hosztol\u00e1s Azure-ban</li> <li>HiLo els\u0151dleges kulcs alkalmaz\u00e1sa</li> <li>logikai t\u00f6rl\u00e9s (soft delete) glob\u00e1lis sz\u0171r\u0151kkel</li> <li>OData szolg\u00e1ltat\u00e1s megval\u00f3s\u00edt\u00e1sa</li> </ul> <ol> <li> <p>2-3 mondatban foglald \u00f6ssze a feladatot!\u00a0\u21a9</p> </li> <li> <p>Adatm\u00f3dos\u00edt\u00e1ssal j\u00e1r\u00f3 is legyen benne\u00a0\u21a9</p> </li> <li> <p>min. 3 db.\u00a0\u21a9</p> </li> <li> <p>a szerver oldal mindenkinek ugyanez lesz, kliensoldal v\u00e1laszthat\u00f3. Verzi\u00f3sz\u00e1mok lehetnek nagyobbak, mint a lentiek\u00a0\u21a9</p> </li> <li> <p>opcion\u00e1lis, a pontrendszerb\u0151l \u00e9rdemes v\u00e1logatni. C\u00e9lja, hogy KHF bemutat\u00e1skor a felmer\u00fcl\u0151 k\u00e9rd\u00e9seket megbesz\u00e9lhess\u00fck\u00a0\u21a9</p> </li> </ol>"},{"location":"homework/hw-points/","title":"NagyHF pontrendszer","text":""},{"location":"homework/hw-points/#pontszerzesi-szabalyok","title":"Pontszerz\u00e9si szab\u00e1lyok","text":"<ul> <li>Egy jogc\u00edmen csak egyszer szerezhet\u0151 pont (pl. nem lehet 3 k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1rral 21 pontot \u00f6sszeszedni), kiv\u00e9ve ahol ezt k\u00fcl\u00f6n jelezz\u00fck</li> <li>R\u00e9szpontsz\u00e1m nem adhat\u00f3, kiv\u00e9ve, ahol intervallum van megadva</li> <li>Kliensoldali megold\u00e1s\u00e9rt nem adhat\u00f3 pont</li> <li>A szoftvernek egys\u00e9ges funkci\u00f3halmazt kell ny\u00fajtania, k\u00fcl\u00f6n\u00e1ll\u00f3, egym\u00e1shoz nem kapcsol\u00f3d\u00f3 funkci\u00f3kb\u00f3l \u00e1ll\u00f3 szoftver nem elfogadhat\u00f3. Azaz k\u00fcl\u00f6n\u00e1ll\u00f3 tutorialok \u00f6sszef\u00e9rcel\u00e9s\u00e9t nem d\u00edjazzuk.</li> </ul> <p>Pontrendszer v\u00e9gleges\u00edt\u00e9s</p> <p>Jelenleg a 2024. tavaszif\u00e9l\u00e9vre nincs v\u00e9gleges\u00edtve a pontrendszer!</p> <p>V\u00e9gleges\u00edt\u00e9s ut\u00e1n csak a k\u00f6vetkez\u0151 t\u00edpus\u00fa v\u00e1ltoz\u00e1sok lehetnek</p> <ul> <li>hallgat\u00f3knak kedvez\u0151 v\u00e1ltoz\u00e1sok (pl. \u00faj jogc\u00edmek)</li> <li>el\u00edr\u00e1sok, megfogalmaz\u00e1sbeli pontos\u00edt\u00e1sok jav\u00edt\u00e1sa</li> <li>ellentmond\u00e1sok felold\u00e1sa</li> </ul>"},{"location":"homework/hw-points/#tarsadalmi-munka","title":"T\u00e1rsadalmi munka","text":"<ul> <li>a v\u00e9gleges\u00edtett pontrendszer vagy jegyzet jav\u00edt\u00e1sa, b\u0151v\u00edt\u00e9se, m\u00f3dos\u00edt\u00e1sa pull request-tel [0-2, max. 5]<ul> <li>Helyes\u00edr\u00e1si hiba is lehet, de az oktat\u00f3k d\u00f6ntenek, hogy h\u00e1ny pontot (0-2) \u00e9r a m\u00f3dos\u00edt\u00e1s</li> <li>T\u00f6bbsz\u00f6r is megszerezhet\u0151!</li> </ul> </li> </ul>"},{"location":"homework/hw-points/#aspnet-core-web-api","title":"ASP.NET Core Web API","text":"<ul> <li>HATEOAS linkek gener\u00e1l\u00e1sa a v\u00e1laszban [7]</li> <li>Web API Core \u00e1ltal alapb\u00f3l nem t\u00e1mogatott HTTP ige (verb) implement\u00e1l\u00e1sa [5-7]<ul> <li>pl. GET-hez hasonl\u00f3 m\u0171k\u00f6d\u00e9s 5</li> <li>pl. PATCH ige r\u00e9szleges m\u00f3dos\u00edt\u00e1shoz JSON Patch dokumentumok felk\u00fcld\u00e9s\u00e9vel 7</li> <li>pl. OPTIONS ige az er\u0151forr\u00e1s \u00e1ltal t\u00e1mogatott ig\u00e9k lek\u00e9rdez\u00e9s\u00e9hez 7</li> </ul> </li> <li>verzi\u00f3kezelt API. Szeml\u00e9ltet\u00e9s k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 verzi\u00f3s API egyidej\u0171 kiszolg\u00e1l\u00e1s\u00e1val. A k\u00edv\u00e1nt verzi\u00f3t HTTP fejl\u00e9c vagy p\u00e9ld\u00e1ul URL szegmens alapj\u00e1n v\u00e1laszthatja meg a kliens. [7]</li> <li>cache megval\u00f3s\u00edt\u00e1sa [3-9]<ul> <li>ETAG alap\u00fa: a kliens fel\u00fck\u00fcld egy E-TAG-et, szerver \u00f6sszeveti az adatb\u00e1zisb\u00f3l felolvasott verzi\u00f3val 3</li> <li>a szerver is mem\u00f3ria alap\u00fa cache-b\u0151l olvassa ki az aktu\u00e1lis verzi\u00f3t +3</li> <li>a szerver is elosztott alap\u00fa cache-b\u0151l olvassa ki az aktu\u00e1lis verzi\u00f3t pl.: Redis + <code>IDistributedCache</code> +3</li> </ul> </li> <li>Szerver oldali autentik\u00e1ci\u00f3. Saj\u00e1t token provider k\u00e9sz\u00edt\u00e9se, haszn\u00e1lata (DIY security) eset\u00e9n nem j\u00e1r pont. [7-15]<ul> <li>API (egy r\u00e9sz\u00e9nek) v\u00e9d\u00e9se felhaszn\u00e1l\u00f3 \u00e1ltal ig\u00e9nyelhet\u0151 API kulccsal 7</li> <li>ASP.NET Core Identity be\u00e9p\u00edtett megold\u00e1saival (s\u00fcti alap\u00fa) - csak b\u00f6ng\u00e9sz\u0151s/Postman kliens eset\u00e9n! 7</li> <li>OpenID Connect, JWT token alap\u00fa oszt\u00e1lyk\u00f6nyvt\u00e1rat integr\u00e1lva ASP.NET Core Identity + Duende IdentityServer / OpenIddict middleware-rel, interakt\u00edv flow<ul> <li>angular, react kliens eset\u00e9n 7</li> <li>Blazor WebAssembly kliens eset\u00e9n 10</li> <li>egy\u00e9b kliens eset\u00e9n 12</li> </ul> </li> <li>Azure AD B2C-re (ingyenes szint) \u00e9p\u00edtve 10</li> <li>norm\u00e1l Azure AD (nem B2C) 7</li> <li>LDAP alap\u00fa szolg\u00e1ltat\u00e1sra \u00e9p\u00edtve 10</li> <li>m\u00e1s Identity-as-a-Service szolg\u00e1ltat\u00e1ssal (pl. Auth0) 7</li> <li>legal\u00e1bb egy k\u00fcls\u0151 identity provider integr\u00e1l\u00e1sa (Google login, Windows login, stb.)  +3</li> </ul> </li> <li>szerver oldali hozz\u00e1f\u00e9r\u00e9s-szab\u00e1lyoz\u00e1s, az el\u0151bbi authentik\u00e1ci\u00f3ra \u00e9p\u00edtve  [2-5]<ul> <li>szerepk\u00f6r alap\u00fa hozz\u00e1f\u00e9r\u00e9s-szab\u00e1lyoz\u00e1s 2</li> <li>policy alap\u00fa hozz\u00e1f\u00e9r\u00e9s-szab\u00e1lyoz\u00e1s (pl.: Claim alapon) 5</li> </ul> </li> <li>k\u00fcls\u0151 online szolg\u00e1ltat\u00e1s (Twitter, Facebook, Google Maps, Bing Maps, stb.) integr\u00e1l\u00e1sa a szerveroldali alkalmaz\u00e1sba kliensk\u00f6nyvt\u00e1rral (pl. HttpClient) vagy SDK-val [7-10]<ul> <li>egyszer\u0171 REST API, SDK haszn\u00e1lat n\u00e9lk\u00fcl, egyszer\u0171 API kulcs alap\u00fa authentik\u00e1ci\u00f3 7</li> <li>SDK-val / REST API-val, authentik\u00e1ci\u00f3t (pl. OIDC) v\u00e9grehajtva 10</li> </ul> </li> <li>SignalR Core alkalmaz\u00e1sa val\u00f3s idej\u0171, szerver fel\u0151l \u00e9rkez\u0151 push jelleg\u0171 kommunik\u00e1ci\u00f3ra 7</li> <li>teljes szerveroldal hosztol\u00e1sa k\u00fcls\u0151 szolg\u00e1ltat\u00f3n\u00e1l [5-15]<ul> <li>Azure (ingyenes App Services - WebApp szolg\u00e1ltat\u00e1s) 7</li> <li>egy\u00e9b szolg\u00e1ltat\u00f3 5</li> <li>Automatiz\u00e1lt telep\u00edt\u00e9s (pl. GitHub Actions, Azure DevOps) +3</li> </ul> </li> <li>Publik\u00e1l\u00e1s docker kont\u00e9nerbe \u00e9s futtat\u00e1s kont\u00e9nerb\u0151l 5</li> <li>hosztol\u00e1s service-ben (Windows Service, Linux systemd) [3-5]<ul> <li>Windows service 3</li> <li>Linux systemd 5</li> </ul> </li> <li>OpenAPI le\u00edr\u00f3 (swagger) alap\u00fa dokument\u00e1ci\u00f3 [3-12]<ul> <li>minden v\u00e9gpont kliens szempontj\u00e1b\u00f3l relev\u00e1ns m\u0171k\u00f6d\u00e9se dokument\u00e1lt, minden lehets\u00e9ges v\u00e1laszk\u00f3ddal egy\u00fctt 3</li> <li>az API-nak egyidej\u0171leg t\u00f6bb t\u00e1mogatott verzi\u00f3ja van, mindegyik dokument\u00e1lt \u00e9s mindegyik t\u00e1mogatott verzi\u00f3 dokument\u00e1ci\u00f3ja el\u00e9rhet\u0151  +4</li> <li>A kliensen az OpenApi le\u00edr\u00f3 alapj\u00e1n gener\u00e1lt kliensk\u00f6nyvt\u00e1r haszn\u00e1lata +5</li> </ul> </li> <li>Adatb\u00e1zis entit\u00e1s els\u0151dleges kulcs elrejt\u00e9se a kliens el\u0151l v\u00e9letlenszer\u0171en gener\u00e1lt, nem n\u00f6vekv\u0151 sorrendben kiosztott kulcsokkal. A kliens nem ismeri az adatb\u00e1zis entit\u00e1s kulcs \u00e9rt\u00e9k\u00e9t, helyette egy gener\u00e1lt kulcsot l\u00e1t csak. Az adatb\u00e1zis nem t\u00e1rolja a gener\u00e1lt kulcsot. Megval\u00f3s\u00edthat\u00f3 k\u00e9tir\u00e1ny\u00fa sz\u00e1m &lt;-&gt; gener\u00e1lt azonos\u00edt\u00f3 f\u00fcggv\u00e9nyek seg\u00edts\u00e9g\u00e9vel. 7</li> <li>K\u00f6zpontos\u00edtott hibakezel\u00e9s, a kliens sz\u00e1m\u00e1ra \u00e9rtelmezhet\u0151 <code>ProblemDetails</code> objektumok k\u00fcld\u00e9se hib\u00e1s k\u00e9r\u00e9sek eset\u00e9n. Teh\u00e1t nem a Controllerekben van try-catch, hanem a hib\u00e1k k\u00f6zpontilag vannak kezelve 5</li> <li>D\u00e1tumok helyes kezel\u00e9se olyan esetben is, ha a kliens \u00e9s a szerver(ek) elt\u00e9r\u0151 id\u0151z\u00f3n\u00e1ban vannak. (tipikusan <code>DateTimeOffset</code> haszn\u00e1lata). Implement\u00e1ci\u00f3t nem kell bemutat\u00e1sk\u00f6r demonstr\u00e1lni, de a k\u00f3d alapj\u00e1n \u00e9rvelve bizony\u00edtani kell a helyes m\u0171k\u00f6d\u00e9st. 5</li> </ul>"},{"location":"homework/hw-points/#kommunikacio-halozatkezeles","title":"Kommunik\u00e1ci\u00f3, h\u00e1l\u00f3zatkezel\u00e9s","text":"<ul> <li>alacsony szint\u0171 kommunik\u00e1ci\u00f3 (soros port, HTTP alatti OSI r\u00e9teg, pl. k\u00e9tir\u00e1ny\u00fa TCP) 10</li> <li>HTTPS kommunik\u00e1ci\u00f3 (self-signed tan\u00fas\u00edtv\u00e1nnyal) az ASP.NET Web API \u00e9s a kliens k\u00f6z\u00f6tt, hosztol\u00e1s norm\u00e1l, nem fejleszt\u0151i webszerverben (pl. Apache, nginx, nem IIS Express) \u00e9s nem Kestrel-en, szeml\u00e9ltet\u00e9s Fiddler-rel/Postman-nel [5-10]<ul> <li>csak szerver oldali tan\u00fas\u00edtv\u00e1ny 5</li> <li>kliens is azonos\u00edtja mag\u00e1t tan\u00fas\u00edtv\u00e1nnyal a szerver fel\u00e9 +5</li> </ul> </li> <li>az API funkci\u00f3k egy r\u00e9sz\u00e9nek el\u00e9rhet\u0151v\u00e9 t\u00e9tele GraphQL h\u00edv\u00e1sokon kereszt\u00fcl, ASP.NET Core middleware seg\u00edts\u00e9g\u00e9vel (pl. GraphQL.NET vagy Hot Chocolate) az EF entit\u00e1smodellre \u00e9p\u00edtve. Szeml\u00e9ltet\u00e9s p\u00e9ldah\u00edv\u00e1sokkal a kliensb\u0151l. [7-10]<ul> <li>csak lek\u00e9rdez\u00e9s 7</li> <li>m\u00f3dos\u00edt\u00e1s vagy hozz\u00e1ad\u00e1s is (mut\u00e1ci\u00f3) +3</li> </ul> </li> <li>az API funkci\u00f3k egy r\u00e9sz\u00e9nek el\u00e9rhet\u0151v\u00e9 t\u00e9tele gRPC HTTP/2 vagy gRPC-Web h\u00edv\u00e1sokon kereszt\u00fcl. Szeml\u00e9ltet\u00e9s p\u00e9ldah\u00edv\u00e1sokkal kliensb\u0151l vagy gRPC teszteszk\u00f6zb\u0151l (pl. bloomrpc) Azure App Service-szel, IIS-sel, b\u00f6ng\u00e9sz\u0151s klienssel korl\u00e1tozottan kompatibilis! [7]</li> <li>az EF adatmodell kiaj\u00e1nl\u00e1sa OData szolg\u00e1ltat\u00e1s seg\u00edts\u00e9g\u00e9vel (Microsoft.AspNetCore.OData csomag). P\u00e9ldah\u00edv\u00e1s bemutat\u00e1sa a kliensb\u0151l OData v4 protokollt haszn\u00e1lva.  [7-10]<ul> <li>csak lek\u00e9rdez\u00e9s 7</li> <li>m\u00f3dos\u00edt\u00e1s vagy hozz\u00e1ad\u00e1s vagy t\u00f6rl\u00e9s is +3</li> </ul> </li> </ul>"},{"location":"homework/hw-points/#entity-framework-core","title":"Entity Framework Core","text":"<ul> <li>lesz\u00e1rmaz\u00e1si hierarchia lek\u00e9pez\u00e9se Entity Framework-kel (legal\u00e1bb k\u00e9tszint\u0171, legal\u00e1bb 3 tag\u00fa hierarchia) [3-7]<ul> <li>TPH, a diszkrimin\u00e1tor mez\u0151 testreszab\u00e1s\u00e1val (saj\u00e1t mez\u0151n\u00e9v vagy saj\u00e1t \u00e9rt\u00e9kek) 3</li> <li>TPT-vel 5</li> <li>TPC-vel 7</li> </ul> </li> <li>MS SQL/Azure SQL/LocalDB-t\u0151l elt\u00e9r\u0151 adatb\u00e1ziskiszolg\u00e1l\u00f3 haszn\u00e1lata EF Core-ral (kiv\u00e9ve m\u00e9g: sqlite) [10-12]<ul> <li>Azure Cosmos DB (NoSQL!) 10</li> <li>egy\u00e9b, EF Core t\u00e1mogatott adatb\u00e1zis 5 </li> </ul> </li> <li>saj\u00e1t Code-First konvenci\u00f3 k\u00e9sz\u00edt\u00e9se 5</li> <li>saj\u00e1t t\u00f6bbessz\u00e1mos\u00edt\u00f3 (<code>IPluralizer</code>) - nem kell nyelvtanilag helyesnek lennie [7]</li> <li>automatikus \u00fajrapr\u00f3b\u00e1lkoz\u00e1s be\u00e1ll\u00edt\u00e1sa tranziens adatb\u00e1zishib\u00e1k (pl. connection timeout) ellen [2]</li> <li>Table splitting 5</li> <li>Entity splitting [5]</li> <li>alternat\u00edv kulcs [3-5]<ul> <li>alternat\u00edv kulcs bevezet\u00e9se valamelyik entit\u00e1sban 3</li> <li>m\u00e1s entit\u00e1s kapcsolattal hivatkozik az alternat\u00edv kulcsra +2</li> </ul> </li> <li>adatb\u00e1zis index konfigur\u00e1ci\u00f3ja az EF modellben [3]</li> <li>HiLo els\u0151dleges kulcs alkalmaz\u00e1sa [3]</li> <li>birtokolt t\u00edpus (owned type) haszn\u00e1lata [3]</li> <li>adatbet\u00f6lt\u00e9s (seeding) migr\u00e1ci\u00f3 seg\u00edts\u00e9g\u00e9vel (<code>HasData</code>) [3]</li> <li>\u00e9rt\u00e9kkonverter (value converter) alkalmaz\u00e1sa EF Core lek\u00e9pez\u00e9sben [3-5]<ul> <li>be\u00e9p\u00edtett, vagy k\u00fcls\u0151 komponensb\u0151l sz\u00e1rmaz\u00f3 value converter 3</li> <li>saj\u00e1t value converter 5</li> </ul> </li> <li>t\u00e9rbeli (spatial) adatok kezel\u00e9se EF Core \u00e9s NetTopologySuite seg\u00edts\u00e9g\u00e9vel. Legal\u00e1bb egy spatial oszlop kezel\u00e9se \u00e9s legal\u00e1bb egy spatial m\u0171velet (pl. <code>Contains</code>) alkalmaz\u00e1sa. Nem minden provider t\u00e1mogaja!  [7]</li> <li>id\u0151kezelt (temporal) t\u00e1bl\u00e1k kezel\u00e9se EF Core seg\u00edts\u00e9g\u00e9vel. Legal\u00e1bb egy id\u0151kezelt t\u00e1bla haszn\u00e1lata \u00e9s historikus adat\u00e1nak felhaszn\u00e1l\u00e1sa. Csak SQL Server/LocalDB/Azure SQL provider t\u00e1mogatja! [7]</li> <li>Egy\u00e9b EF Core funkci\u00f3 haszn\u00e1lata, ami nincs a list\u00e1ban [3-10] Gyakorlatvezet\u0151vel el\u0151re egyeztetend\u0151, hogy felker\u00fclj\u00f6n a list\u00e1ra.</li> </ul>"},{"location":"homework/hw-points/#net-reszfunkciok-alkalmazasa","title":".NET r\u00e9szfunkci\u00f3k alkalmaz\u00e1sa","text":"<ul> <li>az EF Core m\u0171k\u00f6d\u0151k\u00e9pess\u00e9g\u00e9t, az adatb\u00e1zis el\u00e9rhet\u0151s\u00e9g\u00e9t jelz\u0151 health check v\u00e9gpont publik\u00e1l\u00e1sa a Microsoft.Extensions.Diagnostics.HealthChecks.EntityFrameworkCore NuGet csomag haszn\u00e1lat\u00e1val [3]</li> <li>kifejez\u00e9sfa (ExpressionTree) \u00e9rtelmez\u00e9se/k\u00e9sz\u00edt\u00e9se/m\u00f3dos\u00edt\u00e1sa az Expression API haszn\u00e1lat\u00e1val [5-20]<ul> <li>pl. sz\u0171r\u00e9s dinamikusan, param\u00e9terb\u0151l \u00e9rkez\u0151 property neve alapj\u00e1n (pl. <code>o =&gt; o.Prop == propNev</code>) 5</li> <li>pl. keres\u00e9s kapcsol\u00f3d\u00f3 kollekci\u00f3ban dinamikusan (pl. <code>o =&gt; o.Coll.Any(e =&gt; e.Prop == propNev)</code>) 10</li> <li>saj\u00e1t LINQ provider - el\u0151zetes egyeztet\u00e9s sz\u00fcks\u00e9ges! 20</li> </ul> </li> <li>explicit k\u00f6lcs\u00f6n\u00f6s kiz\u00e1r\u00e1s helyett ConcurretBag/ConcurrentQueue/ConcurrentStack/ConcurrentDictionary haszn\u00e1lata olyan r\u00e9tegben, ahol p\u00e1rhuzamos hozz\u00e1f\u00e9r\u00e9s val\u00f3ban el\u0151fordul [5]</li> <li>lock-free algoritmus implement\u00e1l\u00e1sa \u00e9s haszn\u00e1lata (k\u00f6nyvt\u00e1ri implement\u00e1ci\u00f3 felhaszn\u00e1l\u00e1sa n\u00e9lk\u00fcl, <code>Interlocked</code> f\u00fcggv\u00e9nyek haszn\u00e1lat\u00e1val) [10]</li> <li>automatiz\u00e1lt (unit vagy integr\u00e1ci\u00f3s) tesztek k\u00e9sz\u00edt\u00e9se  [7-14]<ul> <li>minimum 10 f\u00fcggv\u00e9nyhez/v\u00e9gponthoz 7</li> <li>a unit tesztekben a mock objektumok injekt\u00e1l\u00e1sa +3</li> <li>EF Core mem\u00f3ria-adatb\u00e1zis vagy sqlite (vagy in-memory sqlite) haszn\u00e1lata tesztel\u00e9shez +4</li> </ul> </li> <li>XML valid\u00e1l\u00e1s, alkalmazkod\u00e1s megl\u00e9v\u0151 XML form\u00e1tumhoz pl. publikus webes s\u00e9m\u00e1hoz (RSS, opml) [7]</li> <li>Optimista konkurenciakezel\u00e9s [5-15]<ul> <li>\u00fctk\u00f6z\u00e9sdetekt\u00e1l\u00e1s \u00e9s automatikus \u00fctk\u00f6z\u00e9sfelold\u00e1s 5</li> <li>\u00fctk\u00f6z\u00e9sfelold\u00e1s a felhaszn\u00e1l\u00f3 d\u00f6nt\u00e9se alapj\u00e1n: client wins vagy store wins felold\u00e1ssal. \u00dctk\u00f6z\u00e9s eset\u00e9n a felhaszn\u00e1l\u00f3t\u00f3l megk\u00e9rdezz\u00fck, hogy a k\u00e9t adatverzi\u00f3 k\u00f6z\u00fcl melyik legyen mentve az adatb\u00e1zisba: az aktu\u00e1lis felhaszn\u00e1l\u00f3\u00e9, a m\u00e1sik felhaszn\u00e1l\u00f3\u00e9. Bemutat\u00e1skor szeml\u00e9ltet\u00e9s egy p\u00e9ld\u00e1n kereszt\u00fcl. 10</li> <li>a felhaszn\u00e1l\u00f3 az eredeti \u00e9rt\u00e9ket is v\u00e1laszthatja (a m\u00f3dos\u00edt\u00e1sok el\u0151tti \u00e9rt\u00e9k vissza\u00e1ll\u00edt\u00e1sa) +5</li> </ul> </li> <li>pesszimista konkurenciakezel\u00e9s (adatb\u00e1zisobjektumok z\u00e1rol\u00e1sa) bizonyos entit\u00e1sok/funkci\u00f3k eset\u00e9n, nem kell a teljes alkalmaz\u00e1sban alkalmazni. Bemutat\u00e1skor szeml\u00e9ltet\u00e9s egy p\u00e9ld\u00e1n kereszt\u00fcl. [10]</li> <li>diagnosztika be\u00e9p\u00edtett vagy k\u00fcls\u0151 komponens seg\u00edts\u00e9g\u00e9vel [5-11]<ul> <li>legal\u00e1bb k\u00e9t c\u00e9lba, amib\u0151l legal\u00e1bb egy perzisztens (pl. f\u00e1jl vagy adatb\u00e1zis vagy k\u00fcls\u0151 szolg\u00e1ltat\u00e1s) 5</li> <li>strukt\u00far\u00e1lt napl\u00f3z\u00e1s (structured logging) +2</li> <li>f\u00e1jl c\u00e9l eset\u00e9n rolling log (minden napon/h\u00e9ten/10 MB-onk\u00e9nt \u00faj napl\u00f3f\u00e1jl) +2</li> <li>az egyik c\u00e9l egy k\u00fcls\u0151 napl\u00f3z\u00f3 szolg\u00e1ltat\u00e1s (pl. Azure Application Insights) +2</li> <li>Param\u00e9terezett nagy teljes\u00edtm\u00e9ny\u0171 k\u00f3dgener\u00e1lt napl\u00f3z\u00e1s haszn\u00e1lata legal\u00e1bb 2 helyen. +2</li> </ul> </li> <li>\u00e1th\u00edv\u00e1s nem fel\u00fcgyelt k\u00f6rnyezetbe (pl. nat\u00edv Win32, nat\u00edv linux) [7-12]<ul> <li>legal\u00e1bb egy nem egyszer\u0171 t\u00edpus \u00e1tad\u00e1sa/\u00e1tv\u00e9tele param\u00e9terk\u00e9nt 7</li> <li>saj\u00e1t nat\u00edv k\u00f3d haszn\u00e1lata, \u00f6sszetett t\u00edpus \u00e1tad\u00e1s\u00e1val 12</li> </ul> </li> <li>k\u00fcls\u0151 komponens haszn\u00e1lata DTO-k inicializ\u00e1l\u00e1s\u00e1ra [3]<ul> <li>Object mapper, pl. AutoMapper 3</li> <li>Explicit k\u00f3dgener\u00e1l\u00f3, pl. MappingGenerator (ingyenes v\u00e1ltozat) 3</li> </ul> </li> <li>logikai t\u00f6rl\u00e9s (soft delete) megval\u00f3s\u00edt\u00e1sa. A logikailag t\u00f6r\u00f6lt elemek alap\u00e9rtelmez\u00e9sben nem lek\u00e9rdezhet\u0151ek - ezen sz\u0171r\u00e9s megval\u00f3s\u00edt\u00e1sa glob\u00e1lis sz\u0171r\u0151kkel (Global Query Filter) [5]</li> <li>h\u00e1tt\u00e9rm\u0171velet(ek) megval\u00f3s\u00edt\u00e1sa [5-7]<ul> <li><code>IHostedService</code> / <code>BackgroundService</code> haszn\u00e1lat\u00e1val [5]</li> <li>nem be\u00e9p\u00edtett, k\u00fcls\u0151 h\u00e1tt\u00e9rfolyamat komponenssel, pl. Quartz.NET, Hangfire [7]</li> </ul> </li> <li>nem nullozhat\u00f3 referencia t\u00edpusok (NRT) k\u00e9nyszer\u00edt\u00e9se a nullable context bekapcsol\u00e1s\u00e1val minden szerveroldali projektre \u00e9s minden nullable context s\u00e9rt\u00e9s figyelmeztet\u00e9s hibak\u00e9nt kezel\u00e9se. Nullable context kikapcsol\u00e1sa projekten bel\u00fcl csak indokolt esetekben. [3]</li> <li>Entit\u00e1s specifikus els\u0151dleges kulcs t\u00edpusok haszn\u00e1lata (<code>entityA.Id = entityB.Id</code> ford\u00edt\u00e1si hiba, ha a k\u00e9t enti\u00e1s t\u00edpusa elt\u00e9r). A kliens oldalon, illetve a kontroller f\u00fcggv\u00e9nyek fejl\u00e9c\u00e9ben (pl. bemenetk\u00e9nt) nem kell, hogy megjelenjenek ezek a t\u00edpusok, csak a kontroller r\u00e9tegt\u0151l lefel\u00e9 (EF szinten is). Seg\u00e9dk\u00f6nyvt\u00e1r. [10]</li> <li>Szoftver funkci\u00f3inak ki/bekapcsolhat\u00f3s\u00e1ga FeatureFlagek kezel\u00e9s\u00e9vel [5-8] pl.: https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/feature-flags<ul> <li>config alap\u00fa 5</li> <li>felhaszn\u00e1l\u00f3i fel\u00fcletr\u0151l \u00e1ll\u00edthat\u00f3 +3</li> </ul> </li> <li>Szerver oldalon el\u0151fordul\u00f3 sz\u00f6veges er\u0151forr\u00e1sok lokaliz\u00e1l\u00e1sa, amik a kliensre eljuthatnak (pl.: hiba\u00fczenetek) [5]</li> </ul>"},{"location":"homework/hw-points/#kiegeszito-kapcsolodo-technologiak-alkalmazasa","title":"Kieg\u00e9sz\u00edt\u0151, kapcsol\u00f3d\u00f3 technol\u00f3gi\u00e1k alkalmaz\u00e1sa","text":"<ul> <li>Rx.NET haszn\u00e1lata (dokument\u00e1ci\u00f3) [7-10]<ul> <li>n\u00e9h\u00e1ny alap Rx oper\u00e1tor haszn\u00e1lata 7</li> <li>k\u00e9t k\u00fcls\u0151 adatforr\u00e1s integr\u00e1l\u00e1sa 10</li> </ul> </li> <li>F# modul k\u00e9sz\u00edt\u00e9se \u00e9s megh\u00edv\u00e1sa. Legal\u00e1bb az egyik legyen benne ezek k\u00f6z\u00fcl: pattern matching, async, magasabb rend\u0171 f\u00fcggv\u00e9ny [7]</li> <li>k\u00fcls\u0151 oszt\u00e1lyk\u00f6nyvt\u00e1r haszn\u00e1lata szerver oldalon. A k\u00fcls\u0151 komponens \u00e1ltal megval\u00f3s\u00edtott funkcionalit\u00e1s\u00e9rt, k\u00e9pess\u00e9g\u00e9rt tov\u00e1bbi pontsz\u00e1m nem adhat\u00f3. Nem sz\u00e1m\u00edt ide a projekt gener\u00e1l\u00e1sakor automatikusan beker\u00fcl\u0151, illetve a Microsoft \u00e1ltal k\u00e9sz\u00edtett, az alaptechnol\u00f3gi\u00e1k f\u00fcgg\u0151s\u00e9geit jelent\u0151 NuGet csomagok [7]</li> <li>platformf\u00fcggetlen k\u00f3db\u00e1zis\u00fa szerveralkalmaz\u00e1s k\u00e9sz\u00edt\u00e9se \u00e9s bemutat\u00e1sa legal\u00e1bb 2 oper\u00e1ci\u00f3s rendszeren az al\u00e1bbiak k\u00f6z\u00fcl: Windows, Linux, Mac, ARM alap\u00fa OS (pl. Raspberry Pi OS). K\u00f6zvetlen futtat\u00e1s fogadhat\u00f3 csak el, pl. kont\u00e9nerb\u0151l val\u00f3 futtat\u00e1s nem (arra van k\u00fcl\u00f6n jogc\u00edm). [3]</li> <li>NET Compiler platform (Roslyn) Diagnostic Analyzer [3-7]<ul> <li>egyszer\u0171 analyzer, pl. property n\u00e9v konvenci\u00f3k ellen\u0151rz\u00e9se 3</li> <li>bonyolultabb analyzer \u00e9s k\u00f3d fix is, pl. kiemel\u00e9s met\u00f3dusba 7</li> </ul> </li> <li>CQRS \u00e9s Medi\u00e1tor tervez\u00e9si minta haszn\u00e1lata a teljes alkalmaz\u00e1sban (MediatR) [5-11]<ul> <li>Commandok \u00e9s Queryk sz\u00e9tv\u00e1laszt\u00e1sa \u00e9s laz\u00e1n csatol\u00e1sa medi\u00e1torral 5</li> <li>Domain esem\u00e9nyek haszn\u00e1lata +3</li> <li>MediatR behavior pipeline kiterjeszt\u00e9se  +3</li> </ul> </li> </ul>"},{"location":"information/contributing/","title":"Hozz\u00e1j\u00e1rul\u00e1s az anyaghoz","text":"<p>Az anyag terjedelm\u00e9b\u0151l adand\u00f3an apr\u00f3bb hib\u00e1k esetenk\u00e9nt hi\u00e1nyoss\u00e1gok jelentkezhetnek a laborokban. Ha egy ilyennel tal\u00e1lkozol \u00e9s \u00fagy d\u00f6ntesz szeretn\u00e9l seg\u00edteni hallgat\u00f3t\u00e1rsaidnak, azt a k\u00f6vetkez\u0151kben le\u00edrtak alapj\u00e1n tudod megtenni.</p> <p>Plusz pont jegyzet jav\u00edt\u00e1s\u00e9rt</p> <p>M\u00e1s tant\u00e1rgyak mint\u00e1j\u00e1ra itt is szeretn\u00e9nk plusz pontot adni a jegyzet open-source hozz\u00e1j\u00e1rul\u00e1sai\u00e9rt. Akik a t\u00e1rgyat jelenleg hallgatj\u00e1k, pontokat kaphatnak hozz\u00e1j\u00e1rul\u00e1saik\u00e9rrt.</p> <p>A f\u00e9l\u00e9v sor\u00e1n max 3 db plusz pontot lehet szerezni fejenk\u00e9nt olyan jav\u00edt\u00e1sok\u00e9rt, amik a trivi\u00e1lis 1-2 bet\u0171 elg\u00e9pel\u00e9sen t\u00fal \u00e9rdemben jav\u00edtanak a githubon tal\u00e1lhat\u00f3 labor jegyzetek min\u0151s\u00e9g\u00e9n. Pl.: jelent\u0151s mennyis\u00e9g\u0171 elg\u00e9pel\u00e9s jav\u00edt\u00e1sa, egy\u00e9rtelm\u0171s\u00edt\u00e9sek, illusztr\u00e1ci\u00f3k kieg\u00e9sz\u00edt\u00e9sek k\u00e9sz\u00edt\u00e9se vagy ak\u00e1r egy teljes kieg\u00e9sz\u00edt\u0151 jegyzet \u00edr\u00e1sa  (term\u00e9szetesen nem azonos pont\u00e9rt\u00e9kkel).</p> <p>Persze a pont n\u00e9lk\u00fcl az 1-1 bet\u0171s elg\u00e9pel\u00e9seket is sz\u00edvesen fogadjuk, ami bemeleg\u00edt\u00e9snek is t\u00f6k\u00e9letes.</p>"},{"location":"information/contributing/#hibak-jelzese","title":"Hib\u00e1k jelz\u00e9se","text":"<p>Amennyiben hib\u00e1t tal\u00e1lsz az anyagban, vagy szeretn\u00e9d b\u0151v\u00edteni, de nem \u00e1ll m\u00f3dodban jav\u00edtani, nyithatsz egy issue-t amiben le\u00edrod a hib\u00e1t.</p> <ol> <li>N\u00e9zd meg, hogy valaki nem jelezte-e, amit szeretn\u00e9l.     Gyakran m\u00e1r l\u00e9tez\u0151 probl\u00e9m\u00e1kat tal\u00e1lnak, amire m\u00e1r van pull request,     \u00edgy miel\u0151tt b\u00e1rmit tenn\u00e9l n\u00e9zd meg valaki nem el\u0151z\u00f6tt-e meg</li> <li>Az issues tabon a new issue gombbal hozz l\u00e9tre egy \u00faj issue-t.     </li> <li>L\u00e1sd el a megfelel\u0151 c\u00edmk\u00e9kkel<ol> <li>A labor t\u00edpusa (<code>android</code> az androidos laborokn\u00e1l \u00e9s <code>web</code> a webes laborokn\u00e1l)</li> <li>A hiba t\u00edpusa (<code>clarification</code>, <code>typo</code>, <code>illustration</code> vagy <code>notes</code>)</li> </ol> </li> <li>\u00cdrd le, hogy mit k\u00e9ne tartalmaznia a jav\u00edt\u00e1snak</li> </ol> <p>Tip</p> <p>Az c\u00edme legyen r\u00f6vid \u00e9s l\u00e9nyegret\u00f6r\u0151, pl.: <code>Megfogalmaz\u00e1s pontos\u00edt\u00e1sa a 4. laborban</code> vagy <code>A 6. laborban a le\u00edrt k\u00f3d hib\u00e1san m\u0171k\u00f6dik Android 12-n</code></p> <p>A issue descriptionj\u00e9ben pedig fejtsd ki, hol tal\u00e1lhat\u00f3 a hi\u00e1nyoss\u00e1g, illetve ha van r\u00e1 \u00f6tleted, hogy lehetne orvosolni ezt. Ha ezeken t\u00fal m\u00e9g screenshotot is tudsz mell\u00e9kelni, az nagyban megseg\u00edti a probl\u00e9ma mihamarabbi jav\u00edt\u00e1s\u00e1t.</p> <p>Warning</p> <p>A github issues nem a laborfeladatok megold\u00e1s\u00e1val kapcsolatos probl\u00e9m\u00e1k helye, \u00edgy a \"Nem tudom megoldani hogy az \u00e9rtes\u00edt\u00e9s meg\u00e9rkezzen\" jelleg\u0171 probl\u00e9m\u00e1kat ne itt jelezz\u00e9tek, erre vannak a laboralkalmak.</p>"},{"location":"information/contributing/#valtoztatasok-javaslasa","title":"V\u00e1ltoztat\u00e1sok javasl\u00e1sa","text":"<p>Amennyiben a hozz\u00e1j\u00e1rul\u00e1sod meg tudod val\u00f3s\u00edtani ind\u00edts pull requestet</p> <ol> <li> <p>Forkold a repository-t a Githubon jobb fels\u0151 sarokban tal\u00e1lhat\u00f3 gombbal     </p> </li> <li> <p>V\u00e9gezd el a v\u00e1ltoztat\u00e1sokat.</p> <ol> <li> <p>Hozz l\u00e9tre egy branchet a saj\u00e1t forkodon, amin a v\u00e1ltoztat\u00e1sokat el fogod v\u00e9gezni.</p> </li> <li> <p>Ezen a branchen k\u00e9sz\u00edtsd el a jav\u00edt\u00e1sokat</p> </li> <li> <p>Ellen\u0151rizd, hogy ne ker\u00fclj\u00f6n bele a commitba olyan file, amit az editor gener\u00e1lt (pl.: <code>.idea</code> mappa) illetve olyan file aminek nem k\u00e9ne kiker\u00fclnie, pl.: Github Private Access Token</p> </li> <li> <p>Ha k\u00e9sz vagy ind\u00edts egy pull requestet a jegyzeteket tartalmaz\u00f3 rep\u00f3 f\u0151 \u00e1g\u00e1ra.</p> </li> <li> <p>A le\u00edr\u00e1sban r\u00e9szletezd v\u00e1ltoztat\u00e1sok ok\u00e1t.     Ne felejtsd el bele\u00edrni a NEPTUN k\u00f3dod a le\u00edr\u00e1sba, mert \u00edgy fogjuk tudni megadni a pontokat.</p> </li> </ol> </li> <li> <p>Valaki, akinek hozz\u00e1f\u00e9r\u00e9se van a repositoryhoz, ellen\u0151rzi a v\u00e1ltoztat\u00e1sok sz\u00fcks\u00e9gess\u00e9g\u00e9t, \u00e9s elb\u00edr\u00e1lja, hogy val\u00f3ban beker\u00fclhet az anyagba.</p> </li> <li>A v\u00e1ltoztat\u00e1sokra review-t ind\u00edtunk \u00e9s ha kell m\u00f3dos\u00edt\u00e1sokat fogunk k\u00e9rni.</li> <li>Ha minden k\u00e9rt v\u00e1ltoztat\u00e1s megt\u00f6rt\u00e9nt, a hozz\u00e1j\u00e1rul\u00e1sod beleker\u00fcl az anyagba.</li> </ol>"},{"location":"information/contributing/#code-style","title":"Code style","text":"<ul> <li>Markdown: Mivel az alap spec nem mindig a legtiszt\u00e1bban \u00e9rthet\u0151, a markdownlint szab\u00e1lyai alapj\u00e1n, az n\u00e9h\u00e1ny kiv\u00e9tel\u00e9vel. Ezeket a <code>.markdownlint.yaml</code>-ben tal\u00e1lod, ha VSCode-ot haszn\u00e1lsz automatikusan alkalmazza \u0151ket az editor \u00e9s jelzi ha nem megfelel\u0151 amit \u00edrsz.</li> </ul> <p>Ezek a st\u00edlusok a t\u00e1rgyban aj\u00e1nlott editorokban k\u00f6nnyen be\u00e1ll\u00edthat\u00f3ak.</p>"},{"location":"information/contributing/#vscode","title":"VSCode","text":"<p>Aj\u00e1nlott extension\u00f6k:</p> <ul> <li><code>yzhang.markdown-all-in-one</code>: MD szinkroniz\u00e1lt live preview</li> <li><code>DavidAnson.vscode-markdownlint</code>: MD form\u00e1z\u00e1s, szab\u00e1lyok stb.</li> <li>Prettier: HTML+CSS form\u00e1z\u00f3</li> <li>Error Lens: Kiemeli a hib\u00e1kat hogy gyorsabben megtal\u00e1ljuk \u0151ket</li> <li>Paste Image: egyszer\u0171s\u00edti a k\u00e9pek beilleszt\u00e9s\u00e9t markdownba</li> </ul> <p>Az editor be\u00e1ll\u00edt\u00e1s\u00e1hoz nyisd meg a repo-t a gy\u00f6ker\u00e9ben VSCode-al. A VSCode fel fogja aj\u00e1nlani a k\u00e9t markdown extension-t.</p> <p></p> <p>Ha ez megt\u00f6rt\u00e9nt, nyiss meg egy markdown dokumentumot, \u00e9s haszn\u00e1ld a Ctrl+Shift+P shortcutot, a command palette megnyit\u00e1s\u00e1hoz.</p> <p>Tip</p> <p>A command palette a VSCode parancsaihoz ny\u00fajt hozz\u00e1f\u00e9r\u00e9st, autocompleteeli a parancsokat \u00e9s egy minim\u00e1lis GUI-t is biztos\u00edt.</p> <p>A command palette-be keress\u00fck meg a <code>Format Document With...</code> men\u00fcpontot \u00e9s v\u00e1lasszuk ki. Ekkor egy almen\u00fcbe dob az editor \u00e9s kiv\u00e1laszthatjuk hogy melyik form\u00e1z\u00f3val form\u00e1zzuk a MD dokumentumokat. Legalul lesz egy <code>Configure Default Formatter</code>, v\u00e1lasszuk ezt. Ezut\u00e1n v\u00e1lasszuk a <code>markdownlint</code> extensiont, \u00e9s k\u00e9szen vagyunk.</p> <p>Megfelel\u0151 formatter kiv\u00e1laszt\u00e1sa</p> <p>Ne v\u00e1laszd ki a prettiert formatterk\u00e9nt, mert elt\u00f6ri a sz\u00f6vegbubor\u00e9kokat.</p> <p>Ezen fel\u00fcl \u00e9rdemes lehet bekapcsolni a ment\u00e9s el\u0151tti form\u00e1z\u00e1st.</p> <p>A Ctrl+, shortcuttal megnyitjuk a be\u00e1ll\u00edt\u00e1sokat, \u00e9s r\u00e1keres\u00fcnk arra, hogy format on save. Itt kipip\u00e1ljuk a checkboxot \u00e9s k\u00e9szen vagyunk.</p> <p>Ha ehhez nem lenne t\u00fcrelmed, itt a json amit a <code>settings.json</code>-ba illesztve be\u00e1ll\u00edt\u00f3dik minden.</p> <pre><code>{\n  \"[markdown]\": {\n    \"editor.defaultFormatter\": \"DavidAnson.vscode-markdownlint\",\n    \"editor.formatOnSave\": true\n  }\n}\n</code></pre>"},{"location":"information/preface/","title":"Tudnival\u00f3k","text":""},{"location":"information/preface/#a-jegyzet-celja-es-celkozonsege","title":"A jegyzet c\u00e9lja \u00e9s c\u00e9lk\u00f6z\u00f6ns\u00e9ge","text":"<p>Ezen jegyzet els\u0151dlegesen a BME Villamosm\u00e9rn\u00f6ki \u00e9s Informatikai Kar\u00e1n oktatott Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgyhoz k\u00e9sz\u00fclt, c\u00e9lja, hogy seg\u00edts\u00e9get ny\u00fajtson egyr\u00e9szt a gyakorlatvezet\u0151nek a gyakorlat megtart\u00e1s\u00e1ban, m\u00e1sr\u00e9szt a kurzus hallgat\u00f3inak a gyakorlat otthoni ut\u00f3lagos megism\u00e9tl\u00e9s\u00e9hez, a tanult ismeretek \u00e1tism\u00e9tl\u00e9s\u00e9hez.</p> <p>Ebb\u0151l kifoly\u00f3lag nem tekinthet\u0151 egy teljesen kezd\u0151 szint\u0171 bevezet\u0151 C# tank\u00f6nyvnek, hiszen er\u0151teljesen \u00e9p\u00edt m\u00e1s kari t\u00e1rgyak (pl. Szoftvertechnik\u00e1k, Adatb\u00e1zisok) \u00e1ltal lefedett ismeretekre, de m\u00e9g ink\u00e1bb a Szoftverfejleszt\u00e9s .NET platformra c\u00edm\u0171 t\u00e1rgy el\u0151ad\u00e1saira.</p> <p>A felt\u00e9telezett el\u0151ismeretek:</p> <ul> <li>C# \u00e9s objektumorient\u00e1lt nyelvi alapok<ul> <li>oper\u00e1torok, v\u00e1ltoz\u00f3k, t\u00f6mb\u00f6k, strukt\u00far\u00e1k, f\u00fcggv\u00e9nyek fogalma</li> <li>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s \u00e9s f\u00fcggv\u00e9nyv\u00e1ltozatok</li> <li>alapvet\u0151 mem\u00f3riakezel\u00e9s (heap, stack), mutat\u00f3k fogalma, \u00e9rt\u00e9k \u00e9s referencia t\u00edpusok</li> <li>alapvet\u0151 vez\u00e9rl\u00e9si szerkezetek (ciklus, el\u00e1gaz\u00e1s, stb.), \u00e9rt\u00e9k- \u00e9s referencia szerinti param\u00e9ter\u00e1tad\u00e1s, rekurzi\u00f3</li> <li>oszt\u00e1ly, oszt\u00e1lyp\u00e9ld\u00e1ny fogalma, static, <code>new</code> oper\u00e1tor, oszt\u00e1ly szint\u0171 v\u00e1ltoz\u00f3k, generikus t\u00edpusok</li> <li>lesz\u00e1rmaz\u00e1s, virtu\u00e1lis tagf\u00fcggv\u00e9nyek</li> <li>C# esem\u00e9ny, delegate t\u00edpusok \u00e9s delegate p\u00e9ld\u00e1nyok</li> <li>Visual Studio haszn\u00e1lat\u00e1nak alapjai</li> <li>oper\u00e1ci\u00f3s rendszer kapcsolatok, folyamatok, sz\u00e1lak, parancssor, parancssori argumentumok, k\u00f6rnyezeti v\u00e1ltoz\u00f3k</li> </ul> </li> <li>SQL nyelvi alapok (SELECT, UPDATE, INSERT, DELETE utas\u00edt\u00e1sok), valamint alapvet\u0151 rel\u00e1ci\u00f3s adatmodell ismeretek (t\u00e1bl\u00e1k, els\u0151dleges- \u00e9s idegen kulcsok)</li> </ul> <p>A fentiek elsaj\u00e1t\u00edt\u00e1s\u00e1hoz seg\u00edts\u00e9get ny\u00fajthatnak Reiter Istv\u00e1n ingyenesen let\u00f6lthet\u0151 k\u00f6nyvei.</p> <p>A sz\u00f6vegben megtal\u00e1lhat\u00f3k a gyakorlatvezet\u0151knek sz\u00f3l\u00f3 kit\u00e9telek (\u201eR\u00f6viden mondjuk el\u2026\", \u201eMutassuk meg\u2026\", stb.). Ezeket mezei olvas\u00f3k\u00e9nt \u00e9rdemes figyelmen k\u00edv\u00fcl hagyni, illetve sz\u00fcks\u00e9g eset\u00e9n a kapcsol\u00f3d\u00f3 elm\u00e9leti ismereteket az el\u0151ad\u00e1sanyagb\u00f3l \u00e1tism\u00e9telni.</p>"},{"location":"information/preface/#a-jegyzet-naprakeszsege","title":"A jegyzet naprak\u00e9szs\u00e9ge","text":"<p>Az anyag gerinc\u00e9t ad\u00f3 .NET Core / .NET 5,6 platform jelenleg igen gyors \u00fctemben fejl\u0151dik. A .NET Core 1.0-s verzi\u00f3 \u00f3ta a k\u00e9sz\u00edt\u0151k t\u00f6rekednek a visszafel\u00e9 kompatibilit\u00e1sra, azonban az eszk\u00f6zk\u00e9szlet \u00e9s a korszer\u0171nek \u00e9s aj\u00e1nlottnak tekinthet\u0151 m\u00f3dszerek folyamatosan v\u00e1ltoznak, finomodnak.</p> <p>A jegyzet els\u0151dlegesen az al\u00e1bbi technol\u00f3giai verzi\u00f3khoz k\u00e9sz\u00fclt:</p> <ul> <li>C# 12</li> <li>.NET 8</li> <li>ASP.NET Core 8</li> <li>Visual Studio 2022</li> </ul> <p>Ahogyan a fenti verzi\u00f3k v\u00e1ltoznak, \u00fagy avulhatnak el a jegyzetben mutatott elj\u00e1r\u00e1sok.</p>"},{"location":"information/preface/#szoftverkornyezet","title":"Szoftverk\u00f6rnyezet","text":"<p>A gyakorlatok az al\u00e1bbi szoftverekb\u0151l \u00e1ll\u00f3 k\u00f6rnyezethez k\u00e9sz\u00fcltek:</p> <ul> <li>Windows 11 oper\u00e1ci\u00f3s rendszer</li> <li>Visual Studio 2022 (az ingyenes Community verzi\u00f3 el\u00e9g) az al\u00e1bbi workloadokkal:<ul> <li>.NET desktop development</li> <li>Data storage and processing</li> <li>ASP.NET and web development</li> <li>Azure Development</li> </ul> </li> <li>Telerik Fiddler Classic</li> <li>Postman</li> </ul> <p>A .NET (kor\u00e1bban .NET Core) sz\u00e9lesk\u00f6r\u0171 platformt\u00e1mogat\u00e1sa miatt bizonyos nem Windows platformokon is elv\u00e9gezhet\u0151k a gyakorlatok Visual Studio helyett Visual Studio Code haszn\u00e1lat\u00e1val - azonban a gyakorlatok sz\u00f6vege a Visual Studio haszn\u00e1lat\u00e1t felt\u00e9telezi.</p>"},{"location":"information/preface/#kodreszletek-valtozaskovetese","title":"K\u00f3dr\u00e9szletek v\u00e1ltoz\u00e1sk\u00f6vet\u00e9se","text":"<p>Az egyes gyakorlatok sor\u00e1n gyakori eset, hogy a C# k\u00f3d egy r\u00e9sz\u00e9t tov\u00e1bbfejlesztj\u00fck, megv\u00e1ltoztatjuk. Ilyen esetben a v\u00e1ltoz\u00f3 sorokat a jegyzetben kiemelt h\u00e1tt\u00e9rrel rendelkeznek. A t\u00f6r\u00f6lt k\u00f3dr\u00e9szleteket (amennyiben van seg\u00edti a meg\u00e9rt\u00e9st) kommentez\u00e9ssel jelezz\u00fck. Jel\u00f6lj\u00fck m\u00e9g a megl\u00e9v\u0151, de a jegyzetben nem megjelen\u00edtett k\u00f3dr\u00e9szleteket komment \u00e9s ... (<code>//...</code>) jellel.</p> <pre><code>using System; //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\nusing static System.Console; //ez \u00faj k\u00f3dsor\n\n//... megl\u00e9v\u0151 k\u00f3dr\u00e9szlet az el\u0151z\u0151 feladatokb\u00f3l\n\nforeach (var dog in dogs)    //ez egy kor\u00e1bban megl\u00e9v\u0151 k\u00f3dsor, v\u00e1ltozatlan\n  /* Console.*/WriteLine(dog); //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n\n/* Console.*/ReadLine();     //ez a sor megv\u00e1ltozott, az elej\u00e9r\u0151l k\u00f3d t\u00f6rl\u0151d\u00f6tt\n</code></pre> <p>JSON kommentek</p> <p>A JSON form\u00e1tum alap\u00e9rtelmez\u00e9sben (RFC szerint) nem t\u00e1mogatja a kommenteket, \u00edgy ha JSON k\u00f3dr\u00e9szletet m\u00e1solunk, gy\u0151z\u0151dj\u00fcnk meg arr\u00f3l, hogy nem maradt-e a beillesztett k\u00f3dban komment, mert probl\u00e9m\u00e1t okozhat.</p>"},{"location":"seminar/01-csharp1/chapter1/","title":"C# alapok, szintaxis","text":"<p>C\u00e9lunk, hogy a hallgat\u00f3k legal\u00e1bb r\u00e9szben meg\u00e9rts\u00e9k \u00e9s r\u00e1\u00e9rezzenek a C# szintaktik\u00e1j\u00e1ra, megismerkedjenek alapvet\u0151 nyelvi elemekkel \u00e9s konstrukci\u00f3kkal.</p>"},{"location":"seminar/01-csharp1/chapter1/#hello-c","title":"Hello C#!","text":"<p>A Visual Studio ind\u00edt\u00f3ablak\u00e1ban v\u00e1lasszuk a <code>Create a new project</code> opci\u00f3t. Magyar\u00e1zzuk el, hogy van lehet\u0151s\u00e9g\u00fcnk el\u0151re gy\u00e1rtott sablonokb\u00f3l l\u00e9trehozni projekteket, illetve hogy</p> <ul> <li>egy C# projekt egy szerelv\u00e9nny\u00e9 fordul (.dll, .exe).</li> <li>a Solution dolga, hogy logikailag \u00f6sszefogja a Project-eket (t\u00f6bb-t\u00f6bbes kapcsolatban vannak).</li> <li>a projektek k\u00f6z\u00f6tt referenci\u00e1kat adhatunk m\u00e1sik projektekre \u00fagy, hogy a ford\u00edt\u00e1si mechanizmus figyelembe veszi a referenci\u00e1kat \u00e9s sz\u00fcks\u00e9g eset\u00e9n \u00fajraford\u00edtja a szerelv\u00e9nyeket.</li> <li>a projektek hivatkozhatnak k\u00fcls\u0151 forr\u00e1sb\u00f3l sz\u00e1rmaz\u00f3 szerelv\u00e9nyekre is NuGet csomagok form\u00e1j\u00e1ban. A NuGet egy egys\u00e9ges m\u00f3dszer szerelv\u00e9nyeink terjeszt\u00e9s\u00e9re.</li> </ul> <p>Hozzunk l\u00e9tre egy \u00faj C# Console Application-t! Ehhez keress\u00fck ki a sablonok k\u00f6z\u00fcl a Console App nev\u0171t (ne a .NET Framework-\u00f6set). A neve legyen HelloCSharp.</p> <p>New Project dialogusablak keres\u0151</p> <p>A kikeres\u00e9shez haszn\u00e1lhatjuk fel\u00fcl a sz\u00f6vegdobozos sz\u0171r\u0151t, illetve a leg\u00f6rd\u00fcl\u0151 list\u00e1s sz\u0171r\u0151ket is (Nyelv: C#, Platform: Windows, Projektt\u00edpus: Console)</p> <p>A sablon konfigur\u00e1ci\u00f3j\u00e1n\u00e1l adjunk meg egy olyan helyet, ahov\u00e1 van \u00edr\u00e1si jogunk. A Place solution and project in the same directory opci\u00f3t kapcsoljuk be, \u00edgy nem fog l\u00e9trej\u00f6nni egy felesleges mappa a k\u00f6nyvt\u00e1rszerkezetben. A .NET verzi\u00f3t \u00e1ll\u00edtsuk .NET 8-ra.</p> <p>\u00c9szrevehetj\u00fck, hogy az alkalmaz\u00e1s sablonok k\u00f6z\u00f6tt sima \u00e9s (.NET Framework) jel\u00f6l\u00e9s\u0171ek is vannak. A sim\u00e1k alapvet\u0151en a modernebb .NET Core/.NET 5-8 platformot c\u00e9lozz\u00e1k, a .NET Framework ezekhez k\u00e9pest egy r\u00e9gebbi platform.</p> <ul> <li>.NET Core: a .NET Framework modulariz\u00e1lt, moderniz\u00e1lt, cross-platform \u00e9s ny\u00edlt forr\u00e1sk\u00f3d\u00fa megval\u00f3s\u00edt\u00e1sa. Kisebb NuGet csomagokban \u00e9rhet\u0151 el a teljes .NET Framework funkcionalit\u00e1sa (Collections, Reflection, XML feldolgoz\u00e1s, stb.).</li> <li>.NET Framework: a \u201eklasszikus\u201d, teljes\u00e9rt\u00e9k\u0171 .NET keretrendszer, out-of-the-box t\u00e1mogatja a legelterjedtebb alkalmaz\u00e1sfejleszt\u00e9si lehet\u0151s\u00e9geket. A .NET Core megjelen\u00e9s\u00e9t k\u00f6vet\u0151en is t\u00e1mogatott, enterprise k\u00f6rnyezetekben haszn\u00e1latos, ugyanis n\u00e9h\u00e1ny enterprise technol\u00f3gia els\u0151dlegesen csak ebben t\u00e1mogatott (pl. szerver oldali WCF). Csak Windows-ra telep\u00edthet\u0151.</li> <li>.NET 5 \u00e9s f\u00f6l\u00f6tte: A .NET Core 3.1 ut\u00e1ni f\u0151 verzi\u00f3i. M\u00e1r elnevez\u00e9s\u00e9ben is jelzi, hogy ez egyben a kor\u00e1bbi .NET Core \u00e9s .NET Framework verzi\u00f3knak is ut\u00f3dja.</li> </ul> <p>Az al\u00e1bbi elemeket ismertethetj\u00fck, miel\u0151tt a k\u00f3d\u00edr\u00e1sba belekezd\u00fcnk:</p> <ul> <li>R\u00f6vid \u00e1ttekint\u00e9s az IDE-r\u0151l: men\u00fcs\u00e1v, Solution Explorer, Properties, Output, Error List ablakok, ablakoz\u00f3rendszer. Mutassuk meg, hogy drag-n-drop m\u0171veletekkel testreszabhat\u00f3 a fel\u00fclet, pl. helyezz\u00fck a Solution Explorert a k\u00e9perny\u0151 bal oldal\u00e1ra. Ha valaki v\u00e9letlen\u00fcl \u00e1trendezi az alap\u00e9rtelmezett elrendez\u00e9st, a menu:Window[Reset Window Layout] lehet\u0151s\u00e9ggel vissza\u00e1ll\u00edthatja.</li> <li>A projekt tulajdons\u00e1gok (menu:jobb klikk[Properties]) oldal\u00e1n az Application f\u00fcl\u00f6n megn\u00e9zhetj\u00fck, hogy az Output type \u00e9rt\u00e9ke hat\u00e1rozza meg, hogy milyen jelleg\u0171 (konzolos, Windows, oszt\u00e1lyk\u00f6nyvt\u00e1r) alkalmaz\u00e1st k\u00e9sz\u00edt\u00fcnk.</li> <li>Mutassuk meg, hogy milyen alapvet\u0151 szerelv\u00e9nyekre adunk referenci\u00e1t a projektben!</li> <li>N\u00e9zz\u00fck meg a <code>Program.cs</code> f\u00e1jl tartalm\u00e1t \u00e9s fussuk \u00e1t a l\u00e1that\u00f3 elemeket!</li> <li>Magyar\u00e1zzuk el a <code>using</code> \u00e9s <code>namespace</code> kulcsszavak jelent\u00e9s\u00e9t, egym\u00e1shoz k\u00e9pesti viszonyukat! A n\u00e9vt\u00e9r \u00e9rt\u00e9ke egy \u00fajonnan l\u00e9trehozott f\u00e1jln\u00e1l alap\u00e9rtelmezetten Projektn\u00e9v.Mappaszerkezet alak\u00fa, \u00e9rdemes konvencion\u00e1lisan ezt k\u00f6vetni. Sok hallgat\u00f3n\u00e1l nem tiszta, hogy hogyan viszonyul egym\u00e1shoz a n\u00e9vt\u00e9r \u00e9s a szerelv\u00e9ny fogalma, ez\u00e9rt pr\u00f3b\u00e1ljuk meg ezt tiszt\u00e1zni!</li> <li>Utaljunk arra, hogy alapvet\u0151en kiz\u00e1r\u00f3lag objektumorient\u00e1ltan tudunk k\u00f3dot \u00edrni, \u00edgy a <code>Program</code> egy oszt\u00e1ly, a <code>Main</code> bel\u00e9p\u00e9si pont pedig egy statikus met\u00f3dus.</li> <li>Besz\u00e9lj\u00fcnk r\u00f6viden a C# elnevez\u00e9si konvenci\u00f3kr\u00f3l! A publikus elemeket (pl. Java-val \u00e9s JavaScripttel ellent\u00e9tben) \u00e9s minden met\u00f3dust \u00f6k\u00f6lszab\u00e1lyk\u00e9nt PascalCasing elnevez\u00e9si konvenci\u00f3 k\u00f6vet, a nem publikus elemekn\u00e9l camelCasing (ezek k\u00f6z\u00fcl vannak kiv\u00e9telek \u00e9s m\u00e1s konvenci\u00f3k, de ez egy gyakori megk\u00f6zel\u00edt\u00e9s).</li> </ul> <p>Eg\u00e9sz\u00edts\u00fck ki a <code>Main</code> met\u00f3dust az al\u00e1bbi k\u00f3dr\u00e9szlettel, k\u00f6zben h\u00edvjuk fel a figyelmet az IntelliSense haszn\u00e1lat\u00e1ra:</p> <pre><code>int a = 5;\nint b = 7;\nConsole.WriteLine(a + b);\nConsole.ReadLine();\n</code></pre> <p>Az IntelliSense-t demonstr\u00e1lhatjuk az al\u00e1bbi m\u00f3don:</p> <ul> <li>A k\u00f3dban b\u00e1rmely logikus helyen haszn\u00e1lhat\u00f3 az IntelliSense a Ctrl+Space billenty\u0171kombin\u00e1ci\u00f3val, ezen k\u00edv\u00fcl alap\u00e9rtelmezetten felugrik k\u00f3d\u00edr\u00e1s k\u00f6zben is.</li> <li>\u00cdrjuk be a <code>Console</code> \u00e9s a <code>.WriteLine()</code> elemeket \u00fagy, hogy g\u00e9pel\u00e9s k\u00f6zben az IntelliSense leg\u00f6rd\u00fcl\u0151b\u0151l v\u00e1lasszuk ki az elemet, majd Tab billenty\u0171vel v\u00e9gleges\u00edts\u00fck a v\u00e1laszt\u00e1st.</li> <li>Haszn\u00e1ljuk a <code>cw</code> code snippetet, amit az IntelliSense is jelez, azaz \u00edrjuk be: <code>cw</code> majd nyomjunk k\u00e9tszer Tab-ot.</li> <li>Ha a <code>Console.ReadLine()</code> helyett <code>Console.Readline()</code>-t \u00edrunk, els\u0151k\u00e9nt az IDE azonnal jav\u00edtja a hib\u00e1t. Ha ezt a jav\u00edt\u00e1st visszavonjuk Ctrl+Z), lehet\u0151s\u00e9g\u00fcnk van a jav\u00edt\u00e1sra a Ctrl+. haszn\u00e1lat\u00e1val: a fejleszt\u0151eszk\u00f6z \u00e9szreveszi, hogy hib\u00e1t v\u00e9tett\u00fcnk, \u00e9s felk\u00edn\u00e1lja a gyakori megold\u00e1sokat.</li> <li>Overload-ok: jel\u00f6lj\u00fck ki a <code>WriteLine</code> h\u00edv\u00e1s nyit\u00f3 z\u00e1r\u00f3jel\u00e9t, \u00e9s \u00edrjuk be ism\u00e9t a nyit\u00f3 z\u00e1r\u00f3jelet. \u00cdgy el\u0151j\u00f6n az overload-ok list\u00e1ja, amik k\u00f6z\u00fcl a megfelel\u0151t a f\u00f6l/le ir\u00e1nybillenty\u0171kkel v\u00e1laszthatjuk ki. Az overload list\u00e1t megnyithatjuk \u00fagy is, hogy a z\u00e1r\u00f3jelben b\u00e1rhova \u00edrunk egy vessz\u0151 karaktert. Az overload azt jelenti, hogy ugyanazzal a f\u00fcggv\u00e9nyn\u00e9vvel t\u00f6bb, k\u00fcl\u00f6nb\u00f6z\u0151 szignat\u00far\u00e1j\u00fa met\u00f3dust is felvehet\u00fcnk, a megfelel\u0151 f\u00fcggv\u00e9ny kiv\u00e1laszt\u00e1sa a megadott param\u00e9terek sz\u00e1ma \u00e9s t\u00edpusa alapj\u00e1n t\u00f6rt\u00e9nik.</li> </ul> <p>Ind\u00edtsuk el az alkalmaz\u00e1st! Ehhez a fent tal\u00e1lhat\u00f3 Start lehet\u0151s\u00e9get haszn\u00e1lhatjuk, de mondjuk el, hogy ez a men\u00fc menu:Debug[Start Debugging] (F5) lehet\u0151s\u00e9ggel ekvivalens.</p> <p>Mutassuk be a <code>for</code> \u00e9s <code>foreach</code> vez\u00e9rl\u00e9si szerkezeteket! A projekt Properties oldal\u00e1n (kbd:[Alt+Enter] a projekt kijel\u00f6l\u00e9se ut\u00e1n) adjunk meg a Debug f\u00fcl\u00f6n a Start Options blokkn\u00e1l legal\u00e1bb \u00f6t tetsz\u0151leges parancssori argumentumot (sz\u00f3k\u00f6zzel elv\u00e1lasztva), pl. kutya alma b\u00e9ka ban\u00e1n l\u00f3.</p> <p> .NET projektbe\u00e1ll\u00edt\u00e1sok</p> <pre><code>for (int i = 0; i &lt; args.Length; i++)\n    Console.WriteLine(args[i]);\n\nforeach (string arg in args)\n    Console.WriteLine(arg);\n\nConsole.ReadLine();\n</code></pre> <p>Ind\u00edtsuk el, \u00e9s gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk.</p>"},{"location":"seminar/01-csharp1/chapter1/#debug","title":"Debug","text":"<p>Rakjunk egy breakpointot (F9), vagy klikkelj\u00fcnk baloldalon a f\u00fcgg\u0151leges s\u00e1von a k\u00f3d sorsz\u00e1ma mellett) a <code>Console.WriteLine(args[i]);</code> sorra, majd ind\u00edtsuk \u00fajra az alkalmaz\u00e1st! Amikor a breakpointon meg\u00e1ll az alkalmaz\u00e1s fut\u00e1sa, a sor s\u00e1rga sz\u00edn\u0171 lesz. Ekkor vigy\u00fck az egeret az <code>i</code>, az <code>args</code> \u00e9s az <code>args.Length</code> elemek fel\u00e9, \u00e9s mutassuk meg, hogy l\u00e1thatjuk az aktu\u00e1lis \u00e9rt\u00e9keiket, komplexebb objektumok eset\u00e9n be tudjuk j\u00e1rni az objektumgr\u00e1fot. A Watch ablakba is \u00edrhatunk kifejez\u00e9seket, \u00e9s megmutathatjuk a Locals ablakot is. F10-zel (vagy a men\u00fcsoron a Step Over elemmel) l\u00e9pj\u00fcnk tov\u00e1bb, n\u00e9zz\u00fck meg, milyen sorrendben \u00e9rt\u00e9kel\u0151dik ki a <code>for</code> ciklus. Az F5-tel tov\u00e1bbengedhetj\u00fck az alkalmaz\u00e1s fut\u00e1s\u00e1t, majd z\u00e1rjuk is be.</p> <p>Mutassuk meg a Conditional Breakpoint haszn\u00e1lat\u00e1t is. Tegy\u00fcnk m\u00e9g egy breakpointot a m\u00e1sik <code>Console.WriteLine</code>-ra is. menu:Jobb eg\u00e9r gomb az els\u0151 breakpointon[Conditions\u2026], majd adjuk meg az al\u00e1bbiakat: Conditional Expression Is true <code>(i == 3)</code>. A m\u00e1sik breakpointon is adjunk meg felt\u00e9telt: Hit Count = 4. Mindk\u00e9t alkalommal a 4. elemen (ban\u00e1n) \u00e1llunk meg. Megjegyezhetj\u00fck, hogy a Conditional Breakpoint haszn\u00e1lat\u00e1val nem \u00e9rdemes mell\u00e9khat\u00e1st okoz\u00f3 m\u0171veleteket megadni, illetve hogy jelent\u0151sen le tudja cs\u00f6kkenteni a debuggol\u00e1s sebess\u00e9g\u00e9t.</p>"},{"location":"seminar/01-csharp1/chapter1/#tulajdonsagok-property-k","title":"Tulajdons\u00e1gok (Property-k)","text":"<p>Hozzuk l\u00e9tre a <code>Person</code> adatoszt\u00e1lyt! Ehhez menu: jobb katt a projekten[Add &gt; Class], a f\u00e1jl neve legyen <code>Person</code> (a kiterjeszt\u00e9st automatikusan hozz\u00e1biggyeszti a Visual Studio, ha nem adjuk meg). .NET-ben nincs megk\u00f6t\u00e9s arra, hogy a k\u00f3dokat tartalmaz\u00f3 f\u00e1jlok \u00e9s az egyes t\u00edpusok sz\u00e1moss\u00e1ga hogyan viszonyul egym\u00e1shoz: lehets\u00e9ges egy k\u00f3df\u00e1jlba is \u00edrnunk a teljes alkalmaz\u00e1s-k\u00f3dot, illetve egy oszt\u00e1lyt is sz\u00e9tdarabolhatunk t\u00f6bb f\u00e1jlra (ehhez a <code>partial</code> kulcssz\u00f3t haszn\u00e1ljuk).</p> <p>A C# tulajdons\u00e1g (property) egy szintaktikai \u00e9des\u00edt\u0151szer, amely egy objektump\u00e9ld\u00e1ny (vagy oszt\u00e1ly) egy explicit (mem\u00f3riabeli) vagy implicit (sz\u00e1rmaztatott vagy indirekt) jellemz\u0151j\u00e9t \u00edrja le. Egy tulajdons\u00e1ggal k\u00e9t m\u0171velet v\u00e9gezhet\u0151: lek\u00e9rdez\u00e9s (get) \u00e9s \u00e9rt\u00e9kad\u00e1s (set); ezeknek megadhat\u00f3 k\u00fcl\u00f6n a l\u00e1that\u00f3s\u00e1ga, \u00e9s a kett\u0151 k\u00f6z\u00fcl elegend\u0151 egy implement\u00e1l\u00e1sa. A legt\u00f6bb C# szintaktikai \u00e9des\u00edt\u0151szer a boilerplate k\u00f3dok \u00edr\u00e1s\u00e1nak elker\u00fcl\u00e9se v\u00e9gett k\u00e9sz\u00fclt, \u00edgy kevesebb k\u00f3dol\u00e1ssal \u00e9rj\u00fck el ugyanazt az eredm\u00e9nyt (sokszor az IL k\u00f3d nem is v\u00e1ltozik, gyakorlatilag hasonl\u00f3 a k\u00f3dgener\u00e1l\u00e1shoz).</p> <p>A <code>Person</code> oszt\u00e1lyban hozzuk l\u00e9tre a <code>string Name</code> property-t, <code>name</code> oszt\u00e1lyv\u00e1ltoz\u00f3val (field). Ehhez haszn\u00e1ljuk a <code>propfull</code> code snippetet (<code>propf</code>, majd Tab+Tab, ezut\u00e1n Tab-bal lehet l\u00e9pkedni a m\u00f3dos\u00edtand\u00f3 elemek k\u00f6z\u00f6tt):</p> <pre><code>public class Person\n{\n    private string name;\n    public string Name\n    {\n        get { return name; }\n        private set { name = value; }\n    }\n\n    public Person(string name)\n    {\n        this.name = name;\n    }\n}\n</code></pre> <p>L\u00e1that\u00f3s\u00e1g</p> <p>Figyelj\u00fcnk az oszt\u00e1ly l\u00e1that\u00f3s\u00e1g\u00e1ra is, alapb\u00f3l nem publikusk\u00e9nt gener\u00e1l\u00f3dik!</p> <p>Igaz\u00e1b\u00f3l csak k\u00e9t tov\u00e1bbi (k\u00f3dban nem l\u00e1that\u00f3) met\u00f3dust hozunk l\u00e9tre, mintha egy-egy <code>GetName</code> \u00e9s <code>SetName</code> met\u00f3dust k\u00e9sz\u00edten\u00e9nk, viszont haszn\u00e1lat szempontj\u00e1b\u00f3l ugyanolyannak t\u0171nik, mintha egy sima mez\u0151 lenne. A settert priv\u00e1t l\u00e1that\u00f3s\u00e1g\u00fara tessz\u00fck, ez\u00e9rt csak egy <code>Person</code> p\u00e9ld\u00e1nyon bel\u00fclr\u0151l tudjuk \u00e1ll\u00edtani a <code>Name</code> property \u00e9rt\u00e9k\u00e9t. Jegyezz\u00fck meg, hogy a getterben \u00e9s setterben teljesen m\u00e1s jelleg\u0171 m\u0171veleteket is v\u00e9gezhet\u00fcnk (pl. els\u00fcthet\u00fcnk egy esem\u00e9nyt, hogy megv\u00e1ltozott a felhaszn\u00e1l\u00f3 neve, napl\u00f3zhatjuk, h\u00e1nyszor k\u00e9rt\u00e9k le a nev\u00e9t, stb.). A property egyik nagy er\u00e9nye, hogy oszt\u00e1lyon k\u00edv\u00fclr\u0151l az oszt\u00e1lyv\u00e1ltoz\u00f3kn\u00e1l megszokott szintaxissal haszn\u00e1lhatjuk.</p> <p>A <code>Main</code> f\u00fcggv\u00e9nybe \u00edrhatjuk p\u00e9ld\u00e1ul:</p> Program.cs<pre><code>Person p = new Person(\"Eric Lippert\");\np.Name = \"Mads Torgersen\";\nConsole.WriteLine(p.Name);\n</code></pre> <p>Debuggerrel figyelj\u00fck meg, hogy az els\u0151 sor a konstruktort, m\u00edg a m\u00e1sodik a property setter\u00e9t, v\u00e9g\u00fcl a harmadik sor ugyanazon property getter\u00e9t h\u00edvja.</p> <p>Mivel a backing field \u00e1ll\u00edt\u00e1s\u00e1n k\u00edv\u00fcl nem csin\u00e1lunk semmit a property k\u00f3dban, ez\u00e9rt haszn\u00e1lhatjuk a <code>propg</code> code snippetet is:</p> Person.cs<pre><code>public string Name { get; private set; }\n</code></pre> <p>Ez az \u00fan. auto-implement\u00e1lt property szintaxis. A property \u00e1ltal lek\u00e9rdezhet\u0151-be\u00e1ll\u00edthat\u00f3 field gener\u00e1l\u00f3dik, arra a k\u00f3dban nem is tudunk hivatkozni - ez az egys\u00e9gbe z\u00e1r\u00e1s miatt el\u0151ny\u00f6s.</p> <p>A l\u00e1that\u00f3s\u00e1g miatt a <code>Main</code> f\u00fcggv\u00e9ny\u00fcnkben a setter h\u00edv\u00e1s m\u00e1r nem fordul, kommentezz\u00fck ki.</p> Person.cs<pre><code>//p.Name = \"Mads Torgersen\";\n</code></pre> <p>L\u00e9tezik m\u00e9g a <code>prop</code> code snippet is, ami mindk\u00e9t m\u00f3dos\u00edt\u00f3sz\u00f3t publikusan hagyja. L\u00e1that\u00f3s\u00e1gi m\u00f3dos\u00edt\u00f3sz\u00f3t a <code>get</code> \u00e9s <code>set</code> k\u00f6z\u00fcl csak az egyik el\u00e9 tehet\u00fcnk ki, \u00e9s az is csak szigor\u00edthat a k\u00fcls\u0151 l\u00e1that\u00f3s\u00e1gon (ekkor a m\u00e1sik a k\u00fcls\u0151t kapja meg).</p> <p>Ez a megold\u00e1s az el\u0151z\u0151vel teljes m\u00e9rt\u00e9kben ekvivalens (csak nem l\u00e1tjuk a gener\u00e1lt backing fieldet, de val\u00f3j\u00e1ban ott van). Ha van id\u0151nk, akkor vizsg\u00e1ljuk meg decompilerben (pl. Telerik JustDecompile), hogy val\u00f3ban \u00edgy van.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3an vegy\u00fck fel a sz\u00fclet\u00e9si d\u00e1tumot is. A sz\u00fclet\u00e9si d\u00e1tum nem v\u00e1ltozhat, gyakorlatilag <code>readonly</code> mez\u0151r\u0151l van sz\u00f3. Ha egy tulajdons\u00e1g \u00e9rt\u00e9k\u00e9t az objektum is csak a konstruktorban tudja megadni, akkor a setter teljes m\u00e9rt\u00e9kben elhagyhat\u00f3:</p> Person.cs<pre><code>public DateTime DateOfBirth { get; }\n\npublic Person(string name, DateTime dateOfBirth)\n{\n    Name = name;\n    DateOfBirth = dateOfBirth;\n}\n</code></pre> <p>Ez a szintaktika megegyezik azzal, mintha egy <code>readonly</code> mez\u0151t haszn\u00e1ln\u00e1nk, azaz a mez\u0151 \u00e9rt\u00e9ke legk\u00e9s\u0151bb a konstruktorban inicializ\u00e1land\u00f3.</p> <p>Vegy\u00fcnk fel neki egy azonos\u00edt\u00f3t, ami egy <code>Guid</code> strukt\u00fara t\u00edpus\u00fa legyen:</p> Person.cs<pre><code>public Guid Id { get; } = Guid.NewGuid();\n</code></pre> <p>Ez egy csak lek\u00e9rdezhet\u0151 tulajdons\u00e1g, ami konstru\u00e1l\u00e1skor inicializ\u00e1l\u00f3dik egy \u00faj v\u00e9letlenszer\u0171 azonos\u00edt\u00f3 \u00e9rt\u00e9kre.</p> <p>Megadhatjuk a kort, mint implicit/sz\u00e1m\u00edtott tulajdons\u00e1got:</p> Person.cs<pre><code>public int Age { get { return DateTime.Now.Subtract(DateOfBirth).Days / 365; } }\n</code></pre> <p>Mivel a f\u00fcggv\u00e9ny\u00fcnk t\u00f6rzse egyetlen kifejez\u00e9ssel megadhat\u00f3, ez\u00e9rt elhagyva a sallangot (<code>return</code>, kapcsos z\u00e1r\u00f3jelek, stb.) expression bodied property szintaxissal is \u00edrhatjuk:</p> Person.cs<pre><code>public int Age =&gt; DateTime.Now.Subtract(DateOfBirth).Days / 365;\n</code></pre> <p>Tip</p> <p>Alkalmaz\u00e1sok fejleszt\u00e9sekor a legfontosabb els\u0151 l\u00e9p\u00e9sek egyike, hogy az objektummodell\u00fcnk \u00e1tl\u00e1that\u00f3, karbantarthat\u00f3 \u00e9s egy\u00e9rtelm\u0171 legyen. A C# v\u00e1ltozatos szintaxisa nagyon sokat seg\u00edt ezen c\u00e9lok el\u00e9r\u00e9s\u00e9ben.</p>"},{"location":"seminar/01-csharp1/chapter1/#generikus-kollekcio","title":"Generikus kollekci\u00f3","text":"<p>A <code>Main</code> met\u00f3dusban vegy\u00fcnk fel n\u00e9h\u00e1ny <code>Person</code> objektumot, \u00e9s list\u00e1zzuk ki a relev\u00e1ns tulajdons\u00e1gaikat! Ehhez egy <code>Person</code> list\u00e1ban t\u00e1roljuk a szem\u00e9lyeket. A <code>List</code> generikus kollekci\u00f3, azaz t\u00edpusparam\u00e9tert v\u00e1r, t\u00edpusokkal param\u00e9terezhet\u0151. A <code>List</code> t\u00edpusparam\u00e9tere jelzi, hogy milyen t\u00edpus\u00fa objektumokat t\u00e1rol. Met\u00f3dusok, tulajdons\u00e1gok, t\u00edpusok lehetnek generikusak. A genericit\u00e1s fontos a k\u00f3dunk \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1ga \u00e9s karbantarthat\u00f3s\u00e1ga \u00e9rdek\u00e9ben.</p> <pre><code>static void Main(string[] args)\n{\n    List&lt;Person&gt; people = new List&lt;Person&gt;();\n    people.Add(new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)));\n    people.Add(new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)));\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n\n    foreach (Person person in people)\n        Console.WriteLine(person);\n\n    Console.ReadLine();\n}\n</code></pre> <p>Ind\u00edtsuk el az alkalmaz\u00e1st, \u00e9s n\u00e9zz\u00fck meg, mi t\u00f6rt\u00e9nik! Annyiszor \u00edr\u00f3dik ki a <code>Person</code> oszt\u00e1lyunk teljes neve (fully qualified type name), ah\u00e1ny elem van a list\u00e1ban.</p>"},{"location":"seminar/01-csharp1/chapter1/#leszarmazas-string-interpolacio","title":"Lesz\u00e1rmaz\u00e1s, string interpol\u00e1ci\u00f3","text":"<p>Ha a <code>WriteLine</code> f\u00f6l\u00e9 vissz\u00fck az egeret, l\u00e1that\u00f3, hogy az overload-ok k\u00f6z\u00fcl az h\u00edv\u00f3dik meg, amelyik objektumot v\u00e1r param\u00e9ter\u00fcl. Ebben az esetben a param\u00e9ter <code>ToString</code> met\u00f3dus\u00e1t h\u00edvja meg a <code>WriteLine</code>, ami alap\u00e9rtelmez\u00e9s szerint az objektum t\u00edpus\u00e1nak teljes nev\u00e9t adj\u00e1k vissza. Tegy\u00fck szebb\u00e9 a ki\u00edr\u00e1st, defini\u00e1ljuk fel\u00fcl az alap\u00e9rtelmezett <code>ToString</code> implement\u00e1ci\u00f3t a <code>Person</code> oszt\u00e1lyban:</p> Person.cs<pre><code>public override string ToString()\n{\n    return string.Format(\"{0} ({1}) [ID: {2}]\", Name, Age, Id);\n}\n</code></pre> <p>A <code>Person</code> oszt\u00e1lynak nincs explicit megadva \u0151soszt\u00e1lya, m\u00e9gis van fel\u00fcldefini\u00e1lhat\u00f3 f\u00fcggv\u00e9nye. Ezeket az <code>Object</code> oszt\u00e1ly defini\u00e1lja. Ha egy referencia t\u00edpusnak nincs megadva \u0151soszt\u00e1lya, akkor az <code>Object</code> lesz az.</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1ra m\u00e1s szintaktikai \u00e9des\u00edt\u0151szereket is haszn\u00e1lhatunk:</p> Person.cs<pre><code>public override string ToString() =&gt; $\"{Name} ({Age}) [ID: {Id}]\";\n</code></pre> <p>A k\u00e9t implement\u00e1ci\u00f3 ekvivalens, a m\u00e1sodik implement\u00e1ci\u00f3 az \u00fan. expression bodied method \u00e9s a string interpol\u00e1ci\u00f3 kombin\u00e1l\u00e1s\u00e1b\u00f3l ad\u00f3dik.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st!</p> <p>Hozzuk l\u00e9tre a <code>Student</code> oszt\u00e1lyt, ami sz\u00e1rmazik a <code>Person</code> oszt\u00e1lyb\u00f3l!</p> <pre><code>public class Student : Person\n{\n    public string Neptun { get; set; }\n\n    public string Major { get; set; }\n\n    public Student(string name, DateTime dateOfBirth)\n        : base(name, dateOfBirth)\n    {\n    }\n\n    public override string ToString() =&gt; $\"{base.ToString()} Neptun: {Neptun} Major: {Major}\";\n}\n</code></pre> <p>Ez az oszt\u00e1ly m\u00e1s megk\u00f6zel\u00edt\u00e9ssel k\u00e9sz\u00fclt, mint a sz\u00fcl\u0151je, az \u00e1llapota nem a konstruktor megh\u00edv\u00e1sakor t\u00f6lt\u0151dik fel, ut\u00f3lag lehet megadni setter h\u00edv\u00e1sokkal. Ez egyr\u00e9szt k\u00e9nyelmes, mert nem kell sokparam\u00e9teres konstruktorokkal k\u00fczdeni, m\u00e1sr\u00e9szt fel kell k\u00e9sz\u00fcln\u00fcnk arra, hogy bizonyos adatokat nem t\u00f6ltenek ki.</p> <p>\u0150s konstruktora</p> <p>Ha az \u0151soszt\u00e1lynak nincs param\u00e9ter n\u00e9lk\u00fcli konstruktora (a <code>Person</code> oszt\u00e1lynak nincs), akkor k\u00f6telesek vagyunk a gyerek konstruktorban az \u0151soszt\u00e1ly valamelyik konstruktor\u00e1t megh\u00edvni a <code>base</code> kulcssz\u00f3val.</p>"},{"location":"seminar/01-csharp1/chapter1/#objektum-inicializalok","title":"Objektum inicializ\u00e1l\u00f3k","text":"<p>Az object initializer seg\u00edts\u00e9g\u00e9vel az objektum l\u00e9trehoz\u00e1s\u00e1t (konstruktor h\u00edv\u00e1s) \u00e9s a property setterek megh\u00edv\u00e1s\u00e1val t\u00f6rt\u00e9n\u0151 inicializ\u00e1l\u00e1s\u00e1t int\u00e9zhetj\u00fck egy f\u00fcst alatt.  Az objektum inicializ\u00e1l\u00f3 csak konstruktorh\u00edv\u00e1s eset\u00e9n haszn\u00e1lhat\u00f3, \u00edgy pl. factory met\u00f3dus \u00e1ltal gy\u00e1rtott objektump\u00e9ld\u00e1ny eset\u00e9n nem.</p> <p>A <code>Main</code> met\u00f3dusban \u00edrhatjuk az al\u00e1bbi p\u00e9ld\u00e1t:</p> <pre><code>static void Main(string[] args)\n{\n    /*...*/\n    people.Add(new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)));\n    Student elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major = \"Info BSc\"\n    };\n    /*...*/\n}\n</code></pre> <p>Konstruktor szintaktik\u00e1k</p> <p>Objektum inicializ\u00e1l\u00e1s sor\u00e1n, param\u00e9ter n\u00e9lk\u00fcli konstruktor eset\u00e9n a <code>()</code> is elhagyhat\u00f3.</p> <p>T\u00f6bb sorba t\u00f6rdel\u00e9s</p> <p>\u00c1ltal\u00e1ban 1-2 tulajdons\u00e1g eset\u00e9n lehet egy sorba is \u00edrni az inicializ\u00e1ci\u00f3t, t\u00f6bb eset\u00e9n viszont \u00e1ltal\u00e1ban t\u00f6bb sorba \u00e9rdemes t\u00f6rdelni az olvashat\u00f3s\u00e1g \u00e9rdek\u00e9ben.</p> <p>L\u00e1thatjuk, hogy csak az aktu\u00e1lis kontextusban egy\u00e9bk\u00e9nt is l\u00e1that\u00f3 \u00e9s be\u00e1ll\u00edthat\u00f3 tulajdons\u00e1gokat \u00e1ll\u00edthatjuk be, egyik \u00edgy be\u00e1ll\u00edtott tulajdons\u00e1g sem k\u00f6telez\u0151 jelleg\u0171.</p> <p>Az object initializer val\u00f3ban csak az egyes tulajdons\u00e1gokat \u00e1ll\u00edtja be, teh\u00e1t csak szintaktikailag k\u00fcl\u00f6nb\u00f6zik az els\u0151 defin\u00edci\u00f3 az al\u00e1bbit\u00f3l:</p> <p>Note</p> <p>Nem kell be\u00edrni, csak szeml\u00e9ltet\u00e9s.</p> <pre><code>Student _elek = new Student(\"Fel Elek\", new DateTime(2002, 06, 10));\n_elek.Neptun = \"ABC123\";\n_elek.Major = \"Info BSc\";\nStudent elek = _elek;\n</code></pre> <p>A h\u00e1tt\u00e9rben t\u00e9nyleg egy (sz\u00e1munkra nem l\u00e1that\u00f3) tempor\u00e1lis v\u00e1ltoz\u00f3ban fog t\u00f6rt\u00e9nni az inicializ\u00e1ci\u00f3, ugyanis, ha az object initializer kiv\u00e9telt dob (az egyik setter \u00e1ltal), az objektumunk nem veszi fel a k\u00edv\u00e1nt \u00e9rt\u00e9ket.</p> <p>Objektum inicializ\u00e1l\u00f3 haszna</p> <p>Ebb\u0151l l\u00e1tszik az objektum inicializ\u00e1l\u00f3 els\u0151dleges haszna, m\u00e9gpedig, hogy nem kell \u00e1lland\u00f3an ki\u00edrogatni, hogy melyik p\u00e9ld\u00e1nyra gondolunk (\u00edgy elrontani sem tudjuk).</p>"},{"location":"seminar/01-csharp1/chapter1/#kollekcio-inicializacio","title":"Kollekci\u00f3 inicializ\u00e1ci\u00f3","text":"<p>Az egyszer\u0171s\u00edtett kollekci\u00f3 inicializ\u00e1ci\u00f3 szintaxissal a lista teljes felt\u00f6lt\u00e9se j\u00f3val kevesebb k\u00f3ddal \u00e9s j\u00f3val olvashat\u00f3bban megadhat\u00f3. R\u00e1ad\u00e1sul a kollekci\u00f3 elemeit l\u00e9trehozhatjuk az objektum inicializ\u00e1ci\u00f3s szintaxissal is. A teljes lista l\u00e9trehoz\u00e1st \u00e9s -felt\u00f6lt\u00e9s r\u00e9szt cser\u00e9lj\u00fck le az al\u00e1bbira.</p> <pre><code>List&lt;Person&gt; people = new List&lt;Person&gt;\n{\n    new Person(\"Horv\u00e1th Alad\u00e1r\", new DateTime(1991, 06, 10)),\n    new Person(\"Kov\u00e1cs Istv\u00e1n\", new DateTime(1994, 04, 22)),\n    new Person(\"Kov\u00e1cs G\u00e9za\", new DateTime(1998, 03, 16)),\n    new Student(\"Fel Elek\", new DateTime(2002, 06, 10))\n    {\n        Neptun = \"ABC123\",\n        Major=\"Info BSc\"\n    },\n    new Student(\"Hi\u00e1ny \u00c1ron\", new DateTime(2000, 02, 13))\n};\n</code></pre> <p>Nem kell az <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1st \u00e9s a lista referenci\u00e1t ki\u00edrni, egy\u00e9rtelm\u0171, hogy melyik list\u00e1hoz adunk hozz\u00e1.</p> <p>Add</p> <p>Ez a forma is ugyanolyan <code>Add</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokra fordul, mint az eredeti v\u00e1ltozatban.</p> <p>Pr\u00f3b\u00e1ljuk ki az alkalmaz\u00e1st! L\u00e1thatjuk, hogy a konstruktoron kereszt\u00fcl teljesen inicializ\u00e1lhat\u00f3 <code>Person</code> p\u00e9ld\u00e1nyok eset\u00e9ben a ki\u00edr\u00e1s teljes, viszont vannak olyan <code>Student</code> p\u00e9ld\u00e1nyok, ahol a ki\u00edr\u00e1s \u00fcres \u00e9rt\u00e9keket tal\u00e1l. Ezzel a jelens\u00e9ggel a k\u00f6vetkez\u0151 gyakorlatokon tov\u00e1bb foglalkozunk.</p>"},{"location":"seminar/02-csharp2/chapter2/","title":"C# alapok II.","text":""},{"location":"seminar/02-csharp2/chapter2/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>Els\u0151 l\u00e9p\u00e9sk\u00e9nt hozzunk l\u00e9tre egy .NET C# konzolalkalmaz\u00e1st: a projektsablon sz\u0171r\u0151ben v\u00e1lasszuk a C# nyelv - Windows platform - Console projektt\u00edpust. A sz\u0171rt list\u00e1ban v\u00e1lasszuk a Console App sablont (ne a .NET Framework-\u00f6s legyen). A neve legyen HelloCSharp2. A solutiont ne tegy\u00fck k\u00fcl\u00f6n mapp\u00e1ba (Place solution and project in the same directory legyen bekapcsolva). A megc\u00e9lzott framework verzi\u00f3 legyen .NET 8.</p>"},{"location":"seminar/02-csharp2/chapter2/#legfelso-szintu-utasitasok-implicit-globalis-nevter-hivatkozasok","title":"Legfels\u0151 szint\u0171 utas\u00edt\u00e1sok, implicit glob\u00e1lis n\u00e9vt\u00e9r-hivatkoz\u00e1sok","text":"<p>Csod\u00e1lkozzunk r\u00e1, hogy a gener\u00e1lt projekt mind\u00f6ssze egyetlen \u00e9rdemi sort tartalmaz.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\n</code></pre> <p>C# 10 \u00f3ta a program bel\u00e9p\u00e9si pontj\u00e1t ad\u00f3 forr\u00e1sf\u00e1jlt jelent\u0151sen ler\u00f6vid\u00edthetj\u00fck:</p> <ul> <li>a f\u00e1jl tetej\u00e9n l\u00e9v\u0151 using-okat elhagyhatjuk, ha azok implicit hivatkozva vannak. Az implicit hivatkozott using-ok projektt\u00edpust\u00f3l f\u00fcggenek \u00e9s a dokument\u00e1ci\u00f3b\u00f3l olvashatjuk ki</li> <li>a <code>Main</code> f\u00fcggv\u00e9nyt tartalmaz\u00f3 oszt\u00e1ly deklar\u00e1ci\u00f3j\u00e1t (<code>namespace</code> blokk, <code>class</code> blokk) elhagyhatjuk, ezt a ford\u00edt\u00f3 gener\u00e1lja nek\u00fcnk</li> <li>a <code>Main</code> f\u00fcggv\u00e9ny deklar\u00e1ci\u00f3j\u00e1t szint\u00e9n gener\u00e1lja a ford\u00edt\u00f3. A met\u00f3dus neve nem defini\u00e1lt, nem (biztos, hogy) <code>Main</code>. A met\u00f3dus szignat\u00far\u00e1ja att\u00f3l f\u00fcgg, milyen utas\u00edt\u00e1sokat adunk meg a forr\u00e1sf\u00e1jlban. P\u00e9ld\u00e1ul, ha nincs return, akkor <code>void</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171. A param\u00e9tere viszont mindig <code>string[] args</code>.</li> <li>a f\u00fcggv\u00e9ny blokkba nem foglalt k\u00f3d a gener\u00e1lt bel\u00e9p\u00e9si pont f\u00fcggv\u00e9ny belsej\u00e9be ker\u00fcl. F\u00fcggv\u00e9nyt is \u00edrhatunk, az a bel\u00e9p\u00e9si pontot tartalmaz\u00f3 gener\u00e1lt oszt\u00e1ly tagf\u00fcggv\u00e9nye lesz.</li> <li>t\u00edpusokat, oszt\u00e1lyokat is defini\u00e1lhatunk, de csak a legfels\u0151 szint\u0171 k\u00f3dot k\u00f6vet\u0151en</li> </ul> <p>Warning</p> <p>Fontos \u00e9szrev\u00e9tel a fentiekb\u0151l: ezen k\u00e9pess\u00e9g nem v\u00e1ltoztatja meg a C# semmilyen alapvet\u0151 jellemz\u0151j\u00e9t, p\u00e9ld\u00e1ul ugyan\u00fagy minden f\u00fcggv\u00e9nynek oszt\u00e1lyon bel\u00fcl kell lennie. A ford\u00edt\u00e1s sor\u00e1n a legfels\u0151 szint\u0171 utas\u00edt\u00e1sok k\u00f3dja \u00fagy eg\u00e9sz\u00fcl ki, ami m\u00e1r minden szab\u00e1lynak megfelel.</p> <p>L\u00e1that\u00f3s\u00e1g</p> <p>A legfels\u0151 szint\u0171 k\u00f3d olyan, amit a program m\u00e1s r\u00e9sz\u00e9r\u0151l nem tudunk h\u00edvni, hiszen nem is ismerj\u00fck a burkol\u00f3 oszt\u00e1ly nev\u00e9t. Emiatt nincs \u00e9rtelme legfels\u0151 szint\u0171 k\u00f3dban l\u00e1that\u00f3s\u00e1gi be\u00e1ll\u00edt\u00e1snak (<code>private</code>, <code>protected</code> stb.) vagy propertynek.</p> <p>Akad\u00e1lyozzuk meg a program azonnali lefut\u00e1s\u00e1t egy blokkol\u00f3 h\u00edv\u00e1ssal.</p> <pre><code>Console.WriteLine(\"Hello, World!\");\nConsole.ReadLine();\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a gener\u00e1lt projektet mindenf\u00e9le egy\u00e9b v\u00e1ltoztat\u00e1s n\u00e9lk\u00fcl, ford\u00edt\u00e1s (menu:projekten jobbklikk[Build]) ut\u00e1n. N\u00e9zz\u00fcnk bele a kimeneti k\u00f6nyvt\u00e1rba (menu:projekten jobbklikk[Open Folder in File Explorer], majd menu:bin[Debug &gt; net8.0]): l\u00e1that\u00f3, hogy az alkalmaz\u00e1sunkb\u00f3l a ford\u00edt\u00e1s sor\u00e1n egy cross-platform bin\u00e1ris (\\&lt;projektn\u00e9v&gt;.dll) \u00e9s .NET Core v3 \u00f3ta egy platform specifikus futtathat\u00f3 \u00e1llom\u00e1ny (Windows eset\u00e9n \\&lt;projektn\u00e9v&gt;.exe) is gener\u00e1l\u00f3dik. Kipr\u00f3b\u00e1lhatjuk, hogy az exe a szokott m\u00f3don ind\u00edthat\u00f3 (pl. duplaklikkel), m\u00edg a dll a <code>dotnet</code> paranccsal.</p> <pre><code>dotnet &lt;projektn\u00e9v.dll&gt;\n</code></pre> <p>Parancssor aktu\u00e1lis mapp\u00e1ja</p> <p>A dotnet parancshoz a dll k\u00f6nyvt\u00e1r\u00e1ban kell lenn\u00fcnk. Ehhez a legegyszer\u0171bb, ha a Windows f\u00e1jlkezel\u0151ben a megfelel\u0151 k\u00f6nyvt\u00e1rban \u00e1llva az el\u00e9r\u00e9si \u00fatvonal mez\u0151t \u00e1t\u00edrjuk a <code>cmd</code> sz\u00f6vegre, majd kbd:[ENTER]-t nyomunk.</p> <p>Adjunk a l\u00e9trej\u00f6v\u0151 projekthez egy <code>Dog</code> oszt\u00e1lyt Dog.cs n\u00e9ven, ez lesz az adatmodell\u00fcnk:</p> <pre><code>public class Dog\n{\n    public string Name { get; set; }\n    public Guid Id { get; } = Guid.NewGuid();\n    public DateTime DateOfBirth { get; set; }\n    private int AgeInDays =&gt; DateTime.Now.Subtract(DateOfBirth).Days;\n    public int Age =&gt; AgeInDays / 365;\n    public int AgeInDogYears =&gt; AgeInDays * 7 / 365;\n    public override string ToString() =&gt;\n            $\"{Name} ({Age} | {AgeInDogYears}) [ID: {Id}]\";\n}\n</code></pre> <p>Az adatmodell az el\u0151z\u0151 \u00f3r\u00e1n l\u00e9trehozotthoz nagyon hasonl\u00edt, ennek viszont nincsen explicit konstruktora \u00e9s a <code>Name</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gok publikusan is \u00e1ll\u00edthat\u00f3k.</p> <p>Hozzunk l\u00e9tre egy <code>Dog</code> p\u00e9ld\u00e1nyt objektum inicializ\u00e1ci\u00f3s szintaxissal, majd \u00edrjuk ki ezt a p\u00e9ld\u00e1nyt a kezdeti k\u00f6sz\u00f6nt\u0151 sz\u00f6veg helyett:</p> <pre><code>Dog banan = new Dog\n{\n    Name = \"Ban\u00e1n\",\n    DateOfBirth = new DateTime(2014, 06, 10)\n};\nConsole.WriteLine(banan);\n</code></pre> <p>Ezzel k\u00e9sz a kiindul\u00f3 projekt\u00fcnk.</p>"},{"location":"seminar/02-csharp2/chapter2/#implicit-tipusdeklaracio","title":"Implicit t\u00edpusdeklar\u00e1ci\u00f3","text":"<p>A <code>var</code> kulcssz\u00f3 jelent\u0151s\u00e9ge: ha a ford\u00edt\u00f3 ki tudja tal\u00e1lni a kontextusb\u00f3l az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n \u00e1ll\u00f3 \u00e9rt\u00e9k t\u00edpus\u00e1t, nem sz\u00fcks\u00e9ges a t\u00edpus nev\u00e9t explicit megadnunk, az implicit k\u00f6vetkezik a k\u00f3db\u00f3l. Ebben az esetben a t\u00edpus egy\u00e9rtelm\u0171en <code>Dog</code>. Ha csak deklar\u00e1lni szeretn\u00e9nk egy v\u00e1ltoz\u00f3t (nem adunk \u00e9rt\u00e9k\u00fcl a v\u00e1ltoz\u00f3nak semmit), akkor nem haszn\u00e1lhatjuk a <code>var</code> kulcssz\u00f3t, ugyanis nem k\u00f6vetkezik a k\u00f3db\u00f3l a v\u00e1ltoz\u00f3 t\u00edpusa. Ekkor explicit meg kell adnunk a t\u00edpust.</p> <pre><code>Dog banan = new Dog\n{\n   Name = \"Ban\u00e1n\",\n   DateOfBirth = new DateTime(2014, 06, 10)\n};\nvar watson = new Dog { Name = \"Watson\" };\n\nvar unnamed = new Dog { DateOfBirth = new DateTime(2017, 02, 10) };\nvar unknown = new Dog { };\n//watson = 3; // \n//var error;  // \n\nConsole.WriteLine(banan);\nConsole.ReadLine();\n</code></pre> <ul> <li>Ford\u00edt\u00e1si hiba: a <code>watson</code> deklar\u00e1ci\u00f3jakor eld\u0151lt, hogy \u0151 <code>Dog</code> t\u00edpus, ut\u00f3lag nem lehet megv\u00e1ltoztatni \u00e9s p\u00e9ld\u00e1ul sz\u00e1m\u00e9rt\u00e9ket \u00e9rt\u00e9k\u00fcl adni. Ez nem JavaScript.</li> <li>Ford\u00edt\u00e1si hiba: implicit t\u00edpust csak \u00fagy lehet deklar\u00e1lni, ha egy\u00fattal inicializ\u00e1ljuk is. Az inicializ\u00e1ci\u00f3s kifejez\u00e9s alapj\u00e1n d\u0151l el (implicit) a p\u00e9ld\u00e1ny t\u00edpusa.</li> </ul> <p>Pr\u00f3b\u00e1ljuk ki a nem fordul\u00f3 sorokat, n\u00e9zz\u00fck meg a ford\u00edt\u00f3 hiba\u00fczeneteit!</p> <p>Er\u0151ss t\u00edpusos\u00e1g</p> <p>A <code>var</code> nem a gyenge t\u00edpusoss\u00e1g jele a C#-ban, nem \u00fagy, mint pl. JavaScript-ben. Az inicializ\u00e1ci\u00f3s sor ut\u00e1n a t\u00edpus egy\u00e9rtelm\u0171en eld\u0151l, ut\u00e1na m\u00e1r csak ennek a t\u00edpusnak megfelel\u0151 m\u0171veletek v\u00e9gezhet\u0151k, p\u00e9ld\u00e1ul egy \u00e9rt\u00e9kad\u00e1ssal nem v\u00e1ltoztathatjuk meg a t\u00edpust.</p> <p>A <code>var</code>-t tipikusan akkor alkalmazzuk, ha:</p> <ul> <li>hossz\u00fa t\u00edpusneveket nem akarunk ki\u00edrni</li> <li>feleslegesnek tartjuk az inicializ\u00e1ci\u00f3 mindk\u00e9t oldal\u00e1n ki\u00edrni ugyanazt a t\u00edpust</li> <li>anonim t\u00edpusokat haszn\u00e1lunk (k\u00e9s\u0151bb)</li> </ul>"},{"location":"seminar/02-csharp2/chapter2/#init-only-setter","title":"Init-only setter","text":"<p>Az objektum inicializ\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9hez sz\u00fcks\u00e9ges a megfelel\u0151 l\u00e1that\u00f3s\u00e1g\u00fa setter. Viszont egy ilyen settert nem csak objektum inicializ\u00e1ci\u00f3kor lehet haszn\u00e1lni, hanem b\u00e1rmikor \u00e1t\u00e1ll\u00edthatjuk egy p\u00e9ld\u00e1ny adat\u00e1t (mut\u00e1ci\u00f3).</p> <p>Az al\u00e1bbi p\u00e9lda egy ilyen ut\u00f3lagos m\u00f3dos\u00edt\u00e1sra / mut\u00e1ci\u00f3ra.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nwatson.Name = \"Sherlock\";\n</code></pre> <p>Ez \u00edgy hiba n\u00e9lk\u00fcl lefordul.</p> <p>Kiz\u00e1r\u00f3lag az inicializ\u00e1ci\u00f3ra korl\u00e1tozhatjuk a setter megh\u00edv\u00e1s\u00e1t az init-only setterrel (<code>init</code> kulcssz\u00f3).</p> <pre><code>public class Dog\n{\n    public string Name { get; init; }\n    //...\n}\n</code></pre> <p>Ezut\u00e1n az inicializ\u00e1ci\u00f3s sor tov\u00e1bbra is lefordul, de a n\u00e9v\u00e1t\u00edr\u00e1sos m\u00e1r nem. Ez ut\u00f3bbi sort kommentezz\u00fck ki.</p> <p>Init-only setter konstruktorb\u00f3l</p> <p>Init-only settert az oszt\u00e1ly konstruktor\u00e1b\u00f3l is meg lehet h\u00edvni - hiszen az is inicializ\u00e1ci\u00f3.</p> <p>Haszn\u00e1lata</p> <p>Init-only settert t\u00f6bb okb\u00f3l kifoly\u00f3lag is haszn\u00e1lhatunk, p\u00e9ld\u00e1ul a t\u00edpus p\u00e9ld\u00e1nyainak immut\u00e1bilis kezel\u00e9s\u00e9t akarjuk kik\u00e9nyszer\u00edteni, vagy csak inicializ\u00e1ci\u00f3ra akarjuk korl\u00e1tozni a propertyk be\u00e1ll\u00edt\u00e1s\u00e1t, de nem akarunk ehhez konstruktort \u00edrni.</p> <p>Jelen form\u00e1j\u00e1ban az init-only setter nem tudja helyettes\u00edteni a k\u00f6telez\u0151 konstruktor param\u00e9tert, mert nem k\u00f6telez\u0151 kit\u00f6lteni ezt a propertyt. Erre a megold\u00e1s a C# 11-ben bevezetett <code>required</code> kulcssz\u00f3 a property el\u0151tt.</p> <pre><code>public class Dog\n{\n    public required string Name { get; init;  }\n    //...\n}\n</code></pre> <p>Ezzel k\u00f6telez\u0151v\u00e9 v\u00e1lik a <code>Name</code> kit\u00f6lt\u00e9se, ha a <code>Dog</code> p\u00e9ld\u00e1nyt inicializ\u00e1ljuk.</p>"},{"location":"seminar/02-csharp2/chapter2/#indexer-operator-nameof-operator-index-inicializalo","title":"Indexer oper\u00e1tor, nameof oper\u00e1tor, index inicializ\u00e1l\u00f3","text":"<p>A collection initializer anal\u00f3gi\u00e1j\u00e1ra j\u00f6tt l\u00e9tre az index initializer nyelvi elem, ami a kor\u00e1bbihoz hasonl\u00f3an sorban h\u00edv meg egy oper\u00e1tort, hogy m\u00e1r inicializ\u00e1lt objektumot kapjunk vissza. A k\u00fcl\u00f6nbs\u00e9g egyr\u00e9szt a szintaxis, m\u00e1sr\u00e9szt az ilyenkor megh\u00edvott met\u00f3dus, ami az index oper\u00e1tor.</p> <p>oper\u00e1tor fel\u00fcldefini\u00e1l\u00e1s</p> <p>Saj\u00e1t t\u00edpusainkban lehet\u0151s\u00e9g\u00fcnk van defini\u00e1lni \u00e9s fel\u00fcldefini\u00e1lni oper\u00e1torokat, mint pl. +, -, indexel\u00e9s, implicit cast, explicit cast, stb.</p> <p>Tegy\u00fck fel, hogy egy kuty\u00e1hoz b\u00e1rmilyen, \u00fczleti logik\u00e1ban nem felhaszn\u00e1lt inform\u00e1ci\u00f3 ker\u00fclhet, amire \u00e1ltal\u00e1nos strukt\u00far\u00e1t szeretn\u00e9nk. Vegy\u00fcnk fel a <code>Dog</code> oszt\u00e1lyba egy <code>string-object</code> sz\u00f3t\u00e1rat, amiben b\u00e1rmilyen tov\u00e1bbi inform\u00e1ci\u00f3t t\u00e1rolhatunk! Ezen fel\u00fcl \u00e1ll\u00edtsuk be a <code>Dog</code> indexer\u00e9t, hogy az a <code>Metadata</code> indexel\u00e9s\u00e9t v\u00e9gezze:</p> <pre><code>public class Dog\n{\n    //...\n    public Dictionary&lt;string, object&gt;  Metadata { get; } = new();\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>Konstruktor t\u00edpus n\u00e9lk\u00fcl</p> <p>A <code>new</code> oper\u00e1tor ut\u00e1ni konstruktorh\u00edv\u00e1s sok esetben elhagyhat\u00f3, ha a bal oldal alapj\u00e1n am\u00fagy is tudhat\u00f3 a t\u00edpus.</p> <p>n\u00e9vt\u00e9r hivatkoz\u00e1sok</p> <p>Az \u00fajabb projektsablonok sokkal kevesebb n\u00e9vt\u00e9rdeklar\u00e1ci\u00f3t (<code>using</code>) gener\u00e1lnak alapb\u00f3l. Ha kell, vegy\u00fck fel a sz\u00fcks\u00e9geseket a fel nem oldott n\u00e9ven \u00e1llva a gyorsm\u0171velet (villanyk\u00f6rte) eszk\u00f6zzel (Ctrl+.)</p> <p>Az objektum inicializ\u00e1l\u00f3 \u00e9s az index inicializ\u00e1l\u00f3 vegy\u00edthet\u0151, \u00edgy az al\u00e1bbi m\u00f3don tudunk felvenni tov\u00e1bbi tulajdons\u00e1gokat a kuty\u00e1khoz a legfels\u0151 szint\u0171 k\u00f3dba:</p> <pre><code>var pimpedli = new Dog\n{\n    Name = \"Pimpedli\",\n    DateOfBirth = new DateTime(2006, 06, 10),\n    [\"Chip azonos\u00edt\u00f3\"] = \"123125AJ\"\n};\n</code></pre> <p>Mivel indexelni \u00e1ltal\u00e1ban kollekci\u00f3kat szok\u00e1s (t\u00f6mb, lista, sz\u00f3t\u00e1r), ez\u00e9rt ezekben az esetekben igen j\u00f3 eszk\u00f6z lehet az index inicializ\u00e1l\u00f3. Vegy\u00fcnk fel egy \u00faj kutyasz\u00f3t\u00e1rt a kuty\u00e1k kiteny\u00e9szt\u00e9se ut\u00e1n:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [\"banan\"] = banan,\n    [\"watson\"] = watson,\n    [\"unnamed\"] = unnamed,\n    [\"unknown\"] = unknown,\n    [\"pimpedli\"] = pimpedli\n};\n\nforeach (var dog in dogs)\n    Console.WriteLine($\"{dog.Key} - {dog.Value}\");\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki - minden n\u00e9v-kutya p\u00e1rt ki kell \u00edrnia a sz\u00f3t\u00e1rb\u00f3l.</p> <p>Els\u0151re j\u00f3 \u00f6tletnek t\u0171nhet kiv\u00e1ltani a sz\u00f6vegliter\u00e1lokat a <code>Name</code> property haszn\u00e1lat\u00e1val.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [banan.Name] = banan,\n    [watson.Name] = watson,\n    [unnamed.Name] = unnamed,\n    [unknown.Name] = unknown,\n    [pimpedli.Name] = pimpedli\n};\n//ArgumentNullException!\n</code></pre> <p>Ez azonban kiv\u00e9telt okoz, amikor a kutya neve nincs kit\u00f6ltve, azaz <code>null</code> \u00e9rt\u00e9k\u0171. Eset\u00fcnkben el\u00e9g lenne az adott v\u00e1ltoz\u00f3 neve sz\u00f6vegk\u00e9nt. Erre j\u00f3 a <code>nameof</code> oper\u00e1tor.</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    [nameof(banan)] = banan,\n    [nameof(watson)] = watson,\n    [nameof(unnamed)] = unnamed,\n    [nameof(unknown)] = unknown,\n    [nameof(pimpedli)] = pimpedli\n};\n</code></pre> <p>Ez a v\u00e1ltozat m\u00e1r nem fog kiv\u00e9telt okozni.</p> <p>A <code>nameof</code> oper\u00e1tor sokfajta nyelvi elemet t\u00e1mogat, vissza tudja adni egy v\u00e1ltoz\u00f3, egy t\u00edpus, egy property vagy egy f\u00fcggv\u00e9ny nev\u00e9t is.</p> <p>A sz\u00f3t\u00e1r felt\u00f6lt\u00e9s\u00e9t meg\u00edrhatjuk kollekci\u00f3 inicializ\u00e1ci\u00f3val is. Ehhez kihaszn\u00e1ljuk, hogy a sz\u00f3t\u00e1r t\u00edpus rendelkezik egy <code>Add</code> met\u00f3dussal, amelyik egyszer\u0171en egy kulcsot \u00e9s egy hozz\u00e1tartoz\u00f3 \u00e9rt\u00e9ket v\u00e1r:</p> <pre><code>var dogs = new Dictionary&lt;string, Dog&gt;\n{\n    { nameof(banan), banan },\n    { nameof(watson), watson },\n    { nameof(unnamed), unnamed },\n    { nameof(unknown), unknown },\n    { nameof(pimpedli), pimpedli }\n};\n</code></pre>"},{"location":"seminar/02-csharp2/chapter2/#using-static","title":"Using static","text":"<p>Ha egy oszt\u00e1ly statikus tagjait vagy egy statikus oszt\u00e1lyt szeretn\u00e9nk haszn\u00e1lni, lehet\u0151s\u00e9g\u00fcnk van a <code>using static</code> kulcsszavakkal az oszt\u00e1lyt bevonni a n\u00e9vfelold\u00e1si logik\u00e1ba. Ha a <code>Console</code> oszt\u00e1lyt refer\u00e1ljuk ilyen m\u00f3don, lehet\u0151s\u00e9g\u00fcnk van a rajta lev\u0151 met\u00f3dusok megh\u00edv\u00e1s\u00e1ra az aktu\u00e1lis kontextusunkban an\u00e9lk\u00fcl, hogy az oszt\u00e1ly nev\u00e9t ki\u00edrn\u00e1nk:</p> <pre><code>using System;\nusing static System.Console;\n//..\nforeach (var dog in dogs)\n    /*Console.*/WriteLine($\"{dog.Key} - {dog.Value}\");\n/*Console.*/WriteLine(banan);\n/*Console.*/ReadLine();\n</code></pre> <p>n\u00e9vfelold\u00e1s</p> <p>Az \u00e1ltal\u00e1nos n\u00e9vfelold\u00e1si szab\u00e1ly tov\u00e1bbra is \u00e9l: ha egy\u00e9rtelm\u0171en feloldhat\u00f3 a hivatkoz\u00e1s, akkor nem sz\u00fcks\u00e9ges kitenni a megk\u00fcl\u00f6nb\u00f6ztet\u0151 el\u0151tagot (itt: oszt\u00e1ly), k\u00fcl\u00f6nben igen.</p>"},{"location":"seminar/02-csharp2/chapter2/#nullozhato-tipusok","title":"Nullozhat\u00f3 t\u00edpusok","text":"<p>Term\u00e9szetesen a referenciat\u00edpusok mind olyan t\u00edpusok, melyek vehetnek fel <code>null</code> \u00e9rt\u00e9ket, viszont esetenk\u00e9nt j\u00f3 volna, ha a <code>null</code> \u00e9rt\u00e9ket egy\u00e9bk\u00e9nt felvenni nem k\u00e9pes t\u00edpusok is lehet\u00e9nek ilyen \u00e9rt\u00e9k\u0171ek, ezzel pl. jelezv\u00e9n, hogy egy \u00e9rt\u00e9k be van-e \u00e1ll\u00edtva vagy sem. Pl. egy sz\u00e1m eset\u00e9n a 0 egy konkr\u00e9t, helyes \u00e9rt\u00e9k lehet a domain modell\u00fcnkben, a <code>null</code> viszont azt jelenthetn\u00e9, hogy nem vett fel \u00e9rt\u00e9ket.</p> <p>Vizsg\u00e1ljuk meg, hogy a konzolra t\u00f6rt\u00e9n\u0151 ki\u00edr\u00e1skor mi\u00e9rt lesz az aktu\u00e1lis \u00e9v Watson kutya \u00e9letkora! Valamelyik <code>Console.WriteLine</code> sorhoz vegy\u00fcnk fel egy t\u00f6r\u00e9spontot (F9), majd debuggol\u00e1s k\u00f6zben a Locals ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Locals]) figyelj\u00fck meg az egyes p\u00e9ld\u00e1nyok adatait. Watsont kinyitva l\u00e1thatjuk, hogy a turpiss\u00e1g abb\u00f3l fakad, hogy a <code>DateOfBirth</code> adat t\u00edpusa, a <code>DateTime</code> nem referenciat\u00edpus, \u00e9s alap\u00e9rtelmez\u00e9s szerinti \u00e9rt\u00e9ket veszi fel, ami 0001. 01. 01. 00:00:00 - hiszen nem \u00e1ll\u00edtottunk be m\u00e1st.</p> <p>Ismeretlen sz\u00fclet\u00e9si d\u00e1tum\u00fa, kor\u00fa egyedek helyes t\u00e1rol\u00e1s\u00e1hoz az <code>Age</code> tulajdons\u00e1g t\u00edpus\u00e1t v\u00e1ltoztassuk <code>int?</code>-re! Az <code>int?</code> szintaktikai \u00e9des\u00edt\u0151szere a <code>Nullable&lt;int&gt;</code>-nek, egy olyan strukt\u00far\u00e1nak, ami egy <code>int</code> \u00e9rt\u00e9ket t\u00e1rol, \u00e9s t\u00e1rolja, hogy az be van-e \u00e1ll\u00edtva vagy sem. A <code>Nullable&lt;int&gt;</code> szignat\u00far\u00e1it megmutathatjuk, hogyha a kurzort a t\u00edpusra helyezve F12-t nyomunk.</p> <p>M\u00f3dos\u00edtsuk a <code>Dog</code> <code>Age</code> \u00e9s <code>DateOfBirth</code> tulajdons\u00e1gait is, hogy tudjuk, be vannak-e \u00e1ll\u00edtva az \u00e9rt\u00e9keik:</p> <pre><code>public class Dog\n{\n    //...\n\n    public DateTime? DateOfBirth { get; set; }\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    //...\n}\n</code></pre> <p>Aritmentikai oper\u00e1torok</p> <p>\u00d6rvendezz\u00fcnk, hogy az alap aritmetikai oper\u00e1torok pont \u00fagy m\u0171k\u00f6dnek, ahogy szeretn\u00e9nk (<code>null</code> bemenetre <code>null</code> eredm\u00e9ny), nem kellett semmilyen tr\u00fckk.</p> <p>Az <code>AgeInDays</code> akkor ad vissza <code>null</code> \u00e9rt\u00e9ket, ha a <code>DateOfBirth</code> maga is <code>null</code> volt. Teh\u00e1t ha nincs megadva sz\u00fclet\u00e9si d\u00e1tumunk, nem tudunk \u00e9letkort sem sz\u00e1m\u00edtani. Ennek kifejez\u00e9s\u00e9re haszn\u00e1lhatjuk a <code>?.</code> (Elvis, magyarban Kozs\u00f3 - <code>null</code> conditional operator) oper\u00e1tort: a ki\u00e9rt\u00e9kelend\u0151 \u00e9rt\u00e9k jobb oldal\u00e1t adja vissza, ha a bal oldal nem <code>null</code>, k\u00fcl\u00f6nben <code>null</code>-t. A kifejez\u00e9st meg kellett v\u00e1ltoztatnunk, hogy a <code>DateOfBirth</code>-b\u0151l vonjuk ki a jelenlegi d\u00e1tumot \u00e9s ezt neg\u00e1ljuk, ugyanis a <code>null</code> vizsg\u00e1land\u00f3 \u00e9rt\u00e9k a bin\u00e1ris oper\u00e1tor bal oldal\u00e1n kell, hogy elhelyezkedjen.</p> Elvis oper\u00e1tor <p>Az Elvis oper\u00e1tor nev\u00e9nek eredet\u00e9re t\u00f6bb magyar\u00e1zatot is lehet tal\u00e1lni, a forr\u00e1sok annyiban nagyr\u00e9szt megegyeznek, hogy a k\u00e9rd\u0151jel tekered\u0151 r\u00e9sze az \u00e9nekes jellegzetes bodorod\u00f3 hajviselet\u00e9re eml\u00e9keztet, a pontok pedig a szemeket jel\u00f6lik, \u00edgy v\u00e9g\u00fclis a ?. egy Elvis emotikonk\u00e9nt foghat\u00f3 fel. Ezen logika ment\u00e9n ad\u00f3dik a magyar megfelel\u0151, a Kozs\u00f3 oper\u00e1tor, hiszen a szem k\u00f6r\u00fcl tekerg\u0151z\u0151 legikonikusabb hajtincs a magyar zenei kult\u00far\u00e1ban Kozs\u00f3 nev\u00e9hez k\u00f6thet\u0151.</p> <p>Ha \u00edgy futtatjuk az alkalmaz\u00e1st, az <code>AgeInDays</code> \u00e9s a sz\u00e1rmaztatott tulajdons\u00e1gok \u00e9rt\u00e9ke <code>null</code> (vagy ki\u00edrva \u00fcres) lesz, ha a sz\u00fclet\u00e9si d\u00e1tum nincs megadva.</p>"},{"location":"seminar/02-csharp2/chapter2/#rekord-tipus","title":"Rekord t\u00edpus","text":"<p>A rekord t\u00edpusok speci\u00e1lis t\u00edpusok, melyek:</p> <ul> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n \u00e9rt\u00e9k t\u00edpusokra jellemz\u0151 logik\u00e1t k\u00f6vetnek, azaz k\u00e9t p\u00e9ld\u00e1ny akkor egyenl\u0151, ha adataik egyenl\u0151ek</li> <li>k\u00f6nnyen immut\u00e1biliss\u00e1 tehet\u0151k, k\u00f6nnyen kezelhet\u0151k immut\u00e1bilis t\u00edpusk\u00e9nt</li> </ul> <p>A <code>Dog</code> t\u00edpus ezzel szemben jelenleg:</p> <ul> <li>nem immut\u00e1bilis, hiszen a sz\u00fclet\u00e9si d\u00e1tum b\u00e1rmikor m\u00f3dos\u00edthat\u00f3 (sima setter)</li> <li>egyenl\u0151s\u00e9gvizsg\u00e1lat sor\u00e1n a norm\u00e1l referencia szerinti \u00f6sszehasonl\u00edt\u00e1st k\u00f6vet</li> </ul> <p>Az automatikusan gener\u00e1l\u00f3d\u00f3 egyedi azonos\u00edt\u00f3t iktassuk ki a <code>Dog</code> oszt\u00e1lyb\u00f3l, hogy az adat alap\u00fa \u00f6sszehasonl\u00edt\u00e1st k\u00f6nnyebben tesztelhess\u00fck.</p> <pre><code>public Guid Id { get; } = Guid.Empty;\n</code></pre> <p>Vegy\u00fcnk fel egy logikailag megegyez\u0151 p\u00e9ld\u00e1nyt.</p> <pre><code>var watson = new Dog { Name = \"Watson\" };\nvar watson2 = new Dog { Name = watson.Name };\n</code></pre> <p>Ism\u00e9t \u00e1lljunk meg debug sor\u00e1n valamelyik <code>WriteLine</code> soron. A Locals ablakban n\u00e9zz\u00fck meg, hogy a k\u00e9t p\u00e9ld\u00e1ny minden adata megegyezik. A Watch ablakban (debuggol\u00e1s k\u00f6zben menu:Debug[Windows &gt; Watch &gt; Watch 1]) \u00e9rt\u00e9kelj\u00fck ki a <code>watson == watson2</code> kifejez\u00e9st. L\u00e1thatjuk, hogy ez az egyenl\u0151s\u00e9gvizsg\u00e1lat hamist ad, ami technikailag helyes, mert k\u00e9t k\u00fcl\u00f6nb\u00f6z\u0151 mem\u00f3riater\u00fcletr\u0151l van sz\u00f3, a referenci\u00e1k nem ugyanoda mutatnak a mem\u00f3ri\u00e1ban. Sok esetben azonban nem ezt szeretn\u00e9nk, hanem p\u00e9ld\u00e1ul a dupla r\u00f6gz\u00edt\u00e9s elker\u00fcl\u00e9s\u00e9re az adatok alapj\u00e1n t\u00f6rt\u00e9n\u0151 \u00f6sszehasonl\u00edt\u00e1st, ami \u00e9rt\u00e9k t\u00edpusokn\u00e1l van. Referencia t\u00edpusokn\u00e1l klasszikusan ezt a <code>GetHashCode</code>, <code>Equals</code> f\u00fcggv\u00e9nyek fel\u00fcldefini\u00e1l\u00e1s\u00e1val \u00e9rt\u00fck el (vagy az <code>IComparable&lt;T&gt;</code>, <code>IComparer&lt;T&gt;</code> interf\u00e9szre \u00e9p\u00fcl\u0151 logik\u00e1kkal). Egy \u00fajabb lehet\u0151s\u00e9g a rekord t\u00edpus haszn\u00e1lata.</p>"},{"location":"seminar/02-csharp2/chapter2/#pozicio-alapu-megadas","title":"Poz\u00edci\u00f3 alap\u00fa megad\u00e1s","text":"<p>Vegy\u00fcnk fel a <code>Dog</code> t\u00edpus adatainak megfelel\u0151 rekord t\u00edpust, mind\u00f6ssze egy kifejez\u00e9sk\u00e9nt. A <code>Dog</code> t\u00edpus al\u00e1:</p> <pre><code>public record class DogRec(\n    Guid Id,\n    string Name,\n    DateTime? DateOfBirth=null,\n    Dictionary&lt;string, object&gt; Metadata=null\n);\n</code></pre> <p>Note</p> <p>A <code>record class</code> jel\u00f6l\u0151b\u0151l a <code>class</code> elhagyhat\u00f3.</p> <p>Ez az \u00fan. poz\u00edci\u00f3 alap\u00fa megad\u00e1si forma, ami a legink\u00e1bb r\u00f6vid\u00edtett megad\u00e1si form\u00e1ja a rekord t\u00edpusnak. Ebb\u0151l a r\u00f6vid form\u00e1b\u00f3l, mindenfajta extra k\u00f3d \u00edr\u00e1sa n\u00e9lk\u00fcl a ford\u00edt\u00f3 sz\u00e1mos dolgot gener\u00e1l:</p> <ul> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1sb\u00f3l konstruktort \u00e9s dekonstruktort</li> <li>a z\u00e1r\u00f3jelen bel\u00fcli felsorol\u00e1s alapj\u00e1n propertyket <code>get</code> \u00e9s <code>init</code> tagf\u00fcggv\u00e9nyekkel</li> <li>alap\u00e9rtelmezett logik\u00e1t az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1shoz</li> <li>kl\u00f3noz\u00f3 \u00e9s m\u00e1sol\u00f3 konstruktor logik\u00e1kat</li> <li>alap\u00e9rtelmezett form\u00e1zott ki\u00edr\u00e1st, sz\u00f6veges reprezent\u00e1ci\u00f3t (<code>ToString</code> implement\u00e1ci\u00f3t)</li> </ul> <p>\u00cdgy egy k\u00f6nnyen kezelhet\u0151, immut\u00e1bilis, az \u00f6sszehasonl\u00edt\u00e1sokban \u00e9rt\u00e9k t\u00edpusk\u00e9nt viselked\u0151 adatoszt\u00e1lyunk lesz.</p> <p>Warning</p> <p>Az <code>Id</code>-nek nem tudjuk be\u00e1ll\u00edtani ebben a form\u00e1ban az alap\u00e9rtelmezett <code>Guid.Empty</code> \u00e9rt\u00e9ket vagy a <code>Metadata</code>-nak az \u00faj p\u00e9ld\u00e1nyt, mert az egyenl\u0151s\u00e9gjeles kifejez\u00e9sekb\u0151l alap\u00e9rtelmezett konstruktorparam\u00e9ter-\u00e9rt\u00e9kek lesznek, amik csak statikus, ford\u00edt\u00e1si id\u0151ben ki\u00e9rt\u00e9kelhet\u0151 kifejez\u00e9sek lehetnek.</p> <p>Vegy\u00fcnk fel a t\u00f6bbi Watson p\u00e9ld\u00e1ny mell\u00e9 k\u00e9t \u00fajabbat, de itt m\u00e1r az \u00faj rekord t\u00edpusunkat haszn\u00e1ljuk.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\");\n</code></pre> <p>A fentebbi Watch ablakos m\u00f3dszerrel ellen\u0151rizz\u00fck a <code>watson3 == watson4</code> kifejez\u00e9s \u00e9rt\u00e9k\u00e9t. Ez m\u00e1r igaz \u00e9rt\u00e9k lesz az adatmez\u0151 alap\u00fa \u00f6sszehasonl\u00edt\u00e1si logika miatt.</p> <p>Pr\u00f3b\u00e1ljuk ki ugyanezt a ki\u00e9rt\u00e9kel\u00e9st az al\u00e1bbi v\u00e1ltozattal:</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\n</code></pre> <p>Ez hamis \u00e9rt\u00e9ket ad, az egyenl\u0151s\u00e9gnek minden mez\u0151re teljes\u00fclnie kell, nem csak a mindkett\u0151ben kit\u00f6lt\u00f6ttekre.</p> <p>A <code>DogRec</code> t\u00edpus alapvet\u0151en immut\u00e1bilis, a p\u00e9ld\u00e1nyainak alapadatai inicializ\u00e1l\u00e1s ut\u00e1n nem m\u00f3dos\u00edthat\u00f3k. Pr\u00f3b\u00e1ljuk fel\u00fcl\u00edrni a nevet.</p> <pre><code>var watson3 = new DogRec(Guid.Empty, \"Watson\");\nvar watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nwatson4.Name = watson3.Name + \"_2\"; //&lt;= nem fordul\n</code></pre> <p>Nem fog lefordulni, mert minden property init-only t\u00edpus\u00fa. A sor jobboldala egy\u00e9bk\u00e9nt lefordulna, teh\u00e1t a lek\u00e9rdez\u00e9s (getter h\u00edv\u00e1s) m\u0171k\u00f6dne.</p> <p>Ha immut\u00e1bilis t\u00edpusokkal dolgozunk, akkor mut\u00e1ci\u00f3 helyett \u00faj p\u00e9ld\u00e1nyt hozunk l\u00e9tre megv\u00e1ltoztatott adatokkal. Alapvet\u0151en ezt az OO nyelvekben m\u00e1sol\u00f3 konstruktorral oldjuk meg. A rekord t\u00edpusn\u00e1l enn\u00e9l is tov\u00e1bbmenve m\u00e1sol\u00f3 kifejez\u00e9st haszn\u00e1lhatunk.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\n</code></pre> <p>Futtat\u00e1skor a konzolban gy\u00f6ny\u00f6rk\u00f6dj\u00fcnk a rekord t\u00edpusok alap\u00e9rtelmezetten is olvashat\u00f3 sz\u00f6veges ki\u00edr\u00e1s\u00e1ban.</p> <p>A m\u00e1sol\u00f3 kifejez\u00e9sben a <code>with</code> oper\u00e1tor el\u0151tt megadjuk, melyik p\u00e9ld\u00e1nyt kl\u00f3nozn\u00e1nk, majd az inicializ\u00e1ci\u00f3 r\u00e9szek\u00e9nt milyen \u00e9rt\u00e9keket \u00e1ll\u00edtan\u00e1nk \u00e1t, ehhez az objektum inicializ\u00e1ci\u00f3s szintaxist haszn\u00e1lhatjuk. Fontos esz\u00fcnkbe v\u00e9sni, hogy a m\u00e1sol\u00e1s eredm\u00e9nyek\u00e9nt \u00faj p\u00e9ld\u00e1ny j\u00f6n l\u00e9tre, \u00faj mem\u00f3riater\u00fclet foglal\u00f3dik le. Gondoljunk erre akkor, amikor egy ciklusban haszn\u00e1ljuk ezt a m\u00f3dszert sok egym\u00e1st k\u00f6vet\u0151 m\u00f3dos\u00edt\u00e1sra.</p> <p>Mire is j\u00f3 a rekord t\u00edpus</p> <p>Mire j\u00f3 a rekord t\u00edpus, az immutabilit\u00e1s? Az immut\u00e1bilis t\u00edpussokkal val\u00f3 hat\u00e9kony \u00e9s eredm\u00e9nyes munka m\u00e1sfajta, az imperat\u00edv nyelvekhez szokott fejleszt\u0151k sz\u00e1m\u00e1ra szokatlan m\u00f3dszereket k\u00edv\u00e1n. Vannak ter\u00fcletek, ahol ez a befektet\u00e9s megt\u00e9r\u00fcl, ilyen p\u00e9ld\u00e1ul a t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezet. A legt\u00f6bb sz\u00e1lkezel\u00e9ssel kapcsolatos probl\u00e9ma ugyanis a sz\u00e1lak \u00e1ltal k\u00f6z\u00f6sen haszn\u00e1lt adatstrukt\u00far\u00e1k mut\u00e1ci\u00f3j\u00e1ra vezethet\u0151 vissza (\u00fan. race condition, versenyhelyzet). Nincs mut\u00e1ci\u00f3 - nincs probl\u00e9ma. (No mutation - no cry)</p>"},{"location":"seminar/02-csharp2/chapter2/#kitero-a-szotar-visszavag","title":"Kit\u00e9r\u0151: a sz\u00f3t\u00e1r visszav\u00e1g","text":"<p>A rekord t\u00edpus \u00e1ltal biztos\u00edtott kellemes tulajdons\u00e1gok csak akkor \u00e9rv\u00e9nyesek, ha nem keverj\u00fck hagyom\u00e1nyos referencia t\u00edpusokkal.</p> <p>A szok\u00e1sos m\u00f3dszerrel ellen\u0151rizz\u00fck le, hogy a <code>watson5 == watson6</code> kifejez\u00e9s igaz-e. Igen, hiszen minden kit\u00f6lt\u00f6tt adatuk egyezik.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\" };\nvar watson6 = watson4 with { Name = \"Sherlock\" };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Vigy\u00fcnk be egy \u00e1rtatlan inicializ\u00e1ci\u00f3t a <code>Metadata</code> propertyre.</p> <pre><code>var watson4 = new DogRec(Guid.Empty, \"Watson\", DateTime.Now.AddYears(-1));\nvar watson5 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson6 = watson4 with { Name = \"Sherlock\", Metadata= new Dictionary&lt;string, object&gt;() };\nWriteLine(watson4);\nWriteLine(watson5);\nWriteLine(watson6);\n</code></pre> <p>Ezzel el\u00e9gg\u00e9 illogikus m\u00f3don hamisra v\u00e1ltozik a <code>watson5 == watson6</code> kifejez\u00e9s. Az oka az, hogy a <code>Metadata</code> sz\u00f3t\u00e1r egy klasszikus referencia t\u00edpus, az \u00f6sszehasonl\u00edt\u00e1sn\u00e1l a klasszikus mem\u00f3riac\u00edm-\u00f6sszehasonl\u00edt\u00e1s t\u00f6rt\u00e9nik, viszont az a k\u00e9t \u00faj sz\u00f3t\u00e1r p\u00e9ld\u00e1ny eset\u00e9ben elt\u00e9r\u0151 lesz. A form\u00e1zott sz\u00f6veges ki\u00edr\u00e1sba is belerond\u00edt a sz\u00f3t\u00e1r, mert ott is a sz\u00f3t\u00e1r t\u00edpus alap\u00e9rtelmezett sz\u00f6veges reprezent\u00e1ci\u00f3ja jut \u00e9rv\u00e9nyre, ami a t\u00edpus neve.</p> <p>Kl\u00f3nozzunk tov\u00e1bb, azt\u00e1n pr\u00f3b\u00e1ljunk mut\u00e1ci\u00f3t v\u00e9grehajtani a <code>Metadata</code> sz\u00f3t\u00e1ron.</p> <pre><code>var watson6 = watson4 with { Name = \"Sherlock\", Metadata = new Dictionary&lt;string, object&gt;() };\nvar watson7 = watson6 with { Name = \"Watson\" };\nwatson7.Metadata.Add(\"Chip azonos\u00edt\u00f3\", \"12345QQ\");\nWriteLine(watson4);\n</code></pre> <p>Ez lefordul, pedig ez mut\u00e1ci\u00f3. A Locals ablakban figyelj\u00fck meg a <code>watson6</code> \u00e9s <code>watson7</code> sz\u00f3t\u00e1rait: mindkett\u0151be beker\u00fclt a chip azonos\u00edt\u00f3. Ez az \u00fan. shallow copy jelens\u00e9g, amikor nem a sz\u00f3t\u00e1r mem\u00f3riater\u00fclete kl\u00f3noz\u00f3dik, csak a r\u00e1 mutat\u00f3 referencia, ami azt eredm\u00e9nyezi, hogy a k\u00e9t p\u00e9ld\u00e1nynak k\u00f6z\u00f6s sz\u00f3t\u00e1ra lesz.</p> <p>\u00d6sszess\u00e9g\u00e9ben az adatstrukt\u00far\u00e1nkban megjelen\u0151 klasszikus referencia t\u00edpus elrontja:</p> <ul> <li>az immutabilit\u00e1st</li> <li>az \u00e9rt\u00e9k szerinti \u00f6sszehasonl\u00edt\u00e1st</li> <li>a form\u00e1zott sz\u00f6veges megjelen\u00e9st</li> <li>a kl\u00f3noz\u00e1st</li> </ul> <p>Immutabilit\u00e1s</p> <p>Immut\u00e1bilis k\u00f6rnyezetben t\u00f6rekedj\u00fcnk arra, hogy a teljes adatstrukt\u00far\u00e1nk t\u00e1mogassa az immut\u00e1bilis kezel\u00e9st.</p>"},{"location":"seminar/02-csharp2/chapter2/#normal-megadas","title":"Norm\u00e1l megad\u00e1s","text":"<p>Ha nincs sz\u00fcks\u00e9g\u00fcnk a kik\u00e9nyszer\u00edtett immutabilit\u00e1sra, akkor haszn\u00e1lhatjuk a rekord norm\u00e1l megad\u00e1s\u00e1t. Fogjuk a <code>Dog</code> oszt\u00e1lyt, m\u00e1soljuk le a k\u00f3dj\u00e1t, adjunk neki m\u00e1s nevet \u00e9s <code>class</code> helyett <code>record</code> jel\u00f6l\u0151t.</p> <p>A <code>Dog</code> oszt\u00e1ly f\u00f6l\u00e9:</p> <pre><code>public record DogRecExt\n{\n    public string Name { get; init; }\n    public Guid Id { get; } = Guid.Empty;\n    public DateTime? DateOfBirth { get; set; }\n    public Dictionary&lt;string, object&gt; Metadata { get; } = new();\n\n    private int? AgeInDays =&gt; (-DateOfBirth?.Subtract(DateTime.Now))?.Days;\n    public int? Age =&gt; AgeInDays / 365;\n    public int? AgeInDogYears =&gt; AgeInDays * 7 / 365;\n\n    public object this[string key]\n    {\n        get { return Metadata[key]; }\n        set { Metadata[key] = value; }\n    }\n}\n</code></pre> <p>ToString</p> <p>A <code>ToString</code> implement\u00e1ci\u00f3j\u00e1t elhagytuk az el\u0151z\u0151 szakaszban eml\u00edtettek miatt.</p> <p>A <code>Program.cs</code>-be:</p> <pre><code>var watson8 = new DogRecExt { Name = \"Watson\" };\nwatson8.DateOfBirth = DateTime.Now.AddYears(-15);\nvar watson9 = watson8 with { };\nWriteLine(watson8);\nWriteLine(watson9);\n</code></pre> <p>Ellen\u0151rizz\u00fck le a rekord tulajdons\u00e1gokat:</p> <ul> <li>A konzol kimeneten a form\u00e1z\u00e1st, tov\u00e1bb\u00e1 a mut\u00e1ci\u00f3 m\u0171k\u00f6d\u00e9s\u00e9t, azaz a <code>watson8</code> sz\u00fclet\u00e9si d\u00e1tuma a be\u00e1ll\u00edtott lesz.</li> <li>Ez nem csoda, hiszen a property deklar\u00e1ci\u00f3ban engedt\u00fck a mut\u00e1ci\u00f3t.</li> <li>A konzol kimeneten megfigyelt p\u00e9ld\u00e1nyadatokon a kl\u00f3noz\u00f3 kifejez\u00e9s m\u0171k\u00f6d\u00e9s\u00e9t. Semmi k\u00fcl\u00f6n\u00f6s, ugyan\u00fagy m\u0171k\u00f6dik, mint a t\u00f6m\u00f6r form\u00e1n\u00e1l.</li> <li>A Watch ablakban <code>watson8 == watson9</code> egyenl\u0151s\u00e9get. Ez igaz, mert minden adattagjuk egyezik.</li> </ul> <p>record struct</p> <p>A rekordoknak tov\u00e1bbi v\u00e1lfajai vannak, ugyanis strukt\u00fara is lehet rekord, ilyenkor a <code>record struct</code> kulcssz\u00f3 p\u00e1rt haszn\u00e1ljuk a t\u00edpus deklar\u00e1ci\u00f3j\u00e1n\u00e1l. S\u0151t, a <code>readonly record struct</code> egy immut\u00e1bilis <code>record struct</code>. Ezen v\u00e1lfajok nyilv\u00e1n k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek, mely viselked\u00e9seket itt most nem r\u00e9szletezz\u00fck, de a dokument\u00e1ci\u00f3ban megtal\u00e1lhat\u00f3k.</p>"},{"location":"seminar/03-linq/chapter3/","title":"LINQ","text":""},{"location":"seminar/03-linq/chapter3/#elokeszites","title":"El\u0151k\u00e9sz\u00edt\u00e9s","text":"<p>A gyakorlat kezdet\u00e9n kl\u00f3nozzuk le a kiindul\u00f3 projektet az al\u00e1bbi paranccsal:</p> <pre><code>git clone https://github.com/bmeviauav23/Linq-lab.git\n</code></pre> <p>Nyissuk meg Visual Studio-ban a HelloLinq.sln solution f\u00e1jlt.</p> <p>Megnyit\u00e1s ut\u00e1n tekints\u00fck \u00e1t a kiindul\u00f3 projektben lev\u0151 f\u00e1jlokat:</p> <ul> <li>Program.cs: a legfels\u0151 szint\u0171 k\u00f3dot tartalmaz\u00f3 oszt\u00e1ly. Tal\u00e1lhat\u00f3 benne egy <code>Dogs</code> v\u00e1ltoz\u00f3, ami a <code>Dog</code> oszt\u00e1ly statikus <code>Repository</code> tulajdons\u00e1g\u00e1ba h\u00edv \u00e1t.</li> <li>Dog.cs: a kor\u00e1bbi gyakorlatokon haszn\u00e1lt adatmodell (apr\u00f3bb m\u00f3dos\u00edt\u00e1sokkal).<ul> <li>Beker\u00fclt egy <code>Siblings</code> tulajdons\u00e1g, a <code>ToString</code> pedig ki\u00edrja a kuty\u00e1hoz tartoz\u00f3 testv\u00e9rek sz\u00e1m\u00e1t is (ehhez a <code>TrimPad</code> b\u0151v\u00edt\u0151 met\u00f3dust haszn\u00e1lja).</li> <li>A statikus <code>Repository</code> tulajdons\u00e1g m\u00f6g\u00f6tt egy lust\u00e1n inicializ\u00e1lt <code>Lazy&lt;T&gt; RepositoryHolder</code> tal\u00e1lhat\u00f3, ami egy megfelel\u0151en form\u00e1zott bemeneti CSV f\u00e1jlb\u00f3l elk\u00e9sz\u00edti sz\u00e1munkra az adatmodellt, amivel a k\u00e9s\u0151bbiekben dolgozunk. Ennek implement\u00e1ci\u00f3j\u00e1t el\u00e9g a gyakorlat v\u00e9g\u00e9n megn\u00e9zni. Az <code>Import</code> \u00e9s <code>Export</code> f\u00fcggv\u00e9nyek a kuty\u00e1k soros\u00edt\u00e1s\u00e1t v\u00e9gzik el mindk\u00e9t ir\u00e1nyban.</li> </ul> </li> <li>Extensions/StringExtensions.cs: ez az oszt\u00e1ly tartalmaz egy seg\u00e9dmet\u00f3dust a form\u00e1zott ki\u00edr\u00e1shoz. A <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel. A b\u0151v\u00edt\u0151 met\u00f3dusos r\u00e9szben lesz jelent\u0151s\u00e9ge.</li> <li>dogs.csv: egy pontosvessz\u0151vel tagolt adathalmaz, amelyben 100 darab el\u0151re felvett kutya adata tal\u00e1lhat\u00f3. Innen pusk\u00e1zhatunk, ha ellen\u0151rizni akarjuk, hogy helyesek-e a programunk eredm\u00e9nyei.</li> </ul> <p>A kiindul\u00f3 projektben a glob\u00e1lis implicit n\u00e9vt\u00e9rhivatkoz\u00e1sok ki vannak kapcsolva. A csproj f\u00e1jlban megn\u00e9zhetj\u00fck (menu:jobb klikk a projekten[Edit Project File]):</p> <pre><code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;\n</code></pre>"},{"location":"seminar/03-linq/chapter3/#lambda-kifejezesek-delegatok","title":"Lambda kifejez\u00e9sek, deleg\u00e1tok","text":"<p>Gyakori feladat, hogy objektumok kollekci\u00f3j\u00e1val kell dolgoznunk. K\u00e9pesek vagyunk olyan jelleg\u0171 seg\u00e9df\u00fcggv\u00e9nyeket k\u00e9sz\u00edteni, amik p\u00e9ld\u00e1ul egy kollekci\u00f3ban kikeresik az \u00f6sszes olyan elemet, amely egy megadott felt\u00e9telnek eleget tesz.</p> <p>A <code>Program.cs</code> f\u00e1jlban l\u00e1that\u00f3 ennek a kezdeti naiv v\u00e1ltozata, szemrev\u00e9telezz\u00fck:</p> <pre><code>static List&lt;Dog&gt; ListDogsByNamePrefix(IEnumerable&lt;Dog&gt; dogs, string prefix)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (dog.Name.StartsWith(prefix, StringComparison.OrdinalIgnoreCase))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>A k\u00f3d m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3.  Ha b\u00e1rmi m\u00e1s alapj\u00e1n szeretn\u00e9nk keresni a kuty\u00e1k k\u00f6z\u00f6tt (pl. a neve tartalmaz-e egy adott sz\u00f6vegr\u00e9szt), mindig egy \u00faj seg\u00e9df\u00fcggv\u00e9nyt kell k\u00e9sz\u00edten\u00fcnk, ami rontja a k\u00f3d \u00fajrahasznos\u00edthat\u00f3s\u00e1g\u00e1t.</p> <p>Oldjuk meg \u00fagy, hogy az \u00e1ltal\u00e1nos probl\u00e9m\u00e1t is megoldjuk! Ehhez az sz\u00fcks\u00e9ges, hogy a kollekci\u00f3nk egyes elemein ki\u00e9rt\u00e9kelhess\u00fcnk egy, a h\u00edv\u00f3 \u00e1ltal megadott predik\u00e1tumot. K\u00e9sz\u00edts\u00fck el az \u00e1ltal\u00e1nosabb v\u00e1ltozatot, ehhez felhaszn\u00e1lhatjuk a <code>ListDogsByNamePrefix</code> k\u00f3dj\u00e1t.</p> <pre><code>static List&lt;Dog&gt; ListDogsByPredicate(\n    IEnumerable&lt;Dog&gt; dogs, Predicate&lt;Dog&gt; predicate)\n{\n    var result = new List&lt;Dog&gt;();\n    foreach (var dog in dogs)\n    {\n        if (predicate(dog))\n        {\n            result.Add(dog);\n        }\n    }\n    return result;\n}\n</code></pre> <p>A legfels\u0151 szint\u0171 k\u00f3dban \u00edgy h\u00edvhatjuk meg (felhaszn\u00e1lhatjuk az eredeti ciklust):</p> <pre><code>foreach(var dog in ListDogsByPredicate(Dogs, delegate (Dog d) \n    {\n        return d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n    })\n)\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Egy egy bemen\u0151 param\u00e9ter\u0171 \u00e9s egy logikai (<code>bool</code>) \u00e9rt\u00e9ket visszad\u00f3 f\u00fcggv\u00e9nyt defini\u00e1lunk helyben (inline) \u00e9s ezt (illetve a referenci\u00e1j\u00e1t) adjuk \u00e1t. Haszn\u00e1ljunk ink\u00e1bb lambda kifejez\u00e9st, az j\u00f3val r\u00f6videbben le\u00edrhat\u00f3 - egyel\u0151re csak n\u00e9zz\u00fck meg, de ne integr\u00e1ljuk a k\u00f3dba:</p> <pre><code>d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Lambda kifejez\u00e9sek szintaktik\u00e1ja</p> <p>Lambda kifejez\u00e9ssel az egyetlen kifejez\u00e9sb\u0151l \u00e1ll\u00f3 f\u00fcggv\u00e9nyeket adhatjuk meg nagyon kompakt m\u00f3don. A <code>=&gt;</code>-t\u00f3l balra elnevezz\u00fck a bemen\u0151 param\u00e9tereket, jobbra pedig felhaszn\u00e1l(hat)juk. A <code>return</code>, <code>{}</code> \u00e9s egy\u00e9b sallangokat elhagyhatjuk.</p> <p>Vess\u00fck \u00f6ssze, hogy az els\u0151 esetben explicit megadtuk, hogy a bemen\u0151 param\u00e9ter\u00fcnk <code>Dog</code>, most viszont nem. Ezt a ford\u00edt\u00f3 statikus k\u00f3danal\u00edzis alapj\u00e1n el tudja d\u00f6nteni: a <code>d</code> v\u00e1ltoz\u00f3nk nem lehet m\u00e1s, csak <code>Dog</code> (statikus) t\u00edpus\u00fa, ez\u00e9rt csak \u00edgy haszn\u00e1lhatjuk, viszont nem kell ki\u00edrnunk a t\u00edpust.</p> <p>A lambda kifejez\u00e9sek egy lehets\u00e9ges m\u00f3dja a deleg\u00e1tok le\u00edr\u00e1s\u00e1nak. A deleg\u00e1t k\u00f3dot reprezent\u00e1l, viszont a k\u00f3dot kezelhetj\u00fck adatk\u00e9nt is.</p> <p>Pr\u00f3b\u00e1ljuk meg a deleg\u00e1tunkat kivenni egy implicit t\u00edpus\u00fa v\u00e1ltoz\u00f3ba a ciklus el\u0151tt:</p> <pre><code>// ford\u00edt\u00e1si hiba!\nvar predicate = \n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\nforeach (var dog in ListDogsByPredicate(Dogs, predicate))\n{\n    Console.WriteLine(dog);\n}\n</code></pre> <p>Ford\u00edt\u00e1si hib\u00e1t kapunk, lambda kifejez\u00e9s t\u00edpusa nem lehet implicit eld\u00f6nthet\u0151 az inicializ\u00e1ci\u00f3s sorban: sem a bemen\u0151 param\u00e9ter pontos t\u00edpus\u00e1t nem tudjuk (<code>Dog</code>? <code>Puppy</code>?), sem a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket (<code>bool</code>? <code>object</code>? <code>void</code>?). Teh\u00e1t explicit meg kell adnunk a t\u00edpust:</p> <pre><code>Predicate&lt;Dog&gt; predicate =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Ezut\u00e1n fordul \u00e9s fut is az alkalmaz\u00e1sunk.</p> <p>Predicate be\u00e9p\u00edtett deleagate t\u00edpus</p> <p>Ehhez tudnunk kellett, hogy a <code>Predicate&lt;T&gt;</code> megfelel\u0151 szignat\u00far\u00e1j\u00fa. Mutassuk meg ezen t\u00edpus dokument\u00e1ci\u00f3j\u00e1t vagy tegy\u00fck a kurzort a t\u00edpusra \u00e9s nyomjunk F12-t.</p>"},{"location":"seminar/03-linq/chapter3/#func-action","title":"<code>Func&lt;&gt;</code>, <code>Action&lt;&gt;</code>","text":"<p>Ismerkedj\u00fcnk meg a <code>Func</code> \u00e9s <code>Action</code> \u00e1ltal\u00e1nos deleg\u00e1tt\u00edpusokkal. Ezzel a k\u00e9t generikus t\u00edpussal (pontosabban a v\u00e1ltozataikkal) gyakorlatilag az \u00f6sszes gyakorlatban el\u0151fordul\u00f3 f\u00fcggv\u00e9nyszignat\u00far\u00e1t le lehet fedni. P\u00e9ld\u00e1ul a fenti sz\u0171r\u0151logik\u00e1t is \u00e1t\u00edrhatn\u00e1nk erre:</p> <pre><code>Func&lt;Dog, bool&gt; dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A <code>dogFunc</code> \u00e9s a <code>predicate</code> kompatibilisnek t\u0171nhetnek (elv\u00e9gre a jobboldaluk ugyanaz), \u00e1m ha lecser\u00e9ln\u00e9nk pl. a <code>ListDogsByPredicate(Dogs, predicate)</code> h\u00edv\u00e1sban a <code>predicate</code>-et <code>dogFunc</code>-ra, a k\u00f3d nem fordulna, ugyanis a k\u00e9t deleg\u00e1tt\u00edpus nem kompatibilis.</p> <p>Az <code>Action&lt;&gt;</code> hasonl\u00f3 elven m\u0171k\u00f6dik, visszat\u00e9r\u00e9si \u00e9rt\u00e9k n\u00e9lk\u00fcli f\u00fcggv\u00e9nyekre.</p> <p>Egy\u00e9b delegate t\u00edpusok</p> <p>Ha minden esetre j\u00f3k, mi\u00e9rt vannak haszn\u00e1latban <code>Action&lt;&gt;</code> \u00e9s <code>Func&lt;&gt;</code>-on k\u00edv\u00fcl m\u00e1s deleg\u00e1tt\u00edpusok? Egyr\u00e9szt t\u00f6rt\u00e9nelmi okok miatt. K\u00e9s\u0151bb jelentek meg, mint a specifikusak, p\u00e9ld\u00e1ul a <code>Predicate&lt;T&gt;</code>. M\u00e1sr\u00e9szt a specifikusabbak a nev\u00fckkel kifejez\u0151bbek lehetnek.</p> <p>Tiszta f\u00fcggv\u00e9nyek</p> <p>A fenti predik\u00e1tumv\u00e1ltozataink mind nem tiszta f\u00fcggv\u00e9nyek (pure function), ugyanis olyan adatt\u00f3l is f\u00fcgg a visszat\u00e9r\u00e9si \u00e9rt\u00e9ke, ami nem szerepel a param\u00e9terlist\u00e1j\u00e1n - ez eset\u00fcnkben a <code>searchText</code> v\u00e1ltoz\u00f3. A k\u00f3dunk az\u00e9rt m\u0171k\u00f6dik, mert a deleg\u00e1t megad\u00e1sakor a <code>searchText</code> aktu\u00e1lis \u00e9rt\u00e9k\u00e9t elkapjuk (capture), belerakjuk a f\u00fcggv\u00e9nylogik\u00e1ba.</p> <p>Pr\u00f3b\u00e1ljuk a <code>dogFunc</code>-ot <code>var</code>-k\u00e9nt deklar\u00e1lni.</p> <pre><code>//Ford\u00edt\u00e1si hiba!\nvar dogFunc =\n    d =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>A ford\u00edt\u00f3 nem tudja meghat\u00e1rozni a <code>d</code> param\u00e9ter t\u00edpus\u00e1t, ez\u00e9rt kapjuk a ford\u00edt\u00e1si hib\u00e1t. Adjuk meg explicit a param\u00e9ter t\u00edpus\u00e1t.</p> <pre><code>var dogFunc =\n    (Dog d) =&gt; d.Name.StartsWith(searchText, StringComparison.OrdinalIgnoreCase);\n</code></pre> <p>Debugger-rel ellen\u0151rizhetj\u00fck, hogy a <code>dogFunc</code> val\u00f3di t\u00edpusa <code>Func&lt;Dog, bool&gt;</code> lesz.</p>"},{"location":"seminar/03-linq/chapter3/#ienumerablet-bovito-metodusok","title":"IEnumerable\\&lt;T&gt; b\u0151v\u00edt\u0151 met\u00f3dusok","text":"<p>Vigy\u00fck tov\u00e1bb az \u00e1ltal\u00e1nos\u00edt\u00e1st. \u00cdrjunk olyan logik\u00e1kat, mely nem csak kuty\u00e1k list\u00e1j\u00e1ra, hanem b\u00e1rmilyen felsorolhat\u00f3 (enumer\u00e1lhat\u00f3) kollekci\u00f3ra m\u0171k\u00f6dik. \u00cdrjunk <code>IEnumerable&lt;T&gt;</code> t\u00edpuson m\u0171k\u00f6d\u0151 seg\u00e9df\u00fcggv\u00e9nyeket.</p> <p>Hozzunk l\u00e9tre egy <code>EnumerableExtensions</code> (I bet\u0171 n\u00e9lk\u00fcl, az ugyanis interf\u00e9szre utal) nev\u0171 f\u00e1jlt az <code>Extensions</code> mapp\u00e1ban! Els\u0151k\u00e9nt val\u00f3s\u00edtsuk meg az \u00f6sszegz\u0151 logik\u00e1t.</p> <pre><code>namespace HelloLinq.Extensions.Enumerable;\n\npublic static class EnumerableExtensions\n{\n    public static int Sum&lt;T&gt; (IEnumerable&lt;T&gt;  source, Func&lt;T, int&gt;  sumSelector)\n    {\n        var result = 0;\n        foreach (var elem in source)\n        {\n            result += sumSelector(elem);\n        }\n        return result;\n    }\n}\n</code></pre> <p>H\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3db\u00f3l.</p> <pre><code>using HelloLinq.Extensions.Enumerable;\n\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\nforeach (var dog in Dogs)\n{\n    Console.WriteLine(dog);\n}\n\nConsole.WriteLine(\n    \"\u00c9letkorok \u00f6sszege: \" \n    + $\"{EnumerableExtensions.Sum(Dogs, d =&gt; d.Age ?? 0)}\");\n\nstring searchText;\n</code></pre> <p>A seg\u00e9df\u00fcggv\u00e9nyek h\u00e1tr\u00e1nya, hogy ismern\u00fcnk kell a seg\u00e9doszt\u00e1ly nev\u00e9t. Tov\u00e1bb\u00e1 jobb lenne, ha a kollekci\u00f3n k\u00f6zvetlen\u00fcl h\u00edvhatn\u00e1nk az \u00f6sszegz\u0151 f\u00fcggv\u00e9nyt. Erre megold\u00e1s a b\u0151v\u00edt\u0151 met\u00f3dus.</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok:</p> <ul> <li>statikus oszt\u00e1lyban defini\u00e1lhat\u00f3k</li> <li>statikus f\u00fcggv\u00e9nyek</li> <li>els\u0151 param\u00e9tere el\u0151tt <code>this</code> jel\u00f6li, hogy melyik t\u00edpust b\u0151v\u00edtik</li> </ul> <p>Az els\u0151 param\u00e9ter el\u00e9 tegy\u00fck be a <code>this</code> jel\u00f6l\u0151t.</p> <pre><code>public static int Sum&lt;T&gt; (\n    this IEnumerable&lt;T&gt;  source,\n    Func&lt;T, int&gt;  sumSelector)\n    {\n        // ...\n    }\n</code></pre> <p>Most m\u00e1r haszn\u00e1lhatjuk azt a szintaxist, mintha a kollekci\u00f3nak eleve lenne \u00f6sszegz\u0151 f\u00fcggv\u00e9nye:</p> <pre><code>Console.WriteLine($\"\u00c9letkorok \u00f6sszege: {Dogs.Sum(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>OO egys\u00e9gbez\u00e1r\u00e1si elv</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok semmilyen m\u00f3don nem bontj\u00e1k meg a t\u00edpusok egys\u00e9gbez\u00e1r\u00e1si k\u00e9pess\u00e9geit. A f\u00fcggv\u00e9nyek implement\u00e1ci\u00f3i a b\u0151v\u00edtend\u0151 t\u00edpusok k\u00edv\u00fclr\u0151l is el\u00e9rhet\u0151 f\u00fcggv\u00e9nyeit, propertyjeit haszn\u00e1lhatj\u00e1k, priv\u00e1t adattagokhoz, f\u00fcggv\u00e9nyekhez nem f\u00e9rnek hozz\u00e1.</p> <p>Oszt\u00e1ly nev\u00e9nek felold\u00e1sa</p> <p>A b\u0151v\u00edt\u0151 met\u00f3dusok alkalmaz\u00e1sakor nagyon fontos, hogy b\u00e1r a b\u0151v\u00edt\u0151 met\u00f3dus oszt\u00e1ly\u00e1nak nev\u00e9t nem \u00edrjuk ki, az oszt\u00e1ly nev\u00e9nek feloldhat\u00f3nak kell lennie, azaz az oszt\u00e1ly n\u00e9vter\u00e9t <code>using</code> direkt\u00edv\u00e1val be kell hivatkoznunk. Egy pr\u00f3ba erej\u00e9ig kommentezz\u00fck ki a <code>using HelloLinq.Extensions.Enumerable;</code> sort \u00e9s ellen\u0151rizz\u00fck, hogy nem fordul a k\u00f3dunk, a b\u0151v\u00edt\u0151 met\u00f3dus nev\u00e9t a ford\u00edt\u00f3 nem tudja feloldani.</p> <p>Gyakorl\u00e1sk\u00e9ppen \u00edrhatunk tov\u00e1bbi gyakori adatfeldolgoz\u00e1si m\u0171veletekre f\u00fcggv\u00e9nyeket, mint amilyen az \u00e1tlagsz\u00e1m\u00edt\u00e1s, min-max keres\u00e9s.</p> Megold\u00e1s <pre><code>public static class EnumerableExtensions\n{\n    //...\n\n    public static double Average&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; sumSelector)\n    {\n        var result = 0.0; // Az oszt\u00e1s m\u0171velet miatt double\n        var elements = 0;\n        foreach (var elem in source)\n        {\n            elements++;\n            result += sumSelector(elem);\n        }\n        return result / elements;\n    }\n\n    public static int Min&lt;T&gt;(this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n    {\n        int value = int.MaxValue;\n        foreach (var elem in source)\n        {\n            var currentValue = valueSelector(elem);\n            if (currentValue &lt; value)\n            {\n                value = currentValue;\n            }\n        }\n        return value;\n    }\n\n    public static int Max&lt;T&gt; (this IEnumerable&lt;T&gt; source, Func&lt;T, int&gt; valueSelector)\n        =&gt; -source.Min(e =&gt; -valueSelector(e));\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki az \u00faj f\u00fcggv\u00e9nyeket. Mivel a <code>Dogs</code> t\u00edpusa <code>IEnumerable&lt;Dog&gt;</code>, \u00edgy a b\u0151v\u00edt\u0151 met\u00f3dusok b\u0151v\u00edtend\u0151 t\u00edpusa illeszkedik r\u00e1.</p> <pre><code>Console.WriteLine($\"\u00c1tlagos \u00e9letkor: {Dogs.Average(d =&gt; d.Age ?? 0)}\");\nConsole.WriteLine(\n    $\"Minimum-maximum \u00e9letkor: \" +\n    $\"{Dogs.Min(d =&gt; d.Age ?? 0)} | {Dogs.Max(d =&gt; d.Age ?? 0)}\");\n</code></pre> <p>StringExtensions.cs</p> <p>A <code>StringExtensions</code> oszt\u00e1lyban egy lambdak\u00e9nt megval\u00f3s\u00edtott b\u0151v\u00edt\u0151 met\u00f3dust l\u00e1thatunk, ami egy sz\u00f6veget adott hosszra (sz\u00e9less\u00e9gre) eg\u00e9sz\u00edt ki sz\u00f3k\u00f6z\u00f6kkel. A f\u00fcggv\u00e9nyt a <code>Dog</code> <code>ToString</code> met\u00f3dusa haszn\u00e1lja fel.</p>"},{"location":"seminar/03-linq/chapter3/#gyakori-lekerdezo-muveletek-yield-return","title":"Gyakori lek\u00e9rdez\u0151 m\u0171veletek, yield return","text":"<p>Gyakran el\u0151fordul, hogy egy list\u00e1t sz\u0171rni vagy projekt\u00e1lni szeretn\u00e9nk. \u00cdrjunk saj\u00e1t gener\u00e1tort ezekhez a m\u0171veletekhez is az <code>EnumerableExtensions</code>-be:</p> <pre><code>public static IEnumerable&lt;T&gt; Where&lt;T&gt;(\n    this IEnumerable&lt;T&gt;  source, Predicate&lt;T&gt;  predicate)\n{\n    foreach (var elem in source)\n    {\n        if (predicate(elem))\n        {\n            yield return elem;\n        }\n    }\n}\n\npublic static IEnumerable&lt;TValue&gt; Select&lt;T, TValue&gt;(\n    this IEnumerable&lt;T&gt;  source, Func&lt;T, TValue&gt; selector)\n{\n    foreach (var elem in source)\n    {\n        yield return selector(elem);\n    }\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n, v\u00e1lasszuk ki a 2010 el\u0151tt sz\u00fcletett kuty\u00e1k nev\u00e9t \u00e9s kor\u00e1t egy stringbe:</p> <pre><code>foreach (var text in Dogs\n    .Where(d =&gt; d.DateOfBirth?.Year &lt; 2010)\n    .Select(d =&gt; $\"{d.Name} ({d.Age})\"))\n{\n    Console.WriteLine(text);\n}\n</code></pre> <p>A yield return haszna</p> <p>A <code>yield return</code> egy hasznos eszk\u00f6z, ha IEnumerable-t kell produk\u00e1lnunk visszat\u00e9r\u00e9si \u00e9rt\u00e9kk\u00e9nt. Seg\u00edts\u00e9g\u00e9vel mindig csak akkor \u00e1ll\u00edtjuk el\u0151 a k\u00f6vetkez\u0151 elemet, amikor a h\u00edv\u00f3 k\u00e9ri. A m\u0171k\u00f6d\u00e9s\u00e9t debuggerrel is figyelj\u00fck meg: tegy\u00fcnk breakpointot a k\u00e9t <code>yield return</code> sorra, majd F10-zel k\u00f6vess\u00fck v\u00e9gig, ahogy a <code>foreach</code> elk\u00e9ri a <code>Select</code>-t\u0151l a k\u00f6vetkez\u0151 elemet, ami emiatt elk\u00e9ri a <code>Where</code>-t\u0151l, majd \u00fajraindul a ciklus. A h\u00edv\u00e1sok \u00e1llapotg\u00e9pk\u00e9nt m\u0171k\u00f6dnek, a k\u00f6vetkez\u0151 megh\u00edv\u00e1skor onnan folytat\u00f3dnak, ahonnan az el\u0151z\u0151 <code>yield return</code>-n\u00e9l kil\u00e9pt\u00fcnk.</p> <p>Nem nagy meglepet\u00e9s, hogy az \u00e1ltalunk meg\u00edrt <code>Sum</code>, <code>Average</code> (melyek egyedi visszat\u00e9r\u00e9s\u0171ek), <code>Select</code> \u00e9s <code>Where</code> (amik szekvenci\u00e1lis visszat\u00e9r\u00e9s\u0171ek, gener\u00e1torok) met\u00f3dusok mind a .NET keretrendszer r\u00e9sz\u00e9t k\u00e9pezik (a <code>System.Linq.Enumerable</code> statikus oszt\u00e1lyban defini\u00e1lt b\u0151v\u00edt\u0151 met\u00f3dusok). A LINQ\u2009\u2014\u2009**L**anguage **IN**tegrated **Q**uery\u2009\u2014\u2009ezeket a m\u0171veleteket teszi lehet\u0151v\u00e9 <code>IEnumerable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 objektumokon. A LINQ f\u00fcggv\u00e9nyek b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt lettek hozz\u00e1adva meglev\u0151 funkcionalit\u00e1shoz (kollekci\u00f3khoz, lek\u00e9rdez\u00e9sekhez), s\u0151t, k\u00fcls\u0151 library-k is adnak saj\u00e1t LINQ b\u0151v\u00edt\u0151 met\u00f3dusokat.</p> <p>Cser\u00e9lj\u00fck le a <code>Program.cs</code>-ben a <code>using HelloLinq.Extensions.Enumerable</code> hivatkoz\u00e1st <code>using System.Linq</code>-re: az \u00e1ltalunk meg\u00edrt k\u00f3d tov\u00e1bbra is ugyanazt az eredm\u00e9nyt produk\u00e1lja! N\u00e9zz\u00fck meg, hogy hol vannak defini\u00e1lva ezek a f\u00fcggv\u00e9nyek a keretrendszeren bel\u00fcl: a kurzort tegy\u00fck a k\u00f3dban oda, ahol valamelyik kor\u00e1bban meg\u00edrt f\u00fcggv\u00e9ny\u00fcnket h\u00edvn\u00e1nk, majd nyomjunk F12-t. Pr\u00f3b\u00e1ljuk ki, hogy tov\u00e1bbra is az elv\u00e1rt m\u00f3don m\u0171k\u00f6dik-e a programunk.</p> <p>Implicit usings</p> <p>A n\u00e9vt\u00e9rcsere helyett bekapcsolhatjuk a glob\u00e1lis implicit n\u00e9vt\u00e9r funkci\u00f3t, mert a <code>System.Linq</code> n\u00e9vt\u00e9r is egy implicit hivatkozott n\u00e9vt\u00e9r. Ehhez a projektf\u00e1jlban az <code>&lt;ImplicitUsings&gt;disable&lt;/ImplicitUsings&gt;</code> be\u00e1ll\u00edt\u00e1st \u00edrjuk \u00e1t <code>enable</code>-re, majd a <code>using HelloLinq</code> -en k\u00edv\u00fcl minden n\u00e9vt\u00e9rhivatkoz\u00e1st t\u00f6r\u00f6lj\u00fcnk a <code>Program.cs</code>-b\u0151l.</p>"},{"location":"seminar/03-linq/chapter3/#anonim-tipusok","title":"Anonim t\u00edpusok","text":"<p>Lek\u00e9rdez\u00e9sekn\u00e9l gyakran haszn\u00e1latosak az anonim t\u00edpusok, amelyeket jellemz\u0151en lek\u00e9rdez\u00e9sek eredm\u00e9ny\u00e9nek ideiglenes, t\u00edpusos t\u00e1rol\u00e1s\u00e1ra haszn\u00e1lunk. Az anonim t\u00edpusokkal lehet\u0151s\u00e9g\u00fcnk van inline defini\u00e1lni olyan oszt\u00e1lyokat, amelyek jellemz\u0151en csak dobozol\u00e1sra \u00e9s adattov\u00e1bb\u00edt\u00e1sra haszn\u00e1ltak. Vegy\u00fck az al\u00e1bbi p\u00e9ld\u00e1kat a legfels\u0151 szint\u0171 k\u00f3d elej\u00e9n:</p> <pre><code>var dolog1 = new { Name = \"Alma\", Weight = 100, Size = 10 };\nvar dolog2 = new { Name = \"K\u00f6rte\", Weight = 90 };\n</code></pre> <p>Kor\u00e1bban m\u00e1r eml\u00edtett\u00fck a <code>var</code> kulcssz\u00f3t, amellyel implicit t\u00edpus\u00fa, lok\u00e1lis v\u00e1ltoz\u00f3k defini\u00e1lhat\u00f3k. Az \u00e9rt\u00e9kad\u00e1s jobb oldal\u00e1n defini\u00e1lunk egy-egy anonim t\u00edpust, amelynek felvesz\u00fcnk n\u00e9h\u00e1ny tulajdons\u00e1got. A tulajdons\u00e1gok mind t\u00edpusosak maradnak, a t\u00edpusrendszer\u00fcnk tov\u00e1bbra is s\u00e9rtetlen. Az implicit statikus t\u00edpusoss\u00e1g nem csak a <code>var</code> kulcssz\u00f3ban jelenik meg teh\u00e1t, hanem az egyes tulajdons\u00e1gok t\u00edpus\u00e1ban is.</p> <p>Az anonim t\u00edpusok:</p> <ul> <li>csak referencia t\u00edpus\u00faak lehetnek (objektumok, nem pedig strukt\u00far\u00e1k),</li> <li>csak publikusan l\u00e1that\u00f3, csak olvashat\u00f3 tulajdons\u00e1gokat tartalmazhatnak,</li> <li>esem\u00e9nyeket \u00e9s met\u00f3dusokat nem tartalmazhatnak (delegate p\u00e9ld\u00e1nyokat tulajdons\u00e1gban viszont igen),</li> <li>szerelv\u00e9nyen bel\u00fcl l\u00e1that\u00f3k (<code>internal</code>) \u00e9s nem sz\u00e1rmazhat bel\u0151l\u00fck m\u00e1sik t\u00edpus (<code>sealed</code>)</li> <li>t\u00edpusnev\u00e9t nem ismerj\u00fck, \u00edgy hivatkozni sem tudunk r\u00e1, csak a <code>var</code>-t tudjuk haszn\u00e1lni</li> <li>nem haszn\u00e1lhat\u00f3k ott, ahol a <code>var</code> t\u00edpus se haszn\u00e1lhat\u00f3, t\u00f6bbek k\u00f6z\u00f6tt nem adhatjuk \u00e1t f\u00fcggv\u00e9nynek \u00e9s nem lehet visszat\u00e9r\u00e9si \u00e9rt\u00e9k sem</li> </ul> <p>Ha az egeret a <code>var</code> kulcsszavak vagy egyes tulajdons\u00e1gnevek f\u00f6l\u00e9 vissz\u00fck, l\u00e1thatjuk, hogy val\u00f3ban ford\u00edt\u00e1si idej\u0171 t\u00edpusokr\u00f3l van sz\u00f3.</p> <p>IntelliSense</p> <p>Figyelj\u00fck meg, hogy az IntelliSense is m\u0171k\u00f6dik ezekre a t\u00edpusokra, felk\u00edn\u00e1lja a t\u00edpus property-jeit.</p> <p>A ford\u00edt\u00f3 \u00fajra is hasznos\u00edtja az egyes t\u00edpusokat:</p> <pre><code>var dolgok = new { Name = \"Gy\u00fcm\u00f6lcs\u00f6k\", Contents = new[] { dolog1, dolog2 } };\n</code></pre> <p>A <code>Contents</code> tulajdons\u00e1g t\u00edpusa a fenti anonim objektumaink t\u00f6mbje, ez\u00e9rt nem is adhatn\u00e1nk meg m\u00e1sk\u00e9ppen (nem tudjuk a nev\u00e9t, amivel hivatkozhatunk r\u00e1). A ford\u00edt\u00f3 most panaszkodik, ugyanis a k\u00e9t dolog t\u00edpusa nem implicit k\u00f6vetkeztethet\u0151. Ha felvessz\u00fck a <code>Size</code> tulajdons\u00e1got a <code>dolog2</code> defin\u00edci\u00f3j\u00e1ba, m\u00e1ris fordul.</p> <pre><code>var dolog2 = new { Name = \"K\u00f6rte\", Weight = 90, Size = 12 };\n</code></pre> <p>Ha v\u00e9gezt\u00fcnk az anonim t\u00edpusokkal val\u00f3 ismerked\u00e9ssel, az ezekkel kapcsolatos k\u00f3dsorokat kikommentezhetj\u00fck.</p>"},{"location":"seminar/03-linq/chapter3/#linq-szintaxisok","title":"LINQ szintaxisok","text":"<p>Az el\u0151z\u0151 r\u00e9szben ismertetett jelleg\u0171 lek\u00e9rdez\u00e9sek nagyban hasonl\u00edtanak azokhoz, amiket adatb\u00e1zis-lek\u00e9rdez\u00e9sekben alkalmazunk. A k\u00fcl\u00f6nbs\u00e9g itt az, hogy imperat\u00edv szintaxist haszn\u00e1lunk, szemben pl. az SQL-lel, ami deklarat\u00edvat. Ez\u00e9rt is van jelen a C# nyelvben az \u00fan. query syntax, amely j\u00f3val hasonlatosabb az SQL szintaxis\u00e1hoz, \u00edgy az adatb\u00e1zisokban j\u00e1rtas fejleszt\u0151k is k\u00f6nnyebben \u00edrhatnak lek\u00e9rdez\u00e9seket. Ugyanakkor nem minden lek\u00e9rdez\u00e9st tudunk query syntax-szal le\u00edrni.</p> <p>Mi\u00e9rt nem lehet mindent meg\u00edrni query syntaxban?</p> <p>Ennek oka, hogy az oper\u00e1torok bevezet\u00e9se egy nyelvben el\u00e9g dr\u00e1ga - le kell p\u00e9l\u00e1dul foglalni az oper\u00e1tor nev\u00e9t, amit ut\u00e1na korl\u00e1tozottan lehet csak haszn\u00e1lni m\u00e1sra. Ez\u00e9rt sem csin\u00e1lt\u00e1k meg minden LINQ f\u00fcggv\u00e9nynek az oper\u00e1tor p\u00e1rj\u00e1t, csak az SQL-ben gyakrabban haszn\u00e1latosabbaknak.</p> <p>Az el\u0151z\u0151h\u00f6z hasonl\u00f3 lek\u00e9rdez\u00e9st meg\u00edrhatunk az al\u00e1bbi m\u00f3don query syntax haszn\u00e1lat\u00e1val:</p> <pre><code>using HelloLinq.Extensions;\n\n//...\nIEnumerable&lt;Dog&gt; Dogs = Dog.Repository.Values;\n\nvar query = from d in Dogs\n            where d.DateOfBirth?.Year &lt; 2010\n            select new\n            {\n                Dog = d,\n                AverageSiblingAge = d.Siblings.Average(s =&gt; s.Age ?? 0)\n            };\nforeach (var meta in query)\n{\n    Console.WriteLine(\n        $\"{meta.Dog.Name} - {meta.AverageSiblingAge}\");\n}\n</code></pre> <p>A query szintaxis v\u00e9g\u00fcl a kor\u00e1bban is haszn\u00e1lt, \u00fan. *fluent szintaxis*s\u00e1 fordul. Ennek igazol\u00e1s\u00e1ra n\u00e9zz\u00fck meg F12-vel, hogy hol vannak defini\u00e1lva az \u00fajonnan megismert oper\u00e1torok (<code>select</code>, <code>where</code>). A k\u00e9t szintaxist szok\u00e1s \u00f6tv\u00f6zni is, jellemz\u0151en akkor, ha query szintaxisban \u00edrjuk a lek\u00e9rdez\u00e9st, \u00e9s a hi\u00e1nyz\u00f3 funkcionalit\u00e1st fluent szintaxissal p\u00f3toljuk.</p> <p>Fluent szintaxis</p> <p>A fluent szintaxist olyan kialak\u00edt\u00e1s\u00fa API-kn\u00e1l alkalmazhatjuk, ahol a f\u00fcggv\u00e9nyek a tartalmaz\u00f3 t\u00edpust v\u00e1rj\u00e1k (egyik) bemenetk\u00e9nt \u00e9s azonos (vagy lesz\u00e1rmazott) t\u00edpust adnak vissza. A LINQ-n\u00e9l ez a t\u00edpus az <code>IEnumerable&lt;&gt;</code>.</p> <p>Ezen az \u00f3r\u00e1n mem\u00f3riabeli adatforr\u00e1sokkal dolgoztunk (konkr\u00e9tan a <code>Dogs</code> nev\u0171 <code>Dictionary&lt;,&gt;</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3val), a LINQ oper\u00e1torok k\u00f6z\u00fcl a mem\u00f3riabeli list\u00e1kon dolgoz\u00f3kat haszn\u00e1ltuk, melyeket az <code>IEnumerable&lt;&gt;</code> interf\u00e9szre biggyesztettek r\u00e1 b\u0151v\u00edt\u0151 met\u00f3dusk\u00e9nt. Ezt a LINQ API-t teljes nev\u00e9n *LINQ-to-Objects*nek h\u00edvj\u00e1k, de gyakran csak LINQ-k\u00e9nt hivatkozz\u00e1k.</p>"},{"location":"seminar/03-linq/chapter3/#kitekinto-expression-linq-providerek","title":"Kitekint\u0151: Expression\\&lt;&gt;, LINQ providerek","text":"<p>Vegy\u00fck az al\u00e1bbi nagyon egyszer\u0171 delegate-et \u00e9s ennek <code>Expression&lt;&gt;</code>-\u00f6s p\u00e1rj\u00e1t.</p> <pre><code>Func&lt;int, int&gt;  f = x =&gt; x + 1;\nExpression&lt;Func&lt;int, int&gt;&gt; e = x =&gt; x + 1;\n</code></pre> <p>N\u00e9zz\u00fck meg debuggol\u00e1s k\u00f6zben a Watch ablakban a fenti k\u00e9t v\u00e1ltoz\u00f3t. Az <code>f</code> egy delegate, leford\u00edtott k\u00f3d*ra mutat\u00f3 referencia, az <code>Expression</code> a jobb oldali kifejez\u00e9sb\u0151l \u00e9p\u00edtett (fa strukt\u00far\u00e1j\u00fa) *adat.</p> <p>A f\u00e1t k\u00f3dd\u00e1 ford\u00edthatjuk a <code>Compile</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel, mely a leford\u00edtott f\u00fcggv\u00e9ny referenci\u00e1j\u00e1t (deleg\u00e1t p\u00e9ld\u00e1ny) adja vissza, amit a f\u00fcggv\u00e9nyh\u00edv\u00e1s szintaxissal h\u00edvhatunk meg. Ebb\u0151l \u00e1ll \u00f6ssze az al\u00e1bbi fura kin\u00e9zet\u0171 kifejez\u00e9s:</p> <pre><code>Console.WriteLine(e.Compile()(5));\n</code></pre> <p>B\u00e1r az <code>Expression&lt;&gt;</code> emiatt okosabb v\u00e1laszt\u00e1snak t\u0171nik, \u00e1m a LINQ-to-Objects alapinterf\u00e9sz\u00e9nek (ami a lek\u00e9rdez\u0151f\u00fcggv\u00e9nyeket biztos\u00edtja) f\u00fcggv\u00e9nyei <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code> deleg\u00e1tokat v\u00e1rnak. Ami nem csoda, hiszen mem\u00f3riabeli list\u00e1kat \u00e1ltal\u00e1ban sima programk\u00f3ddal dolgozunk fel, nincs \u00e9rtelme fel\u00e9p\u00edteni kifejez\u00e9sf\u00e1t csak az\u00e9rt, hogy ut\u00e1na egyb\u0151l k\u00f3dd\u00e1 ford\u00edtsuk. Emellett m\u00e1s, mem\u00f3riabeli adatokon dolgoz\u00f3 LINQ technol\u00f3gia is l\u00e9tezik, pl. LINQ-to-XML saj\u00e1t API-val (nem <code>IEnumerable&lt;&gt;</code> alapt\u00edpussal).</p> <p>A nem mem\u00f3riabeli adatokon, hanem p\u00e9ld\u00e1ul k\u00fcls\u0151 adatb\u00e1zisb\u00f3l dolgoz\u00f3 LINQ provider-ek viszont <code>IQueryable&lt;&gt;</code>-t val\u00f3s\u00edtanak meg. Az <code>IQueryable&lt;&gt;</code> az <code>IEnumerable&lt;&gt;</code>-b\u00f3l sz\u00e1rmazik, \u00edgy neki is vannak <code>Func&lt;&gt;</code> / <code>Action&lt;&gt;</code>-\u00f6s f\u00fcggv\u00e9nyei, de emellett <code>Expression&lt;&gt;</code>-\u00f6sek is. Ez ut\u00f3bbiak teszik lehet\u0151v\u00e9, hogy ne csak .NET k\u00f3dot gener\u00e1ljanak a lambda kifejez\u00e9sekb\u0151l, hanem helyette pl. SQL kifejez\u00e9st - hiszen egy rel\u00e1ci\u00f3s adatb\u00e1zis adatfeldolgoz\u00f3 nyelve nem .NET, hanem valamilyen SQL dialektus.</p>"},{"location":"seminar/03-linq/chapter3/#a-linq-providerek-altalanos-mukodese","title":"A LINQ providerek \u00e1ltal\u00e1nos m\u0171k\u00f6d\u00e9se","text":"<p>Bemenet\u00fck: query f\u00fcggv\u00e9nyeknek (<code>IQueryable&lt;&gt;</code> vagy <code>IEnumerable&lt;&gt;</code> f\u00fcggv\u00e9nyei vagy pl. <code>XDocument</code>) param\u00e9ter\u00fcl adott lambd\u00e1k (<code>Func&lt;&gt;</code> vagy <code>Expression&lt;&gt;</code>)</p> <p>Kimenet\u00fck: az adatforr\u00e1snak megfelel\u0151 nyelv\u0171, a query-t v\u00e9grehajt\u00f3 k\u00f3d (.NET k\u00f3d vagy SQL).</p> <p>LINQ-to-Objects eset\u00e9n nincs val\u00f3di LINQ provider (a provider az <code>IQueryable.Provider</code>-en kereszt\u00fcl \u00e9rhet\u0151 el, de a <code>List&lt;&gt;</code> nem <code>IQueryable</code>!), hiszen nincs feladata: k\u00f3dot kap bemenet\u00fcl, ugyanazt kellene kimenet\u00fcl adnia. A LINQ-to-XML is hasonl\u00f3 elven m\u0171k\u00f6dik.</p> <p>Val\u00f3di LINQ providert val\u00f3s\u00edt meg p\u00e9ld\u00e1ul az Entity Framework, de ezt a technol\u00f3gi\u00e1t k\u00e9s\u0151bb t\u00e1rgyaljuk.</p>"},{"location":"seminar/04-csharp4/chapter4/","title":"C# alapok IV.","text":"<p>Ezen a gyakorlaton t\u00f6bb k\u00fcl\u00f6nf\u00e9le nyelvi konstrukci\u00f3t tekint\u00fcnk \u00e1t, vegyesfelv\u00e1gott jelleggel. Az egyes f\u0151 t\u00e9mak\u00f6r\u00f6ket k\u00fcl\u00f6n projektk\u00e9nt dolgozzuk ki. A projekteket hozz\u00e1adhatjuk az els\u0151k\u00e9nt l\u00e9trehozott projekt solutionj\u00e9hez (menu:jobbklikk a solution-\u00f6n[Add &gt; New project]). Hozz\u00e1ad\u00e1s ut\u00e1n ne felejts\u00fck el \u00e1t\u00e1ll\u00edtani a futtatand\u00f3 projektet: menu:jobbklikk a projekten[Set as Startup Project].</p>"},{"location":"seminar/04-csharp4/chapter4/#bejarasi-problemak","title":"Bej\u00e1r\u00e1si probl\u00e9m\u00e1k","text":"<p>Enumer\u00e1torok haszn\u00e1lata eset\u00e9n k\u00e9t alapvet\u0151 probl\u00e9m\u00e1ba \u00fctk\u00f6z\u00fcnk: az egyik a m\u00f6g\u00f6ttes kollekci\u00f3 m\u00f3dosul\u00e1sa bej\u00e1r\u00e1s sor\u00e1n, a m\u00e1sik pedig a k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9sb\u0151l ad\u00f3d\u00f3 mell\u00e9khat\u00e1sok kezel\u00e9se.</p>"},{"location":"seminar/04-csharp4/chapter4/#kollekcio-modosulasa-bejarasa-soran","title":"Kollekci\u00f3 m\u00f3dosul\u00e1sa bej\u00e1r\u00e1sa sor\u00e1n","text":"<p>Sz\u0171rj\u00fcnk le egy sz\u00e1mokat tartalmaz\u00f3 kollekci\u00f3t csak azokra az elemekre, amik megfelelnek egy felt\u00e9telnek, \u00e9s ezeket t\u00e1vol\u00edtsuk el a kollekci\u00f3b\u00f3l!</p> <pre><code>var numbers = Enumerable.Range(1, 8).ToList();\nforeach (var p in numbers)\n{\n    if (p % 2 == 0)\n    {\n        numbers.Remove(p);\n    }\n}\nnumbers.ForEach(Console.WriteLine);\n</code></pre> <p>Futtat\u00e1skor kiv\u00e9telt kapunk. Mi a probl\u00e9ma? A kollekci\u00f3t bej\u00e1r\u00e1s k\u00f6zben szerett\u00fck volna m\u00f3dos\u00edtani, viszont ez k\u00f6nnyen nem v\u00e1rt m\u0171k\u00f6d\u00e9st (t\u00falc\u00edmz\u00e9st, nemdeterminisztikus bej\u00e1r\u00e1st) tenne lehet\u0151v\u00e9, ez\u00e9rt kiv\u00e9telt kapunk. Oldjuk meg a probl\u00e9m\u00e1t: nem m\u00f3dos\u00edthatjuk a forr\u00e1s objektumot bej\u00e1r\u00e1s k\u00f6zben, teh\u00e1t ne azt a kollekci\u00f3t j\u00e1rjuk be, m\u00e1soljuk le!</p> <pre><code>foreach (var p in numbers.ToList()) // a ToList beker\u00fclt\n{\n    // ...\n}\n</code></pre> <p>Ez megoldja a probl\u00e9m\u00e1t, siker\u00fcl elt\u00e1vol\u00edtani az elemeket a kollekci\u00f3b\u00f3l. De mi\u00e9rt?  A <code>ToList</code> <code>IEnumerable</code> b\u0151v\u00edt\u0151, teh\u00e1t bej\u00e1rhatja a kollekci\u00f3t, ezut\u00e1n pedig egy m\u00e1sik <code>List&lt;&gt;</code> objektumban t\u00e1rolja az elemeket. \u00cdgy teh\u00e1t k\u00e9t list\u00e1nk lesz (a <code>numbers</code> \u00e9s a <code>numbers.ToList</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9ke), amik kezdetben egym\u00e1s kl\u00f3njai, menet k\u00f6zben az egyikb\u0151l vesz\u00fcnk ki, a m\u00e1sikon pedig iter\u00e1lunk.</p> <p>Kiv\u00e9telek</p> <p>B\u00e1r a fenti az \u00e1ltal\u00e1nos szab\u00e1ly, bizonyos kollekci\u00f3k bizonyos m\u00f3dos\u00edt\u00f3 m\u0171veletei m\u00e9gsem dobnak kiv\u00e9telt, ilyen p\u00e9ld\u00e1ul a <code>Dictionary&lt;,&gt;</code> <code>Remove</code> \u00e9s <code>Clear</code> m\u0171veletei.</p>"},{"location":"seminar/04-csharp4/chapter4/#azonnali-es-kesleltetett-kiertekeles","title":"Azonnali \u00e9s k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s","text":"<p>Amennyiben egy met\u00f3dus gener\u00e1tor (<code>IEnumerable</code> vagy <code>IEnumerable&lt;&gt;</code> visszat\u00e9r\u00e9si \u00e9rt\u00e9k\u0171), az egyes elemeken t\u00f6rt\u00e9n\u0151 iter\u00e1ci\u00f3 a gener\u00e1torok egym\u00e1sba \u00e1gyaz\u00e1s\u00e1t jelenti, azaz az egyes gener\u00e1torokban a <code>yield return</code> \u00e1ltal visszaadott \u00e9rt\u00e9ket fogja az enumer\u00e1tor <code>MoveNext</code> met\u00f3dusa visszaadni. Am\u00edg az <code>IEnumerable</code>-re van referenci\u00e1nk, \u00e9s nem j\u00e1rjuk azt k\u00f6zvetlen\u00fcl be, addig k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9sr\u0151l besz\u00e9l\u00fcnk.</p> <p>Az eddigiek al\u00e1:</p> <pre><code>var i = 0;\nforeach (var n in numbers\n                    .Where(p =&gt; p &gt; 2)\n                    .Select(p =&gt; new { p, x = ++i }))\n{\n    Console.WriteLine($\"{n} - {i}\");\n}\n\nConsole.WriteLine();\n\ni = 0;\nforeach (var n in numbers\n                    .Where(p =&gt; p &gt; 2)\n                    .Select(p =&gt; new { p, x = ++i })\n                    .ToList())\n{\n    Console.WriteLine($\"{n} - {i}\");\n}\n</code></pre> <p>A <code>ToList</code> h\u00edv\u00e1sunk el\u0151sz\u00f6r bej\u00e1rja az iter\u00e1tort \u00e9s visszaad egy list\u00e1t, amelybe \u00f6sszegy\u0171jti az <code>IEnumerable</code> elemeit. Ez\u00e9rt az <code>i</code> v\u00e1ltoz\u00f3nk a m\u00e1sodik esetben nem egy\u00fctt inkrement\u00e1l\u00f3dik a bej\u00e1r\u00e1ssal, mert az k\u00e9tszer t\u00f6rt\u00e9nik meg. Az els\u0151 bej\u00e1r\u00e1skor (a <code>ToList</code> h\u00edv\u00e1sakor) inkrement\u00e1l\u00f3dik az <code>i</code> \u00e9rt\u00e9ke, m\u00e1sodj\u00e1ra pedig m\u00e1r csak bej\u00e1rjuk a kapott list\u00e1t. Eddigre az <code>i</code> \u00e9rt\u00e9ke m\u00e1r meg van n\u00f6velve.</p> <p>Ezzel a megk\u00f6zel\u00edt\u00e9ssel fut\u00e1sid\u0151ben is \u00e1ll\u00edthatunk \u00f6ssze egy id\u0151ben v\u00e1ltoz\u00f3 lek\u00e9rdez\u00e9st, amit majd egyszer, a k\u00e9s\u0151bbiekben fogunk bej\u00e1rni (pl. soros\u00edt\u00e1skor).</p>"},{"location":"seminar/04-csharp4/chapter4/#aszinkron-mukodes","title":"Aszinkron m\u0171k\u00f6d\u00e9s","text":"<p>T\u00f6lts\u00fcnk le egy HTML oldalt, \u00e9s ezen a probl\u00e9m\u00e1n kereszt\u00fcl bemutatjuk az aszinkron programoz\u00e1si modellt. A <code>HttpClient</code> m\u0171k\u00f6d\u00e9s\u00e9nek a r\u00e9szletesebb ismertet\u00e9se most nem t\u00e9ma, csak a legalapvet\u0151bb funkci\u00f3kat fogjuk haszn\u00e1lni.</p> <p>A f\u0151 gond, hogy a hosszan fut\u00f3 m\u0171veletek blokkolhatj\u00e1k a f\u0151/UI/aktu\u00e1lis sz\u00e1l fut\u00e1s\u00e1t, mindez kliens alkalmaz\u00e1sok eset\u00e9ben \u00fagy jelentkezik, hogy nem lesz az alkalmaz\u00e1sunk reszponz\u00edv a felhaszn\u00e1l\u00f3i bemenetekre; szerveralkalmaz\u00e1sok eset\u00e9ben pedig az adott k\u00e9r\u00e9st kiszolg\u00e1l\u00f3 sz\u00e1l feleslegesen blokkol\u00f3dik, amikor esetleg m\u00e1ssal is tudna foglalkozni.</p> <p>\u00d6tlet: a hosszan tart\u00f3 m\u0171veleteket v\u00e9gezz\u00fck aszinkron m\u00f3don, \u00e9s ha az befejez\u0151d\u00f6tt az eredm\u00e9nyr\u0151l valamilyen m\u00f3don \u00e9rtes\u00fclj\u00fcnk. A keretrendszer t\u00f6bbf\u00e9le mint\u00e1t k\u00edn\u00e1l erre:</p> <ul> <li>Asynchronous Programming Model (APM),</li> <li>Event-based Asynchronous Pattern (EAP),</li> <li>Task-based Asynchronous Pattern (TAP).</li> </ul> <p>Mi most a legut\u00f3bbival foglalkozunk csak, a t\u00f6bbi j\u00f3r\u00e9szt elavultnak sz\u00e1m\u00edt ma m\u00e1r.</p>"},{"location":"seminar/04-csharp4/chapter4/#tap-es-asyncawait-alapjai","title":"TAP \u00e9s async/await alapjai","text":"<p>A TAP-ra m\u00e1r C# nyelvi t\u00e1mogat\u00e1st is kapunk az <code>async</code>/<code>await</code> kulcsszavakon kereszt\u00fcl. Vegy\u00fcnk fel egy \u00faj met\u00f3dust \u00e9s h\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3dban. A meg\u00edrt met\u00f3dus \u00edr\u00e1sa sor\u00e1n hivatkozzuk be a <code>System.Net.Http</code> n\u00e9vteret. A k\u00f3d semmi m\u00e1st nem csin\u00e1l, csak elind\u00edt aszinkron m\u00f3don egy HTTP GET k\u00e9r\u00e9st a megadott URL-re, illetve a v\u00e1lasz tartalm\u00e1t is aszinkron m\u00f3don kiolvassa \u00e9s egy r\u00e9sz\u00e9t ki\u00edrja a konzolra.</p> <pre><code>LoadWebPageAsync();\nConsole.WriteLine(\"Ez a v\u00e9ge\");\nConsole.ReadKey();\n\nstatic async void LoadWebPageAsync()\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(new Uri(\"http://www.bing.com\"));\n        Console.WriteLine(response.StatusCode.ToString());\n\n        var content = await response.Content.ReadAsStringAsync();\n        Console.WriteLine(content.Take(1000).ToArray());\n    }\n}\n</code></pre> <p>await: Mindig egy <code>Task</code> <code>await</code>-elhet\u0151 (vagy taszk szer\u0171 dolog: vagyis van neki <code>GetAwaiter</code> met\u00f3dusa, ami meghat\u00e1rozott met\u00f3dusokkal rendelkez\u0151 objektummal t\u00e9r vissza)!  Ak\u00e1r l\u00e9tre is hozhatunk egy <code>Task</code>-ot, amit egy lok\u00e1lis v\u00e1ltoz\u00f3ban t\u00e1rolunk, akkor azt is tudjuk <code>await</code>-elni.</p> <p>async: Ha await-elni akarunk, akkor musz\u00e1j <code>async</code>-nak lennie a tartalmaz\u00f3 met\u00f3dusnak, mert ilyenkor \u00e9p\u00edti fel a ford\u00edt\u00f3 az aszinkron v\u00e9grehajt\u00e1shoz sz\u00fcks\u00e9ges \u00e1llapotg\u00e9pet.</p> <p>Debuggoljuk ki! Minden <code>Console</code>, <code>async</code> sorra tegy\u00fcnk t\u00f6r\u00e9spontot, debuggol\u00e1s sor\u00e1n (F5) k\u00f6vess\u00fck v\u00e9gig, milyen sorrendben \u00e9ri el \u0151ket a v\u00e9grehajt\u00e1s. N\u00e9zz\u00fck meg, melyik r\u00e9sz milyen sz\u00e1lon fut le (debug k\u00f6zben menu:Debug[Windows &gt; Threads]). A <code>LoadWebPageAsync</code> ut\u00e1ni r\u00e9sz el\u0151bb fog lefutni, mint az els\u0151 <code>await</code> ut\u00e1ni r\u00e9sz. Az <code>await</code> ut\u00e1ni r\u00e9sz nem a Main Thread-en fut. Figyelj\u00fck meg azt is, hogy az Ez a v\u00e9ge sz\u00f6veg hamarabb ki\u00edr\u00f3dik, mint a HTML oldal let\u00f6lt\u00e9se.</p> <p>Pr\u00f3b\u00e1ljuk ki a <code>Console.ReadKey</code>-t kikommentezve is, ilyenkor j\u00f3 es\u00e9llyel hamarabb le\u00e1ll a process, minthogy a <code>Task</code> befejez\u0151dne. Az ilyen fire-and-forget t\u00edpus\u00fa h\u00edv\u00e1sokn\u00e1l nem figyel arra senki, hogy itt m\u00e9g valami h\u00e1tt\u00e9rm\u0171velet folyik.</p> <p>async void ker\u00fclend\u0151</p> <p>Az <code>async void</code> \u00e1ltal\u00e1ban helytelen k\u00f3d, mert nem lehet bev\u00e1rni a h\u00e1tt\u00e9rm\u0171velet v\u00e9g\u00e9t. Az <code>async Task</code> m\u00e1ris jobb a bev\u00e1rhat\u00f3s\u00e1g \u00e9s a hibakezel\u00e9s miatt, \u00e9s alig kell m\u00f3dos\u00edtani a k\u00f3dot. Kiv\u00e9tel, amikor valami\u00e9rt k\u00f6telez\u0151 a <code>void</code>, p\u00e9ld\u00e1ul, ha esem\u00e9ny vagy interf\u00e9sz el\u0151\u00edrja.</p>"},{"location":"seminar/04-csharp4/chapter4/#az-oldalletoltes-bevarasa","title":"Az oldallet\u00f6lt\u00e9s bev\u00e1r\u00e1sa","text":"<p>M\u00f3dos\u00edtsuk \u00fagy a k\u00f3dot, hogy a <code>LoadWebPageAsync</code> ut\u00e1ni r\u00e9sz v\u00e1rja meg a let\u00f6lt\u00e9s befejez\u0151d\u00e9s\u00e9t. Ez akkor j\u00f3 p\u00e9ld\u00e1ul, ha a let\u00f6lt\u00e9s ut\u00e1n valamit m\u00e9g szeretn\u00e9k elv\u00e9gezni a h\u00edv\u00f3 f\u00fcggv\u00e9nyben.</p> <p>M\u00f3dos\u00edtsuk a <code>LoadWebPageAsync</code> fejl\u00e9c\u00e9t, hogy taszkot adjon vissza:</p> <pre><code>public static async Task LoadWebPageAsync() //void helyett Task\n</code></pre> <p>V\u00e1rjuk be az aszinkron m\u0171velet v\u00e9g\u00e9t a legfels\u0151 szint\u0171 k\u00f3dban.</p> <pre><code>await LoadWebPageAsync(); //await beker\u00fclt\nConsole.WriteLine(\"Ez a v\u00e9ge\");\n/*Console.ReadKey();*/\n</code></pre> <p>Figyelj\u00fck meg, hogy \u00edgy m\u00e1r az Ez a v\u00e9ge felirat m\u00e1r a let\u00f6lt\u00e9s ut\u00e1n jelenik meg.</p> <p><code>await</code>-et haszn\u00e1ltunk a legfels\u0151 szint\u0171 k\u00f3dban, ilyenkor automatikusan <code>async</code> kulcssz\u00f3val ell\u00e1tott <code>Main</code> gener\u00e1l\u00f3dik - valami hasonl\u00f3, mint az al\u00e1bbi k\u00f3dr\u00e9szlet.</p> <pre><code>await LoadWebPageAsync();\nConsole.WriteLine(\"Ez a v\u00e9ge\");\n//Console.ReadKey();\n</code></pre>"},{"location":"seminar/04-csharp4/chapter4/#hattermuvelet-eredmenyenek-visszaadasa","title":"H\u00e1tt\u00e9rm\u0171velet eredm\u00e9ny\u00e9nek visszaad\u00e1sa","text":"<p>Alak\u00edtsuk \u00e1t, hogy a weboldal tartalm\u00e1nak ki\u00edrat\u00e1sa a legfels\u0151 szint\u0171 k\u00f3dban t\u00f6rt\u00e9njen, \u00e9s a <code>LoadWebPageAsync</code> csak adja vissza a tartalmat <code>string</code>-k\u00e9nt. Ehhez m\u00f3dos\u00edtsuk a visszat\u00e9r\u00e9si \u00e9rt\u00e9ket <code>Task&lt;string&gt;</code>-re, \u00edgy az <code>await</code> m\u00e1r eredm\u00e9nnyel fog tudni visszat\u00e9rni.</p> <pre><code>var content = await LoadWebPageAsync();\nConsole.WriteLine(content);\nConsole.WriteLine(\"Ez a v\u00e9ge\");\nConsole.ReadKey();\nstatic async Task&lt;string&gt; LoadWebPageAsync() //generikus param\u00e9ter\n{\n    using (var client = new HttpClient())\n    {\n        var response = await client.GetAsync(new Uri(\"http://www.bing.com\"));\n        Console.WriteLine(response.StatusCode.ToString());\n\n        var content = await response.Content.ReadAsStringAsync();\n        return new string(content.Take(1000).ToArray());\n    }\n}\n</code></pre> <p>A <code>return</code> val\u00f3j\u00e1ban ezen <code>Task</code> eredm\u00e9ny\u00e9t \u00e1ll\u00edtja be <code>async</code> met\u00f3dusok eset\u00e9ben, \u00e9s nem egy nemgenerikus <code>Task</code> objektummal kell visszat\u00e9rj\u00fcnk.</p>"},{"location":"seminar/04-csharp4/chapter4/#nemigazan-nullozhato-referencia-tipusok","title":"Nem(igaz\u00e1n) nullozhat\u00f3 referencia t\u00edpusok","text":"<p>Kor\u00e1bban l\u00e1ttuk, hogy hogyan lehet egy \u00e9rt\u00e9k t\u00edpusnak null \u00e9rt\u00e9ket adni (<code>Nullable&lt;T&gt;</code>). Az \u00e9rem m\u00e1sik oldala a C# 8-ban megjelent nem nullozhat\u00f3 referencia t\u00edpusok. Nem egy \u00faj t\u00edpust vezettek be, hanem az eddig megszokott t\u00edpusneveket \u00e9rtelmezi m\u00e1shogyan a ford\u00edt\u00f3. A projektf\u00e1jlban az al\u00e1bbi be\u00e1ll\u00edt\u00e1s kapcsolja be ezt a funkci\u00f3t.</p> <pre><code>&lt;Nullable&gt;enable&lt;/Nullable&gt;\n</code></pre> <p>Egy\u00e9b konfigur\u00e1ci\u00f3s lehet\u0151s\u00e9gek</p> <p>Ezen k\u00edv\u00fcl m\u00e9g preprocessor direkt\u00edv\u00e1kkal is szab\u00e1lyozhatjuk a m\u0171k\u00f6d\u00e9st.</p> <p>Induljunk ki egy egyszer\u0171 szem\u00e9lyeket nyilv\u00e1ntart\u00f3 adatoszt\u00e1lyb\u00f3l, ahol elhat\u00e1rozzuk, hogy a k\u00f6z\u00e9ps\u0151 n\u00e9v kiv\u00e9tel\u00e9vel a t\u00f6bbi n\u00e9vdarab nem nullozhat\u00f3 sz\u00f6veg lesz.</p> <pre><code>Console.WriteLine(\"Hello World!\");\nclass Person\n{\n    string FirstName;   // Not null\n    string? MiddleName; // May be null\n    string LastName;    // Not null\n}\n</code></pre> <p>Ez m\u00e1ris sz\u00e1mos figyelmeztet\u00e9st gener\u00e1l. A nem nullozhat\u00f3 referencia t\u00edpusok bekapcsol\u00e1s\u00e1val alapesetben nem hib\u00e1k, csak \u00faj figyelmeztet\u00e9sek gener\u00e1l\u00f3dnak. A vezet\u00e9kn\u00e9v \u00e9s keresztn\u00e9v adatoknak nem szabadna <code>null</code> \u00e9rt\u00e9k\u0171nek lennie (a sima <code>string</code> t\u00edpus nem nullozhat\u00f3 t\u00edpust jelent), viszont \u00edgy az alap\u00e9rt\u00e9k nem egy\u00e9rtelm\u0171, explicit inicializ\u00e1lnunk kellene.</p> <p>Fontos meg\u00e9rten\u00fcnk, hogy a string t\u00edpus fizikailag tov\u00e1bbra is lehet null \u00e9rt\u00e9k\u0171, mind\u00f6ssze a ford\u00edt\u00f3 sz\u00e1m\u00e1ra jelezz\u00fck, hogy sz\u00e1nd\u00e9kunk szerint sohasem szabadna <code>null</code> \u00e9rt\u00e9ket felvennie. A ford\u00edt\u00f3 cser\u00e9be figyelmeztet, ha ezt megs\u00e9rt\u0151 k\u00f3dot detekt\u00e1l.</p> <p>Az egyik legk\u00e9zenfekv\u0151bb megold\u00e1s (az inline inicializ\u00e1ci\u00f3 mellett), ha konstruktorban inicializ\u00e1lunk konstruktorparam\u00e9ter alapj\u00e1n. Adjunk konstruktort a t\u00edpusnak:</p> <pre><code>public Person(string fname, string lname, string? mname)\n{\n    FirstName = fname;\n    LastName = lname;\n    MiddleName = mname;\n}\n</code></pre> <p>Ezzel meg is oldottunk minden figyelmeztet\u00e9st.</p> <p>Rebuild</p> <p>Ha biztosan l\u00e1tni akarjuk az \u00f6sszes figyelmeztet\u00e9st, akkor sima Build m\u0171velet helyett haszn\u00e1ljuk a Rebuild-et.</p> <p>Konstruktorok</p> <p>Sajnos a k\u00f6telez\u0151en konstruktoron kereszt\u00fcli inicializ\u00e1ci\u00f3 nem mindig m\u0171k\u00f6dik, p\u00e9ld\u00e1ul a soros\u00edt\u00f3k \u00e1ltal\u00e1ban nem szeretik, ha nincs alap\u00e9rtelmezett konstruktor.</p> <p>Mennyire okos a ford\u00edt\u00f3 a <code>null</code> \u00e9rt\u00e9k detekt\u00e1l\u00e1s\u00e1ban?N\u00e9zz\u00fcnk p\u00e1r p\u00e9ld\u00e1t! Az al\u00e1bbi statikus f\u00fcggv\u00e9nyt tegy\u00fck bele a <code>Person</code> oszt\u00e1lyunkba \u00e9s vegy\u00fck fel a <code>using static System.Console;</code> n\u00e9vt\u00e9rhivatkoz\u00e1st is.</p> <pre><code>static void M(string? ns)\n{\n    WriteLine(ns.Length); // (1)!\n    if (ns != null)\n    {\n        WriteLine(ns.Length); // (2)!\n    }\n    if (ns == null)\n    {\n        return;\n    }\n    WriteLine(ns.Length); // (3)!\n    ns = null;\n    WriteLine(ns.Length); // (4)!\n    string s = default(string); // (5)!\n    string[] a = new string[10]; // (6)!\n}\n</code></pre> <ol> <li>Figyelmeztet\u00e9s lehets\u00e9ges <code>null</code> \u00e9rt\u00e9kre, mert a t\u00edpusa szerint nullozhat\u00f3.</li> <li>Ha egy egyszer\u0171 <code>if</code>-fel levizsg\u00e1ljuk, akkor m\u00e1ris ok. Pedig pl. t\u00f6bbsz\u00e1l\u00fa k\u00f6rnyezetben az <code>if</code> ki\u00e9rt\u00e9kel\u00e9se \u00e9s ezen sor v\u00e9grehajt\u00e1sa k\u00f6z\u00f6tt a v\u00e1ltoz\u00f3 ak\u00e1r <code>null</code> \u00e9rt\u00e9kre is be\u00edr\u00f3dhat.</li> <li>Az el\u0151tte l\u00e9v\u0151 r\u00f6vidz\u00e1r is megnyugtatja a ford\u00edt\u00f3t, \u00edgy itt sincs figyelmeztet\u00e9s.</li> <li>Ezt az el\u0151z\u0151 sor alapj\u00e1n figyelmeztet\u00e9ssel jutalmazza.</li> <li>Ez is figyelmeztet\u00e9s, a <code>default</code> oper\u00e1tor \u00e1ltal adott \u00e9rt\u00e9kkel (<code>null</code>) nem inicializ\u00e1lhatunk.</li> <li>Ez viszont nem figyelmeztet\u00e9s, pedig egy csom\u00f3 <code>null</code> j\u00f6n l\u00e9tre. Ha ez figyelmeztet\u00e9s lenne, az ar\u00e1nytalanul megnehez\u00edten\u00e9 a t\u00f6mb\u00f6k kezel\u00e9s\u00e9t.</li> </ol> <p>L\u00e1that\u00f3, hogy az egyszer\u0171bb eseteket j\u00f3l kezeli a ford\u00edt\u00f3, de kor\u00e1ntsem mindenhat\u00f3, illetve nem mindig sz\u00f3l akkor sem, amikor egy\u00e9bk\u00e9nt sz\u00f3lhatna.</p> <p>A tov\u00e1bbi p\u00e9ld\u00e1khoz vegy\u00fcnk fel p\u00e1r seg\u00e9df\u00fcggv\u00e9nyt a <code>Person</code> oszt\u00e1lyba:</p> <pre><code>private Person GetAnotherPerson()\n{\n    return new Person(LastName, FirstName, MiddleName ?? string.Empty);\n}\n\nprivate void ResetFields()\n{\n    FirstName = default!;\n    LastName = null!;\n    MiddleName = null;\n}\n</code></pre> <p>L\u00e1that\u00f3, hogy vannak megker\u00fcl\u0151 megold\u00e1sok arra, hogy r\u00e1er\u0151szakoljuk a ford\u00edt\u00f3ra az akaratunkat, a felki\u00e1lt\u00f3jel haszn\u00e1lat\u00e1val be\u00edrhatunk <code>null</code> \u00e9rt\u00e9keket nem nullozhat\u00f3 v\u00e1ltoz\u00f3kba (ez az \u00fan. null forgiving operator ). Illetve <code>string</code> eset\u00e9n null helyett haszn\u00e1lhatjuk az \u00fcres <code>string</code> \u00e9rt\u00e9ket - ami nem biztos, hogy sokkal jobb a <code>null</code> \u00e9rt\u00e9kn\u00e9l. Mindenesetre ezek a f\u00fcggv\u00e9nyek nem okoznak \u00fajabb figyelmeztet\u00e9seket.</p> <p>N\u00e9zz\u00fck meg, hogy mennyire tudja lek\u00f6vetni a fenti f\u00fcggv\u00e9nyek m\u0171k\u00f6d\u00e9s\u00e9t a ford\u00edt\u00f3. Vegy\u00fcnk fel ennek tesztel\u00e9s\u00e9re egy \u00fajabb f\u00fcggv\u00e9nyt a <code>Person</code> oszt\u00e1lyba:</p> <pre><code>void M(Person p)\n{\n    if (p.MiddleName != null)\n    {\n        p.ResetFields();\n        WriteLine(p.MiddleName.Length); // (1)!\n\n        p = GetAnotherPerson();\n        WriteLine(p.MiddleName.Length); // (2)!\n    }\n    p.FirstName = null;          // (3)!\n    p.LastName = p.MiddleName;   // (4)!\n}\n</code></pre> <ol> <li>A ford\u00edt\u00f3 nem k\u00f6veti le, hogy a <code>ResetFields</code> vesz\u00e9lyes m\u00f3don v\u00e1ltoztatja az \u00e1llapotot, csak azt n\u00e9zi, hogy az <code>if</code> m\u00e1r kiv\u00e9dte a vesz\u00e9lyt.</li> <li>Ez egy fals pozit\u00edvnak t\u0171n\u0151 eset, az el\u0151z\u0151 sorban l\u00e9v\u0151 f\u00fcggv\u00e9ny alapj\u00e1n a <code>p.MiddleName</code> nem lehetne <code>null</code>, de a ford\u00edt\u00f3 csak azt figyeli, hogy a beburkol\u00f3 <code>if</code> ellen\u0151rz\u00e9se a <code>p</code> megv\u00e1ltoz\u00e1sa miatt m\u00e1r nem \u00e9rv\u00e9nyes.</li> <li>Egy\u00e9rtelm\u0171en jogos figyelmeztet\u00e9s.</li> <li>Jogos a figyelmeztet\u00e9s, mert nem kezelj\u00fck a <code>p.MiddleName == null</code> esetet.</li> </ol> <p>Strukt\u00faratagok eset\u00e9n is a fals negat\u00edv eset j\u00f6n el\u0151. Pr\u00f3b\u00e1ljuk ki, ak\u00e1r a <code>Person</code> oszt\u00e1lyba \u00edrva:</p> <pre><code>struct PersonHandle\n{\n    public Person person;\n}\n</code></pre> <p>Nem kapunk figyelmeztet\u00e9st.</p> <p>A felki\u00e1lt\u00f3jeles r\u00e1er\u0151szakol\u00e1st a <code>ResetFields</code>-ben l\u00e1that\u00f3 \u00e1mokfut\u00e1s helyett ink\u00e1bb a fals pozit\u00edv esetek kezel\u00e9s\u00e9re haszn\u00e1ljuk. Jav\u00edtsuk ki a <code>GetAnotherPerson</code> h\u00edv\u00e1s miatti fals pozit\u00edv esetet az <code>M(Person)</code> f\u00fcggv\u00e9nyben:</p> <pre><code>p = GetAnotherPerson();\nWriteLine(p.MiddleName!.Length); //beker\u00fclt egy '!'\n</code></pre> <p>Figyelj\u00fck meg, ahogy a figyelmeztet\u00e9s elt\u0171nik.</p> <p>Ha igaz\u00e1n elk\u00f6telezettek vagyunk a <code>null</code> kiirt\u00e1sa mellett, akkor bekapcsolhatjuk, hogy minden, a <code>null</code> kezel\u00e9s miatti, ford\u00edt\u00f3 \u00e1ltal detekt\u00e1lt figyelmeztet\u00e9s legyen hiba. A projekt be\u00e1ll\u00edt\u00e1si k\u00f6z\u00f6tt (menu:a projekten jobbklikk[Properties]), a Build lapon adjuk meg a Treat specific warnings as errors opci\u00f3nak a <code>nullable</code> \u00e9rt\u00e9ket. (Ha t\u00f6bb \u00e9rt\u00e9ket akarunk megadni, akkor a <code>;</code> elv\u00e1laszt\u00f3t alkalmazhatjuk.)</p> <p>Ellen\u0151rizz\u00fck, hogy t\u00e9nyleg hibak\u00e9nt jelennek-e meg az eddigi <code>null</code> kezel\u00e9s miatti figyelmeztet\u00e9sek.</p> <p>Mivel ez csak egy p\u00e9ldak\u00f3d, ne jav\u00edtsuk ki a hib\u00e1kat, csak t\u00e1vol\u00edtsuk el a projektet a solutionb\u0151l (menu:a projekten jobbklikk[Remove]).</p>"},{"location":"seminar/04-csharp4/chapter4/#tuple-nyelvi-szinten-lokalis-fuggvenyek-dispose-minta","title":"Tuple nyelvi szinten, lok\u00e1lis f\u00fcggv\u00e9nyek, Dispose minta","text":""},{"location":"seminar/04-csharp4/chapter4/#tuple-nyelvi-szinten-lokalis-fuggvenyek","title":"Tuple nyelvi szinten, lok\u00e1lis f\u00fcggv\u00e9nyek","text":"<p>K\u00e9sz\u00edts\u00fcnk Fibonacci sz\u00e1msor kisz\u00e1mol\u00e1s\u00e1ra alkalmas f\u00fcggv\u00e9nyt, ahol haszn\u00e1ljuk ki az al\u00e1bbi k\u00e9t \u00faj nyelvi elemet. Term\u00e9szetesen nagyon sokf\u00e9lek\u00e9ppen meg lehetne val\u00f3s\u00edtani ezt a met\u00f3dust, de most kifejezetten a tuple-\u00f6k nyelvi t\u00e1mogat\u00e1s\u00e1t \u00e9s lok\u00e1lis f\u00fcggv\u00e9nyeket szeretn\u00e9nk demonstr\u00e1lni.</p> <ul> <li>Lok\u00e1lis f\u00fcggv\u00e9nyek: ezek a f\u00fcggv\u00e9nyek csak adott met\u00f3dusban l\u00e1that\u00f3k.K\u00e9t esetben \u00e9rdemes \u0151ket haszn\u00e1lni: ha nem szeretn\u00e9nk \u201eszennyezni\u201d a k\u00f6rnyez\u0151 oszt\u00e1lyt k\u00fcl\u00f6nf\u00e9le priv\u00e1t seg\u00e9dmet\u00f3dusokkal, vagy ha egy m\u00e9lyebb, komplexebb h\u00edv\u00e1si l\u00e1ncban nem szeretn\u00e9nk a param\u00e9tereket folyamatosan tov\u00e1bbpasszolni, ugyanis ezek a met\u00f3dusok el\u00e9rik a k\u00fcls\u0151 scope-on tal\u00e1lhat\u00f3 v\u00e1ltoz\u00f3kat is (a lenti esetben p\u00e9ld\u00e1ul az <code>x</code>-et).</li> <li>Value tuple t\u00edpus: a tuple (ennes) t\u00f6bb \u00f6sszetartoz\u00f3 \u00e9rt\u00e9k \u00f6sszefog\u00e1sa, ami gyors, nyelvi szinten t\u00e1mogatott adattov\u00e1bb\u00edt\u00e1st tesz lehet\u0151v\u00e9 - gyakorlatilag inline, neves\u00edtetlen strukt\u00farat\u00edpust hozunk \u00edgy l\u00e9tre. Publikus API-kon, f\u00fcggv\u00e9nyeken nem \u00e9rdemes haszn\u00e1lni, viszont priv\u00e1t, bels\u0151 haszn\u00e1latn\u00e1l sebess\u00e9gn\u00f6veked\u00e9st \u00e9s API tisztul\u00e1st \u00e9rhet\u00fcnk vele el. \u00c9rt\u00e9k t\u00edpus.</li> </ul> <p>Referencia t\u00edpus\u00fa Tuple&lt;&gt;</p> <p>L\u00e9teznek generikus <code>Tuple&lt;&gt;</code> t\u00edpusok is. Ezek referencia t\u00edpusok, hasonl\u00f3 szerepet t\u00f6ltenek be, viszont az egyes \u00e9rt\u00e9keiket az el\u00e9g semmitmond\u00f3 <code>Item1</code>, <code>Item2</code>\u2026 neveken lehet el\u00e9rni.</p> <pre><code>static long Fibonacci(long x)\n{\n    (long Current, long Previous) Fib(long i) # (1)!\n    {\n        if (i == 0) return (1, 0);\n        var (curr, prev) = Fib(i - 1); # (2)!\n        Thread.Sleep(100); # (3)!\n        return (curr + prev, curr);\n    }\n\n    return x &lt; 0\n        ? throw new ArgumentException(\"Less negativity please!\", nameof(x))\n        : Fib(x).Current;\n}\n</code></pre> <ol> <li>Neves\u00edtett tuple visszat\u00e9r\u00e9s. Ez egy lok\u00e1lis f\u00fcggv\u00e9ny, szintaxist tekintve f\u00fcggv\u00e9nyen bel\u00fcli f\u00fcggv\u00e9ny.</li> <li>Az eredm\u00e9ny elt\u00e1rol\u00e1sa egy tuple v\u00e1ltoz\u00f3ban. Ezzel dekonstru\u00e1ljuk is, darabokra szedj\u00fck a tuple-t, mert <code>curr</code>, <code>prev</code> v\u00e1ltoz\u00f3n kereszt\u00fcl el\u00e9rj\u00fck a k\u00e9t <code>long</code> alkot\u00f3r\u00e9szt. Ugyanezen sorban t\u00f6rt\u00e9nik a rekurz\u00edv h\u00edv\u00e1s is.</li> <li>Lass\u00fa m\u0171velet szimul\u00e1ci\u00f3ja mesters\u00e9ges k\u00e9sleltet\u00e9ssel.</li> </ol> <p>Dekonstrukci\u00f3</p> <p>A dekonstrukci\u00f3s szintaxis a kor\u00e1bbi gyakorlaton megismert rekord t\u00edpusok eset\u00e9n is m\u0171k\u00f6dik.</p>"},{"location":"seminar/04-csharp4/chapter4/#dispose-minta","title":"Dispose minta","text":"<p>A Dispose minta az er\u0151forr\u00e1s-felszabad\u00edt\u00e1s megfelel\u0151 megval\u00f3s\u00edt\u00e1s\u00e1hoz k\u00e9sz\u00fclt. Hasonl\u00f3 elv ment\u00e9n \u00fczemel, mint a destruktor, viszont a minta nem felt\u00e9tlen\u00fcl k\u00f6t\u00f6tt az objektum \u00e9letciklus\u00e1nak elej\u00e9hez \u00e9s v\u00e9g\u00e9hez. Amennyiben egy objektum megval\u00f3s\u00edtja az <code>IDisposable</code> interf\u00e9szt, van <code>Dispose</code> met\u00f3dusa. A met\u00f3dus megh\u00edv\u00e1s\u00e1val az objektum \u00e1ltal haszn\u00e1lt, nem a keretrendszer \u00e1ltal menedzselt er\u0151forr\u00e1sokat szabad\u00edtjuk fel. Nem csak mem\u00f3riafoglal\u00e1sra kell gondolni, hanem lehetnek nyitott f\u00e1jlrendszeri handle-\u00f6k, adatkapcsolatok, stream-ek, vagy \u00fczleti er\u0151forr\u00e1sok, tranzakci\u00f3k.</p> <p>M\u00e9rj\u00fck meg az els\u0151 p\u00e1r Fibonacci sz\u00e1m kisz\u00e1m\u00edt\u00e1s\u00e1t (a mesters\u00e9ges k\u00e9sleltet\u00e9ssel):</p> <pre><code>var sw = Stopwatch.StartNew();\nforeach (var n in Enumerable.Range(1, 15))\n{\n  Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n}\nsw.Stop();\nConsole.WriteLine($\"Elapsed: {sw.ElapsedMilliseconds}\");\nConsole.ReadKey();\n</code></pre> <p>Ez \u00edgy j\u00f3, m\u0171k\u00f6dik, viszont nem \u00fajrahasznos\u00edthat\u00f3 ez az id\u0151m\u00e9r\u00e9si mechanizmus.</p> <p>K\u00e9sz\u00edts\u00fcnk egy saj\u00e1t id\u0151m\u00e9r\u0151 oszt\u00e1lyt <code>StopwatchWrapper</code> n\u00e9ven, ami a <code>Stopwatch</code> haszn\u00e1lat\u00e1t egyszer\u0171s\u00edti a Dispose mint\u00e1n kereszt\u00fcl.</p> <pre><code>public class StopwatchWrapper : IDisposable\n{\n    public Stopwatch Stopwatch { get; }\n\n    public string Title { get; }\n\n    public StopwatchWrapper(string? title = default)\n    {\n        Title = title ?? Guid.NewGuid().ToString();\n        Console.WriteLine($\"Task {title} starting at {DateTime.Now}.\");\n        Stopwatch = Stopwatch.StartNew();\n    }\n}\n</code></pre> <p>Ha k\u00e9rj\u00fck a villanyk\u00f6rte seg\u00edts\u00e9g\u00e9t az <code>IDisposable</code>-\u00f6n, akkor 2x2 lehet\u0151s\u00e9g\u00fcnk van: megval\u00f3s\u00edtjuk az interf\u00e9szt implicit vagy explicit, illetve megval\u00f3s\u00edtjuk-e az interf\u00e9szt a Dispose mint\u00e1t alkalmazva. Val\u00f3s\u00edtsuk meg implicit a Dispose mint\u00e1t!</p> <p> Dispose minta implement\u00e1l\u00e1sa IntelliSense seg\u00edts\u00e9g\u00e9vel</p> <p>Fussuk \u00e1t a gener\u00e1lt k\u00f3dot, ami sz\u00e9pen kommentezett. A pattern l\u00e9nyege, hogy a nem menedzselt er\u0151forr\u00e1sokat (unmanaged objects / resources) sz\u00fcks\u00e9ges felszabad\u00edtanunk, amit a <code>Dispose</code> met\u00f3dusokban, illetve menedzselt k\u00f3d eset\u00e9n a kommentekkel kijel\u00f6lt helyen \u00e9rdemes elv\u00e9gezn\u00fcnk. K\u00e9sz\u00edts\u00fck el az id\u0151m\u00e9r\u0151 mechanizmust!</p> <pre><code>protected virtual void Dispose(bool disposing)\n{\n    if (!disposedValue)\n    {\n        if (disposing)\n        {\n            Stopwatch.Stop();\n            Console.WriteLine(\n                $\"Task {Title} completed in { Stopwatch.ElapsedMilliseconds} ms \"+\n                $\"at { DateTime.Now}\");\n        }\n        disposedValue = true;\n    }\n}\n</code></pre> <p>Csak fel\u00fcgyelt er\u0151forr\u00e1sokkal (managed objects) dolgozunk, \u00edgy csak egy helyen kellett a le\u00e1ll\u00edt\u00f3 logik\u00e1t megadnunk.</p> <p>Az <code>IDisposable</code> interf\u00e9szt megval\u00f3s\u00edt\u00f3 elemekkel haszn\u00e1lhatjuk a <code>using</code> konstrukci\u00f3t:</p> <pre><code>using (new StopwatchWrapper(\"Fib 1-15\"))\n{\n    foreach (var n in Enumerable.Range(1, 15))\n    {\n        Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n    }\n}\n</code></pre> <p>Teh\u00e1t a <code>using</code> haszn\u00e1lat\u00e1val a blokk elej\u00e9t \u00e9s v\u00e9g\u00e9t tudjuk kezelni. Gyakorlatilag egy <code>try-finally</code>-val ekvivalens a minta, a <code>finally</code>-ben megh\u00edv\u00f3dik a <code>Dispose</code> met\u00f3dus.</p> <p>Jelenleg csak a folyamat v\u00e9g\u00e9n kapunk jelent\u00e9st az eltelt id\u0151r\u0151l. R\u00e9szid\u0151k ki\u00edr\u00e1s\u00e1hoz k\u00e9sz\u00edts\u00fcnk egy seg\u00e9df\u00fcggv\u00e9nyt a <code>StopwatchWrapper</code>-be:</p> <pre><code>public void Snapshot(string text) =&gt;\n    Console.WriteLine(\n        $\"Task {Title} snapshot {text}: {Stopwatch.ElapsedMilliseconds} ms\"\n    );\n</code></pre> <p>H\u00edvjuk meg a <code>foreach</code> ciklusb\u00f3l:</p> <pre><code>using (var sw = new StopwatchWrapper(\"Fib 1-15\"))\n{\n    foreach (var n in Enumerable.Range(1, 15))\n    {\n        sw.Snapshot(n.ToString());\n        Console.WriteLine($\"{n}: {Fibonacci(n)}\");\n    }\n}\n</code></pre>"},{"location":"seminar/05-aspnetcore1/chapter5/","title":"ASP.NET Core alapszolg\u00e1ltat\u00e1sok","text":""},{"location":"seminar/05-aspnetcore1/chapter5/#projekt-letrehozasa","title":"Projekt l\u00e9trehoz\u00e1sa","text":"<p>Ezen a gyakorlaton nem a be\u00e9p\u00edtett API projektsablont fogjuk felhaszn\u00e1lni, hanem egy \u00fcres ASP.NET Core projektb\u0151l pr\u00f3b\u00e1ljuk fel\u00e9p\u00edteni \u00e9s meg\u00e9rteni azt a funkcionalit\u00e1st, amit egy\u00e9bk\u00e9nt az el\u0151re elk\u00e9sz\u00edtett VS projektsablonok adn\u00e1nak k\u00e9szen a kez\u00fcnkbe.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#generalas","title":"Gener\u00e1l\u00e1s","text":"<p>Hozzunk l\u00e9tre a Visual Studioban egy \u00faj, C# nyelv\u0171 projektet az ASP.NET Core Empty sablonnal, a neve legyen HelloAspNetCore. Megc\u00e9lzott keretrendszerk\u00e9nt adjuk meg a .NET 8-ot. Minden extra opci\u00f3 legyen kikapcsolva, a docker \u00e9s a HTTPS is.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#kitero-nuget-es-a-keretrendszert-alkoto-komponensek-helye","title":"Kit\u00e9r\u0151: NuGet \u00e9s a keretrendszert alkot\u00f3 komponensek helye","text":"<p>A .NET 8 \u00e9s az ASP.NET Core gyakorlatilag teljes m\u00e9rt\u00e9kben publikusan el\u00e9rhet\u0151 komponensekb\u0151l \u00e9p\u00fcl fel. A komponensek kezel\u00e9s\u00e9nek infrastrukt\u00far\u00e1j\u00e1t a NuGet csomagkezel\u0151 szolg\u00e1ltatja. A csomagkezel\u0151n kereszt\u00fcl el\u00e9rhet\u0151 csomagokat a nuget.org list\u00e1zza \u00e9s ig\u00e9ny eset\u00e9n a NuGet kliens, illetve a .NET Core eszk\u00f6z\u00f6k (dotnet.exe, Visual Studio) is innen t\u00f6ltik le. A fejleszt\u0151knek teljes\u00edtm\u00e9nyszempontb\u00f3l nem \u00e9rn\u00e9 meg az alap keretrendszert alkot\u00f3 csomagokat \u00e1lland\u00f3an let\u00f6lt\u00f6getni, \u00edgy a klasszikus keretrendszerekhez hasonl\u00f3an a .NET 8 telep\u00edt\u00e9sekor egy k\u00f6nyvt\u00e1rba (Windows-on ide: C:\\Program Files (x86)\\dotnet, illetve C:\\Program Files\\dotnet) beker\u00fclnek az alap keretrendszert alkot\u00f3 komponensek - l\u00e9nyeg\u00e9ben egy csom\u00f3 .dll k\u00fcl\u00f6nb\u00f6z\u0151 alk\u00f6nyvt\u00e1rakban. A futtat\u00e1shoz sz\u00fcks\u00e9ges szerelv\u00e9nyek a shared alk\u00f6nyvt\u00e1rba telep\u00fclnek, ezek az \u00fan. Shared Framework-\u00f6k. A g\u00e9pen fut\u00f3 k\u00fcl\u00f6nb\u00f6z\u0151 .NET Core/8 alkalmaz\u00e1sok k\u00f6z\u00f6sen haszn\u00e1lhatj\u00e1k ezeket. A fejleszt\u00e9shez az alapvet\u0151 f\u00fcgg\u0151s\u00e9geket a packs alk\u00f6nyvt\u00e1rb\u00f3l hivatkozhatjuk.</p> <p>Nem fejleszt\u0151i, p\u00e9ld\u00e1ul v\u00e9gfelhaszn\u00e1l\u00f3i vagy szerver k\u00f6rnyezetben- ahol nem is biztos, hogy fel van telep\u00edtve az SDK, nem felt\u00e9tlen\u00fcl \u00edgy biztos\u00edtjuk a f\u00fcgg\u0151s\u00e9geket, de ennek a boncolgat\u00e1sa nem t\u00e9m\u00e1ja ennek a gyakorlatnak.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#eredmeny","title":"Eredm\u00e9ny","text":"<p>N\u00e9zz\u00fck meg, milyen projekt gener\u00e1l\u00f3dott:</p> <ul> <li>.csproj: (menu:Projekten jobb gomb[Edit Project File]) a projekt ford\u00edt\u00e1s\u00e1hoz sz\u00fcks\u00e9ges be\u00e1ll\u00edt\u00e1sokat tartalmazza. El\u0151z\u0151 verzi\u00f3khoz k\u00e9pest itt er\u0151sen \u00e9p\u00edtenek az alap\u00e9rtelmezett \u00e9rt\u00e9kekre, hogy min\u00e9l karcs\u00fabbra tudj\u00e1k fogni ezt az \u00e1llom\u00e1nyt.<ul> <li>Project SDK: projekt t\u00edpusa (Microsoft.NET.Sdk.Web), az eszk\u00f6zk\u00e9szlet funkci\u00f3it szab\u00e1lyozza, meghat\u00e1rozza a futtat\u00e1shoz haszn\u00e1latos shared framework-\u00f6t, illetve meghat\u00e1rozza a megc\u00e9lzott keretrendszert is(l\u00e1sd lentebb).</li> <li>TargetFramework: net8.0. Ezzel jelezz\u00fck, hogy .NET 8-os API-kat haszn\u00e1lunk az alkalmaz\u00e1sban.</li> </ul> </li> <li>Connected Services: k\u00fcls\u0151 szolg\u00e1ltat\u00e1sok, amiket haszn\u00e1l a projekt\u00fcnk, most nincs ilyen\u00fcnk.</li> <li>Dependencies: a keretrendszer alapf\u00fcgg\u0151s\u00e9gei \u00e9s egy\u00e9b NuGet csomagf\u00fcgg\u0151s\u00e9gek szerepelnek itt. Egyel\u0151re csak keretrendszer f\u00fcgg\u0151s\u00e9geink vannak.<ul> <li>Frameworks: k\u00e9t alk\u00f6nyvt\u00e1rat (Microsoft.AspNetCore.App, Microsoft.NETCore.App) hivatkozunk a .NET SDK packs alk\u00f6nyvt\u00e1r\u00e1b\u00f3l. Ezek a f\u00fcgg\u0151s\u00e9gek k\u00fcls\u0151 NuGet csomagk\u00e9nt is el\u00e9rhet\u0151ek, de ahogy fentebb jelezt\u00fck, nem \u00e9rdemes \u00fagy hivatkozni \u0151ket.</li> <li>Analyzers: speci\u00e1lis komponensek, amik k\u00f3danal\u00edzist v\u00e9gzenek, de egy\u00e9bk\u00e9nt ugyan\u00fagy k\u00fcls\u0151 f\u00fcgg\u0151s\u00e9gk\u00e9nt (NuGet csomag) kezelhetj\u00fck \u0151ket. Ha kibontjuk az egyes analiz\u00e1torokat, akkor l\u00e1thatjuk, hogy miket ellen\u0151riznek. Ezek a f\u00fcgg\u0151s\u00e9gek a fut\u00e1shoz nem sz\u00fcks\u00e9gesek.</li> </ul> </li> <li>Properties: duplakattra el\u0151j\u00f6n a klasszikus projektbe\u00e1ll\u00edt\u00f3 fel\u00fclet.<ul> <li>launchSettings.json: a k\u00fcl\u00f6nb\u00f6z\u0151 ind\u00edt\u00e1si konfigur\u00e1ci\u00f3khoz tartoz\u00f3 be\u00e1ll\u00edt\u00e1sok (l\u00e1sd k\u00e9s\u0151bb).</li> </ul> </li> <li>appsettings.json: fut\u00e1sidej\u0171 be\u00e1ll\u00edt\u00e1sok helye. Kibonthat\u00f3, kibontva a k\u00fcl\u00f6nb\u00f6z\u0151 k\u00f6rnyezetekre specifikus konfigur\u00e1ci\u00f3k tal\u00e1lhat\u00f3ak (l\u00e1sd k\u00e9s\u0151bb).</li> </ul>"},{"location":"seminar/05-aspnetcore1/chapter5/#legfelso-szintu-kod-minimal-api","title":"Legfels\u0151 szint\u0171 k\u00f3d, minim\u00e1l API","text":"<p>Az el\u0151z\u0151 ASP.NET verzi\u00f3val ellent\u00e9tben, itt m\u00e1r az ASP.NET Core alkalmaz\u00e1sok a sz\u00fclet\u00e9s\u00fckt\u0151l fogva klasszikus konzolos alkalmaz\u00e1sk\u00e9nt is ind\u00edthat\u00f3k, ekkor az alkalmaz\u00e1s alap\u00e9rtelmezett bel\u00e9p\u00e9si pontja a legfels\u0151 szint\u0171 k\u00f3d (esetleg a <code>Main</code> met\u00f3dus). Az ASP.NET Core 6-os verzi\u00f3ban megjelent \u00fan. minim\u00e1l API seg\u00edts\u00e9g\u00e9vel m\u00e1r nem csak a konfigur\u00e1ci\u00f3t tartalmazhatja ez a k\u00f3d, hanem (egyszer\u0171) kiszolg\u00e1l\u00f3 logik\u00e1t is.</p> <p>Eset\u00fcnkben a k\u00f6vetkez\u0151 l\u00e9p\u00e9seket v\u00e9gzi el a gener\u00e1lt k\u00f3d:</p> <ul> <li>a hosztol\u00e1si k\u00f6rnyezetet \u00e9s az alkalmaz\u00e1s alapszolg\u00e1ltat\u00e1sait konfigur\u00e1l\u00f3 builder objektum \u00f6ssze\u00e1ll\u00edt\u00e1sa (<code>CreateBuilder</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> <li>a builder objektum alapj\u00e1n a hosztol\u00e1si k\u00f6rnyezet \u00e9s az alkalmaz\u00e1s szerkezet\u00e9nek fel\u00e1ll\u00edt\u00e1sa (<code>Build</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> <li>v\u00e9gpontot defini\u00e1l az alkalmaz\u00e1s gy\u00f6k\u00e9rc\u00edm\u00e9re minim\u00e1l API seg\u00edts\u00e9g\u00e9vel. A v\u00e9gpont a megh\u00edv\u00e1s\u00e1ra a Hello World! sz\u00f6veget adja vissza.</li> <li>a fel\u00e1ll\u00edtott szerkezet futtat\u00e1sa (<code>Run</code> f\u00fcggv\u00e9nyh\u00edv\u00e1s)</li> </ul> <p>Az igaz\u00e1n munk\u00e1s feladat a builder megalkot\u00e1sa lenne, igen sok mindent lehetne benne konfigur\u00e1lni, ez a k\u00f3dban a <code>CreateBuilder</code>-ben t\u00f6rt\u00e9nik, ami egy szokv\u00e1nyos, az eg\u00e9sz webalkalmaz\u00e1s m\u0171k\u00f6d\u00e9si k\u00f6rnyezet\u00e9t meghat\u00e1roz\u00f3 be\u00e1ll\u00edt\u00e1sokat elv\u00e9gz\u0151 kiindul\u00f3 buildert \u00e1ll\u00edt el\u0151. Ha valamit a kiindul\u00f3 builderben megadott\u00f3l elt\u00e9r\u0151en szeretn\u00e9nk, vagy \u00faj be\u00e1ll\u00edt\u00e1sokat adn\u00e1nk meg, akkor a kiindul\u00f3 builder objektumon t\u00f6rt\u00e9n\u0151 f\u00fcggv\u00e9nyh\u00edv\u00e1sokkal tehetn\u00e9nk meg.</p> <p>Mivel a kiindul\u00f3 builderen nem v\u00e9gz\u00fcnk semmilyen ut\u00f3lagos konfigur\u00e1l\u00e1st, \u00edgy ak\u00e1r egy utas\u00edt\u00e1ssal is megkaphatn\u00e1nk az alkalmaz\u00e1sszerkezetet reprezent\u00e1l\u00f3 <code>WebApplication</code> p\u00e9ld\u00e1nyt.</p> <pre><code>//var builder = WebApplication.CreateBuilder(args);\n//var app = builder.Build();\n\nvar app = WebApplication.Create();\n</code></pre>"},{"location":"seminar/05-aspnetcore1/chapter5/#vegrehajtasi-pipeline-middleware-ek","title":"V\u00e9grehajt\u00e1si pipeline, middleware-ek","text":"<p>Az ASP.NET Core-ban egy k\u00e9r\u00e9s kiszolg\u00e1l\u00e1sa \u00fagy t\u00f6rt\u00e9nik, hogy a k\u00e9r\u00e9s egy cs\u0151vezet\u00e9ken halad (v\u00e9gig). A cs\u0151vezet\u00e9k middleware-ekb\u0151l (MW) \u00e1ll. Az al\u00e1bbi \u00e1bra szeml\u00e9lteti a middleware pipeline m\u0171k\u00f6d\u00e9s\u00e9t.</p> <p> ASP.NET Core pipeline Forr\u00e1s</p> <p>Az ASP.NET Core alkalmaz\u00e1s alapszerkezete, hogy a befut\u00f3 HTTP k\u00e9r\u00e9s (v\u00e9gig)fusson a middleware-ekb\u0151l \u00e1ll\u00f3 cs\u0151vezet\u00e9ken \u00e9s valamelyik (alapesetben az utols\u00f3) middleware el\u0151\u00e1ll\u00edtja a v\u00e1laszt, ami visszair\u00e1nyban halad v\u00e9gig a cs\u0151vezet\u00e9ken. A cs\u0151vezet\u00e9k adja teh\u00e1t az alkalmaz\u00e1s szerkezet\u00e9t. A kiindul\u00f3 cs\u0151vezet\u00e9ket a <code>WebApplication.Create</code> vagy a <code>builder.Build</code> \u00e9p\u00edti fel, ezt ut\u00e1na <code>app.UseX</code> (X= MW neve) h\u00edv\u00e1sokkal testreszabhatjuk, kieg\u00e9sz\u00edthetj\u00fck.</p> <p>Eset\u00fcnkben a kiindul\u00f3 cs\u0151vezet\u00e9kben h\u00e1rom MW van:</p> <ul> <li>kiv\u00e9telkezel\u0151 middleware (<code>UseDeveloperExceptionPage</code>), ami az \u0151t k\u00f6vet\u0151 middleware-ek hib\u00e1it k\u00e9pes elkapni \u00e9s ennek megfelel\u0151en egy a fejleszt\u0151knek sz\u00f3l\u00f3 hibaoldalt jelen\u00edt meg. Ez csak opcion\u00e1lisan ker\u00fcl beregisztr\u00e1l\u00e1sra att\u00f3l f\u00fcgg\u0151en, hogy most \u00e9ppen Development m\u00f3dban futtatjuk-e az alkalmaz\u00e1st vagy sem. (l\u00e1sd k\u00e9s\u0151bb)</li> <li>routing middleware (<code>UseRouting</code>), aminek a feladata, hogy a bej\u00f6v\u0151 k\u00e9r\u00e9s \u00e9s a v\u00e9gpontok (l\u00e1sd lentebb) \u00e1ltal adott inform\u00e1ci\u00f3k alapj\u00e1n kital\u00e1lja, hogy melyik endpoint fel\u00e9 tov\u00e1bb\u00edtsa a bej\u00f6v\u0151 k\u00e9r\u00e9st.</li> <li>v\u00e9gpontok middleware (<code>UseEndpoints</code>), ami a kiv\u00e1lasztott endpoint defin\u00edci\u00f3j\u00e1ban megadott logika t\u00e9nyleges lefuttat\u00e1s\u00e1\u00e9rt felel</li> </ul> <p>P\u00e9lda middleware regisztr\u00e1ci\u00f3ra</p> <p>A kiindul\u00f3 cs\u0151vezet\u00e9k regisztr\u00e1l\u00e1s\u00e1t megfigyelhetj\u00fck a <code>WebApplicationBuilder</code> forr\u00e1sk\u00f3dj\u00e1ban - keress\u00fck az <code>app.UseX</code> sorokat.</p> <p>A kiindul\u00f3 projekt nem v\u00e1ltoztat a kiindul\u00f3 cs\u0151vezet\u00e9ken, csak egy v\u00e9gpont defin\u00edci\u00f3t ad meg (<code>app.MapGet</code> sor).</p> <p>Fontos a sorrend</p> <p>A middleware-ek sorrendje fontos. Ha nem megfelel\u0151 sorrendben regisztr\u00e1ljuk \u0151ket, nem megfelel\u0151 m\u0171k\u00f6d\u00e9s lehet az eredm\u00e9ny. A dokument\u00e1ci\u00f3 \u00e1ltal\u00e1ban tartalmazza, hogy melyik middleware hova illeszthet\u0151 be.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#hosztolasi-lehetosegek-a-fejlesztoi-gepen","title":"Hosztol\u00e1si lehet\u0151s\u00e9gek a fejleszt\u0151i g\u00e9pen","text":"<p>Pr\u00f3b\u00e1ljuk ki IIS Expressen kereszt\u00fcl futtatva, azaz a VS-ben az ind\u00edt\u00f3gomb (z\u00f6ld ny\u00edl) mellett az IIS Express felirat legyen! Ha nem ez a felirat van, \u00e1ll\u00edtsuk \u00e1t az ind\u00edt\u00f3gomb jobb sz\u00e9l\u00e9n l\u00e9v\u0151 men\u00fct lenyitva.</p> <p>K\u00e9t dolog is t\u00f6rt\u00e9nik: az alkalmaz\u00e1sunk IIS Express webkiszolg\u00e1l\u00f3ban hosztolva kezd futni \u00e9s egy b\u00f6ng\u00e9sz\u0151 is elindul, hogy ki tudjuk pr\u00f3b\u00e1lni. Figyelj\u00fck meg az \u00e9rtes\u00edt\u00e9si ter\u00fcleten (az \u00f3ra mellett) megjelen\u0151 IIS Express ikont, \u00e9s azon jobbklikkelve a hosztolt alkalmaz\u00e1s c\u00edm\u00e9t (menu:jobbklikk[Show All Applications]).</p> <p>A b\u00f6ng\u00e9sz\u0151 az alkalmaz\u00e1s gy\u00f6k\u00e9rc\u00edm\u00e9re navig\u00e1l (a c\u00edm csak localhost:port-b\u00f3l \u00e1ll), \u00edgy a Hello World! sz\u00f6veg jelenik meg.</p> <p>B\u00f6ng\u00e9sz\u0151 v\u00e1laszt\u00e1sa</p> <p>A ind\u00edt\u00f3gomb leg\u00f6rd\u00fcl\u0151j\u00e9ben a b\u00f6ng\u00e9sz\u0151 t\u00edpus\u00e1t is \u00e1ll\u00edthatjuk.</p> <p>IIS Express</p> <p>Az IIS Express a Microsoft webszerver\u00e9nek (IIS) fejleszt\u0151i c\u00e9lra optimaliz\u00e1lt v\u00e1ltozata. Alapvet\u0151en csak ugyanarr\u00f3l a g\u00e9pr\u0151l \u00e9rkez\u0151 (localhost) k\u00e9r\u00e9seket szolg\u00e1l ki.</p> <p>A m\u00e1sik lehet\u0151s\u00e9g, ha k\u00f6zvetlen\u00fcl a konzolos alkalmaz\u00e1st szeretn\u00e9nk futtatni, akkor ezt az ind\u00edt\u00f3gombot lenyitva a projekt nev\u00e9t kiv\u00e1lasztva tehetj\u00fck meg. Ebben az esetben egy be\u00e1gyazott webszerverhez (Kestrel) futnak be a k\u00e9r\u00e9sek. Pr\u00f3b\u00e1ljuk ki a Kestrelt k\u00f6zvetlen\u00fcl futtatva!</p> <p>Most is k\u00e9t dolog t\u00f6rt\u00e9nik: az alkalmaz\u00e1sunk konzolos alkalmaz\u00e1sk\u00e9nt kezd futni, illetve az el\u0151z\u0151 esethez hasonl\u00f3an a b\u00f6ng\u00e9sz\u0151 is elindul. Figyelj\u00fck meg a konzolban megjelen\u0151 napl\u00f3\u00fczeneteket.</p> <p>\u00c9les hosting</p> <p>B\u00e1r ezek a hosztol\u00e1si opci\u00f3k fejleszt\u0151i k\u00f6rnyezetben nagyon k\u00e9nyelmesek, \u00e9rdemes \u00e1ttekinteni az \u00e9les hosztol\u00e1si opci\u00f3kat itt. A Kestrel ugyan jelenleg m\u00e1r alkalmas arra, hogy kipublik\u00e1ljuk k\u00f6zvetlen\u00fcl a vil\u00e1gh\u00e1l\u00f3ra, de mivel nem rendelkezik olyan sz\u00e9les konfigur\u00e1ci\u00f3s \u00e9s biztons\u00e1gi be\u00e1ll\u00edt\u00e1sokkal, mint a m\u00e1r bej\u00e1ratott webszerverek, \u00edgy \u00e9rdemes lehet egy ilyen webszervert a Kestrel el\u00e9 rakni proxy gyan\u00e1nt, p\u00e9ld\u00e1ul az IIS-t vagy nginx-et.</p> <p>Rakjunk most a kiszolg\u00e1l\u00f3 logik\u00e1nkba egy kiv\u00e9tel dob\u00e1st a ki\u00edr\u00e1s helyett, hogy kipr\u00f3b\u00e1ljuk a hibakezel\u0151 MW-t.</p> <pre><code>app.MapGet(\"/\", () =&gt;\n{\n    throw new Exception(\"hiba\");\n    //return \"Hello World!\"\n}\n);\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki debugger n\u00e9lk\u00fcl (Ctrl+F5)!</p> <p>L\u00e1thatjuk, hogy a kiv\u00e9telt a hibakezel\u0151 middleware elkapja \u00e9s egy hibaoldalt jelen\u00edt\u00fcnk meg, s\u0151t m\u00e9g a konzolon is megjelenik napl\u00f3bejegyz\u00e9sk\u00e9nt.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#alkalmazasbeallitasok-vs-inditasi-profilok","title":"Alkalmaz\u00e1sbe\u00e1ll\u00edt\u00e1sok vs. ind\u00edt\u00e1si profilok","text":"<p>Figyelj\u00fck meg, hogy most Development konfigur\u00e1ci\u00f3ban fut az alkalmaz\u00e1s (konzolban a Hosting environment kezdet\u0171 sor). Ezt az inform\u00e1ci\u00f3t a keretrendszer k\u00f6rnyezeti v\u00e1ltoz\u00f3 alapj\u00e1n \u00e1llap\u00edtja meg. Ha a lauchSettings.json \u00e1llom\u00e1nyt megn\u00e9zz\u00fck, akkor l\u00e1thatjuk, hogy az <code>ASPNETCORE_ENVIRONMENT</code> k\u00f6rnyezeti v\u00e1ltoz\u00f3 <code>Development</code>-re van \u00e1ll\u00edtva.</p> <p>Pr\u00f3b\u00e1ljuk ki Visual Studio-n k\u00edv\u00fclr\u0151l futtatni. menu:Projekten jobb klikk[Open Folder in File Explorer]. Ezut\u00e1n a c\u00edmsorba mindent kijel\u00f6lve <code>cmd</code> + Enter, a parancssorba <code>dotnet run</code>.</p> <p>Ugyan\u00fagy fog indulni, mint VS-b\u0151l, mert az \u00fajabb .NET verzi\u00f3kban m\u00e1r a dotnet run is figyelembe veszi a launchSettings.json-t. A b\u00f6ng\u00e9sz\u0151t magunknak kell ind\u00edtani (most m\u00e9g) \u00e9s elnavig\u00e1lni a napl\u00f3ban szerepl\u0151 c\u00edmre (Now listening on: http://localhost:port \u00fczenetet keress\u00fcnk).</p> <p>Ha nem akarjuk ezt, akkor a <code>--no-launch-profile</code> kapcsol\u00f3t haszn\u00e1lhatjuk a dotnet run futtat\u00e1s\u00e1n\u00e1l.</p> <p>Most az alkalmaz\u00e1sunk Production m\u00f3dban indul el, \u00e9s ha a localhost:5000-es oldalt megnyitjuk a b\u00f6ng\u00e9sz\u0151ben, akkor nem kapunk hibaoldalt, de a konzolon tov\u00e1bbra is megjelenik a napl\u00f3bejegyz\u00e9s.</p> <p>Le\u00e1ll\u00edt\u00e1s</p> <p>A dotnet run fut\u00e1s\u00e1t Ctrl+C-vel \u00e1ll\u00edthatjuk le.</p> <p>K\u00f6rnyezeti v\u00e1ltoz\u00f3k felv\u00e9tele</p> <p>A konzolban a <code>setx ENV_NAME Value</code> utas\u00edt\u00e1ssal tudunk felvenni k\u00f6rnyezeti v\u00e1ltoz\u00f3t \u00fagy, hogy az permanensen megmaradjon, \u00e9s ne csak a konzolablak bez\u00e1r\u00e1s\u00e1ig maradjon \u00e9rv\u00e9nyben. (Admin/nem admin, illetve powershell konzolok k\u00fcl\u00f6nb\u00f6z\u0151k\u00e9ppen viselkednek)</p> <p>Az eredeti logik\u00e1nkat kommentezz\u00fck vissza.</p> <pre><code>app.MapGet(\"/\", () =&gt;\n{\n    //throw new Exception(\"hiba\");\n    return \"Hello World!\";\n});\n</code></pre> <p>Az alkalmaz\u00e1s sz\u00e1m\u00e1ra a k\u00fcl\u00f6nb\u00f6z\u0151 be\u00e1ll\u00edt\u00e1sokat JSON \u00e1llom\u00e1nyokban t\u00e1rolhatjuk, amelyek ak\u00e1r k\u00f6rnyezetenk\u00e9nt k\u00fcl\u00f6nb\u00f6z\u0151ek is lehetnek. A gener\u00e1lt projekt\u00fcnkben ez az appsettings.json, n\u00e9zz\u00fcnk bele - f\u0151leg napl\u00f3z\u00e1si be\u00e1ll\u00edt\u00e1sok vannak benne. A f\u00e1jl a Solution Explorer ablakban kinyithat\u00f3, alatta megtal\u00e1ljuk az appsettings.Development.json-t. Ebben a Development nev\u0171 konfigur\u00e1ci\u00f3ra vonatkoz\u00f3 be\u00e1ll\u00edt\u00e1sok vannak. Alap\u00e9rtelmez\u00e9sben az appsettings.\\&lt;ind\u00edt\u00e1si konfigur\u00e1ci\u00f3 neve&gt;.json be\u00e1ll\u00edt\u00e1sai jutnak \u00e9rv\u00e9nyre, fel\u00fcl\u00edrva a sima appsettings.json egyez\u0151 \u00e9rt\u00e9keit (a pontosabb logik\u00e1t l\u00e1sd lentebb).</p> <p>\u00c1ll\u00edtsunk Development m\u00f3dban r\u00e9szletesebb napl\u00f3z\u00e1st. Az appsettings.Development.json-ben minden napl\u00f3z\u00e1si szintet \u00edrjunk <code>Debug</code>-ra.</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Debug\",\n      \"Microsoft.AspNetCore\": \"Debug\"\n    }\n  }\n}\n</code></pre> <p>Napl\u00f3z\u00e1si szintek</p> <p>A napl\u00f3z\u00e1si szintek sorrendje itt tal\u00e1lhat\u00f3.</p> <p>Pr\u00f3b\u00e1ljuk ki, hogy \u00edgy az alkalmaz\u00e1sunk fut\u00e1sakor minden b\u00f6ng\u00e9sz\u0151beli friss\u00edt\u00e9s\u00fcnk (F5) megjelenik a konzolon.</p> <p>VS-b\u0151l is tudjuk \u00e1ll\u00edtani a k\u00f6rnyezeti v\u00e1ltoz\u00f3kat, nem kell a launchSettings.json-ben k\u00e9zzel var\u00e1zsolni. A projekt tulajdons\u00e1gok Debug lapj\u00e1n az Open debug launch profiles UI sz\u00f6vegre kattintva egy dial\u00f3gusablak ugrik fel, itt tudunk \u00faj ind\u00edt\u00e1si profilt megadni, illetve a megl\u00e9v\u0151eket m\u00f3dos\u00edtani. V\u00e1lasszuk ki az aktu\u00e1lisan haszn\u00e1lt profilunkat (projektneves), majd \u00edrjuk \u00e1t az ASPNETCORE_ENVIRONMENT k\u00f6rnyezeti v\u00e1ltoz\u00f3 \u00e9rt\u00e9k\u00e9t az Environment Variables r\u00e9szen mondjuk Production-re.</p> <p>Ind\u00edtsuk ezzel a profillal \u00e9s figyelj\u00fck meg, hogy m\u00e1r nem jelennek meg az egyes k\u00e9r\u00e9sek a napl\u00f3ban, b\u00e1rhogy is friss\u00edtgetj\u00fck a b\u00f6ng\u00e9sz\u0151t. Oka: nincs appsettings.Production.json, \u00edgy az \u00e1ltal\u00e1nos appsettings.json jut \u00e9rv\u00e9nyre.</p> <p>Konfigur\u00e1ci\u00f3k forr\u00e1sa</p> <p>Sz\u00e1mos forr\u00e1sb\u00f3l lehet konfigur\u00e1ci\u00f3t megadni: parancssor, k\u00f6rnyezeti v\u00e1ltoz\u00f3, f\u00e1jl (ezt l\u00e1ttuk most), felh\u0151 (Azure Key Vault) stb. Ezek k\u00f6z\u00fcl t\u00f6bbet is haszn\u00e1lhatunk egyszerre, a k\u00fcl\u00f6nb\u00f6z\u0151 forr\u00e1sok konfigur\u00e1ci\u00f3ja a k\u00f6z\u00f6s kulcsok ment\u00e9n \u00f6sszef\u00e9s\u00fcl\u0151dik. A forr\u00e1sok (configuration provider-ek) k\u00f6z\u00f6tt sorrendet adhatunk meg, amikor regisztr\u00e1ljuk \u0151ket, a legutols\u00f3k\u00e9nt regisztr\u00e1lt provider konfigur\u00e1ci\u00f3ja a leger\u0151sebb. Az alap\u00e9rtelmezett provider-ek regisztr\u00e1ci\u00f3j\u00e1t elint\u00e9zi a kor\u00e1bban l\u00e1tott kiindul\u00f3 builder.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#statikus-fajl-mw","title":"Statikus f\u00e1jl MW","text":"<p>Hozzunk l\u00e9tre a projekt gy\u00f6ker\u00e9be egy <code>wwwroot</code> nev\u0171 mapp\u00e1t (menu:jobbklikk a projekten[Add &gt; New Folder]) \u00e9s tegy\u00fcnk egy k\u00e9pf\u00e1jlt bele. (Ellophatjuk pl. a http://www.bme.hu honlap bal fels\u0151 sark\u00e1b\u00f3l a logo-t)</p> <p>A statikus f\u00e1jlkezel\u00e9st a teljes modularit\u00e1s jegy\u00e9ben egy k\u00fcl\u00f6n middleware-k\u00e9nt implement\u00e1lt\u00e1k a Microsoft.AspNetCore.StaticFiles oszt\u00e1lyk\u00f6nyvt\u00e1rban (az AspNetCore.App m\u00e1r f\u00fcgg\u0151s\u00e9gk\u00e9nt tartalmazza, \u00edgy nem kell k\u00fcl\u00f6n hivatkoznunk), csak hozz\u00e1 kell adnunk a pipeline-hoz.</p> <pre><code>app.UseStaticFiles();\napp.MapGet(\"/\", () =&gt; \"Hello World!\");\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>L\u00e1thatjuk hogy a localhost:port c\u00edmen m\u00e9g mindig a Hello World! sz\u00f6veg t\u0171nik fel, de amint a localhost:port/[k\u00e9pf\u00e1jln\u00e9v]-vel pr\u00f3b\u00e1lkozunk, a k\u00e9p t\u00f6lt\u0151dik be. A static file MW megszak\u00edtja a pipeline fut\u00e1s\u00e1t, ha egy \u00e1ltala ismert f\u00e1jlt\u00edpusra hivatkozunk, egy\u00e9bk\u00e9nt tov\u00e1bbh\u00edv a k\u00f6vetkez\u0151 MW-be. Az ilyen MW-eket \u00fan. termin\u00e1l\u00f3 MW-eknek h\u00edvjuk.</p> <p>Breakpoint a lambd\u00e1ban</p> <p>Ezt az egysoros endpoint logik\u00e1ra tett t\u00f6r\u00e9sponttal is szeml\u00e9ltethetj\u00fck. Figyelj\u00fcnk arra, hogy csak a Hello World! sz\u00f6vegre ker\u00fclj\u00f6n a t\u00f6r\u00e9spont \u00e9s ne az eg\u00e9sz <code>MapGet</code> sorra, illetve csak akkor n\u00e9zz\u00fck, hogy mi fut le, amikor a k\u00e9p URL-re h\u00edvunk.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#web-api","title":"Web API","text":"<p>Minden API-n\u00e1l nagyon magas szinten az a c\u00e9l, hogy egy k\u00e9r\u00e9s hat\u00e1s\u00e1ra egy szerveroldali k\u00f3dr\u00e9szlet megh\u00edv\u00f3djon. ASP.NET Core-ban a Minimap API megk\u00f6zel\u00edt\u00e9s mellett alkalmazhat\u00f3 az MVC keretrendszer is, ahol a k\u00f3dr\u00e9szleteket f\u00fcggv\u00e9nyekbe \u00edrjuk, a f\u00fcggv\u00e9nyek pedig \u00fan. kontrollerek-be ker\u00fclnek. Egy controller \u00e1ltal\u00e1ban az egy er\u0151forr\u00e1st\u00edpushoz kapcsol\u00f3d\u00f3 m\u0171veleteket fogja \u00f6ssze. \u00d6sszess\u00e9g\u00e9ben teh\u00e1t a c\u00e9l, hogy a webes k\u00e9r\u00e9s hat\u00e1s\u00e1ra egy kontroller egy f\u00fcggv\u00e9nye megh\u00edv\u00f3djon.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#dummycontroller","title":"DummyController","text":"<p>Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t Controllers n\u00e9ven. A mapp\u00e1ba hozzunk l\u00e9tre egy kontrollert (menu:jobbklikk a Controllers mapp\u00e1n[Add &gt; Controller\u2026 &gt; a bal oldali f\u00e1ban Common &gt; API &gt; jobb oldalon API Controller with read/write actions]) <code>DummyController</code> n\u00e9ven. A gener\u00e1lt kontroller\u00fcnk a Microsoft.AspNetCore.Mvc.Core csomagban tal\u00e1lhat\u00f3 <code>ControllerBase</code> oszt\u00e1lyb\u00f3l sz\u00e1rmazik. (Ezt a csomagot sem kell feltenn\u00fcnk, mivel az AspNetCore.App f\u00fcgg\u0151s\u00e9ge)</p> <p>Adjuk hozz\u00e1 a szolg\u00e1ltat\u00e1sokhoz a kontrollert\u00e1mogat\u00e1s szolg\u00e1ltat\u00e1st, \u00e9s adjuk hozz\u00e1 a cs\u0151vezet\u00e9khez a kontroller kezel\u0151 MW-t. Az egysoros MW-t kommentezz\u00fck ki. \u00cdgy n\u00e9z ki a teljes legfels\u0151 szint\u0171 k\u00f3d:</p> <pre><code>var builder = WebApplication.CreateBuilder(args);\nbuilder.Services.AddControllers(); // (1)!\nvar app = builder.Build();\n/*var app = WebApplication.Create();*/ // (2)!\napp.UseStaticFiles();\n/*app.MapGet(\"/\", () =&gt; \"Hello World!\");*/ // (3)!\napp.MapControllers();\napp.Run();\n</code></pre> <ol> <li>Kontrollert\u00e1mogat\u00e1s szolg\u00e1ltat\u00e1s regisztr\u00e1l\u00e1sa</li> <li>Mivel kell a kiindul\u00f3 builder, \u00edgy ezt az egysoros app inicializ\u00e1ci\u00f3t nem alkalmazhatjuk</li> <li>Egysoros MW kikommentezve</li> </ol> <p>Pr\u00f3b\u00e1ljuk ki.</p> <p>Az alapoldal \u00fcres, viszont ha az <code>/api/Dummy</code> c\u00edmre h\u00edvunk, akkor megjelenik a <code>DummyController.Get</code> \u00e1ltal visszaadott \u00e9rt\u00e9k. A routing szab\u00e1lyok szab\u00e1lyozz\u00e1k, hogy hogyan jut el a HTTP k\u00e9r\u00e9s alapj\u00e1n a v\u00e9grehajt\u00e1s a f\u00fcggv\u00e9nyig. Itt attrib\u00fatum alap\u00fa routing-ot haszn\u00e1lunk, azaz a kontroller oszt\u00e1lyra \u00e9s a f\u00fcggv\u00e9nyeire biggyesztett attrib\u00fatumok hat\u00e1rozz\u00e1k meg, hogy a HTTP k\u00e9r\u00e9s adata (pl. URL) alapj\u00e1n melyik f\u00fcggv\u00e9ny h\u00edv\u00f3dik meg.</p> <p>A <code>DummyController</code> oszt\u00e1lyon l\u00e9v\u0151 <code>Route</code> attrib\u00fatum az <code>\"api/[controller]\"</code> \u00fatvonalat defini\u00e1lja, melyb\u0151l a <code>[controller]</code> \u00fagynevezett token, ami jelen esetben a controller nev\u00e9re cser\u00e9l\u0151dik. Ezzel \u00f6sszess\u00e9g\u00e9ben megadtuk, hogy az <code>api/Dummy</code> \u00fatvonal a <code>DummyController</code>-t v\u00e1lasztja ki, de m\u00e9g nem tudjuk, hogy a f\u00fcggv\u00e9nyei k\u00f6z\u00fcl melyiket kell megh\u00edvni - ez a f\u00fcggv\u00e9nyekre tett attrib\u00fatumokb\u00f3l k\u00f6vetkezik. A <code>Get</code> f\u00fcggv\u00e9nyen lev\u0151 <code>HttpGet</code> mutatja, hogy ez a f\u00fcggv\u00e9ny akkor h\u00edvand\u00f3, ha a GET k\u00e9r\u00e9s URL-je nem folytat\u00f3dik - ellent\u00e9tben a <code>Get(int id)</code> f\u00fcggv\u00e9nnyel, ami az URL-ben m\u00e9g egy tov\u00e1bbi szegmenst v\u00e1r (ez\u00e9rt van egy <code>\"{id}\"</code> param\u00e9ter megadva az attrib\u00fatum konstruktorban), amit az <code>id</code> nev\u0171 f\u00fcggv\u00e9nyparam\u00e9terk\u00e9nt haszn\u00e1l fel.</p> <p>Routing lehet\u0151s\u00e9gek</p> <p>Az API-t publik\u00e1l\u00f3 alkalmaz\u00e1sokn\u00e1l az attrib\u00fatum alap\u00fa routing az aj\u00e1nlott, de emellett vannak m\u00e1s megk\u00f6zel\u00edt\u00e9sek is, p\u00e9ld\u00e1ul Razor alap\u00fa weboldalakn\u00e1l konvenci\u00f3 alap\u00fa routing az aj\u00e1nlott. B\u0151vebben a t\u00e9mak\u00f6rr\u0151l \u00e1ltal\u00e1nosan itt, illetve specifikusan webes API-k vonatkoz\u00e1s\u00e1ban itt lehet olvasni. A dokument\u00e1ci\u00f3 mennyis\u00e9g\u00e9b\u0151l l\u00e1that\u00f3, hogy a routing alrendszer nagyon szofisztik\u00e1lt \u00e9s sokat tud, szerencs\u00e9re az alap m\u0171k\u00f6d\u00e9s el\u00e9g egyszer\u0171 \u00e9s gyorsan megszokhat\u00f3.</p> <p>Ha van id\u0151nk, pr\u00f3b\u00e1ljuk ki az <code>/api/Dummy/[eg\u00e9sz sz\u00e1m]</code> c\u00edmet is. A <code>Get(int id)</code> f\u00fcggv\u00e9ny k\u00f3dj\u00e1nak megfelel\u0151en, b\u00e1rmit adunk meg, az eredm\u00e9ny a value sz\u00f6veg lesz.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#tipusos-beallitasok-ioptionst","title":"T\u00edpusos be\u00e1ll\u00edt\u00e1sok, <code>IOptions&lt;T&gt;</code>","text":"<p>Fentebb l\u00e1ttuk, hogy a konfigur\u00e1ci\u00f3t ki tudtuk olvasni az <code>IConfiguration</code> interf\u00e9szen kereszt\u00fcl, de m\u00e9g jobb lenne, ha csoportos\u00edtva \u00e9s csoportonk\u00e9nt k\u00fcl\u00f6n C# oszt\u00e1lyokon kereszt\u00fcl l\u00e1tn\u00e1nk \u0151ket.</p> <p>B\u0151v\u00edts\u00fck az appsettings.json-t egy saj\u00e1t be\u00e1ll\u00edt\u00e1scsoporttal (DummySettings):</p> <pre><code>{\n  \"Logging\": {\n    \"LogLevel\": {\n      \"Default\": \"Information\",\n      \"Microsoft\": \"Warning\",\n      \"Microsoft.Hosting.Lifetime\": \"Information\"\n    }\n  },\n  \"AllowedHosts\": \"*\", // a sor v\u00e9g\u00e9re beker\u00fclt egy vessz\u0151\n  \"DummySettings\": {\n    \"DefaultString\": \"My Value\",\n    \"DefaultInt\": 23,\n    \"SuperSecret\":  \"Spoiler Alert!!!\"\n  }\n}\n</code></pre> <p>Hozzunk l\u00e9tre egy \u00faj mapp\u00e1t <code>Options</code> n\u00e9ven. A mapp\u00e1ba hozzunk l\u00e9tre egy sima oszt\u00e1lyt <code>DummySettings</code> n\u00e9ven, a szerkezete feleljen meg a JSON-ben le\u00edrt be\u00e1ll\u00edt\u00e1scsoportnak:</p> <pre><code>public class DummySettings\n{\n    public string? DefaultString { get; set; }\n    public int DefaultInt { get; set; }\n    public string? SuperSecret { get; set; }\n}\n</code></pre> <p>Regisztr\u00e1ljuk szolg\u00e1ltat\u00e1sk\u00e9nt a <code>DummySettings</code> kezel\u00e9s\u00e9t, \u00e9s adjuk meg, hogy a p\u00e9ld\u00e1nyt mi alapj\u00e1n kell inicializ\u00e1lni - a konfigur\u00e1ci\u00f3 megfelel\u0151 szekci\u00f3j\u00e1ra hivatkozzunk:</p> <pre><code>builder.Services.Configure&lt;DummySettings&gt;(\n    builder.Configuration.GetSection(nameof(DummySettings)));\n</code></pre> <p>A <code>builder.Services</code>-ben regisztr\u00e1lt szolg\u00e1ltat\u00e1sok val\u00f3j\u00e1ban egy dependency injection (DI) kont\u00e9nerbe ker\u00fclnek regisztr\u00e1l\u00e1sra. Ez t\u00f6bbek k\u00f6z\u00f6tt lehet\u0151v\u00e9 teszi, hogy az alkalmaz\u00e1son bel\u00fcl konstruktorban param\u00e9terk\u00e9nt ig\u00e9nyelj\u00fck a szolg\u00e1ltat\u00e1st. A param\u00e9ter \u00e9rt\u00e9k\u00e9t a DI alrendszer automatikusan t\u00f6lti ki a regisztr\u00e1lt szolg\u00e1ltat\u00e1sok alapj\u00e1n.</p> <p>DI minta prefer\u00e1l\u00e1sa</p> <p>ASP.NET Core k\u00f6rnyezetben (is) t\u00f6rekedj\u00fcnk arra, hogy lehet\u0151leg minden oszt\u00e1lyunk minden f\u00fcgg\u0151s\u00e9g\u00e9t a DI minta szerint a DI kont\u00e9ner kezelje. Ez nagyban hozz\u00e1j\u00e1rul a komponensek k\u00f6z\u00f6tti laza csatol\u00e1s \u00e9s a jobb tesztelhet\u0151s\u00e9g el\u00e9r\u00e9s\u00e9hez. B\u0151vebb inform\u00e1ci\u00f3 az ASP.NET Core DI alrendszer\u00e9r\u0151l a dokument\u00e1ci\u00f3ban tal\u00e1lhat\u00f3.</p> <p>Ig\u00e9nyelj\u00fcnk <code>DummySettings</code>-t a <code>DummyController</code> konstruktorban:</p> <pre><code>private readonly DummySettings _options;\n\npublic DummyController(IOptions&lt;DummySettings&gt; options)\n{\n    options = options.Value;\n}\n</code></pre> <p>IOptions&lt;&gt; \u00e9s t\u00e1rsai</p> <p>L\u00e1that\u00f3, hogy a be\u00e1ll\u00edt\u00e1s <code>IOptions</code>-ba burkolva \u00e9rkezik. Vannak az <code>IOptions</code>-n\u00e1l okosabb burkol\u00f3k is (pl. <code>IOptionsMonitor</code>), ami p\u00e9ld\u00e1ul jelzi, ha megv\u00e1ltozik valamilyen be\u00e1ll\u00edt\u00e1s. B\u0151vebb inform\u00e1ci\u00f3 az <code>IOptions</code> \u00e9s t\u00e1rsair\u00f3l a hivatalos dokument\u00e1ci\u00f3ban tal\u00e1lhat\u00f3.</p> <p>Az eg\u00e9sz sz\u00e1mot v\u00e1r\u00f3 <code>Get</code> v\u00e1ltozatban haszn\u00e1ljuk fel az \u00e9rt\u00e9keket:</p> <pre><code>[HttpGet(\"{id}\")]\npublic string Get(int id)\n{\n    return id % 2 == 0\n        ? (options.DefaultString ?? \"value\")\n        : options.DefaultInt.ToString();\n}\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki, hogy az <code>/api/Dummy/[p\u00e1ros sz\u00e1m]</code>, illetve <code>/api/Dummy/[p\u00e1ratlan sz\u00e1m]</code> v\u00e9gpontok megh\u00edv\u00e1sakor a megfelel\u0151 \u00e9rt\u00e9ket kapjuk-e vissza.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#user-secrets","title":"User Secrets","text":"<p>A projekt k\u00f6nyvt\u00e1ra gyakran valamilyen verzi\u00f3kezel\u0151 (pl. Git) kezel\u00e9s\u00e9ben van. Ilyenkor gyakori probl\u00e9ma, hogy a konfigur\u00e1ci\u00f3s f\u00e1jlokba \u00edrt szenzit\u00edv inform\u00e1ci\u00f3k (API kulcsok, adatb\u00e1zis jelszavak) beker\u00fclnek a verzi\u00f3kezel\u0151be. Ha egy publikus projekten dolgozunk, p\u00e9ld\u00e1ul publikus GitHub projekt, akkor ez komoly biztons\u00e1gi kock\u00e1zat lehet.</p> <p>Szenzit\u00edv inform\u00e1ci\u00f3k</p> <p>Ne tegy\u00fcnk a verzi\u00f3kezel\u0151be szenzit\u00edv inform\u00e1ci\u00f3kat m\u00e9g priv\u00e1t rep\u00f3 eset\u00e9ben sem. Gondoljunk arra is, hogy a verzi\u00f3kezel\u0151 nem felejt! Ami egyszer m\u00e1r beker\u00fclt, azt vissza is lehet nyerni bel\u0151le (history).</p> <p>Ennek a probl\u00e9m\u00e1nak megold\u00e1s\u00e1ra egy eszk\u00f6z a User Secrets t\u00e1rol\u00f3. Jobbklikkelj\u00fcnk a projekten a Solution Explorer ablakban, majd v\u00e1lasszuk a Manage User Secrets men\u00fcpontot. Ennek hat\u00e1s\u00e1ra megny\u00edlik egy secrets.json nev\u0171 f\u00e1jl. Vizsg\u00e1ljuk meg, hol is van ez a f\u00e1jl: vigy\u00fck az egeret a f\u00e1jlf\u00fcl f\u00f6l\u00e9 - azt l\u00e1thatjuk, hogy a f\u00e1jl a felhaszn\u00e1l\u00f3nk saj\u00e1t k\u00f6nyvt\u00e1r\u00e1n bel\u00fcl van \u00e9s az \u00fatvonal r\u00e9sze egy GUID is. A projektf\u00e1jlba (.csproj) beker\u00fclt ugyanez a GUID (a UserSecretsId c\u00edmk\u00e9be).</p> <p>Vegy\u00fcnk fel egy \u00faj be\u00e1ll\u00edt\u00e1st a secrets.json-ba, ami a <code>SuperSecret</code> \u00e9rt\u00e9k\u00e9t \u00edrja fel\u00fcl:</p> <pre><code>{\n  \"DummySettings\": {\n    \"SuperSecret\": \"SECRET\"\n  }\n}\n</code></pre> <p>R\u00e9szleges fel\u00fcl\u00edr\u00e1s</p> <p>A secrets.json-ban csak azokat a json lev\u00e9l elemeket kell felvenni, amiket fel\u00fcl akarunk \u00edrni. Ez a m\u00f3dszer m\u0171k\u00f6dik a sima appsettings.json k\u00f6rnyezetf\u00fcgg\u0151 v\u00e1ltoz\u00f3ira is.</p> <p>T\u00f6r\u00e9spontot let\u00e9ve (pl. a <code>DummyController</code> konstruktor\u00e1nak v\u00e9g\u00e9n) ellen\u0151rizz\u00fck, hogy a titkos \u00e9rt\u00e9k melyik f\u00e1jlb\u00f3l j\u00f6n. Ehhez meg kell h\u00edvnunk b\u00f6ng\u00e9sz\u0151b\u0151l az <code>api/dummy</code> c\u00edmet.</p> <p>User Secrets csak Development m\u00f3dban</p> <p>Fontos tudni, hogy a User Secrets t\u00e1rol\u00f3 csak Development m\u00f3d eset\u00e9n jut \u00e9rv\u00e9nyre, \u00edgy figyelj\u00fcnk r\u00e1, hogy a megfelel\u0151 m\u00f3dot ind\u00edtsuk \u00e9s a k\u00f6rnyezeti v\u00e1ltoz\u00f3k is j\u00f3l legyenek be\u00e1ll\u00edtva.</p> <p>Ez az elj\u00e1r\u00e1s teh\u00e1t a futtat\u00f3 felhaszn\u00e1l\u00f3 saj\u00e1t k\u00f6nyvt\u00e1r\u00e1b\u00f3l a GUID alapj\u00e1n kikeresi a projekthez tartoz\u00f3 secrets.json-t, annak tartalm\u00e1t pedig fut\u00e1s k\u00f6zben \u00f6sszef\u00e9s\u00fcli az appsettings.json tartalm\u00e1val. \u00cdgy szenzit\u00edv adat nem ker\u00fcl a projekt k\u00f6nyvt\u00e1r\u00e1ba.</p> <p>Titkok \u00e9les k\u00f6rnyezetben</p> <p>Mivel a User Secrets t\u00e1rol\u00f3 csak Development m\u00f3d eset\u00e9n jut \u00e9rv\u00e9nyre, \u00edgy ha az \u00e9les v\u00e1ltozatnak sz\u00fcks\u00e9ge van ezekre a titkos \u00e9rt\u00e9kekre, akkor tov\u00e1bbi tr\u00fckk\u00f6kre van sz\u00fcks\u00e9g. Ilyen megold\u00e1s lehet, ha a felh\u0151s hosztol\u00e1s eset\u00e9n a felh\u0151b\u0151l (pl. Azure App Service Configuration) vagy felh\u0151beli titokt\u00e1rol\u00f3b\u00f3l (pl. Azure Key Vault) vagy a DevOps eszk\u00f6zb\u0151l (pl. Azure DevOps Pipeline Secrets) t\u00f6ltj\u00fck be a szenzit\u00edv be\u00e1ll\u00edt\u00e1sokat.</p>"},{"location":"seminar/05-aspnetcore1/chapter5/#epilogus-webapplicationbuilder","title":"Epil\u00f3gus - WebApplicationBuilder","text":"<p>Az eddigiekb\u0151l l\u00e1that\u00f3, hogy sz\u00e1mos alapszolg\u00e1ltat\u00e1s m\u00e1r a <code>CreateBuilder</code> h\u00edv\u00e1s \u00e1ltal visszaadott kiindul\u00f3 builderben konfigur\u00e1lva van. Ilyen az alap (<code>IOptions</code> n\u00e9lk\u00fcli) alkalmaz\u00e1sbe\u00e1ll\u00edt\u00e1sok kezel\u00e9se vagy a napl\u00f3z\u00e1s. A <code>CreateBuilder</code> a <code>WebApplicationBuilder</code> internal konstruktor\u00e1t h\u00edvja.</p> <p>A <code>WebApplicationBuilder</code> el\u0151dje az <code>IWebHostBuilder</code>, ez ut\u00f3bbinak a dokument\u00e1ci\u00f3j\u00e1t tanulm\u00e1nyozva \u00e9rthetj\u00fck meg, hogy mi mindent tud a kiindul\u00f3 builder.</p>"},{"location":"seminar/06-efcore/chapter6/","title":"Entity Framework Core I-II.","text":""},{"location":"seminar/06-efcore/chapter6/#az-entity-framework-lekepezesi-modszerei","title":"Az Entity Framework lek\u00e9pez\u00e9si m\u00f3dszerei","text":"<p>Az objektum-rel\u00e1ci\u00f3s (OR) lek\u00e9pz\u00e9s (mapping) k\u00e9t f\u0151 r\u00e9szb\u0151l \u00e1ll: az egyik az adatb\u00e1zis s\u00e9ma, a m\u00e1sik pedig egy menedzselt k\u00f3db\u00e9li objektummodell. Eset\u00fcnkben a C# k\u00f3dban l\u00e9v\u0151 oszt\u00e1lyokat k\u00e9pezz\u00fck le adatb\u00e1zisbeli objektumokk\u00e1, ezt h\u00edvjuk Code-First mapping m\u00f3dszernek. A m\u00e1sik ir\u00e1ny is lehets\u00e9ges, ha m\u00e1r van egy adatb\u00e1zis s\u00e9m\u00e1nk, akkor azt is lek\u00e9pezhetj\u00fck Code-First modell\u00e9. Ezt a folyamatot Reverse Engineered Code-First nek vagy scaffolding--nak h\u00edvjuk (ez ut\u00f3bbival nem foglalkozunk ezen gyakorlat keret\u00e9ben).</p> <p>Ak\u00e1rhogy is, az Entity Framework Core (EF) mint OR lek\u00e9pez\u0151 eszk\u00f6z (ORM) haszn\u00e1lat\u00e1hoz az al\u00e1bbi \u00f6sszetev\u0151kre van sz\u00fcks\u00e9g:</p> <ul> <li>objektummodell k\u00f3dban</li> <li>rel\u00e1ci\u00f3s modell az adatb\u00e1zisban</li> <li>lek\u00e9pez\u00e9s (mapping) az el\u0151bbi kett\u0151 k\u00f6z\u00f6tt, szint\u00e9n k\u00f3dban megadva</li> <li>maga az Entity Framework Core, mint (NuGet) komponens</li> <li>Entity Framework Core kompatibilis adatb\u00e1zis driver (provider)</li> <li>adatb\u00e1zis kapcsol\u00f3d\u00e1si adatok, connection string form\u00e1tumban</li> </ul>"},{"location":"seminar/06-efcore/chapter6/#a-code-first-lekepezesi-modszer","title":"A Code-First lek\u00e9pez\u00e9si m\u00f3dszer","text":"<p>A Code-First m\u00f3dszer l\u00e9nyege, hogy els\u0151k\u00e9nt az OO entit\u00e1sokat defini\u00e1ljuk egyszer\u0171en programk\u00f3dban, majd a lek\u00e9pez\u00e9st szint\u00e9n programk\u00f3dban. A lek\u00e9pez\u00e9s alapj\u00e1n az EF eszk\u00f6z\u00f6k k\u00e9pesek az adatb\u00e1zis l\u00e9trehoz\u00e1s\u00e1ra, inicializ\u00e1l\u00e1s\u00e1ra \u00e9s a s\u00e9ma v\u00e1ltoz\u00e1sk\u00f6vet\u00e9s\u00e9re is (l\u00e1sd lentebb a Code-First Migrations r\u00e9szt).</p>"},{"location":"seminar/06-efcore/chapter6/#az-entitasok-definialasa","title":"Az entit\u00e1sok defini\u00e1l\u00e1sa","text":"<p>K\u00e9sz\u00edts\u00fcnk egy .NET 8 konzolos alkalmaz\u00e1st (csak ne EF legyen a neve), majd a projekten bel\u00fcl hozzunk l\u00e9tre egy Entities nev\u0171 mapp\u00e1t. Adjunk hozz\u00e1 a mapp\u00e1hoz egyszer\u0171 oszt\u00e1lyokat az al\u00e1bbi s\u00e9m\u00e1nak megfelel\u0151en:</p> <ul> <li><code>Product</code> (<code>Id</code>: <code>int</code>, <code>Name</code>: <code>string</code>, <code>UnitPrice</code>: <code>int</code>)</li> <li><code>Order</code> (<code>Id</code>: <code>int</code>, <code>OrderDate</code>: <code>DateTime</code>)</li> <li><code>Category</code> (<code>Id</code>: <code>int</code>, <code>Name</code>: <code>string</code>)</li> </ul> <p>Az oszt\u00e1lyok legyenek publikusak, az attrib\u00fatumok pedig egyszer\u0171 auto-implement\u00e1lt propertyk (prop snippet).</p> <p>A <code>string</code> t\u00edpus\u00fa property-k eset\u00e9n figyelmeztet a ford\u00edt\u00f3, hogy nem nullozhat\u00f3 referencia t\u00edpus\u00fa property inicializ\u00e1ci\u00f3 ut\u00e1n is <code>null</code> \u00e9rt\u00e9k\u0171 lehet. Ennek kiv\u00e9d\u00e9s\u00e9re az aj\u00e1nlott m\u00f3dszer olyan konstruktor \u00edr\u00e1sa, ami az ilyen propertyk kezdeti \u00e9rt\u00e9k\u00e9t param\u00e9terben megkapja \u00e9s be\u00e1ll\u00edtja.</p> <p>EF Core \u00e9s konstruktorok</p> <p>A konstruktort az EF is fogja h\u00edvni, neki automatikusan tudnia kell, hogy melyik param\u00e9ter melyik tulajdons\u00e1got \u00e1ll\u00edtja - pedig ez a konstruktor szignat\u00far\u00e1j\u00e1b\u00f3l alapesetben nem kik\u00f6vetkeztethet\u0151. Emiatt \u00f6nk\u00e9ntesen tartanunk kell magunkat ahhoz, hogy a konstruktorparam\u00e9ter nev\u00e9nek \u00e9s a property nev\u00e9nek egyeznie kell, kiv\u00e9ve, hogy a param\u00e9tere neve kezd\u0151dhet kisbet\u0171vel is (camel casing).</p> <p>P\u00e9ldak\u00e9nt \u00edgy n\u00e9z ki a <code>Product</code> konstruktor:</p> <pre><code>public Product(string name)\n{\n    Name = name;\n}\n</code></pre> <p>Quick Action</p> <p>A Visual Studio Quick Action-k\u00e9nt fel szokta aj\u00e1nlani a Generate constructor [konstruktorfejl\u00e9c] vagy Add parameter to [konstruktorfejl\u00e9c] gyors k\u00f3dgener\u00e1l\u00e1si lehet\u0151s\u00e9geket, amivel l\u00e9trehozhatjuk vagy b\u0151v\u00edthetj\u00fck a sz\u00fcks\u00e9ges konstruktort.</p>"},{"location":"seminar/06-efcore/chapter6/#mapping-es-egyeb-metaadatok-megadasa-i","title":"Mapping \u00e9s egy\u00e9b metaadatok megad\u00e1sa I.","text":"<p>Eddig megadtuk az entit\u00e1s nev\u00e9t, a rel\u00e1ci\u00f3s attrib\u00fatumok nev\u00e9t \u00e9s t\u00edpus\u00e1t, azonban ezen fel\u00fcl m\u00e9g sok mindent lehet/kell megadni: az entit\u00e1s els\u0151dleges kulcsa, idegen kulcsok, rel\u00e1ci\u00f3k, k\u00e9nyszerek \u00e9s egy\u00e9b mapping inform\u00e1ci\u00f3k (pl. hogy mi legyen a rel\u00e1ci\u00f3s attrib\u00fatum oszlopneve az adatb\u00e1zisban). A Code-First strat\u00e9gia k\u00e9tfajta m\u00f3dszert is k\u00edn\u00e1l ezek megad\u00e1s\u00e1ra. Az egyik m\u00f3dszer, hogy C# attrib\u00fatumokat helyez\u00fcnk az entit\u00e1soszt\u00e1lyok k\u00fcl\u00f6nb\u00f6z\u0151 r\u00e9szeire, a m\u00e1sik, hogy \u00fan. fluent jelleg\u0171 k\u00f3dot alkalmazunk. Ez ut\u00f3bbi m\u00f3dszer els\u0151re furcs\u00e1n n\u00e9z ki, de t\u00f6bbet tud (van, amit attrib\u00fatummal nem lehet megadni).</p> <p>A fenti k\u00e9t m\u00f3dszert kieg\u00e9sz\u00edti a konvenci\u00f3 alap\u00fa konfigur\u00e1ci\u00f3, amikor az EF a rendelkez\u00e9sekre \u00e1ll\u00f3 adatokb\u00f3l automatikusan k\u00f6vetkezteti ki a metaadatokat: p\u00e9ld\u00e1ul gyakori, hogy az els\u0151dleges kulcs neve tartalmazza az id sz\u00f6veget. Az EF teh\u00e1t a konvenci\u00f3 alapj\u00e1n kital\u00e1lhatja, hogy melyik ez els\u0151dleges kulcs oszlop. Ha valamit rosszul tal\u00e1lna ki, vagy v\u00e1ltoztatni akarunk a kital\u00e1lt neveken, akkor azt az attrib\u00fatumos vagy a fluent megad\u00e1ssal tehetj\u00fck meg.</p> <p>Saj\u00e1t konvenci\u00f3k</p> <p>EF Core 7 \u00f3ta saj\u00e1t konvenci\u00f3kat is megadhatunk l\u00e1sd b\u0151vebben.</p> <p>Els\u0151k\u00e9nt azt fogjuk megn\u00e9zni, hogy mit tal\u00e1l ki az EF, ha semmi plusz adatot nem adunk meg.</p>"},{"location":"seminar/06-efcore/chapter6/#relaciok","title":"Rel\u00e1ci\u00f3k","text":"<p>A f\u0151 entit\u00e1sok k\u00f6z\u00f6tti kapcsolatokat mutatja sematikusan az al\u00e1bbi \u00e1bra:</p> <p></p> <p>A rel\u00e1ci\u00f3kat idegen kulcs propertyk \u00e9s navig\u00e1ci\u00f3s propertyk reprezent\u00e1lj\u00e1k. Az idegen kulcs propertyk t\u00edpusa a kapcsolat m\u00e1sik v\u00e9g\u00e9n l\u00e9v\u0151 entit\u00e1s kulcs\u00e1nak t\u00edpusa. A navig\u00e1ci\u00f3s propertyk t\u00edpusa pedig a kapcsolat m\u00e1sik v\u00e9g\u00e9n l\u00e9v\u0151 entit\u00e1s t\u00edpusa vagy ilyen t\u00edpus\u00fa kollekci\u00f3.</p> <p>Egy konkr\u00e9t kapcsolat eset\u00e9ben: a <code>Product</code>-<code>Category</code> egy-t\u00f6bbes kapcsolathoz egy idegen kulcs property \u00e9s egy navig\u00e1ci\u00f3s property tartozik a <code>Product</code> oszt\u00e1lyban \u00e9s egy kollekci\u00f3 t\u00edpus\u00fa navig\u00e1ci\u00f3s property a <code>Category</code>-ban. A t\u00f6bbes navig\u00e1ci\u00f3s property-k legyenek csak olvashat\u00f3k \u00e9s a t\u00edpusuk legyen <code>ICollection&lt;&gt;</code>.</p> <p>Navig\u00e1ci\u00f3s propertyk</p> <p>\u00c1ltal\u00e1noss\u00e1gban nem k\u00f6telez\u0151 egy kapcsolat mindk\u00e9t oldal\u00e1n navig\u00e1ci\u00f3s property-t vagy k\u00fcls\u0151 kulcsot felvenni, de er\u0151sen javasolt \u00e9s mindig j\u00f3, ha van. Az entit\u00e1son v\u00e9gzend\u0151 m\u0171veleteket egyszer\u0171s\u00edti, illetve a konvenci\u00f3s logika is k\u00f6vetkeztet bel\u0151le.</p> <p>A navig\u00e1ci\u00f3s propertyk referencia t\u00edpus\u00faak, \u00edgy foglalkoznunk kell a nullozhat\u00f3s\u00e1g k\u00e9rd\u00e9s\u00e9vel. Ha a kapcsolat modellez\u00e9si szempontb\u00f3l nem k\u00f6telez\u0151 (p\u00e9ld\u00e1ul ha nem v\u00e1rn\u00e1nk el, hogy minden term\u00e9knek legyen megadva a kateg\u00f3ri\u00e1ja), akkor a navig\u00e1ci\u00f3s property t\u00edpusa is legyen \u00e9rtelemszer\u0171en nullozhat\u00f3. Ha a kapcsolat k\u00f6telez\u0151, akkor az aj\u00e1nlott elj\u00e1r\u00e1s, hogy a navig\u00e1ci\u00f3s property t\u00edpusa ne legyen nullozhat\u00f3 - viszont ekkor kezdeti \u00e9rt\u00e9ket kell adnunk. Gyakori eset, hogy egy entit\u00e1st bet\u00f6lt\u00fcnk adatb\u00e1zisb\u00f3l, de a hozz\u00e1 kapcsol\u00f3d\u00f3 entit\u00e1s(oka)t nem, ilyenkor m\u00e9gis a <code>null</code> \u00e9rt\u00e9k lenne a megfelel\u0151. Emiatt az egyik aj\u00e1nlott m\u00f3dszer, ha a propertyt null forgiving oper\u00e1torral inicializ\u00e1ljuk <code>null</code> \u00e9rt\u00e9kre.</p> <p>P\u00e9lda: <code>public Category Category { get; set; } = null!;</code>.</p> <p>Az <code>Order</code>-<code>Product</code> t\u00f6bb-t\u00f6bbes kapcsolatokhoz hozzuk l\u00e9tre a kapcsol\u00f3t\u00e1bl\u00e1nak megfelel\u0151 entit\u00e1st is, ami egy-egy <code>Product</code> \u00e9s <code>Order</code> k\u00f6z\u00f6tti kapcsolatot reprezent\u00e1lja.</p> <ul> <li><code>OrderItem</code> (<code>Id</code>: <code>int</code>, <code>ProductId</code>: <code>int</code>, <code>OrderId</code>: <code>int</code>, <code>Quantity</code>: <code>int</code>)</li> </ul> <p>Kapcsol\u00f3 entit\u00e1s</p> <p>Nem k\u00f6telez\u0151 l\u00e9trehozni oszt\u00e1lyt a kapcsol\u00f3t\u00e1bl\u00e1nak, konfigur\u00e1ci\u00f3val is lehet \u00e9rni, hogy a kapcsol\u00f3t\u00e1bla l\u00e9trej\u00f6jj\u00f6n \u00e9s az EF megfelel\u0151en haszn\u00e1lja. Ezt a m\u00f3dszert akkor \u00e9rdemes k\u00f6vetni, ha a kapcsol\u00f3t\u00e1bla csup\u00e1n technikai tehert\u00e9tel, de ha p\u00e9ld\u00e1ul extra adatot is t\u00e1rol, eset\u00fcnkben a rendelt mennyis\u00e9get (<code>Quantity</code>), akkor jobban k\u00f6vethet\u0151 k\u00f3dot eredm\u00e9nyez, ha explicit l\u00e9trehozzuk a kapcsol\u00f3t\u00e1bl\u00e1nak megfelel\u0151 entit\u00e1st\u00edpust.</p> <p>Az \u00edgy kialakult modell (konstruktorok n\u00e9lk\u00fcl):</p> <p></p> <p>K\u00f3dk\u00e9nt:</p> <pre><code>public class Category\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public ICollection&lt;Product&gt; Products { get; } = new List&lt;Product&gt;();\n\n    public Category(string name)\n    {\n        Name = name;\n    }\n}\n\npublic class Order\n{\n    public int Id { get; set; }\n    public DateTime OrderDate { get; set; }\n    public ICollection&lt;OrderItem&gt; OrderItems { get; } = new List&lt;OrderItem&gt;();\n}\n\npublic class Product\n{\n    public int Id { get; set; }\n    public string Name { get; set; }\n    public int UnitPrice { get; set; }\n    public int CategoryId { get; set; }\n    public Category Category { get; set; } = null!;\n    public ICollection&lt;OrderItem&gt; ProductOrders { get; } = new List&lt;OrderItem&gt;();\n\n    public Product(string name)\n    {\n        Name = name;\n    }\n}\n\npublic class OrderItem\n{\n    public int Id { get; set; }\n    public int ProductId { get; set; }\n    public Product Product { get; set; } = null!;\n    public int OrderId { get; set; }\n    public Order Order { get; set; } = null!;\n    public int Quantity { get; set; }\n}\n</code></pre> <p>Vegy\u00fck \u00e9szre, hogy eddig semmilyen EF specifikus k\u00f3dot nem \u00edrtunk, a modell\u00fcnk sima \u00fan. POCO oszt\u00e1lyokb\u00f3l \u00e1ll.</p>"},{"location":"seminar/06-efcore/chapter6/#kapcsolat-az-adatbazissal","title":"Kapcsolat az adatb\u00e1zissal","text":""},{"location":"seminar/06-efcore/chapter6/#dbcontext-nuget","title":"DbContext - NuGet","text":"<p>Az entit\u00e1sokat defini\u00e1ltuk, a mapping-et az EF esz\u00e9re b\u00edztuk, a k\u00f6vetkez\u0151 l\u00e9p\u00e9s az adatb\u00e1ziss\u00e9ma l\u00e9trehoz\u00e1sa a mapping alapj\u00e1n, amit k\u00e9pes az EF migr\u00e1ci\u00f3s eszk\u00f6ze megoldani.  M\u0171veletet az \u00fan. kontext-en kereszt\u00fcl tudunk v\u00e9gezni. \u00c9rdemes saj\u00e1t kontext t\u00edpust l\u00e9trehozni, amit az alap <code>DbContext</code>-b\u0151l sz\u00e1rmaztatunk. Eddig m\u00e9g nem is \u00edrtunk semmilyen EF specifikus k\u00f3dot, most viszont m\u00e1r kell a <code>DbContext</code> t\u00edpus, \u00edgy NuGet-b\u0151l hozz\u00e1 kell adnunk a Microsoft.EntityFrameworkCore.SqlServer csomagot. Nem ez a csomag tartalmazza a <code>DbContext</code>-et, viszont f\u00fcgg\u0151s\u00e9gk\u00e9nt hivatkozza (Microsoft.EntityFrameworkCore).</p> <p>NuGet csomagok telep\u00edt\u00e9se</p> <p>A NuGet csomagok telep\u00edt\u00e9s\u00e9hez seg\u00edts\u00e9g a dokument\u00e1ci\u00f3ban.</p> <p>NuGet verzi\u00f3k</p> <p>Olyan csomagokn\u00e1l, ahol a verzi\u00f3sz\u00e1moz\u00e1s k\u00f6veti az alap keretrendszer verzi\u00f3sz\u00e1moz\u00e1s\u00e1t, t\u00f6rekedj\u00fcnk arra, hogy a csomagok verzi\u00f3i konzisztensek legyenek egym\u00e1ssal \u00e9s a keretrendszer verzi\u00f3j\u00e1val is - akkor is, ha egy\u00e9bk\u00e9nt a f\u00fcgg\u0151s\u00e9gi szab\u00e1lyok engedn\u00e9k a verzi\u00f3k kever\u00e9s\u00e9t. Ha a projekt\u00fcnk p\u00e9ld\u00e1ul .NET 8-os keretrendszert haszn\u00e1l, akkor az Entity Framework Core \u00e9s egy\u00e9b extra ASP.NET Core csomagok k\u00f6z\u00fcl is olyan verzi\u00f3t v\u00e1lasszunk, ahol legal\u00e1bb a f\u0151verzi\u00f3 egyezik, teh\u00e1t valamilyen 8.x verzi\u00f3t. Ez nem azt jelenti, hogy az inkonzisztens verzi\u00f3k mindig hib\u00e1t eredm\u00e9nyeznek, ink\u00e1bb a projekt \u00e1ltal\u00e1ban stabilabb, ha a f\u0151verzi\u00f3k k\u00f6z\u00f6tti v\u00e1lt\u00e1st egyszerre, k\u00fcl\u00f6n migr\u00e1ci\u00f3s folyamat (p\u00e9lda) keret\u00e9ben v\u00e9gezz\u00fck.</p> <p>Az Entity Framework \u00f6nmag\u00e1ban f\u00fcggetlen az adatb\u00e1zis implement\u00e1ci\u00f3kt\u00f3l, azokhoz k\u00fcl\u00f6nb\u00f6z\u0151, adatb\u00e1zisgy\u00e1rt\u00f3-specifikus adatb\u00e1zis providereken kereszt\u00fcl kapcsol\u00f3dik. A Microsoft.EntityFrameworkCore.SqlServer csomag hivatkozza az EF absztrakt rel\u00e1ci\u00f3s komponens\u00e9t (EntityFrameworkCore.Relational), \u00e9s tartalmazza az MS SQL Server-hez tartoz\u00f3 providert. A providert a <code>DbContext</code> <code>OnConfiguring</code> met\u00f3dus\u00e1ban adhatjuk meg, eset\u00fcnkben a <code>UseSqlServer</code> met\u00f3dussal, ami egy connection stringet v\u00e1r.</p> <p>MS SQL Server helyett a LocalDB nev\u0171 fejleszt\u0151i adatb\u00e1zist haszn\u00e1ljuk, mely fejleszt\u0151i szempontb\u00f3l gyakorlatilag megegyezik az MS SQL Server-rel. A LocalDB a Visual Studio-val egy\u00fctt telep\u00fcl, minden Windows felhaszn\u00e1l\u00f3nak k\u00fcl\u00f6n LocalDB p\u00e9ld\u00e1ny ind\u00edthat\u00f3 el. A Visual Studio az SQL Server Object Explorer ablak megnyit\u00e1sakor automatikusan l\u00e9trehozza a felhaszn\u00e1l\u00f3nkhoz tartoz\u00f3, MSSQLLocalDB nev\u0171 p\u00e9ld\u00e1nyt.</p> <p>Localdb</p> <p>A LocalDB k\u00fcl\u00f6n is let\u00f6lthet\u0151, illetve a vele egy\u00fctt telep\u00fcl\u0151 <code>sqllocaldb</code> parancs seg\u00edts\u00e9g\u00e9vel egyszer\u0171en kezelhet\u0151. Minderr\u0151l b\u0151vebb inform\u00e1ci\u00f3 a dokument\u00e1ci\u00f3ban olvashat\u00f3.</p> <p>Adjunk hozz\u00e1 \u00faj oszt\u00e1lyt a projekthez <code>NorthwindContext</code> n\u00e9ven, ebben defini\u00e1ljuk majd, hogy milyen entit\u00e1skollekci\u00f3kon lehet m\u0171veleteket v\u00e9gezni.</p> <p>Az automatikusan l\u00e9trej\u00f6v\u0151 MSSQLLocalDB nev\u0171 LocalDB p\u00e9ld\u00e1ny connection stringj\u00e9t adjuk meg, pontosabban az SQL Server Object Explorer ablak seg\u00edt\u00e9s\u00e9vel m\u00e1soljuk ki: menu:SQL Server-t kibontva[(localdb)\\MSSQLLocalDB-n jobbklikk &gt; Properties &gt; Connection String]. A kim\u00e1solt stringben az Initial Catalog \u00e9rt\u00e9k\u00e9t (a DB nev\u00e9t) a master-r\u0151l v\u00e1ltoztassuk meg valamilyen m\u00e1s n\u00e9vre, p\u00e9ld\u00e1ul a Neptun k\u00f3dunkra. Ha nincs a stringben Initial Catalog r\u00e9sz, akkor \u00edrjuk a string v\u00e9g\u00e9re, hogy <code>;Initial Catalog=neptunkod</code>.</p> <p> Connection string megszerz\u00e9se az SQL Server Object Explorer-b\u0151l</p> <p>K\u00fcl\u00f6nleges karakterek</p> <p>A connection stringben k\u00fcl\u00f6nleges karakterek (pl. \\) vannak. Ha a kim\u00e1solt connection k\u00e9t \" k\u00f6z\u00e9 illesztj\u00fck be, a VS automatikusan escape-eli a k\u00fcl\u00f6nleges karaktereket. Ellenkez\u0151 esetben (ha pl. a k\u00e9t \" a beilleszt\u00e9s ut\u00e1n ker\u00fcl elhelyez\u00e9sre a sz\u00f6veg k\u00f6r\u00e9) az automatikus escape-el\u00e9s nem t\u00f6rt\u00e9nik meg, ilyenkor ne felejts\u00fck el a @-ot a string el\u00e9 \u00edrni, vagy manu\u00e1lisan escape-elni a sz\u00fcks\u00e9ges karaktereket!</p> <pre><code>public class NorthwindContext : DbContext\n{\n    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n    {\n        optionsBuilder.UseSqlServer(\"&lt;connstring&gt;\");\n    }\n\n    public DbSet&lt;Product&gt; Products =&gt; Set&lt;Product&gt;();\n    public DbSet&lt;Category&gt; Categories =&gt; Set&lt;Category&gt;();\n    public DbSet&lt;Order&gt; Orders =&gt; Set&lt;Order&gt;();\n}\n</code></pre> <p>Connection String helye</p> <p>A nagyobb rugalmass\u00e1g \u00e9rdek\u00e9ben \u00e9rdemes a connection stringet konfigur\u00e1ci\u00f3s f\u00e1jlba helyezni, majd az ASP.NET Core konfigur\u00e1ci\u00f3s megold\u00e1saival felolvasni. Erre egy k\u00e9s\u0151bbi gyakorlaton n\u00e9z\u00fcnk p\u00e9ld\u00e1t.</p> <p><code>DbSet</code> property-k szerepe</p> <p>A <code>DbSet&lt;&gt;</code> t\u00edpus\u00fa tulajdons\u00e1goknak l\u00e1tsz\u00f3lag csak k\u00e9nyelmi funkci\u00f3juk van, a <code>Set&lt;&gt;()</code> f\u00fcggv\u00e9nyh\u00edv\u00e1sokat egyszer\u0171s\u00edtik, azonban val\u00f3j\u00e1ban nagyobb a jelent\u0151s\u00e9g\u00fck. T\u00f6bbek k\u00f6z\u00f6tt ezek alapj\u00e1n der\u00edti fel az EF, hogy melyek az entit\u00e1soszt\u00e1lyok, hiszen alapvet\u0151en nincsen semmilyen megk\u00fcl\u00f6nb\u00f6ztet\u0151 jellemz\u0151j\u00fck. Alapvet\u0151en a <code>DbSet&lt;&gt;</code> t\u00edpus\u00fa property-k t\u00edpusparam\u00e9terei \u00e9s az \u00edgy felder\u00edtett entit\u00e1st\u00edpusokban l\u00e9v\u0151 navig\u00e1ci\u00f3s propertyk t\u00edpusa alapj\u00e1n \u00e1ll \u00f6ssze az entit\u00e1st\u00edpusok k\u00f6re.</p> <p>Az els\u0151 verzi\u00f3s adatel\u00e9r\u00e9si (DAL) r\u00e9teg\u00fcnk ezzel k\u00e9sz is van.</p>"},{"location":"seminar/06-efcore/chapter6/#semamodositas","title":"S\u00e9mam\u00f3dos\u00edt\u00e1s","text":""},{"location":"seminar/06-efcore/chapter6/#code-first-migrations","title":"Code-First Migrations","text":"<p>A k\u00f3dban t\u00f6rt\u00e9n\u0151 s\u00e9mam\u00f3dos\u00edt\u00e1sokat k\u00f6vetni tudja a keretrendszer, \u00e9s a v\u00e1ltoz\u00e1sok alapj\u00e1n friss\u00edteni tudja az adatb\u00e1zis s\u00e9m\u00e1j\u00e1t lefele, illetve felfele ir\u00e1nyban is. Ezt a mechanizmust nevezz\u00fck migr\u00e1ci\u00f3nak. Eset\u00fcnkben a s\u00e9ma null\u00e1r\u00f3l felh\u00faz\u00e1sa is m\u00e1r m\u00f3dos\u00edt\u00e1snak sz\u00e1m\u00edt.</p> <p>A migr\u00e1ci\u00f3 elv\u00e9gz\u00e9s\u00e9re parancssoros utas\u00edt\u00e1sokat kell ig\u00e9nybe venn\u00fcnk. Itt k\u00e9tfajta megk\u00f6zel\u00edt\u00e9s is adott: vannak PowerShell \u00e9s vannak klasszikus cmd (dotnet cli) parancsaink. Fel kell telep\u00edts\u00fck a projekt\u00fcnkbe valamelyik NuGet csomagot:</p> <ul> <li>PowerShell: Microsoft.EntityFrameworkCore.Tools (telep\u00edts\u00fck fel most ezt)</li> <li>Parancssor: Microsoft.EntityFrameworkCore.Tools.DotNet</li> </ul> <p>Hozzuk el\u0151 a Package Manager Console-t. (menu:Tools[NuGet Package Manager &gt; Package Manager Console]). Ellen\u0151rizz\u00fck, hogy a Default Project leg\u00f6rd\u00fcl\u0151ben a mi projekt\u00fcnk van-e kiv\u00e1lasztva. Az <code>Add-Migration &lt;n\u00e9v&gt;</code> paranccsal tudunk k\u00e9sz\u00edteni egy \u00faj migr\u00e1ci\u00f3s l\u00e9p\u00e9st, \u00edgy az els\u0151 migr\u00e1ci\u00f3nk a kiindul\u00f3 s\u00e9m\u00e1nk migr\u00e1ci\u00f3j\u00e1t fogja tartalmazni.</p> <pre><code>Add-Migration Init\n</code></pre> <p>Figyelj\u00fck meg, mit gener\u00e1lt a projekt\u00fcnkbe ez a parancs. Itt a migr\u00e1ci\u00f3hoz egy oszt\u00e1lyt k\u00e9sz\u00edt, ami tartalmazza azokat az utas\u00edt\u00e1sokat (<code>Up</code> f\u00fcggv\u00e9ny), amikkel a modell\u00fcnknek megfelel\u0151 t\u00e1bl\u00e1kat fel lehet venni. Emellett k\u00fcl\u00f6n f\u00fcggv\u00e9nyben (<code>Down</code>) olyan utas\u00edt\u00e1sok is vannak, melyek ugyanezen t\u00e1bl\u00e1kat eldobj\u00e1k.</p> <p>Ford\u00edt\u00e1s ut\u00e1n adjuk ki az <code>Update-Database</code> parancsot, amivel egy adott migr\u00e1ci\u00f3s \u00e1llapotig pr\u00f3b\u00e1lja friss\u00edteni a s\u00e9m\u00e1t. Ha nem adunk meg s\u00e9manevet akkor a legfrissebb migr\u00e1ci\u00f3ig friss\u00edt:</p> <pre><code>Update-Database Init\n</code></pre> <p>Localdb migr\u00e1ci\u00f3s hiba</p> <p>Bizonyos LocalDB verzi\u00f3kn\u00e1l hib\u00e1ra futhat az adatb\u00e1zisl\u00e9trehoz\u00e1s (CREATE FILE encountered operating system error 5(Access is denied.)), mert rossz helyen pr\u00f3b\u00e1lja l\u00e9trehozni az adatb\u00e1zisf\u00e1jlt. Ilyenkor az SQL Server Object Explorer ablakban bontsuk ki a LocalDB p\u00e9ld\u00e1nyunk, alatta a menu:Databases mapp\u00e1n jobbklikk[Add New Database]. A megjelen\u0151 ablakban adjuk meg n\u00e9vk\u00e9nt ugyanazt az adatb\u00e1zisnevet, amit kor\u00e1bban a connection string-ben a master helyett megadtunk.</p> <p>Ellen\u0151rizz\u00fck le az adatb\u00e1zis s\u00e9m\u00e1j\u00e1t az SQL Server Object Explorer ablakban. N\u00e9zz\u00fck meg, hogy puszt\u00e1n konvenci\u00f3k alapj\u00e1n milyen tulajdons\u00e1gokat tal\u00e1lt ki az EF.</p> <p>Migr\u00e1ci\u00f3 k\u00f3db\u00f3l</p> <p>K\u00f3db\u00f3l is legener\u00e1lhatn\u00e1nk az adatb\u00e1zist az aktu\u00e1lis s\u00e9m\u00e1val a <code>DbContext.Database.EnsureCreated</code> met\u00f3dus seg\u00edts\u00e9g\u00e9vel, viszont ez a k\u00e9s\u0151bbiekben megnehez\u00edti a tov\u00e1bbi s\u00e9mam\u00f3dos\u00edt\u00e1st, mivel mindig el kellene dobjuk az adatb\u00e1zist, illetve a migr\u00e1ci\u00f3t sem k\u00f6nny\u0171 ut\u00f3lag bevezetni.</p>"},{"location":"seminar/06-efcore/chapter6/#lekepezes-es-egyeb-metaadatok-megadasa-ii-fluent-es-attributum-alapu-lekepezes","title":"Lek\u00e9pez\u00e9s \u00e9s egy\u00e9b metaadatok megad\u00e1sa II.\u2009\u2014\u2009fluent \u00e9s attrib\u00fatum alap\u00fa lek\u00e9pez\u00e9s","text":"<p>Defini\u00e1ljuk fel\u00fcl a kontext\u00fcnkben az \u0151s <code>OnModelCreating</code> met\u00f3dus\u00e1t \u00e9s itt \u00e1ll\u00edtsunk be p\u00e1r mapping inform\u00e1ci\u00f3t.</p> <pre><code>protected override void OnModelCreating(ModelBuilder modelBuilder)\n{\n    base.OnModelCreating(modelBuilder);\n\n    modelBuilder.Entity&lt;Category&gt;()\n        .Property(c =&gt; c.Name)\n        .HasMaxLength(15);\n}\n</code></pre> <p>Ezzel a <code>Name</code> property hossz\u00e1t \u00e1ll\u00edtottuk be.</p> <p>A fluent mellett pr\u00f3b\u00e1ljuk ki az attrib\u00fatumos konfigur\u00e1ci\u00f3t is. \u00c1ll\u00edtsunk \u00e1t egy oszlopnevet a <code>Product</code> oszt\u00e1lyban a <code>Column</code> attrib\u00fatummal.</p> <pre><code>[Column(\"ProductName\")]\npublic string Name { get; set; }\n</code></pre> <p>POCO</p> <p>A fenti miatt az entit\u00e1smodell\u00fcnk m\u00e1r nem POCO, mert EF specifikus attrib\u00fatum jelent meg a k\u00f3dj\u00e1ban.</p> <p>T\u00f6bbessz\u00e1mok kezel\u00e9se</p> <p>\u00c9rdemes megfigyelni a t\u00e1blanevek kapcs\u00e1n, hogy eleve t\u00f6bbessz\u00e1mos\u00edtott neveket tal\u00e1lunk az adatb\u00e1zisban. Ezt az <code>IPluralizer</code> service v\u00e9gzi, melyhez saj\u00e1t implement\u00e1ci\u00f3 is \u00edrhat\u00f3.</p> <p>Mivel m\u00e1r l\u00e9tezik az adatb\u00e1zisunk, migr\u00e1ci\u00f3 seg\u00edts\u00e9g\u00e9vel kell friss\u00edts\u00fck az adatb\u00e1zis s\u00e9m\u00e1j\u00e1t. K\u00e9sz\u00edts\u00fcnk egy \u00faj migr\u00e1ci\u00f3s l\u00e9p\u00e9st az <code>Add-Migration</code> utas\u00edt\u00e1ssal \u00e9s friss\u00edts\u00fck a s\u00e9m\u00e1t az <code>Update-Database</code> paranccsal.</p> <pre><code>Add-Migration CategoryName_ProductName\nUpdate-Database CategoryName_ProductName\n</code></pre> <p>Migr\u00e1ci\u00f3s SQL script</p> <p>Megn\u00e9zhetj\u00fck az adatb\u00e1zison futtatott SQL-t is a Script-Migration paranccsal. P\u00e9ld\u00e1ul ez mutatja a legut\u00f3bbi m\u00f3dos\u00edt\u00e1st \u00e9rv\u00e9nyes\u00edt\u0151 SQL-t: <code>Script-Migration -From Init</code></p> <p>Migr\u00e1ci\u00f3 vesz\u00e9lyei</p> <p>Term\u00e9szetesen mivel m\u00e9g nincsenek adataink az adatb\u00e1zisban, ak\u00e1r el is dobhatn\u00e1nk az adatb\u00e1zist \u00e9s \u00fajra legener\u00e1lhatn\u00e1nk null\u00e1r\u00f3l a s\u00e9m\u00e1t, de most kifejezetten a migr\u00e1ci\u00f3t szeretn\u00e9nk gyakorolni. Az <code>Add-Migration</code> kimenete figyelmeztet, hogy adatveszt\u00e9s is t\u00f6rt\u00e9nhet. Vannak vesz\u00e9lyes migr\u00e1ci\u00f3s m\u0171veletek, ez\u00e9rt \u00e9rdemes \u00e1tn\u00e9zni a gener\u00e1l\u00f3d\u00f3 migr\u00e1ci\u00f3s k\u00f3dot.</p> <p>Migr\u00e1ci\u00f3k szinkronban tart\u00e1sa</p> <p>Ha valamilyen okb\u00f3l nem megfelel\u0151 a migr\u00e1ci\u00f3nk, ne t\u00f6r\u00f6lj\u00fck k\u00e9zzel a gener\u00e1lt C# k\u00f3df\u00e1jlokat. Haszn\u00e1ljuk helyette a <code>Remove-Migration</code> parancsot (mindenfajta param\u00e9ter n\u00e9lk\u00fcl), ami a legut\u00f3bbi migr\u00e1ci\u00f3t t\u00f6rli.</p> <p>N\u00e9zz\u00fck meg, milyen migr\u00e1ci\u00f3s oszt\u00e1lyt gener\u00e1ltunk, \u00e9s hogy ez milyen utas\u00edt\u00e1sokat tartalmaz.</p> <p>Ellen\u0151rizz\u00fck, hogy a <code>Name</code> oszlop most m\u00e1r az \u00faj k\u00e9nyszereknek megfelel\u0151en lett-e felv\u00e9ve, \u00e9s hogy a term\u00e9kn\u00e9v oszlop neve is megv\u00e1ltozott-e.</p> <p>Ezzel k\u00e9sz a DAL r\u00e9teg\u00fcnk konfigur\u00e1ci\u00f3ja, egy\u00fattal mindent kipip\u00e1ltunk az anyagr\u00e9sz elej\u00e9n l\u00e9v\u0151 felsorol\u00e1sb\u00f3l.</p>"},{"location":"seminar/06-efcore/chapter6/#adatbazis-naplozas","title":"Adatb\u00e1zis napl\u00f3z\u00e1s","text":"<p>A k\u00f6vetkez\u0151 feladat k\u00f6nnyebb k\u00f6vethet\u0151s\u00e9ge \u00e9rdek\u00e9ben \u00e1ll\u00edtsuk be a napl\u00f3z\u00e1st az Entity Framework kapcs\u00e1n. A kontext oszt\u00e1lyba:</p> <pre><code>protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)\n{\n    optionsBuilder.UseSqlServer(\"&lt;connstring&gt;\") // ; t\u00f6r\u00f6lve\n        .LogTo(Console.WriteLine, LogLevel.Information);\n}\n</code></pre> <p>Napl\u00f3z\u00e1s m\u00e1shova</p> <p>Ha nem a konzolt szeretn\u00e9nk teleszemetelni, akkor ak\u00e1r a Debug kimenetre (Output ablak) is \u00edrhatunk. Ehhez a <code>LogTo</code>-nak adjuk meg param\u00e9terk\u00e9nt a <code>m =&gt; Debug.WriteLine(m)</code> deleg\u00e1tot.</p>"},{"location":"seminar/06-efcore/chapter6/#beszuras","title":"Besz\u00far\u00e1s","text":"<p>\u00cdrjunk egy egyszer\u0171 besz\u00far\u00f3 k\u00f3dot a <code>Program.cs</code>-be. V\u00e1rjunk param\u00e9ter\u00fcl egy kontext-et, \u00e9s csak akkor sz\u00farjunk be az adatb\u00e1zisba b\u00e1rmit, ha m\u00e9g \u00fcres.</p> <pre><code>static void SeedDatabase(NorthwindContext ctx)\n{\n    if (ctx.Products.Any())\n    {\n        return;\n    }\n\n    var drink = new Category(\"Ital\");\n    var food = new Category(\"\u00c9tel\");\n\n    ctx.Categories.Add(drink);\n    ctx.Categories.Add(food);\n\n    ctx.Products.Add(new Product(\"S\u00f6r\") { UnitPrice = 50, Category = drink });\n    ctx.Products.Add(new Product(\"Bor\") { Name = \"Bor\", Category = drink });\n    ctx.Products.Add(new Product(\"Tej\") { Name = \"Tej\", CategoryId = drink.Id });\n\n    ctx.SaveChanges();\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy kevert\u00fck a kapcsolatok be\u00e1ll\u00edt\u00e1s\u00e1n\u00e1l a navig\u00e1ci\u00f3s property szerinti, illetve a sima <code>Id</code> \u00e9rt\u00e9k be\u00e1ll\u00edt\u00e1st.</p> <p>H\u00edvjuk meg a legfels\u0151 szint\u0171 k\u00f3db\u00f3l \u00e9s pr\u00f3b\u00e1ljuk meg lek\u00e9rdezni az els\u0151 term\u00e9ket. Rakjunk a k\u00f3d v\u00e9g\u00e9re egy <code>Console.ReadKey</code>-t, hogy legyen id\u0151nk megn\u00e9zni a napl\u00f3t.</p> <pre><code>using var ctx = new NorthwindContext();\nSeedDatabase(ctx);\nvar p = ctx.Products.FirstOrDefault();\n\nConsole.ReadKey();\n</code></pre> <p>Pr\u00f3b\u00e1ljuk ki!</p> <p>Hib\u00e1ra fut, mert besz\u00far\u00e1sn\u00e1l az <code>Id</code> \u00e9rt\u00e9kes hivatkoz\u00e1s alap\u00e9rtelmezett <code>int</code>, azaz 0 \u00e9rt\u00e9k\u0171 lesz, hiszen a kateg\u00f3ria is \u00faj. Az \u00faj elemekn\u00e9l gyakori, hogy az adatb\u00e1zis osztja ki az els\u0151dleges kulcs \u00e9rt\u00e9ket, addig az alap\u00e9rtelmezett \u00e9rt\u00e9k\u0171. Konvenci\u00f3 szerint a mi <code>Id</code> oszlopaink is ilyenek lesznek (\u00fan. IDENTITY oszlopok). A term\u00e9k besz\u00far\u00e1sakor viszont a 0 \u00e9rt\u00e9k m\u00e1r nem lesz helyes, hiszen addigra a kateg\u00f3ria kapott valamilyen kulcs \u00e9rt\u00e9ket. Mindezt a probl\u00e9m\u00e1t navig\u00e1ci\u00f3s property-s hivatkoz\u00e1ssal elker\u00fclhetj\u00fck.</p> <p>Figyelj\u00fck meg a konzol napl\u00f3ban, hogy a <code>Category</code> besz\u00far\u00e1sa m\u00e9g megt\u00f6rt\u00e9nik, de az egyik <code>Product</code> hozz\u00e1ad\u00e1sa m\u00e1r elsz\u00e1ll. A debuggerrel, ha meg\u00e1llunk a <code>SaveChanges</code> h\u00edv\u00e1son, akkor l\u00e1that\u00f3, hogy a <code>CategoryId</code> property \u00e9rt\u00e9ke nulla.</p> <p>Figyelj\u00fck meg azt is, hogy a <code>SaveChanges</code> h\u00edv\u00e1sig nem t\u00f6rt\u00e9nik m\u00f3dos\u00edt\u00f3 adatb\u00e1zism\u0171velet. Az EF mem\u00f3ri\u00e1ban gy\u0171jti a v\u00e1ltoz\u00e1sokat, amiket a SaveChanges-szel szinkroniz\u00e1lunk az adatb\u00e1zisba.</p> <p>Itt l\u00e1thatjuk az alap\u00e9rtelmezett tranzakci\u00f3kezel\u00e9s m\u0171k\u00f6d\u00e9s\u00e9t is. Egy h\u00edv\u00e1sban t\u00f6bb elemet kell besz\u00farni, ha b\u00e1rmelyik m\u0171velet meghi\u00fasul, akkor semmilyen v\u00e1ltoz\u00e1s nem \u00e9rv\u00e9nyes\u00fcl az adatb\u00e1zisban. \u00c1ltal\u00e1nosan igaz, hogy egy <code>SaveChanges</code> vagy minden v\u00e1ltoz\u00e1st \u00e9rv\u00e9nyes\u00edt vagy semmit sem.</p> <p>Jav\u00edtsuk ki:</p> <pre><code>ctx.Products.Add(new Product(\"Tej\")\n{\n    Name = \"Tej\",\n    Category = drink //navig\u00e1ci\u00f3s property-re v\u00e1ltottunk\n});\nctx.SaveChanges();\n</code></pre> <p>Ennek m\u00e1r le kell futnia. N\u00e9zz\u00fck meg a konzolon az SQL utas\u00edt\u00e1sokat \u00e9s a v\u00e1ltoz\u00e1sokat az adatb\u00e1zisban. Param\u00e9terezett <code>INSERT</code> utas\u00edt\u00e1sokat haszn\u00e1l az EF, \u00edgy elker\u00fclve az SQL injection t\u00e1mad\u00e1st.</p> <p>\u00c1tmeneti azonos\u00edt\u00f3k</p> <p>A h\u00e1tt\u00e9rben az EF minden \u00faj entit\u00e1snak kioszt egy \u00e1tmeneti azonos\u00edt\u00f3t, amit felhaszn\u00e1lhatunk a fenti hiba elker\u00fcl\u00e9s\u00e9re, ha semmik\u00e9pp sem akarjuk a navig\u00e1ci\u00f3s property-ket haszn\u00e1lni. \u00cdgy tudn\u00e1nk a context-t\u0151l elk\u00e9rni: <code>ctx.Entry(cat_drink).Property(e =&gt; e.Id).CurrentValue</code></p> <p>Azonos\u00edt\u00f3k kezel\u00e9se</p> <p>Ha egyszerre t\u00f6bb egym\u00e1sra hivatkoz\u00f3 elemet sz\u00farunk be \u00e9s azonos\u00edt\u00f3 alapj\u00e1n k\u00f6tj\u00fck \u0151ket \u00f6ssze, mindig gondoljuk \u00e1t, hogy a t\u00e9nyleges adatb\u00e1zisbeli azonos\u00edt\u00f3k biztosan rendelkez\u00e9sre \u00e1llnak-e, mert k\u00fcl\u00f6nben fut\u00e1sidej\u0171 kiv\u00e9telt kaphatunk, a ford\u00edt\u00f3 nem fog figyelmeztetni.</p>"},{"location":"seminar/06-efcore/chapter6/#osfeltoltes-seeding-elvart-adattartalom-megadasaval","title":"\u0150sfelt\u00f6lt\u00e9s (seeding) elv\u00e1rt adattartalom megad\u00e1s\u00e1val","text":"<p>A kontextuskonfigur\u00e1ci\u00f3 r\u00e9szek\u00e9nt megadhatjuk, hogy milyen adattartalmat szeretn\u00e9nk az egyes t\u00e1bl\u00e1kban l\u00e1tni. A kontext <code>OnModelCreating</code> f\u00fcggv\u00e9ny\u00e9nek v\u00e9g\u00e9re:</p> <pre><code>modelBuilder.Entity&lt;Category&gt;().HasData(\n    new Category (\"Ital\") { Id = 1 }\n);\n\nmodelBuilder.Entity&lt;Product&gt;().HasData(\n    new Product(\"S\u00f6r\") { Id = 1, UnitPrice = 50, CategoryId = 1 },\n    new Product(\"Bor\") { Id = 2, UnitPrice = 550, CategoryId = 1 },\n    new Product(\"Tej\") { Id = 3, UnitPrice = 260, CategoryId = 1 }\n);\n</code></pre> <p>HasData kulcsok</p> <p>Fontos, hogy ezen m\u00f3dszer eset\u00e9n mindenk\u00e9pp k\u00e9zzel meg kell adnunk az els\u0151dleges kulcs \u00e9rt\u00e9keket. Ford\u00edt\u00e1s ut\u00e1n gener\u00e1ltassunk \u00faj migr\u00e1ci\u00f3t \u00e9s friss\u00edts\u00fck is az adatb\u00e1zist - ez ut\u00f3bbi hib\u00e1ra fog futni:</p> <pre><code>Add-Migration Seed\nUpdate-Database\n</code></pre> <p>A <code>HasData</code> alapj\u00e1n gener\u00e1lt migr\u00e1ci\u00f3s k\u00f3d nem veszi figyelembe az id\u0151k\u00f6zben beker\u00fclt adatokat, csak a modellt \u00e9s a t\u00f6bbi migr\u00e1ci\u00f3t n\u00e9zi. Ha megn\u00e9zz\u00fck a gener\u00e1lt k\u00f3dot, l\u00e1thatjuk, hogy csak sima besz\u00far\u00e1sok. Mivel mi k\u00f6zben j\u00f3l \u00f6sszeszemetelt\u00fck az adatb\u00e1zist, a migr\u00e1ci\u00f3 \u00e1ltal kiadott besz\u00far\u00f3 m\u0171veletek j\u00f3 es\u00e9llyel hib\u00e1ra futnak.</p> <p>Ha szeretn\u00e9nk tiszta lappal indulni, b\u00e1rmikor kipucolhatjuk az adatb\u00e1zist a speci\u00e1lis null\u00e1s migr\u00e1ci\u00f3ra val\u00f3 friss\u00edt\u00e9ssel, majd \u00fajrah\u00fazhatjuk a <code>HasData</code>-nak k\u00f6sz\u00f6nhet\u0151en kezdeti adatokkal \u0151sfelt\u00f6ltve.</p> <pre><code>Update-Database 0\nUpdate-Database\n</code></pre> <p>Ezek ut\u00e1n a <code>SeedDatabase</code> h\u00edv\u00e1sra nincs sz\u00fcks\u00e9g, kommentezz\u00fck ki.</p>"},{"location":"seminar/06-efcore/chapter6/#lekerdezesek","title":"Lek\u00e9rdez\u00e9sek","text":"<p>Minden r\u00e9sz ut\u00e1n az el\u0151z\u0151 szakasz k\u00f3dj\u00e1t kommentezz\u00fck ki, hogy ne keltsen felesleges zajt a kimeneten az el\u0151z\u0151 utas\u00edt\u00e1s, illetve ne legyenek felesleges mell\u00e9khat\u00e1sok.</p> <p>K\u00e9rdezz\u00fck le azoknak a term\u00e9keknek a nev\u00e9t, melyeknek neve egy adott bet\u0171t tartalmaz:</p> <pre><code>//SeedDatabase(ctx);\n//var p = ctx.Products.FirstOrDefault();\n\nvar q = from p in ctx.Products\n        where p.Name.Contains(\"\u00f6\")\n        select p.Name;\n\nforeach (var name in q)\n{\n    Console.WriteLine(name);\n}\n</code></pre> <p>Itt figyelhet\u0151 meg a kor\u00e1bban m\u00e1r t\u00e1rgyalt <code>IEnumerable&lt;&gt;</code> - <code>IQueryable&lt;&gt;</code> k\u00fcl\u00f6nbs\u00e9g. A <code>Products</code> property t\u00edpusa <code>DbSet</code>, ami <code>IQueryable&lt;&gt;</code>. Az <code>IQueryable&lt;&gt;</code>-en t\u00f6rt\u00e9n\u0151 h\u00edv\u00e1sok kifejez\u00e9sf\u00e1t (<code>Expression</code>) \u00e9p\u00edtenek \u00e9s szint\u00e9n <code>IQueryable&lt;&gt;</code>-t adnak vissza. A <code>q</code> \u00e9rt\u00e9ke egy olyan <code>IQueryable&lt;&gt;</code>, ami <code>Expression</code>-j\u00e9ben tartalmazza a teljes lek\u00e9rdez\u00e9st. Amikor sz\u00fcks\u00e9g van az adatra, a kifejez\u00e9sfa alapj\u00e1n SQL gener\u00e1l\u00f3dik \u00e9s ez az SQL fut le az adatb\u00e1zison.</p> <p>A debuggerrel l\u00e9ptess\u00fck \u00e1t az egyes utas\u00edt\u00e1sokon a program fut\u00e1s\u00e1t. A k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s miatt csak a <code>foreach</code> v\u00e9grehajt\u00e1sa k\u00f6zben fog az adatb\u00e1zishoz fordulni az EF, hiszen csak ekkor van t\u00e9nylegesen sz\u00fcks\u00e9g az adatra. N\u00e9zz\u00fck meg a lefuttatott SQL-t is. Siker\u00fclt az <code>IQueryable&lt;&gt;</code>-ben tal\u00e1lhat\u00f3 <code>Expression</code>-t SQL utas\u00edt\u00e1ss\u00e1 alak\u00edtania.</p> <p>A fenti p\u00e9ld\u00e1ban az \u00fagynevezett query syntax-t haszn\u00e1ltuk, de ugyanezt megtehetj\u00fck a method vagy fluent syntax-sal is:</p> <pre><code>var q = ctx.Products\n    .Where(p =&gt; p.Name.Contains(\"\u00f6\"))\n    .Select(p =&gt; p.Name);\n</code></pre> <p>A labor sor\u00e1n ez lesz a prefer\u00e1lt a tov\u00e1bbiakban.</p> <p>Az EF el\u00e9g sok C# f\u00fcggv\u00e9nyt SQL-l\u00e9 tud ford\u00edtani. P\u00e9ldak\u00e9pp alak\u00edtsuk a visszaadott nevet nagybet\u0171ss\u00e9.</p> <pre><code>var q = ctx.Products\n    .Where(p =&gt; p.Name.Contains(\"\u00f6\"))\n    .Select(p =&gt; p.Name.ToUpper());\n</code></pre> <p>Figyelj\u00fck meg a konzolon a gener\u00e1lt SQL-t: a projekci\u00f3s r\u00e9szbe beker\u00fclt az <code>UPPER</code> SQL f\u00fcggv\u00e9ny.</p>"},{"location":"seminar/06-efcore/chapter6/#vegyes-kiertekeles","title":"Vegyes ki\u00e9rt\u00e9kel\u00e9s","text":"<p>A f\u00e1k sem n\u0151nek az \u00e9gig, az EF sem tud minden C# f\u00fcggv\u00e9nyt SQL-l\u00e9 ford\u00edtani. Pr\u00f3b\u00e1ljuk ki \u00fagy, hogy a <code>Contains</code>-t karakterrel h\u00edvjuk meg a sz\u0171r\u00e9sben.</p> <pre><code>var q = ctx.Products\n    .Where(p =&gt; p.Name.Contains('\u00f6'))\n    .Select(p =&gt; p.Name.ToUpper());\n</code></pre> <p><code>InvalidOperationException</code>-t kapunk: ezt a lek\u00e9rdez\u00e9st nem tudja a provider SQL-l\u00e9 ford\u00edtani. Egyik lehet\u0151s\u00e9g\u00fcnk, ahogy a hiba\u00fczenet is \u00edrja, hogy kik\u00e9nyszer\u00edtj\u00fck a ki\u00e9rt\u00e9kel\u00e9st a nem lefordul\u00f3 m\u0171velet el\u00e9 helyezett <code>AsEnumerable</code> vagy <code>ToList</code> (illetve ezek aszinkron v\u00e1ltozatai) h\u00edv\u00e1ssal. Pr\u00f3b\u00e1ljuk ki - mivel a sz\u0171r\u00e9st nem siker\u00fclt \u00e1tford\u00edtani, a sz\u0171r\u00e9s el\u00e9 a from v\u00e9g\u00e9re tegy\u00fck az <code>AsEnumerable</code>-t:</p> <pre><code>var q = ctx.Products\n    .AsEnumerable()\n    .Where(p =&gt; p.Name.Contains('\u00f6'))\n    .Select(p =&gt; p.Name.ToUpper());\n</code></pre> <p>Ez m\u0171k\u00f6dik, de a konzolon megjelen\u0151 SQL utas\u00edt\u00e1son l\u00e1tszik, hogy a teljes term\u00e9k t\u00e1bl\u00e1t lek\u00e9rdezt\u00fck \u00e9s felolvastuk a mem\u00f3ri\u00e1ba. Az <code>AsEnumerable</code> jelent\u00e9se: a lek\u00e9rdez\u00e9s innent\u0151l LINQ-to-Objects-k\u00e9nt \u00e9p\u00fcl tov\u00e1bb, a lek\u00e9rdez\u00e9s eddigi r\u00e9sz\u00e9nek mem\u00f3riabeli reprezent\u00e1ci\u00f3ja lesz az adatforr\u00e1s, teh\u00e1t a sz\u0171r\u00e9s \u00e9s a projekci\u00f3 m\u00e1r mem\u00f3ri\u00e1ban fut le. Mivel a teljes lek\u00e9rdez\u00e9s egy r\u00e9sze LINQ-to-Entities (adatb\u00e1zis \u00e9rt\u00e9keli ki), a m\u00e1sik r\u00e9sze LINQ-to-Objects (a .NET runtime \u00e9rt\u00e9keli ki), az ilyen lek\u00e9rdez\u00e9seket \u00fan. vegyes ki\u00e9rt\u00e9kel\u00e9s\u0171nek (mixed evaluation), a LINQ-to-Objects r\u00e9szt kliensoldali ki\u00e9rt\u00e9kel\u00e9s\u0171nek (client evaluation) nevezik. A <code>q</code> t\u00edpusa ebben az esetben m\u00e1r nem <code>IQueryable&lt;&gt;</code>, csak <code>IEnumerable&lt;&gt;</code>.</p> <p>IEnumerable \u00e9s IQueryable k\u00fcl\u00f6nbs\u00e9g\u00e9nek felder\u00edt\u00e9se</p> <p>\u00c9rdemes \u00f6sszevetni a <code>Where</code> f\u00fcggv\u00e9ny defin\u00edci\u00f3j\u00e1t (kurzorral r\u00e1\u00e1llva F12 vagy menu:jobbklikk[Go To Definition]) a k\u00e9t v\u00e1ltozatn\u00e1l. Az els\u0151 esetben <code>IQueryable</code> az adatforr\u00e1s \u00e9s <code>Expression</code> a felt\u00e9tel, a m\u00e1sodikn\u00e1l <code>IEnumerable</code> az adatforr\u00e1s \u00e9s sima delegate a felt\u00e9tel.</p> <p>Vegyes ki\u00e9rt\u00e9kel\u00e9s vesz\u00e9lyei</p> <p>A vegyes ki\u00e9rt\u00e9kel\u00e9s vesz\u00e9lyes lehet, mert a sz\u0171r\u00e9s \u00e9s a projekci\u00f3 m\u00e1r mem\u00f3ri\u00e1ban fut le, azaz az adatb\u00e1zisban l\u00e9v\u0151 adatokat a mem\u00f3ri\u00e1ba kell olvasni, ami nagy adatmennyis\u00e9g eset\u00e9n lass\u00fa \u00e9s er\u0151forr\u00e1sig\u00e9nyes lehet.</p> <p>K\u00fcl\u00f6n\u00f6sen fontos, hogy lehet\u0151leg minden EF lek\u00e9rdez\u00e9s\u00fcnket ellen\u0151rizz\u00fck le, hogy minden r\u00e9sze ott fut-e le (adatb\u00e1zisban vagy mem\u00f3ri\u00e1ban), ahol sz\u00e1m\u00edtunk r\u00e1.</p> <p>M\u00e1sik lehet\u0151s\u00e9g, ha keretrendszer korl\u00e1tba  \u00fctk\u00f6z\u00fcnk, hogy a lek\u00e9rdez\u00e9st megpr\u00f3b\u00e1ljuk \u00fagy \u00e1t\u00edrni, hogy min\u00e9l nagyobb r\u00e9sze lefuttathat\u00f3 legyen adatb\u00e1zisban. Ez a konkr\u00e9t p\u00e9ld\u00e1ban egyszer\u0171, csak vissza kell \u00edrni az els\u0151 v\u00e1ltozatot.</p>"},{"location":"seminar/06-efcore/chapter6/#lekerdezesek-osszefuzese-es-cimkezese","title":"Lek\u00e9rdez\u00e9sek \u00f6sszef\u0171z\u00e9se \u00e9s c\u00edmk\u00e9z\u00e9se","text":"<p>K\u00e9rdezz\u00fck le egy bizonyos \u00e1rn\u00e1l dr\u00e1g\u00e1bb, bizonyos bet\u0171t a nev\u00fckben tartalmaz\u00f3 term\u00e9kek nev\u00e9t - mindezt k\u00e9t k\u00fcl\u00f6n lek\u00e9rdez\u00e9sben:</p> <pre><code>var q1 = ctx.Products.TagWith(\"N\u00e9vsz\u0171r\u00e9s\")\n    .Where(p =&gt; p.Name.Contains(\"r\"));\n\nvar q2 = ctx.Products\n    .Where(p =&gt; p.UnitPrice &gt; 20)\n    .Select(p =&gt; p.Name);\n\nforeach (var name in q2)\n{\n    Console.WriteLine(name);\n}\n</code></pre> <p>A <code>TagWith</code> haszn\u00e1lat\u00e1val k\u00f6nnyebben megtal\u00e1lhatjuk a lek\u00e9rdez\u00e9s \u00e1ltal gener\u00e1lt SQL utas\u00edt\u00e1st a napl\u00f3ban: a f\u00fcggv\u00e9nynek megadott sz\u00f6veg k\u00f6zvetlen\u00fcl a gener\u00e1lt utas\u00edt\u00e1s el\u00e9 ker\u00fcl.</p> <p>Ism\u00e9t figyelj\u00fck meg a napl\u00f3ban, mikor fut le \u00e9s milyen lek\u00e9rdez\u00e9s. Itt is l\u00e1tszik a k\u00e9sleltetett ki\u00e9rt\u00e9kel\u00e9s \u00e9s a lek\u00e9rdez\u00e9sek \u00f6ssze lesznek f\u0171zve, egy lek\u00e9rdez\u00e9s hajt\u00f3dik v\u00e9gre.</p> <p>Lek\u00e9rdez\u00e9sek \u00f6sszef\u0171z\u00e9se</p> <p>Ez r\u00e1mutat az EF egy nagy el\u0151ny\u00e9re: bonyolult lek\u00e9rdez\u00e9seket meg\u00edrhatunk kisebb, egyszer\u0171bb r\u00e9szletekben, az EF pedig \u00f6sszevonja, s\u0151t optimaliz\u00e1lhatja is a teljes lek\u00e9rdez\u00e9st.</p> <p>Pr\u00f3b\u00e1ljuk ki, <code>var q =</code> helyett <code>IEnumerable&lt;Product&gt; q =</code>-val is, ilyenkor nem f\u0171zi \u00f6ssze a lek\u00e9rdez\u00e9st. A <code>q2</code> m\u0171veletei m\u00e1r mem\u00f3ri\u00e1ban fognak lefutni, hiszen a <code>q2</code> adatforr\u00e1sk\u00e9nt csak egy <code>IEnumerable</code>-t l\u00e1t.</p> <p>Pr\u00f3b\u00e1ljuk ki, <code>var q =</code> helyett <code>IQueryable&lt;Product&gt; q =</code> -val is, ilyenkor megint \u00f6sszef\u0171zi a lek\u00e9rdez\u00e9st.</p> <p>Itt is \u00e9rdemes \u00f6sszevetni a <code>where</code> oper\u00e1tor defin\u00edci\u00f3j\u00e1t a k\u00e9t lek\u00e9rdez\u00e9sr\u00e9szben.</p> <p><code>IQueryable</code> \u00e9s <code>IEnumberable</code> k\u00fcl\u00f6nbs\u00e9gei \u00fajra</p> <p>Nem lehet el\u00e9gszer hangs\u00falyozni az <code>IQueryable</code> \u00e9s az <code>IEnumerable</code> k\u00f6zti k\u00fcl\u00f6nbs\u00e9geket. Az <code>IQueryable</code> kifejez\u00e9sek SQL-l\u00e9 fordulnak (amikor le tudnak), m\u00edg az <code>IEnumerable</code>-en v\u00e9gzett m\u0171veletek minden esetben mem\u00f3ri\u00e1ban hajt\u00f3dnak v\u00e9gre.</p> <p>Ha nem akarunk v\u00e9letlen\u00fcl mem\u00f3riabeli ki\u00e9rt\u00e9kel\u00e9sre v\u00e1ltani, az implicit t\u00edpus (<code>var</code>) alkalmaz\u00e1sa j\u00f3 szolg\u00e1latot tehet.</p>"},{"location":"seminar/06-efcore/chapter6/#beszuras-tobb-tobbes-kapcsolatba","title":"Besz\u00far\u00e1s t\u00f6bb-t\u00f6bbes kapcsolatba","text":"<p>Azokat a term\u00e9keket szeretn\u00e9nk megrendelni, amiknek a nev\u00e9ben van egy adott bet\u0171. Haszn\u00e1ljuk fel \u00fajra az el\u0151z\u0151, hasonl\u00f3 lek\u00e9rdez\u00e9s\u00fcnket.</p> <pre><code>var products = ctx.Products\n    .Where(p =&gt; p.Name.Contains(\"r\"))\n    .ToList();\n\nvar order = new Order { OrderDate = DateTime.Now };\n\nforeach (var p in products)\n{\n    order.OrderItems.Add(\n        new OrderItem { Product = p, Order = order, Quantity=2 }\n    );\n}\n\nctx.Orders.Add(order);\nctx.SaveChanges();\n</code></pre> <p>Ism\u00e9t figyelj\u00fck, hogy milyen SQL gener\u00e1l\u00f3dik. Az <code>Order</code> l\u00e9trehoz\u00e1sa ut\u00e1n nek\u00fcnk m\u00e9g egy \u00faj <code>OrderItem</code> entit\u00e1st is l\u00e9tre kell hoznunk, amit a t\u00f6bb-t\u00f6bb kapcsolatra haszn\u00e1lunk fel. Figyelj\u00fck meg, hogy nem kellett minden <code>OrderItem</code>-et k\u00fcl\u00f6n-k\u00fcl\u00f6n hozz\u00e1adnunk a kontextushoz, az <code>Order</code> hozz\u00e1ad\u00e1s\u00e1val minden <code>OrderItem</code> is beker\u00fclt a kontextusba, majd el is ment\u0151d\u00f6tt az adatb\u00e1zisba.</p>"},{"location":"seminar/06-efcore/chapter6/#kapcsolodo-entitasok-betoltese","title":"Kapcsol\u00f3d\u00f3 entit\u00e1sok bet\u00f6lt\u00e9se","text":"<p>\u00cdrjuk ki minden term\u00e9k neve mell\u00e9 a kateg\u00f3ri\u00e1j\u00e1t is.</p> <pre><code>var products = ctx.Products.ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.Name} ({p.Category.Name})\");\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy a fenti lek\u00e9rdez\u00e9sben a kateg\u00f3ria navig\u00e1ci\u00f3s property <code>null</code> \u00e9rt\u00e9k\u0171 \u00e9s kiv\u00e9tel is keletkezik, pedig biztosan tartozik a term\u00e9khez kateg\u00f3ria az adatb\u00e1zisban.  Ennek oka, hogy az EF alapb\u00f3l nem t\u00f6lti be a navig\u00e1ci\u00f3s property-k \u00e9rt\u00e9keit, ezt egy k\u00fcl\u00f6n <code>Include</code> met\u00f3dush\u00edv\u00e1ssal tudjuk megtenni az <code>IQueryable</code> t\u00edpuson. Ez az \u00fan. eager loading.</p> <pre><code>var products = ctx.Products\n    .Include(p =&gt; p.Category)\n    .ToList();\n</code></pre> <p>Ism\u00e9t figyelj\u00fck, hogy mikor mi fut le az adatb\u00e1zisszerveren: ez egy <code>JOIN</code> seg\u00edts\u00e9g\u00e9vel egy f\u00fcst alatt ber\u00e1nt minden adatot mindk\u00e9t t\u00e1bl\u00e1b\u00f3l.</p> <p>Ha a kapcsol\u00f3d\u00f3 <code>Order</code> list\u00e1t is szeretn\u00e9nk kit\u00f6ltetni, akkor ott egyr\u00e9szt a <code>ProductOrders</code> list\u00e1t is be kell <code>Include</code>-olni, m\u00e1sr\u00e9szt pedig m\u00e9g egy kapcsolattal tov\u00e1bbmenve a <code>OrderItem</code> <code>Order</code> tulajdons\u00e1g\u00e1t is be kell t\u00f6ltetni. Az ilyen t\u00f6bbszintes hivatkoz\u00e1st az <code>Include</code> \u00e9s <code>ThenInclude</code> haszn\u00e1lat\u00e1val lehet el\u00e9rni:</p> <pre><code>var products = ctx.Products\n    .Include(p =&gt; p.Category)\n    .Include(p =&gt; p.ProductOrders)\n        .ThenInclude(po =&gt; po.Order)\n    .ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.Name} ({p.Category.Name})\");\n    foreach (var po in p.ProductOrders)\n    {\n        Console.WriteLine($\"\\tRendel\u00e9s: {po.Order.OrderDate}\");\n    }\n}\n</code></pre> <p>Ha nem akarunk minden oszlopot lek\u00e9rdezni az \u00f6sszes \u00e9rintett t\u00e1bl\u00e1b\u00f3l, akkor a projekci\u00f3s (<code>select</code>) r\u00e9szt \u00fagy is meg\u00edrhatjuk, hogy csak a sz\u00fcks\u00e9ges adatokat k\u00e9rdezze le, ez az \u00fan. query result shaping.</p> <pre><code>var products = ctx.Products\n    .Select(p =&gt; new\n    {\n        ProductName = p.Name,\n        CategoryName = p.Category.Name,\n        OrderDates = p.ProductOrders\n            .Select(po =&gt; po.Order.OrderDate)\n            .ToList(),\n    })\n    .ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.ProductName} ({p.CategoryName})\");\n    foreach (var po in p.OrderDates)\n    {\n        Console.WriteLine($\"\\tRendel\u00e9s: {po}\");\n    }\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy a gener\u00e1l\u00f3d\u00f3 <code>SELECT</code> projekci\u00f3s r\u00e9sze \u00edgy j\u00f3val r\u00f6videbb.</p> <p>Lazy Loading</p> <p>Tov\u00e1bbi ritk\u00e1bban alkalmazott / kor\u00e1bbi verzi\u00f3kban elterjedt m\u00f3dszerek: explicit loading, lazy loading.</p>"},{"location":"seminar/06-efcore/chapter6/#tobb-tobbes-kapcsolat-kozvetlen-navigalasa","title":"T\u00f6bb-t\u00f6bbes kapcsolat k\u00f6zvetlen navig\u00e1l\u00e1sa","text":"<p>Lehet\u0151s\u00e9g van t\u00f6bb-t\u00f6bbes kapcsolat navig\u00e1l\u00e1sakor a kapcsol\u00f3t\u00e1bla \u00e1tugr\u00e1s\u00e1ra. Ehhez vegy\u00fcnk fel ennek megfelel\u0151 property-ket a kapcsolat k\u00e9t oldal\u00e1n. Az <code>Order</code>-be:</p> <pre><code>public ICollection&lt;Product&gt; Products { get; } = new List&lt;Product&gt;();\n</code></pre> <p>A <code>Product</code>-ba:</p> <pre><code>public ICollection&lt;Order&gt; Orders { get; } = new List&lt;Order&gt;();\n</code></pre> <p>A kontext <code>OnModelCreating</code>-j\u00e9ben konfigur\u00e1lnunk kell a t\u00f6bb-t\u00f6bbes kapcsolatban r\u00e9szt vev\u0151 minden property-t, hogy az EF tudja, hogy ez az \u00f6sszes property ugyanazon kapcsolathoz tartozik:</p> <pre><code>modelBuilder.Entity&lt;Product&gt;()\n    .HasMany(p =&gt; p.Orders)\n    .WithMany(o =&gt; o.Products)\n    .UsingEntity&lt;OrderItem&gt;(\n        j =&gt; j\n            .HasOne(oi =&gt; oi.Order)\n            .WithMany(o =&gt; o.OrderItems)\n            .HasForeignKey(oi =&gt; oi.OrderId),\n        j =&gt; j\n            .HasOne(oi =&gt; oi.Product)\n            .WithMany(p =&gt; p.ProductOrders)\n            .HasForeignKey(oi =&gt; oi.ProductId),\n        j =&gt;\n        {\n            j.HasKey(oi =&gt; oi.Id);\n        });\n</code></pre> <p>Bonyolultnak t\u0171nik, de ink\u00e1bb csak hossz\u00fa, m\u00edg mind a 9 \u00e9rintett property szerep\u00e9t be\u00e1ll\u00edtjuk.</p> <p>Mindennek nem szabadna adatb\u00e1zis v\u00e1ltoz\u00e1st okoznia, hiszen nem lett t\u00f6bb kapcsolat, csak egy logikai \u00fatr\u00f6vid\u00edt\u00e9st vett\u00fcnk fel. Ellen\u0151rizz\u00fck le:</p> <pre><code>Add-Migration NxN\n</code></pre> <p>Ha mindent j\u00f3l csin\u00e1ltunk, ennek egy \u00fcres migr\u00e1ci\u00f3t kell gener\u00e1lnia. T\u00f6r\u00f6lj\u00fck is.</p> <pre><code>Remove-Migration\n</code></pre> <p>Ezut\u00e1n a kor\u00e1bbi lek\u00e9rdez\u00e9s\u00fcnkn\u00e9l elhagyhatjuk az <code>OrderItem</code> bet\u00f6lt\u00e9s\u00e9t.</p> <pre><code>var products = ctx.Products\n    .Include(p =&gt; p.Category)\n    .Include(p =&gt; p.Orders)\n    .ToList();\n\nforeach (var p in products)\n{\n    Console.WriteLine($\"{p.Name} ({p.Category.Name})\");\n    foreach (var po in p.ProductOrders)\n    {\n        Console.WriteLine($\"\\tRendel\u00e9s: {po.Order.OrderDate}\");\n    }\n}\n</code></pre> <p>Warning</p> <p>Ett\u0151l nem felt\u00e9tlen\u00fcl lesz egyszer\u0171bb vagy gyorsabb a gener\u00e1lt lek\u00e9rdez\u00e9s, csak a k\u00f3dunk lesz egyszer\u0171bb.</p>"},{"location":"seminar/06-efcore/chapter6/#modositas-find","title":"M\u00f3dos\u00edt\u00e1s, Find","text":"<p>N\u00e9zz\u00fcnk p\u00e9ld\u00e1t egyszer\u0171 m\u00f3dos\u00edt\u00e1sra.</p> <pre><code>var pFirst = ctx.Products.Find(1);\nif (pFirst != null)\n{\n    Console.WriteLine(ctx.Entry(pFirst).State);\n    pFirst.UnitPrice *= 2;\n    Console.WriteLine(ctx.Entry(pFirst).State);\n    ctx.SaveChanges();\n    Console.WriteLine(ctx.Entry(pFirst).State);\n}\n</code></pre> <p>Debuggerrel sorr\u00f3l sorra l\u00e9pkedve k\u00f6vess\u00fck v\u00e9gig az EF v\u00e1ltoz\u00e1sk\u00f6vet\u0151 m\u0171k\u00f6d\u00e9s\u00e9t. A lek\u00e9rdez\u00e9sek eredm\u00e9nye alap\u00e9rtelmezetten beker\u00fcl a v\u00e1ltoz\u00e1sk\u00f6vet\u0151be (change tracker). Ezut\u00e1n az oszt\u00e1lyon v\u00e9gezhet\u00fcnk adatv\u00e1ltoztat\u00f3 m\u0171veletet, mindig k\u00f6nnyen eld\u00f6nthet\u0151, hogy volt-e v\u00e1ltoz\u00e1s, ha \u00f6sszevetj\u00fck az aktu\u00e1lis \u00e1llapotot (current value) a beker\u00fcl\u00e9skorival (original value). Figyelj\u00fck meg, hogyan kezeli az EF a hozz\u00e1 tartoz\u00f3 objektumok \u00e1llapot\u00e1t.</p> <p>Change tracker Entry adatai</p> <p>Az <code>Entry</code> \u00e1ltal adott oszt\u00e1lyb\u00f3l megtudhatjuk az aktu\u00e1lis \u00e9s a beker\u00fcl\u00e9skori \u00e9rt\u00e9keket az <code>OriginalValues</code> \u00e9s <code>CurrentValues</code> propertyk \u00e1ltal, amit ak\u00e1r mi is felhaszn\u00e1lhatunk saj\u00e1t change tracking logik\u00e1hoz: pl.: audit napl\u00f3.</p> <p>Find</p> <p>A <code>Find</code> az els\u0151dleges kulcs alapj\u00e1n keres ki egy entit\u00e1st. Nem kell ismern\u00fcnk az els\u0151dleges kulcs property nev\u00e9t. Ha a v\u00e1ltoz\u00e1sk\u00f6vet\u0151be m\u00e1r kor\u00e1bban beker\u00fclt a keresett entit\u00e1s, akkor onnan kapjuk vissza, ilyenkor adatb\u00e1zishozz\u00e1f\u00e9r\u00e9s nem t\u00f6rt\u00e9nik.</p>"},{"location":"seminar/06-efcore/chapter6/#torles","title":"T\u00f6rl\u00e9s","text":"<p>T\u00f6r\u00f6lj\u00fck ki az adatb\u00e1zisb\u00f3l az egyik megrendel\u00e9st.</p> <pre><code>var orderToRemove = ctx.Orders\n    .OrderBy(o =&gt; o.OrderDate)\n    .First();\n\nctx.Orders.Remove(orderToRemove);\nctx.SaveChanges();\n</code></pre> <p>Figyelj\u00fck meg az adatb\u00e1zis adatai k\u00f6z\u00f6tt, hogy az <code>Order</code> t\u00f6rl\u00e9s\u00e9vel a kapcsol\u00f3d\u00f3 <code>OrderItem</code> bejegyz\u00e9sek is t\u00f6rl\u0151dtek, mivel alap\u00e9rtelmezetten a s\u00e9m\u00e1n be van kapcsolva a kaszk\u00e1d t\u00f6rl\u00e9s. Ez ebben az esetben indokolt is lenne, de sokszor nem szeretn\u00e9nk, ha a kapcsol\u00f3d\u00f3 rekordok is t\u00f6rl\u0151dn\u00e9nek. Ennek megakad\u00e1lyoz\u00e1s\u00e1ra vegy\u00fck fel explicit a konfigur\u00e1ci\u00f3ban az <code>Order-OrderItem</code> kapcsolatot \u00e9s kapcsoljuk ki rajta a kaszk\u00e1d t\u00f6rl\u00e9st az <code>OnModelCreating</code>-ben.</p> <pre><code>j =&gt; j\n    .HasOne(oi =&gt; oi.Order)\n    .WithMany(o =&gt; o.OrderItems)\n    .HasForeignKey(oi =&gt; oi.OrderId) // , t\u00f6r\u00f6lve\n    .OnDelete(DeleteBehavior.Restrict),\n</code></pre> <p>A t\u00f6r\u00f6lt <code>Order</code>-t \u00e9s a sz\u00fcks\u00e9ges kapcsol\u00f3 rekordokat vegy\u00fck fel migr\u00e1ci\u00f3 \u00e1ltal besz\u00fart adatk\u00e9nt. Az <code>OnModelCreating</code> v\u00e9g\u00e9re:</p> <pre><code>modelBuilder.Entity&lt;Order&gt;().HasData(\n     new Order { Id = 1, OrderDate = new DateTime(2019, 02, 01) }\n);\n\nmodelBuilder.Entity&lt;OrderItem&gt;().HasData(\n    new OrderItem { Id = 1, OrderId = 1, ProductId = 1 },\n    new OrderItem { Id = 2, OrderId = 1, ProductId = 2 }\n);\n</code></pre> <p>Ford\u00edt\u00e1s ut\u00e1n ne felejts\u00fck el migr\u00e1ci\u00f3val \u00e1tvezetni az adatb\u00e1zis s\u00e9m\u00e1j\u00e1ba is a v\u00e1ltoz\u00e1sokat, mivel a kaszk\u00e1d t\u00f6rl\u00e9s egy MSSQL funkci\u00f3 nem EF viselked\u00e9s.</p> <pre><code>Add-Migration ProductOrderRestrictDelete\nUpdate-Database 0\nUpdate-Database\n</code></pre> <p>Futtassuk \u00fajra a t\u00f6rl\u0151 k\u00f3dot - kiv\u00e9telt kapunk, mivel az <code>OrderItem</code> rekord nem t\u00f6rl\u0151d\u00f6tt kaszk\u00e1d m\u00f3don, \u00edgy az egy m\u00e1r nem l\u00e9tez\u0151 <code>Order</code>-re hivatkozik, viszont ez a k\u00fcls\u0151 kulcs k\u00e9nyszert megs\u00e9rti. Emiatt az eg\u00e9sz t\u00f6rl\u00e9si m\u0171velet meghi\u00fasul.</p> <p>Soft delete</p> <p>Adatkezel\u0151 alkalmaz\u00e1sokban az adatb\u00e1zisbeli t\u00f6rl\u00e9s (SQL <code>DELETE</code> utas\u00edt\u00e1s) helyett gyakran ink\u00e1bb logikai t\u00f6rl\u00e9st (soft delete) alkalmaznak. A logikai t\u00f6rl\u00e9s megval\u00f3s\u00edt\u00e1s\u00e1val ezen gyakorlat keret\u00e9ben nem foglalkozunk, de egyszer\u0171en megval\u00f3s\u00edthat\u00f3 a SaveChanges fel\u00fcldefini\u00e1l\u00e1s\u00e1val, abban a change tracker figyel\u00e9s\u00e9vel \u00e9s lek\u00e9rdez\u00e9skor Global Query Filter haszn\u00e1lat\u00e1val.</p>"},{"location":"seminar/06-efcore/chapter6/#felsorolt-tipus-ertekkonvertalok","title":"Felsorolt t\u00edpus, \u00e9rt\u00e9kkonvert\u00e1l\u00f3k","text":"<p>Az EF alap\u00e9rtelmezetten k\u00e9pes a felsorolt t\u00edpusokat is lek\u00e9pezni. Hozzunk l\u00e9tre \u00faj felsorolt t\u00edpust a <code>Product</code> oszt\u00e1ly mell\u00e9 <code>ShipmentRegion</code> n\u00e9ven.</p> <pre><code>[Flags]\npublic enum ShipmentRegion\n{\n    EU = 1,\n    NorthAmerica = 2,\n    Asia = 4,\n    Australia = 8\n}\n</code></pre> <p>A <code>Flags</code> attrib\u00fatummal azt jelezz\u00fck, hogy szeretn\u00e9nk a bitm\u0171veleteket is alkalmazni a felsorolt \u00e9rt\u00e9k\u00e9re, \u00edgy egy <code>ShipmentRegion</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3 egyszerre t\u00f6bb \u00e9rt\u00e9ket is felvehet (pl.: 3-as \u00e9rt\u00e9k egyszerre tartalmazza az EU-t \u00e9s \u00c9szak-Amerik\u00e1t is).</p> <p>Vegy\u00fcnk fel a <code>Product</code> oszt\u00e1lyba egy \u00faj property-t az \u00faj felsorolt t\u00edpussal.</p> <pre><code>public ShipmentRegion? ShipmentRegion { get; set; }\n</code></pre> <p>M\u00f3dos\u00edtsuk \u00e9s b\u0151v\u00edts\u00fck a kezdeti <code>Product</code>-ok list\u00e1j\u00e1t sz\u00e1ll\u00edt\u00e1si inform\u00e1ci\u00f3kkal:</p> <pre><code>modelBuilder.Entity&lt;Product&gt;().HasData(\n    new Product(\"S\u00f6r\")\n    {\n        Id = 1,\n        UnitPrice = 50,\n        CategoryId = 1,\n        ShipmentRegion = ShipmentRegion.Asia\n    },\n    new Product(\"Bor\") { Id = 2, UnitPrice = 550, CategoryId = 1 },\n    new Product(\"Tej\") { Id = 3, UnitPrice = 260, CategoryId = 1 },\n    new Product(\"Whiskey\")\n    {\n        Id = 4,\n        UnitPrice = 960,\n        CategoryId = 1,\n        ShipmentRegion = ShipmentRegion.Australia\n    },\n    new Product(\"Rum\")\n    {\n        Id = 5,\n        UnitPrice = 960,\n        CategoryId = 1,\n        ShipmentRegion = ShipmentRegion.EU | ShipmentRegion.NorthAmerica\n    }\n);\n</code></pre> <p>Figyelj\u00fck meg a gener\u00e1lt migr\u00e1ci\u00f3ban, hogy milyen \u00fcgyesen lekezeli az EF a kor\u00e1bbi migr\u00e1ci\u00f3ban besz\u00fart elem (1-es <code>Id</code>) v\u00e1ltoz\u00e1s\u00e1t, m\u00f3dos\u00edt\u00f3 k\u00f3dot gener\u00e1l hozz\u00e1.</p> <p>V\u00e1ltozott a modell, friss\u00edts\u00fck az adatb\u00e1zist.</p> <pre><code>Add-Migration ProductShipmentRegion\nUpdate-Database\n</code></pre> <p>Figyelj\u00fck meg, hogy az \u00faj oszlop eg\u00e9sz sz\u00e1mk\u00e9nt t\u00e1rolja a felsorolt t\u00edpus \u00e9rt\u00e9keit. Ha ez nem tetszik nek\u00fcnk, mert p\u00e9ld\u00e1ul sz\u00f6vegesen szeretn\u00e9nk az adatb\u00e1zisban l\u00e1tni az \u00e9rt\u00e9keket, haszn\u00e1lhatjuk az \u00e9rt\u00e9kkonvert\u00e1l\u00f3kat (value converter), melyek az adatb\u00e1zis- \u00e9s az objektummodell k\u00f6z\u00f6tt k\u00e9pesek oda-vissza konvert\u00e1lni a lek\u00e9pezett elemek \u00e9rt\u00e9keit. Sz\u00e1mos be\u00e9p\u00edtett konvert\u00e1l\u00f3 van az EF-ben, melyek k\u00f6z\u00fcl a leggyakoribbakat automatikusan alkalmaz is az EF, el\u00e9g csak a c\u00e9lt\u00edpust megadnunk. Az felsorolt t\u00edpus - sz\u00f6veg \u00e1talak\u00edt\u00f3 is ilyen. Az <code>OnModelCreating</code>-be:</p> <pre><code>modelBuilder\n    .Entity&lt;Product&gt;()\n    .Property(e =&gt; e.ShipmentRegion)\n    .HasConversion&lt;string&gt;();\n</code></pre> <p>V\u00e1ltozott a modell, friss\u00edts\u00fck az adatb\u00e1zist.</p> <pre><code>Add-Migration ProductShipmentRegionAsString\nUpdate-Database\n</code></pre> <p>Migr\u00e1ci\u00f3k helyess\u00e9g\u00e9nek ellen\u0151rz\u00e9se</p> <p>Ahogy a migr\u00e1ci\u00f3 gener\u00e1l\u00e1sakor a figyelmeztet\u00e9s is \u00edrja, ellen\u0151rizz\u00fck a migr\u00e1ci\u00f3t, mert olyan oszlop t\u00edpus\u00e1t v\u00e1ltoztatjuk, amiben vannak m\u00e1r adatok, ez pedig k\u00fcl\u00f6n\u00f6s k\u00f6r\u00fcltekint\u00e9st ig\u00e9nyel. A gener\u00e1lt migr\u00e1ci\u00f3 nem is t\u00f6k\u00e9letes, a <code>Down</code> r\u00e9szben el\u0151bb \u00e1ll\u00edtja a migr\u00e1ci\u00f3 <code>nvarchar</code>-r\u00f3l <code>int</code>-re az oszlop t\u00edpus\u00e1t, minthogy a sz\u00f6veges \u00e9rt\u00e9ket sz\u00e1mra (pontosabban sz\u00e1mot tartalmaz\u00f3 sz\u00f6vegre) cser\u00e9ln\u00e9 - \u00edgy lefel\u00e9 migr\u00e1l\u00e1skor SQL hib\u00e1t kapunk. Az <code>UpdateData</code> h\u00edv\u00e1s <code>AlterColumn</code> h\u00edv\u00e1s el\u00e9 helyez\u00e9s\u00e9vel ezt jav\u00edthatjuk.</p> <p>Ellen\u0151rizz\u00fck a term\u00e9kek t\u00e1bl\u00e1j\u00e1ban, hogy siker\u00fclt-e az \u00e1talak\u00edt\u00e1s. Kipr\u00f3b\u00e1lhatjuk, hogy m\u0171k\u00f6dik-e a konverzi\u00f3 objektummodell szinten is. A legfels\u0151 szint\u0171 k\u00f3dban k\u00e9rj\u00fck el az \u00f6sszes term\u00e9ket:</p> <pre><code>var prods = ctx.Products.ToList();\n</code></pre> <p>Vizsg\u00e1ljuk meg a list\u00e1ban l\u00e9v\u0151 term\u00e9keket debuggerrel: l\u00e1that\u00f3, hogy a sz\u00e1ll\u00edt\u00e1si ter\u00fcletek megfelel\u0151 \u00e9rt\u00e9k\u0171ek.</p> <p>\u00c9rt\u00e9kkonvert\u00e1l\u00f3k</p> <p>Explicit is megadhatjuk az alkalmazand\u00f3 konvertert, ami leggyakrabban a sz\u00e1mos be\u00e9p\u00edtett konverter k\u00f6z\u00fcl ker\u00fcl ki. Saj\u00e1t konvertereket is \u00edrhatunk, ha a be\u00e9p\u00edtettek k\u00f6z\u00f6tt nem tal\u00e1lunk megfelel\u0151t.</p>"},{"location":"seminar/06-efcore/chapter6/#tranzakciok","title":"Tranzakci\u00f3k","text":"<p>Az EF az egyes <code>SaveChanges</code> h\u00edv\u00e1sokat egy tranzakci\u00f3ban futtatja (ha az adatb\u00e1zis provider t\u00e1mogatja azt). Viszont gyakran megesik az, hogy t\u00f6bb <code>SaveChanges</code> h\u00edv\u00e1st kellene egy tranzakci\u00f3ban kezeln\u00fcnk. Teh\u00e1t ha az egyik sikertelen\u00fcl fut le, akkor a t\u00f6bbit sem szabad \u00e9rv\u00e9nyre juttatni.</p> <p>N\u00e9zz\u00fcnk p\u00e9ld\u00e1t a tranzakci\u00f3kezel\u00e9sre. Sz\u00farjunk be t\u00f6bb term\u00e9ket az adatb\u00e1zisba t\u00f6bb <code>SaveChanges</code> h\u00edv\u00e1ssal.</p> <pre><code>int cid = ctx.Categories.First().Id;\ntry\n{\n    using (var transaction = ctx.Database.BeginTransaction())\n    {\n        ctx.Products.Add(new Product(\"Coca Cola\")\n        {\n            CategoryId = cid,\n        });\n        ctx.SaveChanges();\n\n        ctx.Products.Add(new Product(\"Pepsi\")\n        {\n            CategoryId = cid,\n        });\n        ctx.SaveChanges();\n\n        transaction.Commit();\n    }\n}\ncatch (Exception)\n{\n}\n</code></pre> <p>A tranzakci\u00f3k kezdete-v\u00e9g\u00e9vel kapcsolatos esem\u00e9nyek csak a debug szint\u0171 napl\u00f3ban jelennek meg. \u00c1ll\u00edtsuk \u00e1t a napl\u00f3z\u00e1si szintet a <code>LogTo</code> f\u00fcggv\u00e9nyben:</p> <pre><code>.LogTo(Console.WriteLine, LogLevel.Debug); // LogLevel m\u00f3dos\u00edtva\n</code></pre> <p>A tranzakci\u00f3n <code>Commit</code>-ot h\u00edvunk, ha sikeresen lefutott mindegyik <code>SaveChanges</code>, ha valamelyik hib\u00e1ra futott, akkor a using blokkb\u00f3l val\u00f3 kil\u00e9p\u00e9sig nem fog <code>Commit</code> h\u00edv\u00f3dni. Ha b\u00e1rmilyen ok miatt a <code>Commit</code> nem h\u00edv\u00f3dik meg, legk\u00e9s\u0151bb a using blokk v\u00e9ge <code>Rollback</code>-kel lez\u00e1rja a tranzakci\u00f3t.</p> <p>Pr\u00f3b\u00e1ljuk ki! Ezesetben helyesen fut le a besz\u00far\u00e1sunk. Figyelj\u00fck meg a konzolon a tranzakci\u00f3kezel\u00e9ssel kapcsolatos \u00fczeneteket.</p> <p>Tesztelj\u00fck a hib\u00e1s \u00e1gat is az\u00e1ltal, hogy a m\u00e1sodik term\u00e9ket egy nem l\u00e9tez\u0151 kateg\u00f3ri\u00e1ba pr\u00f3b\u00e1ljuk meg besz\u00farni.</p> <pre><code>using (var transaction = ctx.Database.BeginTransaction())\n{\n    ctx.Products.Add(new Product(\"Cider\") //\u00faj n\u00e9v\n    {\n        CategoryId = cid,\n    });\n    ctx.SaveChanges();\n    ctx.Products.Add(new Product(\"K\u0151m\u0171ves KUBU\") //\u00faj n\u00e9v\n    {\n        CategoryId = 100, //nem l\u00e9tez\u0151 CategoryId\n    });\n    ctx.SaveChanges();\n    transaction.Commit();\n}\n</code></pre> <p>Figyelj\u00fck meg, hogy ilyenkor nem ker\u00fcl besz\u00far\u00e1sra az els\u0151 term\u00e9k sem. \u00dagyszint\u00e9n figyelj\u00fck meg a konzolon a tranzakci\u00f3kezel\u00e9ssel kapcsolatos \u00fczeneteket.</p>"}]}